 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

 <!-- üöÄ Universal performance boost -->
  <link rel="preconnect" href="https://code.jquery.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://esm.sh">
  <title>Olympus Chess Academy ‚Äî Dashboard</title>

  <!-- Chessboard.js CSS -->
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

  <style>
    /* ===== THEME & BASE ===== */
    :root {
      --bg-dark: #0b0d1a;
      --bg-darker: #0f1224;
      --bg-card: #171a32;
      --bg-input: #242748;
      --accent: #ffd700;
      --accent-hover: #e6c200;
      --text: #f5f5f7;
      --text-muted: #9da0b8;
      --danger: #ff4757;
      --success: #2ed573;
      --warning: #ffa502;
      --ring: rgba(255, 215, 0, 0.25);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
      background: radial-gradient(1200px 600px at 10% 0%, #0f1224 0%, #0b0d1a 60%), var(--bg-dark);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* ===== NAVBAR ===== */
    .navbar {
      background: linear-gradient(180deg, rgba(18, 20, 49, 0.9), rgba(13, 15, 36, 0.95));
      backdrop-filter: saturate(1.3) blur(8px);
      padding: 14px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      border-bottom: 1px solid rgba(255, 215, 0, 0.18);
      position: sticky;
      top: 0;
      z-index: 50;
    }
    .brand {
  display: flex;
  align-items: center;
  gap: 0px;
  margin-right: auto;
}





    
    .nav-btn {
      color: var(--text);
      background: none;
      border: none;
      padding: 10px 14px;
      cursor: pointer;
      border-radius: 9px;
      font-weight: 600;
      transition: all 160ms ease;
      outline: none;
    }
    .nav-btn:hover { background: rgba(255, 215, 0, 0.08); }
    .nav-btn.active { background: var(--accent); color: #121431; box-shadow: 0 0 0 2px var(--ring); }
    .user-info { color: var(--accent); font-weight: 500; margin: 0 8px; opacity: 0.9; }
    .btn-logout {
      background: var(--danger); color: white; border: none; padding: 10px 14px; border-radius: 9px;
      cursor: pointer; font-weight: 600; transition: transform 150ms ease, opacity 150ms ease;
    }
    .btn-logout:hover { opacity: 0.92; transform: translateY(-1px); }

   /* ===============================
   AUTO HIDE / HOVER NAVBAR
================================ */

#topNavbar {
  position: sticky;
  top: 0;
  z-index: 1000;

  /* COLLAPSED STATE */
  max-height: 50px;
  overflow: hidden;

  transition: max-height 0.35s ease, box-shadow 0.3s ease;
}

/* EXPAND ON HOVER */
#topNavbar:hover {
  max-height: 280px; /* enough for 2 rows */
  box-shadow: 0 10px 35px rgba(0, 0, 0, 0.7);
}

/* Optional hint text */
#topNavbar::after {
  content: "‚ñº Hover to expand menu";
  display: block;
  text-align: center;
  font-size: 11px;
  color: #aaa;
  padding-bottom: 6px;
  opacity: 0.6;
}

#topNavbar:hover::after {
  display: none;
}


    /* ===== MAIN CONTAINER ===== */
    .container { padding: 24px; max-width: 1300px; margin: 0 auto; }

    
    

    /* ===== SECTIONS ===== */
    .section {
      background: var(--bg-card);
      padding: 24px;
      border-radius: 14px;
      margin-bottom: 24px;
      display: none;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);
    }
    .section.active { display: block; animation: fadeIn 240ms ease; }
    @keyframes fadeIn { from {opacity:0; transform: translateY(8px);} to {opacity:1; transform: translateY(0);} }
    .section h2 {
      color: var(--accent);
      margin-bottom: 16px; font-size: 1.5rem;
      border-bottom: 2px solid rgba(255, 215, 0, 0.28); padding-bottom: 10px;
    }

    /* ===== BOARD + SIDE PANEL LAYOUT ===== */
    .board-layout {
      display: flex;
      gap: 20px;
      align-items: stretch;
      justify-content: center;
      flex-wrap: nowrap;
    }

    .board-wrapper {
  flex: 1 1 600px;   /* ‚¨Ö bigger board */
  min-width: 600px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255,255,255,0.06);
  background: #101226;
  padding-bottom: 6px; /* üîë small breathing space */
}


    .side-panel {
  flex: 0 0 320px;
  max-width: 340px;
  min-width: 300px;
  display: flex;
  flex-direction: column;
  gap: 14px;
}


    #chessboard {
      width: 100%;
      height: 100%;
      position: relative;
      cursor: default;
    }

    #notationPanel {
      flex: 0 0 100px;
      min-width: 220px;
      max-width: 380px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-self: stretch;
      background: linear-gradient(180deg, #1f2240, #242748);
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
      overflow: hidden;
    }

    #notationPanel > h4 {
      margin: 0;
      padding: 8px 0;
      width: 100%;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 1rem;
      font-weight: 800;
      color: var(--accent);
      letter-spacing: 0.2px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
    }

    #notationList {
      flex: 1 1 auto;
      overflow-y: auto;
      padding-right: 6px;
      margin-top: 8px;
      font-family: ui-monospace, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 0.95rem;
      line-height: 1.35;
    }

    #notationList .move {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      color: var(--text);
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #notationList .move:hover {
      background: rgba(255,255,255,0.02);
    }
    #notationList .move.current {
      background: rgba(255,215,0,0.06);
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.04);
    }

    #notationList::-webkit-scrollbar { width: 8px; }
    #notationList::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.06);
      border-radius: 8px;
    }
    #notationList::-webkit-scrollbar-track { background: transparent; }

    @media (max-width: 900px) {
      .board-layout { flex-wrap: wrap; }
      #notationPanel { order: 3; width: 100%; max-width: none; flex: 1 1 100%; }
    }

    #notationList { padding: 6px 4px; }
    #notationList .move {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      color: var(--text);
    }
    #notationList .move:hover { background: rgba(255,255,255,0.02); }
    #notationList .move.current {
      background: rgba(255,215,0,0.06);
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.04);
    }
    #notationList .move .num { color: var(--text-muted); width: 36px; text-align: right; padding-right: 8px; }
    #notationList .move .san { flex: 1 1 auto; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    #notationList .move {
      display: grid;
      grid-template-columns: 40px 1fr 1fr;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
    }

    #notationList .move .num {
      color: var(--text-muted);
      text-align: right;
      padding-right: 8px;
      font-weight: 700;
      font-size: 0.95rem;
    }

    #notationList .move .white,
    #notationList .move .black {
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.98rem;
    }

    #notationList .move .black { opacity: 0.95; }

    #notationList .move:hover { background: rgba(255,255,255,0.02); }
    #notationList .move.current {
      background: rgba(255,215,0,0.06);
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.04);
    }

    #notationList { padding: 6px 4px; }

    @media (max-width: 600px) {
      #notationList .move { grid-template-columns: 32px 1fr 1fr; gap: 8px; padding: 8px 10px; }
      #notationList .move .num { font-size: 0.9rem; }
    }

    #notationList .move.current {
      background: rgba(255, 215, 0, 0.15) !important;
      border-left: none;
      font-weight: bold;
      color: var(--accent) !important;
    }

    #notationList .move.current .white,
    #notationList .move.current .black {
      color: var(--accent) !important;
    }

    .hidden { display: none !important; }
    .hidden-ui {
      opacity: 0;
      pointer-events: none;
      user-select: none;
    }
    .offscreen {
      position: absolute;
      left: -9999px;
      top: -9999px;
    }

    .board-b72b1 { border: 2px solid #353a5c; box-sizing: content-box; transition: border-color 200ms ease; }
    .board-b72b1:hover { border-color: #404676; }

    button { cursor: pointer; font-weight: 700; transition: all 160ms ease; }
    .btn-primary { background: var(--accent); color: #121431; border-radius: 9px; padding: 10px 14px; }
    .btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
    .btn-success { background: var(--success); color: #121431; border-radius: 9px; padding: 10px 14px; }
    .btn-success:hover { opacity: 0.94; transform: translateY(-1px); }
    .btn-danger { background: var(--danger); color: #fff; border-radius: 9px; padding: 10px 14px; }
    .btn-danger:hover { opacity: 0.94; transform: translateY(-1px); }
    .btn-secondary { background: var(--bg-input); color: var(--text); border-radius: 9px; padding: 10px 14px; }
    .btn-secondary:hover { background: #30345e; transform: translateY(-1px); }

    .control-grid {
      display: grid; grid-template-columns: repeat(2, 1fr);
      gap: 10px; width: 100%;
    }
    .keypad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; width: 100%; }

    input, select, textarea {
      padding: 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, #242748, #1f2240);
      color: var(--text); width: 100%; margin-bottom: 12px;
      outline: none; transition: border-color 140ms ease, box-shadow 140ms ease;
    }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 2px var(--ring); }
    input::placeholder, textarea::placeholder { color: var(--text-muted); }
    textarea { min-height: 100px; resize: vertical; }
    .form-row { display: flex; gap: 10px; flex-wrap: wrap; }
    .form-row > * { flex: 1 1 auto; }

    table {
      width: 100%; border-collapse: collapse; margin-top: 14px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 10px; overflow: hidden;
    }
    th { background: rgba(255, 215, 0, 0.12); color: var(--accent); padding: 14px; text-align: left; font-weight: 800; }
    td { padding: 14px; border-bottom: 1px solid rgba(255,255,255,0.05); }
    tr:hover { background: rgba(255,255,255,0.02); }

    .card { background: linear-gradient(180deg, #242748 0%, #1f2240 100%); padding: 18px; border-radius: 12px; margin-bottom: 14px; border-left: 4px solid var(--accent); }
    .card h4 { color: var(--accent); margin-bottom: 8px; font-weight: 800; }
    .card p { color: var(--text-muted); margin-bottom: 5px; }
    .access-denied { text-align: center; padding: 36px; color: var(--danger); }
    .loading { text-align: center; padding: 24px; color: var(--accent); }
    .pgn-viewer {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      padding: 12px; border-radius: 10px; margin-top: 6px;
      max-height: 220px; overflow-y: auto; font-family: ui-monospace, Menlo, Monaco, Consolas, "Courier New", monospace;
      line-height: 1.35;
    }
    .timer { background: linear-gradient(180deg, #242748 0%, #1f2240 100%); padding: 10px 12px; border-radius: 10px; font-family: ui-monospace, monospace; font-size: 1.05rem; color: var(--accent); }
    .status-indicator { padding: 6px 10px; border-radius: 7px; font-size: 0.92rem; margin-top: 4px; background: linear-gradient(180deg, #242748 0%, #1f2240 100%); border: 1px solid rgba(255,255,255,0.06); }

    @media (max-width: 768px) {
      .navbar { flex-direction: column; align-items: flex-start; gap: 10px; }
      .nav-btn { width: 100%; text-align: left; }
      .container { padding: 16px; }
      .section { padding: 18px; }
      .board-layout { flex-direction: column; }
      .side-panel { max-width: 100%; }
    }

    .assignments-search {
      width: 100%;
      max-width: 400px;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, #242748, #1f2240);
      color: var(--text);
      font-size: 1rem;
      margin-bottom: 20px;
    }

    .assignments-filters {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .assignments-dropdown {
      flex: 1 1 250px;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, #242748, #1f2240);
      color: var(--text);
      font-size: 1rem;
    }

    .assignment-details {
      background: var(--bg-card);
      padding: 18px;
      border-radius: 12px;
      border-left: 4px solid var(--accent);
      display: none;
    }

    .clear-filters-btn {
      background: var(--danger);
      color: #fff;
      border: none;
      padding: 10px 14px;
      border-radius: 9px;
      cursor: pointer;
      font-weight: 600;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    .clear-filters-btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .admin-layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 20px;
      align-items: start;
      width: 100%;
    }

    .admin-table {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.04);
      max-height: calc(100vh - 140px);
      overflow: auto;
    }

    .admin-table table { width: 100%; border-collapse: collapse; }
    .admin-table thead th { position: sticky; top: 0; background: rgba(255,215,0,0.08); z-index: 2; }

    .admin-form {
      min-width: 280px;
      max-width: 420px;
    }
    .admin-form > .card,
    .admin-form > div {
      position: sticky;
      top: 90px;
      align-self: start;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      padding: 18px;
      border-radius: 12px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border: 1px solid rgba(255,255,255,0.04);
    }

    @media (max-width: 980px) {
      .admin-layout { grid-template-columns: 1fr; }
      .admin-form > .card, .admin-form > div { position: relative; top: 0; max-height: none; }
    }

    :root {
      --admin-form-width: 520px;
    }

    .admin-layout {
      display: grid;
      grid-template-columns: 1fr var(--admin-form-width);
      gap: 20px;
      align-items: start;
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
    }

    .admin-table {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.04);
      max-height: calc(100vh - 140px);
      overflow: auto;
      min-width: 320px;
    }

    .admin-form {
      min-width: 320px;
      max-width: var(--admin-form-width);
    }
    .admin-form > .card,
    .admin-form > div {
      position: sticky;
      top: 90px;
      align-self: start;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      padding: 18px;
      border-radius: 12px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border: 1px solid rgba(255,255,255,0.04);
    }

    .admin-table table { width: 100%; border-collapse: collapse; }
    .admin-table thead th { position: sticky; top: 0; background: rgba(255,215,0,0.08); z-index: 2; }

    @media (max-width: 980px) {
      .admin-layout { grid-template-columns: 1fr; padding: 0 8px; }
      .admin-form > .card, .admin-form > div { position: relative; top: 0; max-height: none; }
    }

    :root { --assign-form-width: 520px; }

    .assignments-layout {
      display: grid;
      grid-template-columns: minmax(320px, 1fr) var(--assign-form-width);
      gap: 18px;
      align-items: start;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    .assignments-list {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 12px;
      padding: 14px;
      border: 1px solid rgba(255,255,255,0.04);
      max-height: calc(100vh - 220px);
      overflow-y: auto;
      min-width: 280px;
    }

    .assignments-form {
      min-width: 280px;
      max-width: var(--assign-form-width);
    }
    .assignments-form > .card,
    .assignments-form > div {
      position: sticky;
      top: 90px;
      align-self: start;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      padding: 18px;
      border-radius: 12px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border: 1px solid rgba(255,255,255,0.04);
    }

    @media (max-width: 980px) {
      .assignments-layout { grid-template-columns: 1fr; padding: 0 8px; }
      .assignments-form > .card,
    .assignments-form > div { position: relative; top: 0; max-height: none; }
    }

    @media (min-width: 1400px) {
      .assignments-layout { max-width: 1400px; }
    }

    /* ===============================
   ‚ôüÔ∏è PUZZLE RUSH ‚Äì GRAB CURSOR
   =============================== */

/* Default hover on Puzzle Rush board */
#puzzleRushBoard {
  cursor: grab;
}

/* When hovering a piece */
#puzzleRushBoard .piece-417db {
  cursor: grab !important;
}

/* While dragging a piece */
#puzzleRushBoard .piece-417db:active {
  cursor: grabbing !important;
}

/* Optional: squares also feel interactive */
#puzzleRushBoard .square-55d63 {
  cursor: grab;
}


    /* ===== CHESSBOARD CURSOR STYLES ===== */
    #chessboard {
      cursor: default;
    }

    /* When hovering over draggable pieces */
    #chessboard .piece-417db {
      cursor: grab !important;
    }

    #chessboard .piece-417db:hover {
      cursor: grab !important;
    }

    /* When actively dragging a piece */
    #chessboard .piece-417db:active {
      cursor: grabbing !important;
    }

    /* Disable cursor when in navigation mode */
    .navigation-mode #chessboard .piece-417db {
      cursor: not-allowed !important;
    }

    /* Also style the board squares on hover when piece is present */
    #chessboard .square-55d63:hover {
      cursor: pointer;
    }

    /* Make sure the board container has proper cursor */
    .board-wrapper:hover #chessboard {
      cursor: default;
      
    }


    /* ===== DRAWING SYSTEM STYLES ===== */
    #boardOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    #boardOverlay line {
      stroke: #057505;
      stroke-width: 5;
      stroke-linecap: round;
      marker-end: url(#arrowhead);
      filter: drop-shadow(0 1px 2px rgba(0, 255, 0, 0.5));
    }

    #boardOverlay circle {
      fill: none;
      stroke: #057505;
      
      filter: drop-shadow(0 1px 2px rgba(0, 255, 0, 0.5));
    }

    #boardOverlay rect {
      fill: rgba(255, 255, 255, 0.05);
      stroke: rgba(255, 255, 255, 0.1);
      stroke-width: 1;
    }

    /* Arrow marker definition */
    .marker-arrow {
      fill: #057505;
    }

    /* Disable right-click context menu on chessboard */
    #chessboard {
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    /* Right-click drawing instruction */
    .drawing-instruction {
      position: absolute;
      bottom: 15px;
      left: 15px;
      background: rgba(0, 0, 0, 0.7);
      color: #057505;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.85rem;
      z-index: 5;
      border: 1px solid rgba(0, 255, 0, 0.3);
      pointer-events: none;
    }

    /* Drawing preview */
    .drawing-preview {
      stroke-dasharray: 5,5;
      opacity: 0.7;
    }

    .status-indicator {
  padding: 10px 14px;
  border-radius: 8px;
  margin-bottom: 10px;
  font-weight: 600;
  text-align: center;
  animation: fadeIn 0.3s ease;
}

.status-indicator.success {
  background: linear-gradient(180deg, #1fae66, #15803d);
  color: #fff;
}

.status-indicator.error {
  background: linear-gradient(180deg, #dc2626, #991b1b);
  color: #fff;
}

.status-indicator.info {
  background: linear-gradient(180deg, #334155, #1e293b);
  color: #f8fafc;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ===== MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-overlay.hidden {
  display: none;
}

.modal-card {
  background: linear-gradient(180deg, #1b2b4a, #121c2f);
  padding: 24px 28px;
  border-radius: 14px;
  width: 360px;
  max-width: 90%;
  box-shadow: 0 20px 50px rgba(0,0,0,0.5);
  text-align: center;
  animation: popIn 0.25s ease-out;
}

.modal-card h2 {
  margin-bottom: 14px;
  color: #3cff8f;
}

.modal-content {
  color: #e5e7eb;
  font-size: 0.95rem;
  line-height: 1.6;
  margin-bottom: 20px;
}

.modal-btn {
  width: 100%;
  font-size: 1rem;
}

/* small animation */
@keyframes popIn {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-overlay.hidden {
  display: none;
}

.modal-card {
  background: linear-gradient(145deg, #0f172a, #111827);
  color: #e5e7eb;
  padding: 24px;
  border-radius: 14px;
  width: 420px;
  max-width: 90%;
  box-shadow: 0 25px 60px rgba(0,0,0,0.6);
  text-align: center;
  animation: popIn 0.25s ease;
}

.modal-card h3 {
  color: #22c55e;
  margin-bottom: 12px;
}

.modal-card p {
  line-height: 1.6;
  margin-bottom: 18px;
}

@keyframes popIn {
  from { transform: scale(0.9); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

/* Assign select / clear buttons */
.assign-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 4px;   /* keeps it close to the student list */
}

.assign-actions .btn-small {
  padding: 4px 10px;
  font-size: 12px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  background: #2c2f55;
  color: #fff;
}

.assign-actions .btn-small:hover {
  background: #3a3e75;
}

.assign-actions .btn-small.danger {
  background: #5a2a2a;
}

.assign-actions .btn-small.danger:hover {
  background: #7a3434;
}

.promotion-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.promotion-modal.hidden {
  display: none;
}

.promotion-box {
  display: flex;
  gap: 12px;
  background: #0e1025;
  padding: 16px;
  border-radius: 12px;
  border: 1px solid #ffd700;
}

.promotion-box button {
  font-size: 32px;
  width: 64px;
  height: 64px;
  cursor: pointer;
  border-radius: 8px;
  background: #1c1f35;
  color: #fff;
  border: 1px solid #444;
}

.promotion-box button:hover {
  background: #ffd700;
  color: #000;
}

.player-bar {
  display: flex;
  justify-content: space-between;
  width: 100%;
  max-width: 100%;
  font-size: 1.10rem;
  color: #d0ff00;
  padding: 0 2px;
  margin-top: 2px;
}




#chessboard {
  margin-bottom: 4px;
}

.player {
  opacity: 0.85;
}

.player.white {
  align-self: flex-start;
}

.player.black {
  align-self: flex-end;
}

/* ===== LIVE CLASSROOM ===== */

.live-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display: inline-block;
  margin-right: 6px;
}

.live-dot.red {
  background: #ff4d4d;
  box-shadow: 0 0 6px rgba(255, 77, 77, 0.8);
}

.live-dot.green {
  background: #2ecc71;
  box-shadow: 0 0 6px rgba(46, 204, 113, 0.8);
}


.live-placeholder {
  margin-top: 16px;
  padding: 16px;
  border-radius: 10px;
  background: rgba(255,255,255,0.04);
  color: #ddd;
}

.hidden {
  display: none;
}


/* Live classroom student checklist */
.student-checklist {
  max-height: 260px;        /* üëà controls height */
  overflow-y: auto;         /* üëà scroll */
  padding: 8px 12px;
  border: 1px solid #2e355e;
  border-radius: 10px;
  background: rgba(0, 0, 0, 0.25);
}

/* Each student row */
.student-checklist label {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 14px;
  cursor: pointer;
}

/* Checkbox size fix */
.student-checklist input[type="checkbox"] {
  transform: scale(1.05);
}

/* ===== Dark themed SELECT dropdown ===== */
select {
  background-color: #1c1f35;
  color: #f0f0f0;
  border: 1px solid #333;
}

/* Dropdown options */
select option {
  background-color: #1c1f35;
  color: #f0f0f0;
}

/* Hovered option (works in most browsers) */
select option:hover {
  background-color: #2a2d4a;
  color: #ffd700;
}

/* Selected option */
select option:checked {
  background-color: #ffd700;
  color: #101225;
}


/* ===== MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-box {
  background: #1c1f35;
  padding: 24px;
  border-radius: 14px;
  width: 100%;
  max-width: 420px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  animation: scaleIn 0.2s ease;
}

.modal-box h3 {
  color: #ffd700;
  margin-bottom: 12px;
}

.modal-box p {
  color: #ddd;
  font-size: 0.95rem;
  line-height: 1.5;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.hidden {
  display: none;
}

@keyframes scaleIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

/* ================= ASSIGNMENTS GRID ================= */
.assignments-layout {
  display: grid;
  grid-template-columns:
    minmax(300px, 1fr)
    minmax(420px, 520px)
    minmax(300px, 360px);
  gap: 20px;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;

  /* üîí IMPORTANT: limit vertical growth */
  height: calc(100vh - 160px);
}

/* ================= GENERAL CARD ================= */
.assignments-layout > .card {
  background: linear-gradient(180deg, #1a1f3c 0%, #12162d 100%);
  border-radius: 14px;
  padding: 16px 18px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.04),
    0 10px 30px rgba(0,0,0,0.35);

  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0;
  overflow: hidden;
}

/* ================= LEFT COLUMN SCROLL ================= */
.assignments-layout > .card:first-child {
  overflow-y: auto;
}

/* ================= MIDDLE COLUMN SCROLL ================= */
.assignments-layout > .card:nth-child(2) {
  overflow-y: auto;
}

/* ================= PGN LIBRARY ================= */
.assignments-layout > .card[aria-label="PGN Library"] {
  overflow: hidden;
}

/* PGN list scroll area */
#pgnLibraryList {
  margin-top: 12px;
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
}

body.student-view #pgnLibraryCard { display: none; }


/* ================= STUDENT PROGRESS SCROLL FIX ================= */

#studentProgressCard {
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0;          /* üî• critical */
  overflow: hidden;      /* prevent double scroll */
}

#studentProgressList {
  flex: 1;
  min-height: 0;         /* üî• critical */
  overflow-y: auto;      /* ‚úÖ enable scroll */
  overflow-x: hidden;
  padding-right: 6px;
}


.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  backdrop-filter: blur(6px);
  z-index: 9999;

  display: flex;
  align-items: center;
  justify-content: center;
}

/* üî• THIS LINE FIXES THE BUTTON */
.modal-box {
  pointer-events: auto;
  z-index: 10000;
}


/* üë§ Student Details Modal Scroll Fix */
#studentDetailsModal .modal-box {
  max-height: 80vh;              /* üëà keeps modal inside screen */
  display: flex;
  flex-direction: column;
}

#studentModalBody {
  overflow-y: auto;              /* üëà ENABLE SCROLL */
  max-height: 60vh;              /* üëà scroll area height */
  padding-right: 6px;
}




/* ===== PGN MODAL ===== */
.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal.hidden {
  display: none;
}

.modal-box {
  width: 340px;
  background: #11162b;
  border-radius: 12px;
  padding: 18px;
  box-shadow: 0 0 25px rgba(0,0,0,0.6);
}

.modal-box h3 {
  margin-bottom: 12px;
  color: #ffd700;
}

.modal-box input {
  width: 100%;
  padding: 10px;
  border-radius: 8px;
  border: none;
  margin-bottom: 14px;
  background: #1c2240;
  color: #fff;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

/* ================= PGN CONTROLS ALIGNMENT ================= */

.pgn-item {
  padding: 10px 0;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.pgn-controls {
  margin-top: 8px;
  display: grid;
  grid-template-columns: auto auto 1fr auto auto;
  align-items: center;
  gap: 12px;
}

/* Radio label alignment */
.pgn-controls label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: #ddd;
  cursor: pointer;
}

.pgn-controls input[type="radio"] {
  margin: 0;
}

/* Button normalization */
.pgn-controls .btn-small {
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 6px;
}

.pgn-controls .btn-small.danger {
  background: #f37070;
}

/* ================= STUDENT PROGRESS VISIBILITY ================= */

/* Hide student progress for admin & teacher */
body:not(.student-view) #studentProgressCard {
  display: none !important;
}


/* ================= STUDENT ASSIGNMENT HISTORY ================= */

#studentProgressCard {
  background: linear-gradient(180deg, #1a1f3c 0%, #12162d 100%);
  border-radius: 14px;
  padding: 16px 18px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.04),
    0 10px 30px rgba(0,0,0,0.35);
}

/* Scroll container */
#studentProgressList {
  margin-top: 10px;
  overflow-y: auto;
  padding-right: 6px;
}

/* Each assignment block */
.progress-item {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 12px;
  padding: 12px 14px;
  margin-bottom: 12px;
  border-left: 4px solid #312c49;
  box-shadow: 0 6px 14px rgba(0,0,0,0.35);
}

/* Title */
.progress-item strong {
  color: #ffd700;
  font-size: 1.05rem;
  display: block;
  margin-bottom: 6px;
}

/* Meta info */
.progress-meta {
  font-size: 0.9rem;
  color: #d1d5db;
  margin-bottom: 4px;
}

/* Date */
.progress-date {
  font-size: 0.8rem;
  color: #9da0b8;
  margin-bottom: 8px;
}

/* Buttons container */
.progress-actions {
  display: flex;
  gap: 8px;
  margin-top: 6px;
}

/* Small buttons */
.progress-actions .btn-small {
  padding: 6px 10px;
  font-size: 12px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s ease;
}

/* Re-attempt button */
.progress-actions .reattempt-btn {
  background: linear-gradient(180deg, #22c55e, #15803d);
  color: #052e16;
}
.progress-actions .reattempt-btn:hover {
  transform: translateY(-1px);
  filter: brightness(1.1);
}

/* View details button */
.progress-actions .view-details-btn {
  background: linear-gradient(180deg, #334155, #1e293b);
  color: #f8fafc;
}
.progress-actions .view-details-btn:hover {
  background: linear-gradient(180deg, #475569, #334155);
}

/* Divider remove */
.progress-item hr {
  display: none;
}

/* Scrollbar styling */
#studentProgressList::-webkit-scrollbar {
  width: 8px;
}
#studentProgressList::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}
#studentProgressList::-webkit-scrollbar-track {
  background: transparent;
}

/* ===== Center buttons in Assignment History cards ===== */

.progress-actions {
  display: flex;
  justify-content: center;   /* üî• THIS centers buttons */
  align-items: center;
  gap: 10px;
  margin-top: 8px;
}

/* Optional: make buttons same height & cleaner */
.progress-actions .btn-small {
  min-width: 92px;
  text-align: center;
}

/* ===== STICKY APP FOOTER ===== */
.app-footer {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;

  padding: 6px 8px;
  font-size: 0.75rem;
  text-align: center;

  color: #e6c86e;

  background: linear-gradient(
    180deg,
    rgba(15, 18, 36, 0.95),
    rgba(11, 13, 26, 0.98)
  );

  border-top: 1px solid rgba(255, 215, 0, 0.45);
  box-shadow: 0 -1px 12px rgba(255, 215, 0, 0.18);

  z-index: 100;
}

.app-footer .footer-brand {
  color: #ffd700;
  font-weight: 700;
}

.container {
  padding-bottom: 40px;
}



.bulk-bar {
  height: 42px;                 /* üîí fixed height */
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 14px;

  margin-top: 10px;
  padding: 6px 10px;

  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.08);

  font-weight: 700;
  color: #ffd700;

  /* üî• prevents layout jump */
  flex-shrink: 0;
}

#board-section h2 {
  font-size: 1.25rem;     /* üîΩ smaller than before */
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 12px;
}


.engine-panel {
  margin-top: 10px;
  border-radius: 8px;
  background: #10131c;
  border: 1px solid #2a2f45;
  grid-column: 1 / -1;
  width: 100%;
  box-sizing: border-box;
  overflow: hidden;
}

/* üî• THE KEY PART */
.engine-bar {
  display: flex;
  align-items: center;
  gap: 16px;              /* spacing between title, eval, depth */
  padding: 8px 10px;
  background: #0c0f18;
  border-bottom: 1px solid #2a2f45;
  font-size: 13px;
}


.engine-title {
  font-weight: bold;
  color: #f1c40f;
}


.engine-stat {
  color: #eaeaea;
  font-size: 12.5px;
}

/* BODY = FREE SPACE */
.engine-body {
  padding: 8px 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.engine-line {
  background: #0d1020;
  padding: 6px 8px;
  border-radius: 6px;
  border: 1px solid #2a2f45;
  font-size: 12.5px;
}


.engine-stat {
  color: #9da0b8;   /* Eval: Depth: */
  font-weight: 600;
}

#engineEval {
  color: #22c55e;
  font-weight: 700;
}

#engineDepth {
  color: #38bdf8;
  font-weight: 700;
}

/* Highlight ONLY WASM text */
.engine-title .wasm-badge {
  color: #38bdf8;           /* cyan-blue (matches depth vibe) */
  background: rgba(56, 189, 248, 0.15);
  padding: 2px 6px;
  border-radius: 6px;
  font-weight: 800;
  letter-spacing: 0.5px;
}

/* ===============================
   STUDENT BADGES ‚Äì STEP 2 (UI ONLY)
   =============================== */

#studentBadgePanel {
  display: flex;
  flex-direction: column;
  height: 100%;
}

#studentBadgeContent {
  margin-top: 12px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 12px;
  overflow-y: auto;
  padding-right: 6px;
}

/* Badge card */
.badge-card {
  background: linear-gradient(145deg, #1c1f35, #15182a);
  border-radius: 14px;
  padding: 12px;
  position: relative;
  text-align: center;
  opacity: 0.55; /* locked look */
}

/* Badge icon */
.badge-icon {
  font-size: 28px;
  margin-bottom: 6px;
}

/* Badge title */
.badge-title {
  font-size: 0.9rem;
  font-weight: 600;
  color: #ffd700;
}

/* Badge tagline */
.badge-tagline {
  font-size: 0.80rem;
  color: #aaa;
  margin-top: 4px;
}

/* Locked overlay */
.badge-lock {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  background: rgba(0, 0, 0, 0.45);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
}


/* ===============================
   üèÖ ACHIEVEMENTS ‚Äì CLEAN FIX
   =============================== */

#studentBadgeContent {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 14px;
}

/* CARD */
.badge-card {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 14px 10px 16px;
  min-height: 140px;
  text-align: center;
  position: relative;
  border: 1px solid rgba(255,255,255,0.05);
  box-shadow: 0 8px 20px rgba(0,0,0,0.35);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}


#studentBadgePanel > div {
  overflow: visible;
}


/* Hover */
.badge-card:hover {
  transform: translateY(-3px);
}

/* ICON */
.badge-icon {
  font-size: 34px;
  margin-bottom: 6px;
}

/* TITLE */
.badge-title {
  font-size: 0.95rem;
  font-weight: 700;
  color: #ffd700;
}

/* TAGLINE */
.badge-tagline {
  font-size: 0.80rem;
  color: #9da0b8;
  margin-top: 4px;
}

/* ================= LOCKED ================= */

.badge-card.locked {
  opacity: 0.35;
}

.badge-card.locked .badge-icon {
  filter: grayscale(100%);
}

/* Lock icon */
.badge-lock {
  position: absolute;
  top: 8px;
  right: 10px;
  font-size: 16px;
  opacity: 0.8;
}

/* ================= UNLOCKABLE ================= */

.badge-unlock-btn {
  margin-top: 10px;
  padding: 6px 14px;
  font-size: 12px;
  font-weight: 800;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  background: #ffd700;
  color: #101225;
  box-shadow: 0 0 12px rgba(255,215,0,0.6);
}

.badge-unlock-btn:hover {
  filter: brightness(1.1);
}

/* ================= UNLOCKED ================= */

.badge-card.unlocked {
  opacity: 1;
  box-shadow:
    0 0 0 2px rgba(255,215,0,0.45),
    0 0 22px rgba(255,215,0,0.35);
}

.badge-unlocked-mark {
  position: absolute;
  top: 8px;
  right: 10px;
  font-size: 18px;
}

/* üéâ unlock pop */
.badge-just-unlocked {
  animation: unlockPop 0.5s ease;
}

@keyframes unlockPop {
  0% { transform: scale(0.9); }
  60% { transform: scale(1.08); }
  100% { transform: scale(1); }
}


#studentBadgePanel h3 {
  text-align: center;
  font-size: 1.35rem;
  font-weight: 900;
  letter-spacing: 0.4px;
  margin-bottom: 12px;
  color: #ffd700;

  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

/* ===============================
   üîÅ UNIFIED SCROLLBAR (MATCH HISTORY)
   =============================== */

/* Firefox */
#assignmentsList,
#studentBadgeContent {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* WebKit (Chrome / Edge / Safari) */
#assignmentsList::-webkit-scrollbar,
#studentBadgeContent::-webkit-scrollbar {
  width: 8px;
}

#assignmentsList::-webkit-scrollbar-track,
#studentBadgeContent::-webkit-scrollbar-track {
  background: transparent;
}

#assignmentsList::-webkit-scrollbar-thumb,
#studentBadgeContent::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

#assignmentsList::-webkit-scrollbar-thumb:hover,
#studentBadgeContent::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}



/* ===============================
   üèÖ ACHIEVEMENTS ‚Äì FIX SCROLLBAR
   =============================== */

/* Firefox */
#studentBadgePanel {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* WebKit */
#studentBadgePanel::-webkit-scrollbar {
  width: 8px;
}

#studentBadgePanel::-webkit-scrollbar-track {
  background: transparent;
}

#studentBadgePanel::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

#studentBadgePanel::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}


/* ===============================
   üõ† ADMIN ‚Äì UNIFIED SCROLLBARS
   =============================== */

/* Firefox */
.assignments-form > div,
#pgnLibraryList {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* WebKit */
.assignments-form > div::-webkit-scrollbar,
#pgnLibraryList::-webkit-scrollbar {
  width: 8px;
}

.assignments-form > div::-webkit-scrollbar-track,
#pgnLibraryList::-webkit-scrollbar-track {
  background: transparent;
}

.assignments-form > div::-webkit-scrollbar-thumb,
#pgnLibraryList::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

.assignments-form > div::-webkit-scrollbar-thumb:hover,
#pgnLibraryList::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}


/* ===============================
   üë®‚Äçüéì ADMIN ‚Üí CURRENT STUDENTS SCROLLBAR
   =============================== */

/* make sure this element scrolls */
.admin-table {
  overflow-y: auto;
}

/* Firefox */
.admin-table {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* Chrome / Edge / Safari */
.admin-table::-webkit-scrollbar {
  width: 8px;
}

.admin-table::-webkit-scrollbar-track {
  background: transparent;
}

.admin-table::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

.admin-table::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}

/* ===============================
   üë®‚Äçüéì ADMIN ‚Äì STUDENT ROW TEXT SIZE
   =============================== */

/* Student usernames */
.admin-table tbody td:nth-child(2) {
  font-size: 1.30rem;   /* slightly bigger */
  font-weight: 600;
}

/* Status text (Active / Inactive) */
.admin-table tbody td:nth-child(3) {
  font-size: 1.10rem;
  font-weight: 600;
}

#attempts-section .section-title {
  position: sticky;
  top: 72px;
  z-index: 50;
  background: linear-gradient(135deg, #0e0f1f, #2a2d4a);
}

/* ===============================
   üìä STUDENT ATTEMPTS ‚Äì STICKY HEADER
   =============================== */

#attempts-section > h2 {
  position: sticky;
  top: 72px;              /* height of your navbar */
  z-index: 50;

  background: linear-gradient(135deg, #0e0f1f, #2a2d4a);
  padding: 12px 18px;

  border-radius: 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
}

/* ===============================
   üéâ CELEBRATION EFFECT
   =============================== */

.celebration {
  position: fixed;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
  z-index: 99999;
}

.celebration.hidden {
  display: none;
}

/* Glitter particle */
.glitter {
  position: absolute;
  top: -10px;
  width: 8px;
  height: 8px;
  background: radial-gradient(circle, #ffd700, #ffec8b);
  border-radius: 50%;
  opacity: 0.9;

  animation: fall linear forwards;
  animation-duration: 5s; /* üî• LONGER FALL */
}


@keyframes fall {
  to {
    transform: translateY(130vh) rotate(720deg); /* more spin + longer fall */
    opacity: 0;
  }
}


/* üöÄ BIG BADGE POP-OUT (2s total) */
.badge-pop-animate {
  animation: badgeBigPop 2s cubic-bezier(0.22, 1.61, 0.36, 1);
  z-index: 20;
}

@keyframes badgeBigPop {
  0% {
    transform: scale(1);
  }

  20% {
    transform: scale(1.6);
  }

  40% {
    transform: scale(1.85);
  }

  60% {
    transform: scale(1.4);
  }

  80% {
    transform: scale(1.15);
  }

  100% {
    transform: scale(1);
  }
}

#computerBoard {
  width: 420px;
  max-width: 100%;
}

#computer-section h3 {
  color: var(--accent);
  margin-top: 12px;
  margin-bottom: 6px;
}


#computer-section .analysis-layout {
  display: flex;
  gap: 24px;
  align-items: flex-start;
}

#computer-section .board-column {
  min-width: 420px;
}

#computer-section .side-panel {
  width: 320px;
}

/* ü§ñ Play vs Computer ‚Äì Layout */
#computer-section .analysis-layout {
  display: flex;
  gap: 28px;
  align-items: flex-start;
}

/* Board side takes more space */
#computer-section .board-column {
  flex: 1.4;
}

/* Right panel slightly smaller */
#computer-section .side-panel {
  flex: 1;
}

#computerBoard {
  width: 600px;       /* üî• increase from ~420 */
  max-width: 100%;
  margin: 0 auto;
}



/* ===============================
   ‚ôüÔ∏è Chessboard Cursor (GRAB)
   =============================== */

/* When hovering over a piece */
#chessboard .piece-417db,
#computerBoard .piece-417db {
  cursor: grab !important;
}



/* Board itself should not override */
#chessboard,
#computerBoard {
  cursor: default;
}

.vs-result {
  margin: 10px auto 16px;
  padding: 10px 18px;
  border-radius: 10px;
  text-align: center;
  font-size: 1.1rem;
  font-weight: 800;
  width: fit-content;
  animation: fadeIn 0.3s ease;
}

.vs-result.white {
  background: linear-gradient(180deg, #e5e7eb, #cbd5f5);
  color: #111827;
}

.vs-result.black {
  background: linear-gradient(180deg, #1f2933, #0f172a);
  color: #f8fafc;
}

.vs-result.draw {
  background: linear-gradient(180deg, #334155, #1e293b);
  color: #f8fafc;
}

.hidden {
  display: none;
}


/* ===============================
   ‚ôüÔ∏è PUZZLE RUSH ‚Äì BIGGER BOARD
   =============================== */

#puzzleRushBoard {
  width: 600px;
  height: 600px;
  margin: 0 auto;
  box-shadow: 0 12px 30px rgba(0,0,0,0.45);
  border-radius: 10px;
}

/* Responsive fallback */
@media (max-width: 900px) {
  #puzzleRushBoard {
    width: 420px;
    height: 420px;
  }
}

@media (max-width: 600px) {
  #puzzleRushBoard {
    width: 320px;
    height: 320px;
  }
}



/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì PREMIUM UI
   =============================== */

#puzzlerush-section h2 {
  font-size: 1.6rem;
  letter-spacing: 0.6px;
}

/* Main card */
#puzzleRushMenu {
  background: linear-gradient(145deg, #1a1f3c, #12162d);
  border-radius: 18px;
  padding: 26px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.05),
    0 18px 45px rgba(0,0,0,0.45);
  position: relative;
  overflow: hidden;
}

/* soft glow border */
#puzzleRushMenu::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 18px;
  pointer-events: none;
  box-shadow: 0 0 0 1px rgba(255,215,0,0.15);
}

/* Title */
#puzzleRushMenu h3 {
  text-align: center;
  font-size: 1.25rem;
  font-weight: 800;
  color: #ffd700;
  margin-bottom: 22px;
  letter-spacing: 0.4px;
}

/* Mode grid */
#puzzleRushMenu .control-grid {
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

/* Buttons ‚Äì base */
#puzzleRushMenu button {
  position: relative;
  font-size: 1.05rem;
  padding: 14px 16px;
  border-radius: 14px;
  font-weight: 800;
  letter-spacing: 0.3px;
  transition: all 0.2s ease;
  box-shadow:
    inset 0 -2px 0 rgba(0,0,0,0.25),
    0 8px 20px rgba(0,0,0,0.35);
}

/* Hover lift */
#puzzleRushMenu button:hover {
  transform: translateY(-2px) scale(1.02);
  filter: brightness(1.05);
}

/* Press */
#puzzleRushMenu button:active {
  transform: translateY(1px) scale(0.98);
}

/* 3 & 5 min ‚Äì GOLD */
#rush3,
#rush5 {
  background: linear-gradient(180deg, #ffd700, #e6c200);
  color: #101225;
  box-shadow:
    0 0 0 1px rgba(255,215,0,0.5),
    0 10px 26px rgba(255,215,0,0.45);
}

/* GOLD glow on hover */
#rush3:hover,
#rush5:hover {
  box-shadow:
    0 0 18px rgba(255,215,0,0.6),
    0 14px 32px rgba(255,215,0,0.55);
}

/* Survival ‚Äì DANGER */
#survival {
  grid-column: 1 / -1;
  background: linear-gradient(180deg, #ff4d4d, #c81e1e);
  color: #fff;
  box-shadow:
    0 0 0 1px rgba(255,77,77,0.5),
    0 10px 26px rgba(255,77,77,0.45);
}

/* Survival glow */
#survival:hover {
  box-shadow:
    0 0 18px rgba(255,77,77,0.6),
    0 14px 32px rgba(255,77,77,0.55);
}

/* Icon spacing polish */
#puzzleRushMenu button::first-letter {
  margin-right: 6px;
}

/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì HUD (PREMIUM)
   =============================== */

.puzzle-hud {
  display: flex;
  justify-content: center;
  gap: 16px;
  margin-top: 14px;
}

/* Shared HUD card */
.hud-item {
  min-width: 120px;
  padding: 10px 14px;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;

  font-weight: 900;
  font-size: 1.1rem;
  letter-spacing: 0.5px;

  background: linear-gradient(180deg, #242748, #1f2240);
  border: 1px solid rgba(255,255,255,0.08);

  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.03),
    0 8px 22px rgba(0,0,0,0.45);

  transition: transform 0.15s ease;
}

.hud-item:hover {
  transform: translateY(-2px);
}

/* Icon */
.hud-icon {
  font-size: 1.2rem;
}

/* TIMER */
.hud-timer {
  color: #38bdf8;
  box-shadow:
    0 0 0 1px rgba(56,189,248,0.35),
    0 0 18px rgba(56,189,248,0.25);
}

/* LIVES */
.hud-lives {
  color: #ff6b6b;
  box-shadow:
    0 0 0 1px rgba(255,107,107,0.35),
    0 0 18px rgba(255,107,107,0.25);
}

/* STREAK */
.hud-streak {
  color: #ffd700;
  box-shadow:
    0 0 0 1px rgba(255,215,0,0.45),
    0 0 22px rgba(255,215,0,0.35);
}

/* Small screens */
@media (max-width: 600px) {
  .puzzle-hud {
    gap: 10px;
  }

  .hud-item {
    min-width: 96px;
    font-size: 1rem;
    padding: 8px 10px;
  }
}

/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì EXIT (FINAL)
   =============================== */

/* Make layout the anchor */
#puzzleRushGame .analysis-layout {
  position: relative;
}

/* Exit button inside card */
#exitPuzzleRush {
  position: absolute;
  top: 14px;
  left: 14px;

  padding: 6px 10px;
  font-size: 13px;
  border-radius: 8px;

  background: #1f2240;
  color: #ffd700;
  border: 1px solid rgba(255,255,255,0.18);

  cursor: pointer;
  z-index: 20;
}

/* Hover effect */
#exitPuzzleRush:hover {
  background: #ffd700;
  color: #101225;
}

/* Hide side-panel visuals but keep DOM */
#puzzleRushGame .side-panel {
  width: 0;
  padding: 0;
  margin: 0;
  overflow: visible;
}

.bot-panel {
  width: 160px;
  min-width: 160px;
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 16px;

  padding: 20px 12px 12px;
  margin-right: 30px;   /* ‚¨ÖÔ∏è KEY FIX: pushes board away */

  box-shadow: 0 12px 30px rgba(0,0,0,0.45);

  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;

  gap: 10px;
  position: relative;
}

.bot-avatar {
  position: relative;
}

#botMouth {
  position: absolute;

  top: 115px;

  /* üëâ move mouth slightly RIGHT */
  left: 70%;
  transform: translateX(-50%) translateX(6px);

  width: 20px;
  height: 15px;

  background: #ff4d4d;
  border-radius: 50%;

  opacity: 0;
  z-index: 5;
  transition: height 0.08s ease, opacity 0.08s ease;
}

#botMouth.talk {
  height: 30px;
  opacity: 1;
}







.bot-avatar img {
  width: 145%;
  height: 145%;
  object-fit: contain;

  /* ‚¨ÜÔ∏è pull bot UP */
  transform: translateY(-30px);

  filter: drop-shadow(0 16px 20px rgba(0,0,0,0.55));
}


.game-left-panel {
  padding-right: 20px;
}




.bot-name {
  margin-top: -90px;   /* ‚¨ÜÔ∏è pulls name upward */
  margin-bottom: 6px;

  font-weight: 900;
  color: #ffd700;
  font-size: 1.5rem;
  text-align: center;

  text-shadow: 0 2px 6px rgba(0,0,0,0.6);
}




.bot-bubble {
  margin-top: 10px;              /* üëà puts it BELOW avatar */
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.75);
  color: #ffd966;
  border-radius: 12px;
  font-size: 22px;
  max-width: 160px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);

  /* animation */
  animation: popIn 0.25s ease-out;
}

.bot-bubble.hidden {
  display: none;
}

/* idle animation */
@keyframes botIdle {
  0% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
  100% { transform: translateY(0); }
}


.analysis-layout {
  display: flex;
  align-items: stretch; /* üî• IMPORTANT */
}


.takeback-btn {
  margin-top: auto;   /* üî• finally works */
  margin-bottom: 14px;
  width: 100%;
}

.bot-panel {
  display: flex;
  flex-direction: column;
  padding-bottom: 25px; /* try 24 ‚Üí 32 */
  height: 100%;
  min-height: 520px; /* üî• SAME or slightly less than board height */
}


/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì TRUE CENTER FIX
   =============================== */

/* ‚úÖ Correct centering inside card (no drifting) */
#puzzleRushGame .analysis-layout {
  display: grid !important;
  grid-template-columns: 1fr auto 1fr !important;
  align-items: flex-start !important;
  position: relative !important;
}

/* Board always sits in true center column */
#puzzleRushGame .board-column {
  grid-column: 2 !important;
  position: static !important;   /* ‚ùå remove left:50% logic */
  transform: none !important;    /* ‚ùå remove translateX */
  margin: 0 !important;
}


/* Keep side-panel neutral */
#puzzleRushGame .side-panel {
  width: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
  overflow: visible !important;
}

/* Exit visible on NON-MOBILE devices */
@media (min-width: 769px) {
  #exitPuzzleRush {
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 9999;
    display: block;
  }
}



#editorBoard {
  width: 520px;
  min-height: 520px;
}


/* ===============================
   ‚ôüÔ∏è CHESSBOARD GRAB CURSOR
   =============================== */

/* Board containers */
#chessboard,
#editorBoard,
#computerBoard,
#puzzleRushBoard {
  cursor: default;
}

/* Hovering a draggable piece */
#chessboard .piece-417db,
#editorBoard .piece-417db,
#computerBoard .piece-417db,
#puzzleRushBoard .piece-417db {
  cursor: grab !important;
}

/* While dragging a piece */
#chessboard .piece-417db:active,
#editorBoard .piece-417db:active,
#computerBoard .piece-417db:active,
#puzzleRushBoard .piece-417db:active {
  cursor: grabbing !important;
}

/* Optional: squares feel interactive */
#chessboard .square-55d63,
#editorBoard .square-55d63,
#computerBoard .square-55d63,
#puzzleRushBoard .square-55d63 {
  cursor: grab;
}

/* üß© Board Editor ‚Äì spare pieces container */
#editorBoard .spare-pieces,
#editorBoard .spare-pieces-7492f {
  background: linear-gradient(180deg, #2a2f55, #1f2446);
  border-radius: 10px;
  padding: 8px 10px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.08),
    0 6px 18px rgba(0,0,0,0.35);
}

/* üìã Copy FEN button */
.btn-copy-fen {
  margin-top: 10px;
  background: linear-gradient(135deg, #2f3468, #1e2248);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px;
  padding: 8px 14px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-copy-fen:hover {
  background: linear-gradient(135deg, #3b4190, #262b66);
}

.fen-copy-status {
  display: inline-block;
  margin-left: 10px;
  font-size: 12px;
  color: #7CFF7C;
}

.hidden {
  display: none;
}


.castling-box {
  display: flex;
  gap: 20px;
  margin-top: 6px;
  font-size: 13px;
}

.castling-box label {
  cursor: pointer;
}



.castling-row {
  display: grid;
  grid-template-columns: 50px auto auto;
  align-items: center;
  column-gap: 16px;
  margin-top: 6px;
}

.castling-row .side {
  font-weight: 600;
  font-size: 13px;
}

.castle-opt {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;   /* üî¥ THIS IS THE KEY */
}

.castle-opt span {
  white-space: nowrap;   /* üî¥ PREVENTS O- / O WRAP */
}


.castling-row {
  display: grid;
  grid-template-columns: 50px 1fr 1fr; /* equal columns */
  align-items: center;
  margin-top: 6px;
}

.castle-opt {
  display: flex;
  align-items: center;      /* üî• vertical centering */
  gap: 6px;
  white-space: nowrap;
}

.castle-opt input {
  margin: 0;                /* üî• removes checkbox vertical offset */
}

.bot-panel {
  position: relative;
  width: 180px;
  text-align: center;
}

.bot-bubble {
  position: relative;
  margin-top: 14px;

  padding: 20px 24px;          /* ‚¨Ö bigger bubble */
  background: #222958;
  color: #ffffff;

  border-radius: 26px;         /* ‚¨Ö softer, bigger cloud */
  font-size: 22px;             /* ‚¨Ö BIGGER TEXT */
  font-weight: 700;            /* ‚¨Ö stronger readability */

  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.45);
  display: inline-block;

  max-width: 190px;            /* ‚¨Ö wider bubble */
  line-height: 1.35;           /* ‚¨Ö better spacing */
  text-align: center;

  animation: popIn 0.25s ease-out;
}


/* üî∫ Bubble tail */
/* üî∫ Extended bubble tail */
.bot-bubble::before {
  content: "";
  position: absolute;
  top: -14px;                 /* ‚¨Ö move tail upward */
  left: 50%;
  transform: translateX(-50%);

  border-width: 0 10px 14px 10px;   /* ‚¨Ö LONGER tail */
  border-style: solid;
  border-color: transparent transparent #1c1f35 transparent;
}


.bot-bubble.hidden {
  display: none;
}

/* ‚ú® Smooth pop animation */
@keyframes popIn {
  from {
    transform: scale(0.85);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}



/* ===============================
   üìò STUDY LAYOUT (PHASE 1)
   =============================== */

.study-layout {
  display: grid;
  grid-template-columns: 280px minmax(640px, 1.6fr) 320px;
  gap: 18px;
  height: calc(100vh - 220px);
}


/* LEFT PANEL */
.study-left {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 12px;
  display: flex;
  flex-direction: column;
}

.study-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  color: #ffd700;
}

.study-list {
  flex: 1;
  max-height: calc(100vh - 260px); /* üëà limits height */
  overflow-y: auto;
  padding-right: 6px;
}

.study-list::-webkit-scrollbar {
  width: 6px;
}

.study-list::-webkit-scrollbar-thumb {
  background: rgba(255, 215, 0, 0.35);
  border-radius: 6px;
}

.study-list::-webkit-scrollbar-track {
  background: transparent;
}



.study-item {
  padding: 10px;
  font-weight: 700;
  color: #ffd700;
}

.study-chapter {
  padding: 8px 10px;
  cursor: pointer;
  border-radius: 8px;
}

.study-chapter:hover {
  background: rgba(255,255,255,0.05);
}

/* CENTER BOARD */
.study-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.study-board-placeholder {
  width: min(78vh, 78vw);
  max-width: 680px;
  aspect-ratio: 1 / 1;

  background: #101226;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);

  display: flex;
  align-items: center;
  justify-content: center;

  color: #9da0b8;
  font-size: 1.1rem;
}


/* RIGHT PANEL */
.study-right {
  display: flex;
  flex-direction: column;
  gap: 14px;
  height: 100%;
}

/* üîΩ Smaller engine */
.study-engine {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 12px;
  flex: 0 0 20%; /* engine height */
}

/* üîº Bigger notation */
.study-notation {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 12px;
  flex: 1; /* takes remaining space */
}


/* ===== Study interactions ===== */

.study-item {
  cursor: pointer;
  user-select: none;
}

.study-item.active {
  color: #ffd700;
}

.study-chapter {
  margin-left: 14px;
  font-size: 0.95rem;
  color: #d0d2ff;
}

.study-chapter.active {
  background: rgba(255, 215, 0, 0.12);
  color: #ffd700;
  font-weight: 600;
}


/* ===== Study Import Modal ===== */

.study-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.study-modal.hidden {
  display: none;
}

.study-modal-content {
  width: 520px;
  background: #1b1e3a;
  border-radius: 14px;
  padding: 18px;
}

.study-modal textarea {
  width: 100%;
  height: 220px;
  background: #0e1026;
  border: none;
  border-radius: 10px;
  padding: 12px;
  color: #fff;
  resize: none;
  margin-top: 10px;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 12px;
}




.notation-placeholder {
  overflow-y: auto;
  font-family: "Segoe UI", monospace;
  font-size: 0.95rem;
}

.notation-row {
  display: flex;
  gap: 8px;
  padding: 4px 0;
}

.move-num {
  color: #aaa;
  width: 28px;
}

.move.white {
  color: #fff;
  min-width: 48px;
}

.move.black {
  color: #bbb;
}


/* üìò Study notation ‚Äì grab cursor */
.study-notation .move {
  cursor: grab;
}

.study-notation .move:active {
  cursor: grabbing;
}


/* ‚ôüÔ∏è Study board ‚Äì grab cursor */
#studyBoard .piece-417db {
  cursor: grab;
}

#studyBoard .piece-417db:active {
  cursor: grabbing;
}


/* üìú Study notation panel (Lichess-like) */
.study-notation {
  max-height: 520px;        /* match board height */
  overflow-y: auto;         /* vertical scroll */
  overflow-x: hidden;       /* no horizontal scroll */
  padding-right: 6px;
}

/* Each move row */
.notation-row {
  display: block;
  white-space: normal;      /* allow wrapping */
  line-height: 1.6;
}

/* üåø Inline variations ( (Rxg6+) style ) */
.move.variation {
  margin-left: 6px;
  color: #aaa;
  font-style: italic;
  cursor: grab;
  white-space: normal;
  display: inline;
}

.move.variation:hover {
  color: #ffd700;
}

/* üñ± Scrollbar polish */
.study-notation::-webkit-scrollbar {
  width: 6px;
}

.study-notation::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 4px;
}

/* üîí Engine container ‚Äî FIXED SIZE */
.study-engine-box {
  background: #0f172a;
  border-radius: 12px;
  padding: 12px;
  color: #e5e7eb;
  font-size: 14px;

  height: 180px;              /* ‚úÖ FIXED HEIGHT */
  display: flex;
  flex-direction: column;
  overflow: hidden;           /* ‚ùå prevent resizing */
}

/* ===== Header ===== */
.engine-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;             /* üîí never shrink */
}

.engine-title {
  font-weight: 600;
}

.wasm-badge {
  background: #2563eb;
  color: #fff;
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 6px;
  margin-left: 6px;
}

/* ===== Toggle ===== */
.engine-toggle {
  border: none;
  border-radius: 6px;
  padding: 4px 10px;
  font-weight: 600;
  cursor: pointer;
}

.engine-toggle.off {
  background: #374151;
  color: #fff;
}

.engine-toggle.on {
  background: #16a34a;
  color: #fff;
}

/* ===== Stats ===== */
.engine-stats {
  margin-top: 6px;
  color: #93c5fd;
  flex-shrink: 0;             /* üîí fixed */
}

/* ===== PV Lines (ONLY THIS SCROLLS) ===== */
.engine-line {
  background: #020617;
  border-radius: 8px;
  padding: 6px 10px;
  margin-bottom: 6px;

  font-family: "JetBrains Mono", monospace; /* optional but üî• */
  font-size: 13.5px;
  font-weight: 600;          /* ‚úÖ makes moves bold */
  letter-spacing: 0.3px;     /* improves readability */
  color: #e5e7eb;

  line-height: 1.5;
}


/* Optional scrollbar polish */
.engine-lines::-webkit-scrollbar {
  width: 6px;
}
.engine-lines::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 6px;
}

/* ===== Individual PV Line ===== */
.engine-line {
  background: #020617;
  border-radius: 8px;
  padding: 6px 8px;
  margin-bottom: 6px;
  font-family: monospace;
  font-size: 13px;
  line-height: 1.4;
}

#enginePanel {
  height: 180px;              /* üîí FIXED HEIGHT */
  display: flex;
  flex-direction: column;
  overflow: hidden;           /* prevent resize */
}




/* üîí Study Engine fixed height (already done, re-confirm) */
.study-engine-box {
  height: 180px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* ‚úÖ SCROLLABLE PV AREA */
.engine-lines {
  flex: 1;                    /* take remaining space */
  overflow-y: auto;           /* ‚úÖ enable vertical scroll */
  margin-top: 8px;
  padding-right: 6px;
}

/* üé® Scrollbar styling (optional but nice) */
.engine-lines::-webkit-scrollbar {
  width: 6px;
}

.engine-lines::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 6px;
}

.engine-lines::-webkit-scrollbar-track {
  background: transparent;
}


/* üîí FIXED HEIGHT ANALYSIS ENGINE */
#enginePanel {
  height: 170px;              /* fixed height */
  display: flex;
  flex-direction: column;
  overflow: hidden;           /* prevent jumping */
}

/* Header must stay fixed */
.engine-bar {
  flex-shrink: 0;
}

/* ‚úÖ SCROLLABLE PV LINES */
.engine-body {
  flex: 1;                    /* take remaining space */
  overflow-y: auto;           /* ENABLE SCROLL */
  padding-right: 6px;
}

/* üé® Scrollbar styling (optional, matches Study) */
.engine-body::-webkit-scrollbar {
  width: 6px;
}

.engine-body::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 6px;
}

.engine-body::-webkit-scrollbar-track {
  background: transparent;
}


#quiz-section {
  min-height: calc(100vh - 140px);
}

#quizBoard {
  width: 420px;
}


.quiz-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
}

.quiz-timer,
.quiz-score {
  background: linear-gradient(180deg, #0f172a, #020617);
  border: 2px solid #facc15;          /* gold border */
  padding: 14px 22px;
  border-radius: 16px;

  font-weight: 800;
  font-size: 22px;                    /* BIG */
  letter-spacing: 0.5px;
  color: #facc15;                     /* gold text */

  display: flex;
  align-items: center;
  gap: 8px;

  box-shadow:
    0 0 0 3px rgba(250, 204, 21, 0.15),
    0 12px 30px rgba(0, 0, 0, 0.6);
}

#quizTimer,
#quizScore {
  font-size: 28px;
  font-weight: 900;
}

.quiz-timer.warning {
  border-color: #ef4444;
  color: #ef4444;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%   { box-shadow: 0 0 0 0 rgba(239,68,68,0.6); }
  70%  { box-shadow: 0 0 0 10px rgba(239,68,68,0); }
  100% { box-shadow: 0 0 0 0 rgba(239,68,68,0); }
}




.quiz-title {
  text-align: center;
  font-size: 18px;
  font-weight: 600;
  color: #e5e7eb;
  margin-bottom: 14px;
}


#quizBoardWrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 16px 0 18px;
}

#quizBoard {
  width: 500px;
  max-width: 100%;
  border-radius: 14px;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6);
}

.quiz-options {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 10px;
}

.quiz-option {
  background: linear-gradient(180deg, #1e293b, #111827);
  border: 1px solid #334155;
  border-radius: 14px;
  padding: 14px 10px;
  font-size: 15px;
  font-weight: 600;
  color: #e5e7eb;
  cursor: pointer;
  transition: all 0.15s ease;
}

.quiz-option:hover {
  background: linear-gradient(180deg, #2563eb, #1d4ed8);
  border-color: #3b82f6;
  transform: translateY(-1px);
}

.quiz-option:active {
  transform: scale(0.98);
}

@media (max-width: 480px) {
  #quizBoard {
    width: 100%;
  }

  .quiz-option {
    font-size: 14px;
    padding: 12px 8px;
  }
}



.mini-game {
  width: 450px;
  margin: 0 auto;
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 18px;
  padding: 14px;
  box-shadow: 0 12px 30px rgba(0,0,0,0.45);
  color: #fff;
  text-align: center;
}

.mini-header {
  display: flex;
  justify-content: space-between;
  font-weight: bold;
  margin-bottom: 20px;
}

.mini-title {
  color: gold;
}

.mini-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr); /* üîí force equal ranks */
  aspect-ratio: 1 / 1;               /* üîí perfect square */
  width: 100%;
}

.mini-square {
  width: 64px;
  height: 64px;
  background: #f0d9b5;            /* ‚ôüÔ∏è light square */
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}


.mini-square.dark {
  background: #b58863;            /* ‚ôüÔ∏è dark square */
}

.mini-square.correct {
  background: #4ade80 !important;
}

.mini-square.wrong {
  background: #ef4444 !important;
}

.mini-footer {
  margin-top: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#startMiniGame {
  padding: 6px 14px;
  border-radius: 10px;
  border: none;
  background: gold;
  font-weight: bold;
  cursor: pointer;
}





.mini-games-row {
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* üî• 2 columns */
  grid-template-rows: repeat(2, 1fr);    /* üî• 2 rows */
  gap: 28px;
  align-items: stretch;
}


@media (max-width: 1200px) {
  .mini-games-row {
    grid-template-columns: repeat(2, 260px);
  }
}

@media (max-width: 620px) {
  .mini-games-row {
    grid-template-columns: 1fr;
  }
}


.mini-game {
  width: 260px;
}


.mini-piece {
  width: 40px;          /* ‚¨ÜÔ∏è was 28px */
  height: 40px;
  object-fit: contain;
  pointer-events: none;
}





.mini-square {
  width: 38px;
  height: 38px;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;   /* VERY IMPORTANT */
}


.mini-square {
  cursor: grab;
}

.mini-square:active {
  cursor: grabbing;
}





















/* =========================
   FOOTER
========================= */

.mini-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 40px;
  margin-top: 6px;
}

.mini-footer .stars {
  font-size: 20px;
  font-weight: 700;
  color: #ffd700;
  background: rgba(255,215,0,0.15);
  padding: 6px 12px;
  border-radius: 999px;
  box-shadow: inset 0 0 0 1px rgba(255,215,0,0.35);
}


/* =========================
   ‚ú® BEAUTIFUL START BUTTON
========================= */

.mini-footer button {
  padding: 10px 26px;
  font-size: 16px;
  font-weight: 800;
  border-radius: 999px;
  border: none;
  cursor: pointer;

  background: linear-gradient(180deg, #ffd700, #e6b800);
  color: #111;

  box-shadow:
    0 6px 18px rgba(255,215,0,0.45),
    inset 0 2px 0 rgba(255,255,255,0.35);

  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.mini-footer button:hover {
  transform: translateY(-1px);
  box-shadow:
    0 10px 28px rgba(255,215,0,0.6),
    inset 0 2px 0 rgba(255,255,255,0.45);
}


/* Hover */
.mini-footer button:hover {
  transform: translateY(-2px) scale(1.05);
  box-shadow:
    0 10px 22px rgba(255,215,0,0.65),
    inset 0 -2px 0 rgba(0,0,0,0.3);
}

/* Click */
.mini-footer button:active {
  transform: scale(0.95);
  box-shadow:
    0 4px 10px rgba(255,215,0,0.4),
    inset 0 2px 4px rgba(0,0,0,0.35);
}

/* =========================
   MOBILE TUNING
========================= */

@media (max-width: 520px) {
  .mini-title {
    font-size: 14px;
  }

  .mini-footer button {
    padding: 7px 16px;
    font-size: 12px;
  }
}

/* ===============================
   üéØ QUIZ RESULT MODAL (ISOLATED)
================================ */

.quiz-result-modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.55);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999; /* higher than quiz, lower than system modals */
}

.quiz-result-modal.hidden {
  display: none;
}

.quiz-result-box {
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 16px;
  padding: 24px 28px;
  width: 320px;
  text-align: center;
  box-shadow: 0 20px 50px rgba(0,0,0,0.6);
  animation: quizPop 0.25s ease-out;
}

.quiz-result-box h2 {
  color: #ffd700;
  margin-bottom: 10px;
}

.quiz-result-box p {
  color: #e5e7eb;
  font-size: 15px;
  margin-bottom: 18px;
}

.quiz-result-box button {
  background: #ffd700;
  color: #12162d;
  border: none;
  padding: 10px 18px;
  border-radius: 10px;
  font-weight: bold;
  cursor: pointer;
}

.quiz-result-box button:hover {
  background: #f5c400;
}

@keyframes quizPop {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}






.mini-square {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden; /* safety */
}



.practice-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);   /* üîí FORCE rows */

  width: 530px;
  height: 530px;                        /* üîí ABSOLUTE LOCK */

  
  border-radius: 0px;
  overflow: hidden;
}






.mini-piece {
  width: 90%;
  height: 90%;
  object-fit: contain;
  pointer-events: none;
  display: block;
}


.mini-square {
  position: relative;
}


.mini-game {
  background: radial-gradient(circle at top, #1e2448, #0d1022);
  border-radius: 18px;
  padding: 16px 16px 18px;
  box-shadow:
    0 20px 50px rgba(0,0,0,0.55),
    0 0 0 1px rgba(255,215,0,0.12);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  
}


.mini-game {
  display: flex;
  flex-direction: column;
  align-items: center;   /* üî• THIS is the key */
  gap: 12px;
}


/* ONLY piece practice boards */
.practice-board .mini-square[data-x="0"]::before {
  content: attr(data-rank);
  position: absolute;
  left: 4px;
  top: 4px;
  font-size: 20px;
  font-weight: 700;
  color: rgba(54, 6, 117, 0.851);
  pointer-events: none;
}


.practice-board .mini-square[data-y="7"]::after {
  content: attr(data-file);
  position: absolute;
  right: 4px;
  bottom: 4px;
  font-size: 20px;
  font-weight: 700;
  color: rgba(54, 6, 117, 0.851);
  pointer-events: none;
}



.mini-footer {
  display: flex;
  align-items: center;
  gap: 18px;
}

/* ‚≠ê & ‚ùå pill */
.mini-footer .stars,
.mini-footer .misses {
  display: flex;
  align-items: center;
  gap: 8px;

  padding: 10px 18px;        /* ‚¨ÜÔ∏è BIGGER */
  border-radius: 999px;

  font-weight: 800;
  font-size: 18px;           /* ‚¨ÜÔ∏è BIGGER TEXT */

  min-width: 70px;           /* ‚¨ÖÔ∏è keeps pill size consistent */
  justify-content: center;

  background: rgba(0, 0, 0, 0.55);
  box-shadow:
    inset 0 0 0 2px rgba(255, 215, 0, 0.35),
    0 6px 14px rgba(0,0,0,0.4);
}

/* ‚≠ê */
.mini-footer .stars {
  color: #ffd700;
}

/* ‚ùå */
.mini-footer .misses {
  color: #ff4d4d;
  box-shadow:
    inset 0 0 0 2px rgba(255, 77, 77, 0.45),
    0 6px 14px rgba(0,0,0,0.4);
}


/* üî• Mini-game header title (ALL pieces) */
.mini-title {
  display: inline-flex;
  align-items: center;
  gap: 8px;

  font-size: 18px;        /* ‚¨ÜÔ∏è was small ‚Üí now readable */
  font-weight: 800;       /* bold */
  letter-spacing: 0.4px;

  color: #ffd700;         /* Olympus gold */
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
}



.target-object {
  position: absolute;
  width: 75%;
  height: 75%;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;

  /* glow */
  filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.8))
          drop-shadow(0 0 14px rgba(255, 180, 0, 0.6));

  animation: glowFloat 1.6s ease-in-out infinite;
}

/* ‚ú® glowing + floating */
@keyframes glowFloat {
  0% {
    transform: translate(-50%, -52%) scale(1);
    filter: drop-shadow(0 0 6px rgba(0, 4, 255, 0.7))
            drop-shadow(0 0 14px rgba(255, 0, 200, 0.5));
  }
  50% {
    transform: translate(-50%, -58%) scale(1.08);
    filter: drop-shadow(0 0 12px rgb(24, 2, 75))
            drop-shadow(0 0 26px rgba(228, 0, 141, 0.9));
  }
  100% {
    transform: translate(-50%, -52%) scale(1);
    filter: drop-shadow(0 0 6px rgba(255, 0, 0, 0.7))
            drop-shadow(0 0 14px rgba(255, 180, 0, 0.5));
  }
}


.target-object {
  width: 80%;
  height: 80%;
}

#botMouth {
  z-index: 5;
}

.bot-avatar img {
  position: relative;
  z-index: 1;
}



#studyDrawLayer {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none; /* prevents crashes */
}


.memory-top {
  display: flex;
  justify-content: space-between;
  font-size: 18px;
  margin-bottom: 10px;
}

.memory-square {
  width: 100%;
  aspect-ratio: 1;
  background: #e5e7eb;
  cursor: pointer;
}

/* =========================
   ‚ôü MEMORY BOARD COORDINATES
   (UNIFORM DEEP BLUE)
========================= */

.memory-square {
  position: relative;
}

.memory-coord {
  position: absolute;
  top: 4px;
  left: 4px;

  font-size: 11px;
  font-weight: 700;
  line-height: 1;

  /* üîµ Uniform deep blue */
  color: #60038b;

  opacity: 1;
  pointer-events: none;
  user-select: none;

  /* subtle glow for readability */
  text-shadow: 0 0 3px rgba(30, 111, 217, 0.45);
}


.memory-square.dark {
  background: #9ca3af;
}

.memory-square.flash {
  background: #22c55e !important;
}

.memory-square.correct {
  background: #16a34a !important;
}

.memory-square.wrong {
  background: #dc2626 !important;
}


/* ============================= */
/* üß† Memory Squares Board Size  */
/* ============================= */

#memory-section .mini-board {
  width: 560px;        /* üëà control size here */
  max-width: 90vw;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  aspect-ratio: 1;
}



/* ============================= */
/* üß† Memory Squares ‚Äì Top Bar   */
/* ============================= */

#memory-section .memory-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 360px;
  margin: 0 auto 14px auto;
  padding: 8px 14px;
  background: rgba(0, 0, 0, 0.35);
  border-radius: 14px;
  font-size: 20px;
  font-weight: 600;
  color: #f8fafc;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
}

#memory-section .memory-top span {
  margin-left: 6px;
}

#memory-section .memory-top .timer {
  color: #38bdf8; /* blue */
}

#memory-section .memory-top .lives {
  color: #f87171; /* red */
}

#memory-section .memory-top .score {
  color: #facc15; /* gold */
}




/* ============================= */
/* üß† Memory Squares ‚Äì Board     */
/* ============================= */

#memory-section .memory-square {
  width: 100%;
  aspect-ratio: 1;
  cursor: pointer;
  transition: background 0.15s ease, box-shadow 0.15s ease;
}

#memory-section .memory-square:not(.dark) {
  background: #f0d9b5; /* light brown */
}

#memory-section .memory-square.dark {
  background: #b58863; /* dark brown */
}



#memory-section .memory-square.flash {
  background: #222dc5 !important;
  box-shadow: 0 0 12px rgba(34,197,94,0.8);
}

#memory-section .memory-square.correct {
  background: #16a34a !important;
}

#memory-section .memory-square.wrong {
  background: #dc2626 !important;
}


/* ============================= */
/* üß† Memory Squares ‚Äì Mode Cards */
/* ============================= */

#memory-section #memoryMenu {
  max-width: 900px;
  margin: 0 auto;
}

#memory-section #memoryMenu h3 {
  font-size: 22px;
  margin-bottom: 18px;
  color: #facc15;
}

/* Grid for big buttons */
#memory-section .control-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
}

/* Big buttons */
#memory-section .control-grid button {
  height: 64px;
  font-size: 20px;
  font-weight: 700;
  border-radius: 14px;
  letter-spacing: 0.5px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.35);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

/* Hover effect */
#memory-section .control-grid button:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 26px rgba(0,0,0,0.45);
}

/* Survival full width */
#memory-section .control-grid button#memSurvival {
  grid-column: 1 / -1;
  height: 58px;
  font-size: 19px;
}

#memory-section .control-grid button {
  border: 2px solid rgba(255,255,255,0.15);
}


/* ===============================
   üëë QUEEN MEMORY PATH
================================ */

#pathfinder-section .card {
  max-width: 600px;
  margin: auto;
}

#pfBoard {
  display: grid;
  grid-template-columns: repeat(8, 1fr);

  /* ‚¨ÜÔ∏è Bigger board */
  width: 570px;
  height: 570px;

  margin: 24px auto;
}



.pf-square.light { background: #f0d9b5; }
.pf-square.dark  { background: #b58863; }

/* flash colors */
.pf-green { background: #3fb950 !important; }
.pf-red   { background: #ff4d4f !important; }
.pf-grey  { background: #6b7280 !important; }

.pf-queen {
  width: 100%;
  height: 100%;
  background: url("assets/pieces/wQ.png") center / 70% no-repeat;
}

.pf-home {
  width: 100%;
  height: 100%;
  background: url("assets/icons/home.png") center / 70% no-repeat;
}

.pf-square {
  position: relative;
}

.pf-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}


/* cursor when hovering board */
#pfBoard {
  cursor: grab;
}

/* cursor while clicking */
#pfBoard:active {
  cursor: grabbing;
}

/* individual squares also show grab */
#pfBoard .pf-square {
  cursor: grab;
}

#pfBoard .pf-square:active {
  cursor: grabbing;
}



.qp-home {
  font-size: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;

  background: rgba(0, 255, 0, 0.15);
  border: none solid #00ff66;
  border-radius: 0px;
}


.pf-home-icon {
  font-size: 40px;
  pointer-events: none; /* üëà very important */
}

/* ================================
   üéØ PATHFINDER MODE SELECTION
================================ */

#pfMenu.card {
  max-width: 720px;
  margin: 0 auto;
  padding: 32px 36px;
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 20px;
  box-shadow: 0 20px 50px rgba(0,0,0,0.55);
  border-left: 5px solid #facc15;
}

#pfMenu h3 {
  font-size: 30px;
  margin-bottom: 28px;
  color: #facc15;
  text-align: center;
  letter-spacing: 0.5px;
}

/* grid layout */
#pfMenu .control-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
}

/* buttons */
#pfMenu button {
  height: 70px;
  font-size: 19px;
  font-weight: 700;
  border-radius: 14px;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

/* hover effect */
#pfMenu button:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 10px 25px rgba(0,0,0,0.4);
}

/* EASY */
#pfEasy {
  background: linear-gradient(135deg, #22c55e, #16a34a);
  color: #022c22;
}

/* MEDIUM */
#pfMedium {
  background: linear-gradient(135deg, #facc15, #eab308);
  color: #3a2f00;
}

/* SURVIVAL */
#pfSurvival {
  grid-column: span 2;
  background: linear-gradient(135deg, #ff4d4d, #dc2626);
  color: white;
  font-size: 20px;
}


/* ================================
   üéØ PATH FINDER HUD (TIMER / LIFE / STAR)
================================ */

.pf-hud {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
}

/* common HUD item */
.pf-hud .hud-item {
  background: linear-gradient(180deg, #1f2547, #141a33);
  border-radius: 14px;
  padding: 10px 14px;
  font-size: 20px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.06),
    0 6px 20px rgba(0,0,0,0.4);
}

/* timer */
.pf-hud .timer {
  color: #38bdf8;
}

/* lives */
.pf-hud .lives {
  color: #ff4d4d;
}

/* stars */
.pf-hud .score {
  color: #facc15;
}

/* numbers */
.pf-hud span {
  font-size: 20px;
}

/* small pulse when values change (optional but nice) */
.pf-hud span {
  transition: transform 0.15s ease;
}


.pf-queen-emoji {
  font-size: 42px;
  line-height: 1;
  cursor: grab;
  user-select: none;

  display: flex;
  align-items: center;
  justify-content: center;
  

  animation: queenIdle 1.6s ease-in-out infinite;
}

@keyframes queenIdle {
  0%   { transform: translateY(0); }
  50%  { transform: translateY(-3px); }
  100% { transform: translateY(0); }
}


.pf-queen-emoji:active {
  cursor: grabbing;
}


.pf-piece {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 34px;
  line-height: 1;
}

.mini-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  width: 550px;          /* ‚úÖ FIXED SIZE */
  height: 550px;         /* ‚úÖ PERFECT SQUARE */
  margin: 20px auto;
  border-radius: 10px;
  overflow: hidden;
}


.pf-square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;      /* emoji size */
  cursor: pointer;
  user-select: none;
}



/* All flash-queen pieces */
.pf-piece {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 38px;          /* üî• increase emoji size */
  line-height: 1;
  cursor: pointer;
}

/* Queen slightly bigger + highlight */
.pf-piece.queen {
  font-size: 34px;
  filter: drop-shadow(0 0 6px gold);
}


/* üî• BIG MODE SELECTION CARD */
#flashQueenMenu {
  max-width: 900px;                 /* bigger card */
  margin: 40px auto;
  padding: 32px 36px;

  background: linear-gradient(
    180deg,
    #1b2142 0%,
    #141a36 100%
  );

  border-radius: 22px;
  border: 2px solid rgba(255, 215, 0, 0.35);

  box-shadow:
    0 0 25px rgba(255, 215, 0, 0.25),
    0 0 60px rgba(255, 215, 0, 0.15),
    inset 0 0 20px rgba(255, 255, 255, 0.04);

  animation: fqGlow 3s ease-in-out infinite;
}

/* ‚ú® subtle breathing glow */
@keyframes fqGlow {
  0% {
    box-shadow:
      0 0 18px rgba(255, 215, 0, 0.18),
      0 0 45px rgba(255, 215, 0, 0.12);
  }
  50% {
    box-shadow:
      0 0 32px rgba(255, 215, 0, 0.35),
      0 0 80px rgba(255, 215, 0, 0.25);
  }
  100% {
    box-shadow:
      0 0 18px rgba(255, 215, 0, 0.18),
      0 0 45px rgba(255, 215, 0, 0.12);
  }
}


#flashQueenMenu .control-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
  margin-top: 24px;
}

#flashQueenMenu button {
  font-size: 20px;
  padding: 18px 22px;
  border-radius: 14px;
  font-weight: 700;
  letter-spacing: 0.5px;
}

/* Survival stands out */
#fqSurvival {
  grid-column: span 2;
  font-size: 21px;
}


/* ============================= */
/* üéÆ COMPACT HUD (FIXED HEIGHT) */
/* ============================= */

.flash-queen-hud,
.memory-top {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin: 10px 0 14px;   /* ‚¨ÖÔ∏è reduced vertical margin */
}

#flashQueenBoard {
  margin-top: -1px;
}


.flash-queen-hud .timer,
#fqTimer {
  background: linear-gradient(180deg, #1e2a5c, #131c3f);
  border-radius: 14px;
  padding: 14px 18px;
  margin-top: -40px;


  font-size: 20px;
  font-weight: 700;
  color: #4fd1ff;

  display: flex;
  align-items: center;
  justify-content: center;

  box-shadow:
    inset 0 0 12px rgba(79, 209, 255, 0.25),
    0 0 18px rgba(79, 209, 255, 0.18);
}

.flash-queen-hud .lives,
#fqLives {
  background: linear-gradient(180deg, #4a0f1f, #2a0610);
  border-radius: 14px;
  padding: 14px 18px;
  margin-top: -40px;

  font-size: 20px;
  font-weight: 800;
  color: #ff4d6d;

  display: flex;
  align-items: center;
  justify-content: center;

  box-shadow:
    inset 0 0 12px rgba(255, 77, 109, 0.3),
    0 0 18px rgba(255, 77, 109, 0.25);
}

.flash-queen-hud .score,
#fqScore {
  background: linear-gradient(180deg, #5a4600, #2f2500);
  border-radius: 14px;
  padding: 14px 18px;
  margin-top: -40px;

  font-size: 20px;
  font-weight: 800;
  color: #ffd700;

  display: flex;
  align-items: center;
  justify-content: center;

  box-shadow:
    inset 0 0 14px rgba(255, 215, 0, 0.35),
    0 0 22px rgba(255, 215, 0, 0.35);
}

.flash-queen-question,
.question {
  margin: 6px 0 14px;
  margin-top: -30px;



  font-size: 22px;
  font-weight: 800;
  text-align: center;

  color: #ffffff;
  letter-spacing: 0.5px;

  text-shadow:
    0 0 8px rgba(255, 215, 0, 0.45),
    0 0 18px rgba(255, 215, 0, 0.25);
}

.flash-queen-hud > div {
  animation: hudPop 0.35s ease-out;
}

@keyframes hudPop {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

/* normal emoji */
.pf-piece {
  font-size: 35px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* üë∏ QUEEN SPECIAL */
.pf-queen {
  font-size: 30px;                 /* bigger */
  
}




/* HOW TO PLAY ‚Äì Puzzle Rush */
.how-to-play {
  margin-top: 18px;
  padding: 16px 18px;
  border-radius: 14px;
  background: linear-gradient(180deg, #1b203f, #141833);
  border: 1px solid rgba(255, 215, 0, 0.25);
  box-shadow: inset 0 0 18px rgba(255, 215, 0, 0.08);
}

.how-to-play h4 {
  margin-bottom: 10px;
  color: #ffd700;
  font-size: 1.05rem;
  text-align: center;
}

.how-to-play ul {
  list-style: none;
  padding: 0;
  margin: 0 0 10px;
}

.how-to-play li {
  font-size: 0.95rem;
  color: #eaeaf0;
  padding: 4px 0;
  line-height: 1.4;
}

.how-to-play .mode-info {
  font-size: 0.85rem;
  color: #b9c0ff;
  border-top: 1px dashed rgba(255, 215, 0, 0.3);
  padding-top: 8px;
}

.how-to-play .mode-info span {
  color: #ffd700;
  font-weight: 600;
}


/* HOW TO PLAY ‚Äì Shared Style */
.how-to-play {
  margin-top: 18px;
  padding: 16px 18px;
  border-radius: 14px;
  background: linear-gradient(180deg, #1b203f, #141833);
  border: 1px solid rgba(255, 215, 0, 0.25);
  box-shadow: inset 0 0 18px rgba(255, 215, 0, 0.08);
}

.how-to-play h4 {
  margin-bottom: 10px;
  color: #ffd700;
  font-size: 1.05rem;
  text-align: center;
}

.how-to-play ul {
  list-style: none;
  padding: 0;
  margin: 0 0 10px;
}

.how-to-play li {
  font-size: 0.95rem;
  color: #eaeaf0;
  padding: 4px 0;
  line-height: 1.4;
}

.how-to-play .mode-info {
  font-size: 0.85rem;
  color: #b9c0ff;
  border-top: 1px dashed rgba(255, 215, 0, 0.3);
  padding-top: 8px;
}

.how-to-play .mode-info span {
  color: #ffd700;
  font-weight: 600;
}

.kp-square {
  position: relative;
}

.ksr-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* üîµ deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}



.kp-square.flash {
  background: #ffd700 !important;
  box-shadow: inset 0 0 0 4px #ff9800;
}

.kp-square.knight {
  font-size: 28px;
}

.kp-square {
  position: relative;
}

.kem-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}






/* ===== Knight Flash Path Board ===== */
/* ===== Knight Flash Path Board (REAL CHESS BOARD) ===== */
#kpBoard {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  width: 580px;
  height: 580px;
   margin: -25px auto 30px;
  border-radius: 12px;
  overflow: hidden;
  border: 3px solid #3b2a1a;
}

.kp-square {
  position: relative;
}

.kp-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;       /* üíú Deep Blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}



/* Square base */
.kp-square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
  cursor: pointer;
  user-select: none;
}

/* REAL chessboard coloring */
.kp-square.light {
  background: #f0d9b5; /* light brown */
}

.kp-square.dark {
  background: #b58863; /* dark brown */
}

/* Flash highlight */
.kp-square.flash {
  background: #ffd700 !important;
  box-shadow: inset 0 0 0 3px #ff9800;
}

/* Knight piece */
.kp-square.knight {
  font-size: 28px;
}



.kp-square.knight {
  font-size: 35px;
  line-height: 1;
}

#kpBoard.locked {
  pointer-events: none;
}


/* ===== Knight Flash Path Card ===== */
.kp-card {
  background: linear-gradient(180deg, #1a2040, #141a33);
  border-radius: 18px;
  padding: 22px;
  box-shadow:
    0 15px 40px rgba(0,0,0,0.55),
    inset 0 0 0 1px rgba(255,255,255,0.05);
}

/* Title */
.kp-card h3 {
  margin-bottom: 14px;
  color: #ffd700;
  font-weight: 700;
}

/* ===== Mode Buttons ===== */
.kp-modes {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 14px;
  margin-bottom: 18px;
}

.kp-mode-btn {
  padding: 14px 18px;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.25s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

/* Easy */
.kp-mode-easy {
  background: linear-gradient(135deg, #28c76f, #1ea85a);
  color: #081b12;
}

/* Medium */
.kp-mode-medium {
  background: linear-gradient(135deg, #ffd44d, #ffb703);
  color: #2b1d00;
}

/* Hard */
.kp-mode-hard {
  grid-column: span 2;
  background: linear-gradient(135deg, #ff4d4f, #d62828);
  color: #fff;
}

/* Hover effect */
.kp-mode-btn:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 8px 25px rgba(0,0,0,0.4);
}

/* ===== How To Play ===== */
.kp-how {
  margin-top: 16px;
  padding: 16px;
  border-radius: 14px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,215,0,0.2);
}

.kp-how h4 {
  margin-bottom: 10px;
  color: #ffd700;
  display: flex;
  align-items: center;
  gap: 8px;
}

.kp-how ul {
  padding-left: 18px;
  margin: 0;
}

.kp-how li {
  margin-bottom: 8px;
  color: #d6dbff;
  line-height: 1.5;
  font-size: 20px;
}



/* ===== Knight Flash Path HUD ===== */
.memory-top {
  display: flex;
  gap: 24px;
  margin-bottom: 18px;
}

/* Each stat box */
.memory-top > div {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  border-radius: 14px;
  font-size: 15px;
  font-weight: 600;
  background: linear-gradient(180deg, #1f254a, #161c38);
  box-shadow:
    0 6px 18px rgba(0,0,0,0.4),
    inset 0 0 0 1px rgba(255,255,255,0.05);
}

/* Level specific */
.memory-top > div:first-child {
  color: #ffd700;
  border: 1px solid rgba(255,215,0,0.25);
}

/* Lives specific */
.memory-top > div:last-child {
  color: #ff6b6b;
  border: 1px solid rgba(255,107,107,0.25);
}

/* Numbers */
.memory-top span {
  font-size: 18px;
  font-weight: 800;
  margin-left: 2px;
  transition: transform 0.2s ease;
}

/* Optional pop animation */
.memory-top span.pop {
  transform: scale(1.2);
}

/* =============================== */
/* üß™ LAB MIXER ‚Äì ISOLATED STYLES */
/* =============================== */

.lm-square {
  position: relative;
}

.lm-overlay {
  position: absolute;
  inset: 0;
  border-radius: 0px;
  opacity: 0;
  transition: opacity 0.15s ease;
  pointer-events: none;
}

.lm-overlay.show {
  opacity: 0.9;
}

.lm-square {
  position: relative;
}

.lm-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;     /* üîµ deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}


/* color variants */
.lm-red    { background: #ff4d4d; }
.lm-green  { background: #3cff7a; }
.lm-blue   { background: #4da6ff; }
.lm-yellow { background: #ffd93d; }
.lm-orange { background: #ff9f43; }
.lm-violet { background: #b980ff; }


/* =============================== */
/* üß™ LAB MIXER ‚Äì FIND BANNER */
/* =============================== */

#color-section .lm-find-banner {
  text-align: center;
  margin: -70px auto 8px; /* üëà pulls UP */
  padding: 10px 18px;
  width: fit-content;

  background: linear-gradient(135deg, #1e223d, #2a2f55);
  border: 1px solid rgba(255, 215, 0, 0.35);
  border-radius: 14px;

  font-size: 18px;
  font-weight: 800;
  letter-spacing: 1px;
  color: #ffd700;

  box-shadow: 0 0 12px rgba(255, 215, 0, 0.25);
}

#color-section .lm-find-banner span {
  padding-left: 6px;
  text-transform: uppercase;
}


/* =============================== */
/* üß™ LAB MIXER ‚Äì FIND COLOR THEMES */
/* =============================== */

#color-section .find-red    { color: #ff4d4d; box-shadow: 0 0 14px rgba(255, 77, 77, 0.4); }
#color-section .find-green  { color: #3cff7a; box-shadow: 0 0 14px rgba(60, 255, 122, 0.4); }
#color-section .find-blue   { color: #4da6ff; box-shadow: 0 0 14px rgba(77, 166, 255, 0.4); }
#color-section .find-yellow { color: #ffd700; box-shadow: 0 0 14px rgba(255, 215, 0, 0.4); }
#color-section .find-orange { color: #ff9f43; box-shadow: 0 0 14px rgba(255, 159, 67, 0.4); }
#color-section .find-violet { color: #b980ff; box-shadow: 0 0 14px rgba(185, 128, 255, 0.4); }





/* =============================== */
/* üß™ LAB MIXER ‚Äì ROUND BADGE (ALWAYS GOLD) */
/* =============================== */

#color-section .lm-round {
  background: linear-gradient(
    135deg,
    #3a2c00,
    #8a6a00,
    #ffd700,
    #8a6a00
  );

  color: #1a1300;
  font-weight: 900;
  letter-spacing: 1px;

  padding: 6px 14px;
  border-radius: 10px;

  border: 1px solid rgba(255, 215, 0, 0.6);

  box-shadow:
    0 0 12px rgba(255, 215, 0, 0.6),
    inset 0 0 6px rgba(255, 255, 255, 0.35);

  text-shadow:
    0 1px 1px rgba(255, 255, 255, 0.6),
    0 -1px 1px rgba(0, 0, 0, 0.4);

  transition: all 0.25s ease;
}



#color-section .lm-round {
  animation: lmGoldPulse 2.8s ease-in-out infinite;
}

@keyframes lmGoldPulse {
  0%   { box-shadow: 0 0 10px rgba(255,215,0,0.4); }
  50%  { box-shadow: 0 0 20px rgba(255,215,0,0.9); }
  100% { box-shadow: 0 0 10px rgba(255,215,0,0.4); }
}




/* ============================= */
/* Knight vs Monster - Mode UI  */
/* ============================= */

.kvm-modes {
  display: grid;
  grid-template-columns: repeat(3, minmax(160px, 1fr));
  gap: 16px;
  margin: 20px 0;
}

.kvm-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* üîµ deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}

.kvm-mode {
  background: linear-gradient(180deg, #1b1f3b, #12142a);
  border: 2px solid #2f335c;
  border-radius: 14px;
  padding: 18px 10px;
  color: #fff;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 6px 16px rgba(0,0,0,0.4);
}

.kvm-mode span {
  display: block;
  margin-top: 6px;
  font-size: 13px;
  font-weight: 500;
  opacity: 0.8;
}

/* Hover effect */
.kvm-mode:hover {
  transform: translateY(-4px) scale(1.03);
  box-shadow: 0 10px 26px rgba(0,0,0,0.6);
}

/* Difficulty colors */
.kvm-mode.easy {
  border-color: #2ecc71;
}
.kvm-mode.medium {
  border-color: #f1c40f;
}
.kvm-mode.hard {
  border-color: #e74c3c;
}

/* Click feedback */
.kvm-mode:active {
  transform: scale(0.97);
}




/* ============================= */
/* Knight vs Monster - Emoji UI */
/* ============================= */

#kvmBoard .kp-square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40px;          /* üëà MAIN SIZE CONTROL */
  cursor: pointer;
  user-select: none;
}

/* Slight emphasis */
#kvmBoard .kp-square span {
  transform: scale(1.1);
}



/* ================================================= */
/* üî• KNIGHT LAVA FLOOR ‚Äì CLEAN & NORMAL CHESS BOARD */
/* ================================================= */

#klfBoard {
  display: grid;
  grid-template-columns: repeat(10, 1fr); /* ‚¨ÖÔ∏è 10 files */
  grid-template-rows: repeat(10, 1fr);    /* ‚¨ÖÔ∏è 10 ranks */

  width: 620px;   /* slightly bigger for 10√ó10 */
  height: 620px;

  margin: 20px auto;
  border-radius: 12px;
  overflow: hidden;
  border: 3px solid #3b2a1a;
}


/* ================= */
/* BOARD SQUARE BASE */
/* ================= */
#klfBoard .klf-square {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 34px;
  line-height: 1; /* üî• FIX EMOJI DISTORTION */

  cursor: pointer;
  user-select: none;

  border: none !important;
  outline: none !important;
  box-shadow: none !important;
}

/* ================= */
/* NORMAL BROWN BOARD */
/* ================= */
#klfBoard .klf-light {
  background-color: #f0d9b5;
}

#klfBoard .klf-dark {
  background-color: #b58863;
}

/* ====== */
/* KNIGHT */
/* ====== */
#klfBoard .klf-knight {
  font-size: 36px;
  filter: drop-shadow(0 3px 6px rgba(0,0,0,0.5));
}

/* ===== */
/* LAVA */
/* ===== */
#klfBoard .klf-lava {
  background-color: #e65100;
  box-shadow:
    inset 0 0 10px rgba(255,180,0,0.7),
    inset 0 0 18px rgba(255,80,0,0.9);
  animation: klfLavaPulse 1.2s infinite ease-in-out;
}

@keyframes klfLavaPulse {
  0%   { filter: brightness(1); }
  50%  { filter: brightness(1.25); }
  100% { filter: brightness(1); }
}





/* ================================= */
/* üî• KLF FLOATING RESULT MODAL */
/* ================================= */

#klfResultOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999; /* above game only */
}

#klfResultOverlay.hidden {
  display: none;
}

#klfResultOverlay .klf-modal-card {
  background: linear-gradient(180deg, #1e2238, #14182b);
  padding: 24px 28px;
  border-radius: 14px;
  min-width: 280px;
  text-align: center;

  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
  border: 1px solid rgba(255, 215, 0, 0.35);
}

#klfResultOverlay h3 {
  margin-bottom: 10px;
  color: #ffcc33;
}

#klfResultOverlay p {
  margin-bottom: 18px;
  color: #e6e6e6;
  font-size: 15px;
}





/* ================================================= */
/* üî• KLF INTRO CARD ‚Äì FULLY ISOLATED STYLING */
/* ================================================= */

/* ================================================= */
/* üî• KLF INTRO CARD ‚Äì LARGE & PROMINENT */
/* ================================================= */

#knightlava-section .klf-intro-card {
  background: linear-gradient(180deg, #1f2340, #161a33);
  border-radius: 18px;

  /* üî• SIZE FIX */
  padding: 28px 34px;
  max-width: 900px;          /* ‚¨ÖÔ∏è bigger */
  min-height: 220px;         /* ‚¨ÖÔ∏è gives weight */

  border-left: 6px solid #ffcc33;

  box-shadow:
    inset 0 0 0 1px rgba(255,215,0,0.18),
    0 16px 40px rgba(0,0,0,0.45);
}


/* Title */
#knightlava-section .klf-intro-card h3 {
  margin-bottom: 10px;
  color: #ffcc33;
  font-size: 22px;
}

/* Rules list */
#knightlava-section .klf-rules {
  list-style: none;
  padding: 0;
  margin: 0 0 16px 0;
}

#knightlava-section .klf-rules li {
  margin-bottom: 6px;
  color: #d6d9ff;
  font-size: 15x;
  line-height: 1.5;
}

/* Highlight important text */
#knightlava-section .klf-rules b {
  color: #ffffff;
}

/* Start button */
#knightlava-section .klf-start-btn {
  margin-top: 14px;
  padding: 12px 22px;
  font-size: 15px;
}




/* ========================================= */
/* üå´Ô∏èüçé KNIGHT FOG QUEST ‚Äì ISOLATED BOARD */
/* ========================================= */

#kfqBoard {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  grid-template-rows: repeat(10, 1fr);

  width: 620px;     /* same as your example */
  height: 620px;

  margin: 20px auto;
  padding: 10px;

  background: #e7cfa8;     /* wooden frame */
  border-radius: 12px;
  overflow: hidden;

  border: 3px solid #b3a1a3;
  box-shadow:
    inset 0 0 0 2px #b08968,
    0 10px 30px rgba(0,0,0,0.4);
}

/* ===================== */
/* BOARD SQUARES         */
/* ===================== */

#kfqBoard .kfq-square {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 24px;
  cursor: pointer;
  user-select: none;
}

/* light / dark squares */
#kfqBoard .kfq-light {
  background: #f3ddb8;
}

#kfqBoard .kfq-dark {
  background: #b88a60;
}

/* fog effect */
#kfqBoard .kfq-fog {
  filter: brightness(0.45);
}

/* knight */
#kfqBoard .kfq-knight {
  font-size: 30px;
  transform: scale(1.1);
}




/* ======================================= */
/* üå´Ô∏èüçé KNIGHT FOG QUEST ‚Äì MENU UI (ISOLATED)
/* ======================================= */

#knightfog-section {
  max-width: 1100px;
  margin: 30px auto;
}

/* Title */
#knightfog-section > h2 {
  font-size: 22px;
  font-weight: 700;
  padding-left: 12px;
  margin-bottom: 14px;
  color: #ffd84d;
}

/* Main menu card */
#knightfog-section #kfqMenu {
  background: linear-gradient(180deg, #1f2342, #1a1e38);
  border-radius: 14px;
  padding: 26px 28px;
  box-shadow: 0 15px 40px rgba(0,0,0,0.45);
  position: relative;
}

/* Yellow side accent */
#knightfog-section #kfqMenu::before {
  content: "";
  position: absolute;
  left: 0;
  top: 18px;
  bottom: 18px;
  width: 5px;
  border-radius: 6px;
  background: #ffd400;
}

/* Heading */
#knightfog-section #kfqMenu h3 {
  margin: 0 0 6px 0;
  font-size: 20px;
  color: #ffffff;
}

/* Description text */
#knightfog-section #kfqMenu p {
  margin: 0 0 18px 0;
  line-height: 1.55;
  color: #c9cbe3;
  font-size: 14.5px;
}

/* Speed challenge box */
#knightfog-section .kfq-modes {
  display: flex;
  gap: 12px;
  margin: 10px 0 18px 0;
}

/* Difficulty buttons */
#knightfog-section .kfq-mode {
  flex: 0 0 auto;
  padding: 8px 12px;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
  background: #12152b;
  color: #fff;
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.25s ease;
  text-align: center;
}

#knightfog-section .kfq-mode span {
  display: block;
  font-size: 12px;
  font-weight: 500;
  opacity: 0.9;
}

/* Easy */
#knightfog-section .kfq-mode.easy {
  border-color: #26d96f;
}
#knightfog-section .kfq-mode.easy:hover {
  background: rgba(38,217,111,0.15);
}

/* Medium */
#knightfog-section .kfq-mode.medium {
  border-color: #ffd84d;
}
#knightfog-section .kfq-mode.medium:hover {
  background: rgba(255,216,77,0.15);
}

/* Hard */
#knightfog-section .kfq-mode.hard {
  border-color: #ff6a3d;
}
#knightfog-section .kfq-mode.hard:hover {
  background: rgba(255,106,61,0.15);
}

/* Start normal mode button */
#knightfog-section .btn-primary {
  margin-top: 6px;
  padding: 10px 18px;
  font-size: 14px;
  font-weight: 700;
  border-radius: 10px;
  background: linear-gradient(180deg, #ffd84d, #f0c400);
  color: #121212;
  border: none;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

#knightfog-section .btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 18px rgba(255,216,77,0.45);
}

/* ======================================= */
/* üå´Ô∏èüçé Knight Fog Quest ‚Äì Bigger Buttons */
/* ======================================= */

#knightfog-section .kfq-modes {
  gap: 18px; /* more spacing */
}

#knightfog-section .kfq-mode {
  min-width: 140px;
  padding: 30px 110px;
  border-radius: 14px;

  font-size: 20px;
  line-height: 1.2;
}

#knightfog-section .kfq-mode span {
  font-size: 13px;
  margin-top: 4px;
}

/* Optional: subtle press effect */
#knightfog-section .kfq-mode:active {
  transform: scale(0.97);
}


/* ================================= */
/* üëë KNIGHT DEFENSE ‚Äì 10x10 BOARD */
/* ================================= */

#kndBoard {
  display: grid;

  grid-template-columns: repeat(10, 60px);
  grid-template-rows: repeat(10, 60px);

  width: calc(10 * 60px + 20px);
  height: calc(10 * 60px + 20px);

  margin: 20px auto;
  padding: 10px;

  background: #e7cfa8;
  border-radius: 18px;
  overflow: hidden;

  border: 4px solid #b08968;
  box-shadow:
    inset 0 0 0 2px #b08968,
    0 14px 40px rgba(0,0,0,0.45);

  box-sizing: border-box;
}

#kndBoard .knd-square {
  width: 60px;
  height: 60px;

  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 32px;
  cursor: pointer;
  user-select: none;
}

#kndBoard .light { background: #f3ddb8; }
#kndBoard .dark  { background: #b88a60; }

#kndBoard .king   { font-size: 36px; }
#kndBoard .knight { font-size: 34px; }
#kndBoard .monster{ font-size: 32px; }







/* ===================================== */
/* üëë KNIGHT DEFENSE ‚Äì JOURNEY STYLE MENU */
/* ===================================== */

#knight-defense-section {
  max-width: 1200px;
  margin: 40px auto;
}

/* Main menu card */
#kndMenu {
  background: linear-gradient(180deg, #1c2142, #14172d);
  border-radius: 18px;
  padding: 30px 34px;
  box-shadow: 0 25px 70px rgba(0,0,0,0.55);
  position: relative;
}

/* Left yellow accent */
#kndMenu::before {
  content: "";
  position: absolute;
  left: 0;
  top: 22px;
  bottom: 22px;
  width: 6px;
  border-radius: 6px;
  background: linear-gradient(#ffd84d, #ffb700);
}

/* ===================== */
/* TITLE + TEXT */
/* ===================== */

#kndMenu h3 {
  font-size: 24px;
  font-weight: 900;
  color: #ffffff;
  margin-bottom: 14px;
}

#kndMenu ul {
  list-style: none;
  padding: 0;
  margin: 0 0 20px;
}

#kndMenu ul li {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #d7dcff;
  font-size: 15px;
  margin-bottom: 6px;
}

/* ===================== */
/* MODE BARS (KEY PART) */
/* ===================== */

.knd-modes {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
  margin: 18px 0 22px;
}

/* Full-width row for Hard */
.knd-modes .hard {
  grid-column: 1 / -1;
}

/* Mode bar */
.knd-mode {
  border-radius: 14px;
  padding: 16px 18px;
  font-size: 16px;
  font-weight: 900;
  text-align: center;
  cursor: pointer;
  color: #111;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 26px rgba(0,0,0,0.35);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.knd-mode span {
  font-size: 13px;
  font-weight: 700;
  margin-top: 4px;
}

/* Easy */
.knd-mode.easy {
  background: linear-gradient(180deg, #2ecc71, #27ae60);
}
.knd-mode.easy:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 36px rgba(46,204,113,0.45);
}

/* Medium */
.knd-mode.medium {
  background: linear-gradient(180deg, #f1c40f, #f39c12);
}
.knd-mode.medium:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 36px rgba(241,196,15,0.45);
}

/* Hard */
.knd-mode.hard {
  background: linear-gradient(180deg, #ff4d4d, #e53935);
  color: #fff;
}
.knd-mode.hard:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 36px rgba(231,76,60,0.45);
}

/* ===================== */
/* HOW TO PLAY BOX */
/* ===================== */

.knd-how {
  background: linear-gradient(180deg, #23285a, #1b1f46);
  border-radius: 14px;
  padding: 18px 20px;
  border: 1px solid rgba(255,255,255,0.08);
}

.knd-how h4 {
  color: #ffd84d;
  font-size: 16px;
  margin-bottom: 10px;
}

.knd-how ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.knd-how li {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #e1e4ff;
  font-size: 14px;
  margin-bottom: 6px;
}




/* ================================ */
/* üëë KND MODAL ‚Äì FULLY ISOLATED */
/* ================================ */

.knd-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.knd-modal.hidden {
  display: none;
}

.knd-modal-card {
  background: linear-gradient(180deg, #1c2142, #14182f);
  padding: 26px 30px;
  border-radius: 16px;
  width: 320px;
  text-align: center;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.08);
  animation: kndPop 0.25s ease-out;
}

@keyframes kndPop {
  from { transform: scale(0.85); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

.knd-modal-card h3 {
  color: #ffd84d;
  font-size: 20px;
  margin-bottom: 10px;
}

.knd-modal-card p {
  color: #e6e8ff;
  font-size: 15px;
  margin-bottom: 18px;
}

.knd-btn {
  background: linear-gradient(180deg, #ffd84d, #ffb700);
  color: #1b1b1b;
  border: none;
  padding: 10px 22px;
  font-size: 14px;
  font-weight: 800;
  border-radius: 12px;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(255,200,0,0.4);
}

.knd-btn:hover {
  transform: translateY(-1px);
}


/* ================================ */
/* üîä GLOBAL MUSIC MUTE ICON        */
/* ================================ */
#musicMuteBtn {
  position: fixed;
  bottom: 18px;
  left: 18px;
  z-index: 99999;

  background: #0f1226;
  color: #ffd84d;

  font-size: 22px;
  padding: 10px 12px;
  border-radius: 12px;

  cursor: pointer;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  user-select: none;
}




/* ===================================== */
/* üëë MATH JOURNEY ‚Äì ISOLATED UI */
/* ===================================== */

#kingmath-section {
  max-width: 1100px;
  margin: 40px auto;
}

/* Main card */
#kingmath-section .math-card {
  background: linear-gradient(180deg, #1b1f3a, #14172d);
  border-radius: 18px;
  padding: 26px 30px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.45);
  border: 1px solid rgba(255,255,255,0.06);
}

/* Title */
#kingmath-section h2 {
  color: #ffd84d;
  font-weight: 900;
  margin-bottom: 14px;
}

/* Inner panel */
#kingmath-section .math-panel {
  position: relative;
  background: linear-gradient(180deg, #232850, #1a1e3c);
  border-radius: 16px;
  padding: 24px 26px;
}

/* Yellow accent line */
#kingmath-section .math-panel::before {
  content: "";
  position: absolute;
  left: 0;
  top: 16px;
  bottom: 16px;
  width: 5px;
  border-radius: 6px;
  background: linear-gradient(#ffd84d, #ffb700);
}

/* Section title */
#kingmath-section .math-panel h3 {
  color: #ffffff;
  font-size: 18px;
  font-weight: 800;
  margin-bottom: 16px;
}

/* ======================= */
/* MODE BUTTONS */
/* ======================= */

#kingmath-section .math-modes {
  display: flex;
  flex-direction: column;
  gap: 14px;
  margin-bottom: 22px;
}

#kingmath-section .math-mode {
  height: 54px;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 900;
  color: #1b1b1b;
  border: none;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

#kingmath-section .math-mode:hover {
  transform: translateY(-1px);
  box-shadow: 0 10px 24px rgba(0,0,0,0.35);
}

/* Easy */
#kingmath-section .math-mode.easy {
  background: #2ecc71;
}

/* Medium */
#kingmath-section .math-mode.medium {
  background: #ffd84d;
}

/* Hard */
#kingmath-section .math-mode.hard {
  background: #ff4d4d;
  color: #fff;
}

/* ======================= */
/* HOW TO PLAY */
/* ======================= */

#kingmath-section .math-how {
  background: rgba(0,0,0,0.25);
  border-radius: 14px;
  padding: 16px 18px;
  border: 1px solid rgba(255,255,255,0.08);
}

#kingmath-section .math-how h4 {
  color: #ffd84d;
  font-size: 15px;
  margin-bottom: 10px;
}

#kingmath-section .math-how ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

#kingmath-section .math-how li {
  color: #cfd3ff;
  font-size: 14px;
  margin-bottom: 6px;
  display: flex;
  gap: 8px;
}



/* ================================
   üëë MATH JOURNEY BOARD (10x10)
================================ */

#kmBoard {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  grid-template-rows: repeat(10, 1fr);

  width: 600px;
  height: 600px;

  margin: 20px auto;

  background: #c9a26a;
  border-radius: 14px;
  padding: 8px;

  box-shadow:
    inset 0 0 0 4px #b08b5a,
    0 12px 40px rgba(0,0,0,0.45);
}

/* ================================
   BOARD SQUARES
================================ */

#kmBoard .square {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 22px;
  font-weight: 700;

  cursor: pointer;
  user-select: none;
}

/* light / dark */
#kmBoard .light {
  background: #f3deb3;
}

#kmBoard .dark {
  background: #b88a5b;
}

/* ================================
   PIECES / ELEMENTS
================================ */

#kmBoard .king {
  font-size: 29px;
}



/* ================================
   üü® Base answer styling (NO color)
================================ */

#kmBoard .square.answer {
  font-weight: 900;
  border-radius: 6px;
  cursor: pointer;
  box-shadow: 0 0 2px rgba(0,0,0,0.25) inset;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

#kmBoard .square.answer:hover {
  transform: scale(1.08);
  box-shadow: 0 0 12px rgba(255,255,255,0.4);
}

/* ================================
   üé® Answer colors (REAL COLORS)
================================ */

.answer-green {
  background: #2ecc71 !important;
  color: #0b2e13;
}

.answer-yellow {
  background: #f1c40f !important;
  color: #3a2d00;
}

.answer-blue {
  background: #3498db !important;
  color: #08243a;
}

.answer-purple {
  background: #9b59b6 !important;
  color: #2d133b;
}





.km-timer {
  margin: -60px auto 10px auto;   /* space above board */
  width: fit-content;

  background: #1a1f3a;
  border: 1px solid #ff5555;
  color: #ff7777;

  padding: 8px 18px;
  border-radius: 12px;

  font-weight: 700;
  font-size: 20px;

  box-shadow: 0 0 12px rgba(255, 85, 85, 0.35);
  text-align: center;
}



.km-timer.danger {
  border-color: #ff0000;
  color: #ff0000;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { box-shadow: 0 0 8px rgba(255,0,0,0.4); }
  50% { box-shadow: 0 0 16px rgba(255,0,0,0.9); }
  100% { box-shadow: 0 0 8px rgba(255,0,0,0.4); }
}



/* ================================
   üé® COLOR FLIP CHAOS ‚Äì UI POLISH
================================ */

/* Center everything cleanly */
#cfcGame {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Board alignment + spacing */
#cfcBoard {
  display: grid !important;
  grid-template-columns: repeat(8, 1fr) !important;
  gap: 2px;
  margin: 24px auto;
  margin-top: -17px;   /* üîº adjust if needed */
}

/* Square styling */
#cfcBoard .cfc-square {
  aspect-ratio: 1;
  border-radius: 2px;
  font-size: 26px;
  display: flex;
  align-items: center;
  justify-content: center;

  /* üñê grab cursor */
  cursor: grab;

  transition:
    background-color 0.6s ease,
    transform 0.15s ease;
}

/* Grab effect on click */
#cfcBoard .cfc-square:active {
  cursor: grabbing;
  transform: scale(0.96);
}

/* üê¥ Knight emphasis */
#cfcBoard .cfc-square:has(span),
#cfcBoard .cfc-square {
  line-height: 1;
}

/* Bigger knight (JS adds emoji directly) */
#cfcBoard .cfc-square {
  font-size: 28px;
}

/* Extra boost only when knight is present */
#cfcBoard .cfc-square:has(:contains("üê¥")) {
  font-size: 34px;
}

#cfcBoard .cfc-knight {
  font-size: 36px;
}



/* ================================
   üé® COLOR FLIP CHAOS ‚Äì BIGGER MODE CARD
   (ISOLATED)
================================ */

/* ================================
   üé® COLOR FLIP CHAOS ‚Äì LARGE MODE CARD
   (FINAL, ISOLATED)
================================ */

.cfc-card {
  width: 100%;
  max-width: 760px;          /* üî• MUCH wider */
  min-height: 300px;         /* üî• gives vertical presence */

  padding: 40px 48px;        /* üî• big breathing space */
  margin: 0 auto;

  text-align: center;

  background: linear-gradient(
    180deg,
    rgba(32, 36, 70, 0.96),
    rgba(20, 24, 52, 0.96)
  );

  border-radius: 22px;
  box-shadow:
    0 30px 80px rgba(0, 0, 0, 0.55),
    inset 0 0 0 1px rgba(255, 255, 255, 0.05);

  transform: scale(1.05);   /* üî• makes it feel BIG */
}



.cfc-card h3 {
  font-size: 22px;
  margin-bottom: 24px;
}

.cfc-modes {
  margin: 24px 0;
  gap: 18px;
}

.cfc-mode-btn {
  padding: 14px 22px;
  font-size: 16px;
  border-radius: 10px;
}

.cfc-how {
  margin-top: 26px;
  font-size: 16px;
  line-height: 1.7;
}


.cfc-mode-easy { background: #2ecc71; color: #000; }
.cfc-mode-medium { background: #f1c40f; color: #000; }
.cfc-mode-hard { background: #e74c3c; color: #fff; }

/* Game area alignment */
#cfcGame {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Force board layout (8√ó8) */
#cfcBoard {
  display: grid !important;
  grid-template-columns: repeat(8, 1fr) !important;
  max-width: 360px;
  width: 100%;
  margin: 12px auto;
  gap: 6px;
}

/* Board squares */
#cfcBoard .cfc-square {
  aspect-ratio: 1;
  border-radius: 1px;
  font-size: 28px;
  cursor: grab;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.8s ease, transform 0.15s ease;
}

#cfcBoard .cfc-square:active {
  cursor: grabbing;
  transform: scale(0.95);
}

/* Knight emphasis */
#cfcBoard .cfc-knight {
  font-size: 36px;
  line-height: 1;
}


/* ================================
   üé® COLOR FLIP CHAOS ‚Äì BOARD FIX
   (SQUARE, NON-STRETCHING)
================================ */

/* Lock board aspect */
#cfcBoard {
  width: 550px;
  height: 550px;           /* üî• THIS IS THE KEY */
  max-width: 90vw;
  max-height: 90vw;

  display: grid !important;
  grid-template-columns: repeat(8, 1fr) !important;
  grid-template-rows: repeat(8, 1fr);   /* üî• force equal rows */

  gap: 1px;
  margin: -16px auto;

  align-self: center;
}

/* Square safety */
#cfcBoard .cfc-square {
  width: 100%;
  height: 100%;
}


/* ================================
   üé® COLOR FLIP CHAOS ‚Äì EXIT BUTTON OFFSET
   (ISOLATED)
================================ */

#colorchaos-section .btn-secondary {
  margin-top: 24px;   /* üîΩ pushes Exit button down */
}




/* ================================
   üé® COLOR FLIP CHAOS ‚Äì COORDINATES
   (ISOLATED)
================================ */

.cfc-board-wrapper {
  display: grid;
  grid-template-columns: 28px auto;
  grid-template-rows: auto 28px;
  justify-content: center;
  align-items: center;
  margin: 12px auto 4px;
}

/* RANKS (1‚Äì8) */
.cfc-ranks {
  display: grid;
  grid-template-rows: repeat(8, 1fr);
  gap: 48px;
  font-size: 16px;
  color: #ccc;
  text-align: center;
}

/* FILES (a‚Äìh) */
.cfc-files {
  grid-column: 2;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 6px;
  font-size: 16px;
  color: #ccc;
  text-align: center;
  margin-top: 20px;
}

/* Board alignment fix */
.cfc-board-wrapper #cfcBoard {
  grid-column: 2;
}


#musicControl {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 9999;
}

#musicMuteBtn {
  font-size: 24px;
  cursor: pointer;
  user-select: none;
}

#musicMenu {
  position: absolute;
  bottom: 36px;
  left: 0;
  background: #1c1f35;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 6px;
  min-width: 160px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.4);
}

#musicMenu div {
  padding: 6px 10px;
  cursor: pointer;
  font-size: 14px;
  border-radius: 6px;
}

#musicMenu div:hover {
  background: #2a2d4a;
}

.hidden {
  display: none;
}



/* ================================
üìç Board Coordinate Training ‚Äì Board Skin
(ISOLATED)
================================ */

#coordtrain-section .mini-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  aspect-ratio: 1 / 1;
  border-radius: 1px;
  overflow: hidden;
  background: #3b2a1a;
  margin-top: -15px;
  
}

#coordtrain-section .square {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: box-shadow 0.15s ease, transform 0.1s ease;
}

/* ‚ôü CLASSIC BROWN BOARD */
#coordtrain-section .square.light {
  background: #f0d9b5;
}

#coordtrain-section .square.dark {
  background: #b58863;
}

/* Hover feedback */
#coordtrain-section .square:hover {
  transform: scale(1.02);
}

/* Files (a‚Äìh) closer to board */
#coordtrain-section .cfc-files {
  grid-column: 2;
  margin-top: 4px;   /* üî• reduce this */
  padding-top: 0;
}

/* Board itself ‚Äì remove bottom spacing */
#coordtrain-section .mini-board {
  margin-bottom: 0;  /* üî• important */
}




/* ======================================
üß† BOARD FREEZE ‚Äì COORDINATES FIX
====================================== */

#boardfreeze-section .bf-board-wrapper {
  display: grid;
  grid-template-columns: auto auto;
  grid-template-rows: auto auto;
  gap: 6px;
  justify-content: center;
  margin: 20px auto;
}

/* RANKS */
#boardfreeze-section .bf-ranks {
  display: grid;
  grid-template-rows: repeat(8, 1fr);
  font-size: 13px;
  color: #ddd;
  text-align: right;
  padding-right: 2px;
}

/* FILES */
#boardfreeze-section .bf-files {
  grid-column: 2;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  font-size: 13px;
  color: #ddd;
  text-align: center;
  padding-top: 2px;
}

/* BOARD */
#boardfreeze-section #bfBoard {
  width: 560px;
  height: 560px;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  border-radius: 14px;
  overflow: hidden;
}

/* SQUARES */
#boardfreeze-section #bfBoard .square {
  display: flex;
  align-items: center;
  justify-content: center;
}

/* COLORS (REAL CHESS ORIENTATION) */
#boardfreeze-section #bfBoard .light {
  background: #f0d9b5;
}
#boardfreeze-section #bfBoard .dark {
  background: #b58863;
}

/* PIECES */
#boardfreeze-section #bfBoard img {
  width: 80%;
  height: 80%;
  pointer-events: none;
}



/* ============================= */
/* üß≠ KNIGHT GPS BOARD LAYOUT */
/* ============================= */

.kg-center {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 14px;
}

/* ranks + board */
.kg-board-grid {
  display: grid;
  grid-template-columns: 32px auto;
  align-items: center;
}

/* BOARD */
#kgBoard {
  display: grid;
  grid-template-columns: repeat(8, 80px);
  grid-template-rows: repeat(8, 80px);
  border: 2px solid #ffd700;
  box-shadow: 0 0 28px rgba(255, 215, 0, 0.4);
  margin-top: -70px;
}

/* RANKS */
.kg-ranks {
  display: grid;
  grid-template-rows: repeat(8, 80px);
  font-size: 13px;
  color: #aaa;
  text-align: center;
  margin-right: 6px;

  /* üëá key fixes */
  align-items: flex-start;
  padding-top: 6px;
}


/* FILES */
.kg-files {
  display: grid;
  grid-template-columns: repeat(8, 80px);
  font-size: 13px;
  color: #aaa;
  text-align: center;
  margin-top: -30px;
}

/* SQUARES */
.kg-square {
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}

/* COLORS */
.kg-light { background: #f0d9b5; }
.kg-dark  { background: #b58863; }

/* üéØ Target ‚Äî emoji only, no square color */
.kg-target {
  background: transparent !important;
  position: relative;
}

/* üéØ Target overlay ‚Äî NO square color */
.kg-target {
  position: relative;
}

.kg-target span {
  position: absolute;
  font-size: 34px;
  z-index: 5;
  filter: drop-shadow(0 0 6px rgba(0,255,204,0.8));
}

.kg-target::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 50%;
  background: radial-gradient(
    circle,
    rgba(0, 255, 204, 0.7) 18%,
    rgba(0, 255, 204, 0.35) 28%,
    transparent 45%
  );
  z-index: 1;
  pointer-events: none;
}



/* ‚ôû Knight */
.kg-square img {
  width: 68px;
  height: 68px;
  pointer-events: none;
  transform: translateY(-2px);
  filter: drop-shadow(0 3px 6px rgba(0,0,0,0.45));
}



/* Fixed container should stretch */
.mini-score-fixed {
  position: fixed;
  left: 12px;
  top: 110px;
  bottom: 20px;          /* üî• THIS is the key */
  z-index: 50;
  display: flex;
}

/* Panel fills full height */
.mini-score-panel {
  width: 260px;
  height: 100%;
  display: flex;
  flex-direction: column;
  background: linear-gradient(180deg, #161a33, #0f1328);
  border-radius: 16px;
  padding: 16px;
  box-shadow:
    inset 0 0 0 1px rgba(255,215,0,0.15),
    0 10px 30px rgba(0,0,0,0.4);
}



#miniScoreList {
  flex: 1;                /* fills remaining space */
  overflow-y: auto;
  padding-right: 4px;
}

/* smooth scrollbar (optional but sexy) */
#miniScoreList::-webkit-scrollbar {
  width: 6px;
}
#miniScoreList::-webkit-scrollbar-thumb {
  background: rgba(255,215,0,0.35);
  border-radius: 6px;
}



/* ================================
   üèÜ MINI SCORE ‚Äì FIXED & SHORT
================================ */

/* Fixed position, but NOT full height */
.mini-score-fixed {
  position: fixed;
  left: 12px;
  top: 110px;        /* below navbar */
  z-index: 50;
}

/* Compact panel height (matches main card visually) */
.mini-score-panel {
  width: 260px;
  max-height: 650px;     /* üî• THIS controls red-line height */
  display: flex;
  flex-direction: column;

  background: linear-gradient(180deg, #161a33, #0f1328);
  border-radius: 16px;
  padding: 16px;

  box-shadow:
    inset 0 0 0 1px rgba(255,215,0,0.15),
    0 10px 30px rgba(0,0,0,0.4);
}

/* Title stays fixed */
.mini-score-panel h3 {
  color: #ffd700;
  margin-bottom: 10px;
  font-size: 1.05rem;
  text-align: center;
  flex-shrink: 0;
}

/* Scroll only scores, not whole panel */
#miniScoreList {
  flex: 1;
  overflow-y: auto;
  padding-right: 6px;
}

/* Score row */
.score-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 10px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  margin-bottom: 6px;
  font-size: 0.9rem;
}

.score-row span:first-child {
  color: #a9b7ff;
}

.score-row span:last-child {
  color: #00ffcc;
  font-weight: 700;
}

/* Muted text */
.muted {
  color: #777;
  text-align: center;
  font-size: 0.85rem;
}

/* Smooth scrollbar */
#miniScoreList::-webkit-scrollbar {
  width: 6px;
}
#miniScoreList::-webkit-scrollbar-thumb {
  background: rgba(255,215,0,0.35);
  border-radius: 6px;
}


.mini-score-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 4px;
  font-size: 0.9rem;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.game-name {
  opacity: 0.9;
}

.game-score {
  color: #ffd700;
  font-weight: 700;
}



@media (max-width: 1366px) {

  .mini-score-panel {
    width: 220px;
    max-height: 500px;
  }

  .analysis-board,
  .main-content,
  .section,
  .container {
    margin-left: 100px !important;
  }
}


@media (max-width: 1440px) {
  .analysis-board,
  .main-content,
  .section {
    transform: scale(0.80);
    transform-origin: top center;
  }
}

@media (max-width: 1366px) {
  .analysis-board,
  .main-content,
  .section {
    transform: scale(0.72);   /* ‚âà 75% feel */
    transform-origin: top center;
  }
}


/* =====================================================
üì± TABLET ONLY (768px‚Äì1024px)
Score panel floats bottom-right
===================================================== */
@media (min-width: 768px) and (max-width: 1024px) {

  /* ---- KEEP BOARD & MAIN LAYOUT SAFE ---- */
  .analysis-board,
  .main-content,
  .section,
  .container {
    transform: none !important;
  }

  /* ---- CHESS BOARD (UNCHANGED, CLEAR) ---- */
  #chessboard,
  .chessboard {
    width: 460px !important;
    max-width: 92vw !important;
    height: auto !important;
  }

  /* ---- FLOAT SCORE PANEL ---- */
 .mini-score-panel {
    position: fixed !important;
    left: 16px;      /* üëâ RIGHT side */
    bottom: 100px;     /* üëâ BOTTOM side */

    width: 120px !important;
    max-height: 500px;
    overflow-y: auto;

    z-index: 9999;
  }
}






.user-menu {
  position: relative;
  display: inline-block;
}

.user-info {
  background: transparent;
  border: none;
  color: #ffd700;
  font-weight: 700;
  cursor: pointer;
}

/* üî• dropdown box (detached from navbar flow) */
.user-dropdown {
  position: fixed;              /* üîë KEY CHANGE */
  width: 220px;

  background: #15182e;
  border: 1px solid rgba(255,215,0,0.25);
  border-radius: 12px;
  padding: 10px;

  z-index: 99999;               /* above navbar */
  box-shadow: 0 10px 25px rgba(0,0,0,0.6);
}

/* hidden state */
.user-dropdown.hidden {
  display: none;
}

/* sections */
.dropdown-section {
  margin-bottom: 10px;
}

.dropdown-section strong {
  display: block;
  margin-bottom: 6px;
  color: #ffd700;
  font-size: 0.85rem;
}

/* buttons */
.dropdown-section button {
  width: 100%;
  padding: 7px 10px;
  margin-bottom: 6px;

  background: #222654;
  color: white;
  border: none;
  border-radius: 8px;

  cursor: pointer;
  text-align: left;
}

.dropdown-section button:hover {
  background: #2f347a;
}







/* ================================
   üíª LAPTOP LAYOUT FIX (Puzzle Rush)
================================ */

@media (min-width: 1024px) {

  /* Main layout spacing */
  .analysis-layout {
    display: flex;
    align-items: flex-start;
    gap: 100px;              /* üî• SPACE between board & exit panel */
  }

  /* Board column stays centered */
  .board-column {
    flex: 0 0 auto;
    margin-left: 0;
  }

  /* Right panel (Exit button) */
  .side-panel {
    flex: 0 0 140px;        /* fixed width panel */
    margin-top: 8px;
  }

  /* Exit button never overlaps board */
  #exitPuzzleRush {
    margin-left: 0;
    white-space: nowrap;
  }
}





/* =====================================================
   üñ• LAPTOP FIX ‚Äî ASSIGNMENTS SECTION (NO BREAKAGE)
   Target: 1366px‚Äì1440px
===================================================== */

@media (max-width: 1440px) {

  /* Stop aggressive scaling ONLY for assignments */
  #assignments-section {
    transform: none !important;
    max-width: 1200px;
    margin: 0 auto;
    padding: 16px 20px 40px;
  }

  /* Main 3-column layout */
  .assignments-layout {
    display: grid !important;
    grid-template-columns: 1.1fr 1.3fr 1fr;
    gap: 18px;
    align-items: stretch; /* IMPORTANT */
  }

  /* ===============================
     LEFT COLUMN ‚Äî SCROLL ENABLED
  =============================== */
  .assignments-list {
    max-height: calc(100vh - 190px); /* navbar + footer safe */
    overflow-y: auto !important;
    overflow-x: hidden;
    padding-right: 6px;
  }

  /* ===============================
     CENTER & RIGHT ‚Äî NO SCROLL
  =============================== */
  .assignments-form,
  #pgnLibraryCard {
    overflow: visible !important;
    max-height: none !important;
  }

  /* ===== Scrollbar styling ===== */
  .assignments-list::-webkit-scrollbar {
    width: 8px;
  }

  .assignments-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
  }

  .assignments-list::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #ffd700, #c9a800);
    border-radius: 6px;
  }

  .assignments-list::-webkit-scrollbar-thumb:hover {
    background: #ffdf33;
  }
}

/* =====================================================
   üñ• 1366px SPECIAL TIGHT LAPTOPS
===================================================== */

@media (max-width: 1366px) {

  .analysis-board,
  .main-content,
  .section {
    transform: scale(0.80) !important;
    transform-origin: top center;
  }

  .assignments-layout {
    grid-template-columns: 1fr 1.25fr 1fr;
    gap: 14px;
  }

  /* Slightly smaller scroll area */
  .assignments-list {
    max-height: calc(100vh - 210px);
  }

  .card {
    padding: 12px 14px;
  }

  #assignStudentsBox {
    max-height: 180px;
  }
}

/* =====================================================
   üß† SAFETY
===================================================== */

#assignments-section {
  overflow-x: hidden;
}


   
/* =====================================================
üì± OLYMPUS ‚Äî HARD MOBILE UNLOCK (POLISHED)
Safe for 360√ó800 and all phones
===================================================== */
@media (max-width: 768px) {

  /* ---------- SAFE BOX MODEL ---------- */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  html, body {
    width: 100%;
    overflow-x: hidden !important;
  }

  /* ---------- FORCE FULL-WIDTH SECTIONS ---------- */
  .container,
  .section,
  .card,
  .kp-card,
  .study-layout,
  .analysis-layout,
  .assignments-layout,
  .admin-layout {
    width: 100% !important;
    max-width: 100% !important;
    margin: 0 auto !important;
    padding: 8px !important;
  }

  /* ---------- STACK DESKTOP FLEX ROWS ---------- */
  .study-layout,
  .analysis-layout,
  .board-layout,
  .assignments-layout,
  .admin-layout {
    flex-direction: column !important;
    align-items: stretch !important;
  }

  /* ---------- SIDE PANELS FULL WIDTH ---------- */
  .side-panel,
  .study-left,
  .study-right,
  .study-center,
  #notationPanel {
    width: 100% !important;
    max-width: 100% !important;
    margin: 0 !important;
  }

  /* ---------- CARDS ---------- */
  .card,
  .kp-card,
  .kvmMenu,
  #lmMenu,
  #kfqMenu,
  #kpMenu {
    width: 100% !important;
    max-width: 100% !important;
    margin: 0 !important;
  }

  /* ---------- BUTTON GRIDS ---------- */
  .control-grid,
  .kp-modes,
  .kvm-modes,
  .cfc-modes {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 10px;
  }

  /* ---------- CHESS BOARDS ---------- */
  #chessboard,
  #computerBoard,
  #studyBoard,
  #editorBoard,
  .mini-board,
  .practice-board {
    width: min(92vw, 360px) !important;
    height: auto !important;
    aspect-ratio: 1 / 1;
    margin: 0 auto !important;
  }

  /* ---------- NAVBAR SCROLL ---------- */
  #topNavbar {
    width: 100%;
    overflow-x: auto;
    white-space: nowrap;
    -webkit-overflow-scrolling: touch;
  }

  /* ---------- HIDE MINI SCORE PANEL ON PHONE ---------- */
  .mini-score-panel,
  .mini-score-fixed {
    display: none !important;
  }
}




/* =====================================================
üì± MOBILE FIX ‚Äî PREVENT BOARD CUT OFF
===================================================== */
@media (max-width: 768px) {

  /* ---- ALLOW VERTICAL GROWTH ---- */
  body,
  .analysis-board,
  .analysis-layout,
  .board-layout,
  .board-wrapper {
    height: auto !important;
    min-height: auto !important;
    overflow: visible !important;
  }

  /* ---- CHESSBOARD SAFE AREA ---- */
  #chessboard,
  #computerBoard,
  #studyBoard,
  #editorBoard,
  .practice-board {
    width: 92vw !important;
    max-width: 92vw !important;
    height: auto !important;
    aspect-ratio: 1 / 1;
    display: block;
    margin: 12px auto !important;
  }

  /* ---- PREVENT CLIPPING BY CARDS ---- */
  .card,
  .kp-card,
  .analysis-card {
    overflow: visible !important;
  }
}


/* =====================================================
üì± MOBILE ONLY ‚Äî HIDE PUZZLE RUSH EXIT BUTTON
===================================================== */
@media (max-width: 768px) {
  #exitPuzzleRush {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
}




/* =====================================================
üì± MOBILE TOUCH SAFETY ‚Äî CHESS DRAG FIX
===================================================== */
@media (max-width: 768px) {

  /* Allow touch dragging */
  #chessboard,
  #computerBoard,
  #studyBoard,
  #editorBoard,
  .practice-board,
  .chessboard {
    touch-action: none !important;
    pointer-events: auto !important;
  }

  /* Prevent parents from killing touch */
  .card,
  .kp-card,
  .analysis-board,
  .analysis-layout,
  .board-layout {
    overflow: visible !important;
  }

  /* Avoid accidental scroll lock */
  body {
    overscroll-behavior: contain;
  }
}








/* =====================================================
üì± MOBILE ONLY ‚Äî MINI PRACTICE BOARDS FIX
Knight / Bishop / Piece Practice
===================================================== */
@media (max-width: 768px) {

  /* Mini-game container */
  .mini-game {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* Mini chess boards */
  .practice-board,
  #miniBoard,
  #bishopBoard {
    width: min(88vw, 260px) !important;
    height: auto !important;
    aspect-ratio: 1 / 1;

    margin: 8px auto 10px auto !important;
  }

  /* Prevent inner SVG / canvas overflow */
  .practice-board *,
  #miniBoard *,
  #bishopBoard * {
    max-width: 100% !important;
    max-height: 100% !important;
  }

  /* Footer buttons spacing */
  .mini-footer {
    width: 100%;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
  }
}






/* =====================================================
üì± MOBILE ‚Äî STOP SCROLL ON CHESS DRAG
===================================================== */
@media (max-width: 768px) {

  /* Main chess boards */
  #chessboard,
  #computerBoard,
  #studyBoard,
  #editorBoard,
  #puzzleRushBoard,
  .practice-board,
  .chessboard {
    touch-action: none !important;
    -webkit-touch-callout: none;
    user-select: none;
  }
}





/* =====================================================
üì± MOBILE ‚Äî PREVENT PAGE ZOOM / RECENTER ON BOARD
===================================================== */
@media (max-width: 768px) {

  #chessboard,
  .chessboard,
  .practice-board {
    touch-action: none !important;     /* disables pinch zoom */
    overscroll-behavior: none;
  }

  /* Lock board container position */
  .analysis-board,
  .board-wrapper,
  .mini-game {
    margin-left: 0 !important;
    margin-right: 0 !important;
    left: 0 !important;
    transform: none !important;
  }
}








/* =====================================================
üì± MOBILE ONLY ‚Äî HIDE ANALYSIS RIGHT PANEL (SAFE)
Does NOT affect other games
===================================================== */
@media (max-width: 768px) {

  /* Hide notation ONLY in analysis board */
  #board-section #notationPanel {
    display: none !important;
  }

  /* Hide ONLY the analysis side panel */
  #board-section #sidePanel {
    display: none !important;
  }

  /* Hide engine ONLY in analysis */
  #board-section #enginePanel {
    display: none !important;
  }

  /* Hide analysis control buttons only */
  #board-section .control-grid {
    display: none !important;
  }

  /* Let analysis board take full width */
  #board-section .analysis-layout,
  #board-section .board-layout,
  #board-section .board-wrapper {
    width: 100% !important;
    max-width: 100% !important;
  }
}











@media (max-width: 768px) {
  .mobile-submit-wrapper {
    display: flex;
    justify-content: center;
    margin: 12px 0;
  }

  #submitBtn {
    display: inline-flex;
    padding: 10px 18px;
    font-size: 16px;
    
    border-radius: 10px;
  }
}




























/* =====================================
üèÜ OLYMPUS RATING BAR ‚Äî THIN & PREMIUM
===================================== */

.rating-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;

  background: linear-gradient(135deg, #1c1f35, #2a2d4a);
  padding: 10px 14px;           /* üîª thinner */
  border-radius: 10px;          /* üîª less bulky */
  margin-bottom: 14px;

  color: #fff;
  box-shadow: 0 6px 16px rgba(0,0,0,0.3);
}

.rating-elo {
  font-size: 1rem;
  font-weight: 600;
  color: #9ae6ff;
  opacity: 0.85;
  margin-right: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}


/* LEFT */
.rating-left {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #ffd700;
  font-size: 0.85rem;           /* üîª */
  white-space: nowrap;
}

/* CENTER */
.rating-center {
  display: flex;
  align-items: baseline;
  gap: 5px;
  white-space: nowrap;
}

.rating-main {
  font-size: 1.7rem;            /* üîª */
  font-weight: 800;
}

.rating-tier {
  font-size: 0.9rem;
  color: #9ae6ff;
}

/* RIGHT */
.rating-breakdown {
  display: flex;
  gap: 12px;                    /* üîª */
  font-size: 0.78rem;           /* üîª */
  color: #cfcfcf;
  white-space: nowrap;
}

.rating-breakdown strong {
  color: #ffd700;
  font-weight: 700;
}

/* =====================================
üì± TABLET (<= 900px)
===================================== */
@media (max-width: 900px) {
  .rating-bar {
    flex-wrap: wrap;
    justify-content: center;
    text-align: center;
    padding: 10px 12px;
  }

  .rating-left,
  .rating-center,
  .rating-breakdown {
    width: 100%;
    justify-content: center;
  }

  .rating-breakdown {
    margin-top: 4px;
    flex-wrap: wrap;
    gap: 8px;
  }
}



/* =====================================
üì± MOBILE (<= 480px)
===================================== */
@media (max-width: 480px) {
  .rating-main {
    font-size: 1.4rem;
  }

  .rating-tier {
    font-size: 0.8rem;
  }

  .rating-breakdown {
    font-size: 0.7rem;
  }

  .rating-left {
    font-size: 0.75rem;
  }

  .rating-bar {
    padding: 8px 10px;          /* üîª extra slim on mobile */
    border-radius: 8px;
  }
  .rating-elo {
    font-size: 0.8rem;
  }
}



/* =====================================
üíª LAPTOP OPTIMIZATION (1024px‚Äì1440px)
===================================== */
@media (min-width: 1024px) and (max-width: 1440px) {

  .rating-bar {
    padding: 9px 14px;          /* slimmer height */
    gap: 10px;
    border-radius: 10px;
  }

  .rating-left {
    font-size: 0.82rem;
    gap: 6px;
  }

  .rating-center {
    gap: 4px;
  }

  .rating-main {
    font-size: 1.6rem;          /* balanced for laptop */
  }

  .rating-tier {
    font-size: 0.85rem;
  }

  .rating-breakdown {
    font-size: 0.75rem;
    gap: 10px;
  }
  .rating-elo {
    font-size: 0.8rem;
  }
}


/* =====================================
üíª LAPTOP WIDTH FIX (1024px‚Äì1440px)
===================================== */
@media (min-width: 1024px) and (max-width: 1440px) {

  .rating-bar {
    max-width: 900px;      /* üî• key line: makes it shorter */
    margin-left: auto;
    margin-right: auto;    /* center it */
  }

  .rating-breakdown {
    gap: 10px;
    font-size: 0.72rem;    /* slightly tighter */
  }

  .rating-main {
    font-size: 1.55rem;   /* balanced for laptop */
  }
}




.student-rating-box {
  background: linear-gradient(135deg, #1c1f35, #2a2d4a);
  padding: 10px 12px;
  border-radius: 10px;
  margin-bottom: 12px;
}

.student-rating-box .main-rating {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 1.1rem;
  font-weight: 800;
}

.student-rating-box .tier {
  font-size: 0.85rem;
  color: #9ae6ff;
}

.student-rating-box .rating-breakdown {
  margin-top: 6px;
  font-size: 0.85rem;
  color: #ddd;
  display: flex;
  justify-content: space-between;
}









/* =====================================
üìä OLYMPUS RATING PROGRESS BAR ‚Äî PREMIUM
===================================== */

.rating-progress {
  width: 140px;
  height: 8px;
  background: linear-gradient(
    180deg,
    rgba(255,255,255,0.18),
    rgba(255,255,255,0.08)
  );
  border-radius: 999px;
  overflow: hidden;
  margin-top: 6px;
  position: relative;
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.6);
}

/* üî• Animated fill */
.rating-progress-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(
    90deg,
    #ffcc00,
    #ff9f00,
    #ffd700
  );
  background-size: 200% 100%;
  border-radius: 999px;
  animation: progressShimmer 2.2s linear infinite;
  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow:
    0 0 6px rgba(255, 215, 0, 0.7),
    0 0 14px rgba(255, 170, 0, 0.5);
}

/* ‚ú® shimmer animation */
@keyframes progressShimmer {
  from { background-position: 0% 0; }
  to   { background-position: 200% 0; }
}

/* üìà Progress text */
.rating-progress-text {
  margin-top: 4px;
  font-size: 0.85rem;          /* üî• bigger */
  font-weight: 700;            /* üî• bolder */
  color: #ffd700;
  letter-spacing: 0.4px;
  white-space: nowrap;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
}

/* =====================================
üì± MOBILE
===================================== */
@media (max-width: 480px) {
  .rating-progress {
    width: 100px;
    height: 6px;
  }

  .rating-progress-text {
    font-size: 0.75rem;
    font-weight: 700;
  }
}

/* =====================================
üì± TABLET
===================================== */
@media (max-width: 900px) {
  .rating-progress {
    margin-left: auto;
    margin-right: auto;
  }
}

/* =====================================
üíª LAPTOP & DESKTOP
===================================== */
@media (min-width: 1024px) {
  .rating-progress {
    width: 160px;
    height: 8px;
  }

  .rating-progress-text {
    font-size: 0.9rem;
  }
}





/* ===============================
üéØ RATING PROGRESS ‚Äì TIGHT ALIGN
=============================== */

.rating-progress-wrap {
  display: flex;
  align-items: center;
  gap: 8px;                 /* üî• controls bar ‚Üî text distance */
  margin-left: 10px;        /* üî• distance from ELO text */
}

.rating-progress {
  width: 90px;              /* üî• smaller = tighter */
  height: 6px;
  margin: 0;                /* ‚ùó remove default spacing */
}

.rating-progress-text {
  font-size: 0.75rem;
  font-weight: 600;
  color: #ffd700;
}

@media (max-width: 480px) {
  .rating-progress-wrap {
    justify-content: center;
    margin-left: 0;
    gap: 6px;
  }

  .rating-progress {
    width: 70px;
  }

  .rating-progress-text {
    font-size: 0.65rem;
  }
}


@media (max-width: 900px) {
  .rating-progress-wrap {
    justify-content: center;
    margin-left: 0;
  }
}



/* ===============================
üîí LOCK RATING CENTER FONT SIZES
=============================== */

.rating-center .rating-main {
  font-size: 1.7rem !important;
  font-weight: 800;
}

.rating-center .rating-tier {
  font-size: 0.9rem !important;
  font-weight: 600;
}

.rating-progress-text {
  font-size: 0.8rem !important;
  font-weight: 700;
  letter-spacing: 0.3px;
}



@media (max-width: 480px) {
  .rating-center .rating-main {
    font-size: 1.4rem !important;
  }

  .rating-center .rating-tier {
    font-size: 0.75rem !important;
  }

  .rating-progress-text {
    font-size: 0.7rem !important;
  }
}


@media (max-width: 900px) {
  .rating-center .rating-main {
    font-size: 1.55rem !important;
  }

  .rating-progress-text {
    font-size: 0.75rem !important;
  }
}






/* ‚ùó Info icon */
.rating-info-trigger {
  margin-left: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  color: #ffd700;
  transition: transform 0.2s ease;
}

.rating-info-trigger:hover {
  transform: scale(1.2);
}

/* Popup container */
.rating-info-popup {
  position: absolute;
  top: 45px;
  left: 50%;
  transform: translateX(-50%);
  width: 280px;
  background: linear-gradient(135deg, #1c1f35, #2a2d4a);
  border-radius: 12px;
  box-shadow: 0 15px 40px rgba(0,0,0,0.6);
  color: #fff;
  display: none;
  z-index: 9999;
}

/* Header */
.rating-info-header {
  padding: 10px 12px;
  font-weight: 700;
  border-bottom: 1px solid rgba(255,255,255,0.15);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* Close button */
.rating-info-close {
  cursor: pointer;
  color: #ff6b6b;
  font-size: 0.9rem;
}

/* Body */
.rating-info-body {
  padding: 12px;
  font-size: 0.8rem;
  line-height: 1.5;
}

.rating-info-body ul {
  padding-left: 16px;
  margin: 8px 0;
}

.rating-info-body li {
  margin-bottom: 6px;
}

.rating-note {
  margin-top: 8px;
  font-size: 0.75rem;
  color: #9ae6ff;
}

/* üì± Mobile */
@media (max-width: 480px) {
  .rating-info-popup {
    width: 90%;
    left: 5%;
    transform: none;
  }
}


@media (max-width: 480px) {
  .rating-info-popup {
    position: fixed;
    bottom: 12%;
    left: 35%;
    transform: translateX(-50%);

    width: 92vw;
    max-width: 360px;

    max-height: 65vh;              /* üîë KEY FIX */
    overflow-y: auto;    

    padding: 18px 16px;
    font-size: 0.95rem;
    border-radius: 14px;

    box-shadow: 0 20px 50px rgba(0,0,0,0.7);
  }

  .rating-info-header {
    font-size: 1.05rem;
  }

  .rating-info-body ul {
    padding-left: 18px;
  }
}




/* ‚≠ê Rating Delta Indicator */
.rating-delta {
  margin-left: 6px;
  font-size: 1rem;
  font-weight: 800;

  opacity: 0;
  transform: translateY(8px);

  transition:
    opacity 0.35s ease,
    transform 0.35s ease;

  pointer-events: none;
}

/* Positive gain */
.rating-delta.positive {
  color: #4cff7a; /* bright green */
}

/* No gain */
.rating-delta.zero {
  color: #aaa;
}

/* Visible state */
.rating-delta.show {
  opacity: 1;
  transform: translateY(0);
}

/* Fade-out state */
.rating-delta.hide {
  opacity: 0;
  transform: translateY(-6px);
}

/* Mobile */
@media (max-width: 480px) {
  .rating-delta {
    font-size: 1rem;
  }
}






.student-progress-box {
  margin: 10px 0 16px;
}

.progress-label {
  font-size: 13px;
  opacity: 0.85;
  margin-bottom: 4px;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: rgba(255,255,255,0.15);
  border-radius: 6px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #ff4d4d, #ffcc00);
  transition: width 0.4s ease;
}

.progress-text {
  font-size: 12px;
  margin-top: 4px;
  opacity: 0.75;
  text-align: right;
}




/* =========================================
üì± GAME REVIEW ‚Äî MOBILE FIX
Board on top, Review below
========================================= */
@media (max-width: 768px) {

  /* Main review analysis wrapper */
  #gameReviewAnalysis > div {
    flex-direction: column !important;
    gap: 14px !important;
    align-items: stretch !important;
  }

  /* Chessboard */
  #gameReviewBoard {
    width: 100% !important;
    max-width: 360px;
    margin: 0 auto;
  }

  /* Notation panel */
  #gameReviewNotation {
    font-size: 20px;
    text-align: left;
  }

  /* Review panel ‚Äî BELOW BOARD */
  #gameReviewPanel {
    border-left: none !important;
    border-top: 1px solid #2f335a;
    padding-top: 12px;
    margin-top: 8px;
    max-height: 260px;
    overflow-y: auto;
  }

  /* Review results text */
  #gameReviewResults {
    font-size: 18px;
    line-height: 1.5;
  }
}




/* üî• ACTIVE REVIEW MOVE HIGHLIGHT */
.review-move {
  padding: 4px 6px;
  border-radius: 6px;
  margin-bottom: 2px;
  cursor: pointer;
}

.review-move.active {
  background: rgba(245, 200, 66, 0.22);
  border-left: 3px solid #f5c842;
}





.review-summary {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}


.player-summary {
  padding: 18px 20px;
  border-radius: 12px;
  width: 100%;
  box-sizing: border-box;

  display: flex;
  flex-direction: column;
  align-items: center;   /* ‚úÖ CENTER CONTENT */
  text-align: center;    /* ‚úÖ CENTER TEXT */
}



.player-summary.white {
  border: 2px solid #4caf50;
}

.player-summary.black {
  border: 2px solid #f44336;
}

.player-summary h3 {
  margin: 0;
}

.accuracy {
  font-size: 20px;
  font-weight: bold;
  margin: 8px 0;
}




.review-layout {
  display: grid;
  grid-template-columns: 1fr minmax(480px, 560px);
  gap: 24px;
  align-items: flex-start;
}



#reviewList {
  max-height: 420px;
  overflow-y: auto;
}

#reviewSummary {
  position: sticky;
  top: 10px;
}





/* ==============================
   üì± MOBILE SIDE-BY-SIDE REVIEW CARDS
   ============================== */
@media (max-width: 768px) {

  /* Keep main layout vertical */
  .review-layout {
    display: flex !important;
    flex-direction: column !important;
    gap: 12px;
  }

  /* üî• SIDE-BY-SIDE cards (2 columns) */
  .review-summary {
    display: grid !important;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    width: 100%;
  }

  .player-summary {
    width: 100% !important;
    min-width: 0;
    padding: 10px;
    box-sizing: border-box;
  }

  /* Reduce text size slightly to fit */
  .player-summary h3 {
    font-size: 14px;
  }

  .player-summary .accuracy {
    font-size: 14px;
    margin-bottom: 6px;
  }

  .player-summary ul {
    padding-left: 14px;
    font-size: 16px;
  }

  /* Ensure nothing is clipped */
  #reviewSummary {
    overflow: visible !important;
  }
}


/* ==============================
   üì± MOBILE REVIEW ORDER FIX
   ============================== */
@media (max-width: 768px) {

  /* Parent layout must be flex */
  .review-layout {
    display: flex !important;
    flex-direction: column !important;
  }

  /* üîÅ Change visual order ONLY */
  #reviewSummary {
    order: 1; /* cards first */
  }

  #reviewList {
    order: 2; /* moves after */
  }
}



/* ==============================
   üì± MOBILE SCROLL ISOLATION FIX
   ============================== */
@media (max-width: 768px) {

  /* Ensure parent creates proper stacking */
  .review-layout {
    position: relative;
  }

  /* üîí Cards stay ABOVE move list */
  #reviewSummary {
    position: relative;
    z-index: 2;
    background: transparent;
  }

  /* üßæ Move list scrolls INSIDE itself */
  #reviewList {
    position: relative;
    z-index: 1;

    max-height: 100vh;      /* adjust if needed */
    overflow-y: auto;
    overscroll-behavior: contain;

    margin-top: 8px;
    padding-bottom: 12px;
  }

  /* Prevent children from escaping */
  #reviewList .review-move {
    position: relative;
  }
}






/* ===============================
   üì± GAME REVIEW ‚Äì MOBILE LAYOUT
   =============================== */

.review-top-layout {
  display: flex;
  gap: 20px;
  align-items: flex-start;
}

/* üì± Mobile */
@media (max-width: 768px) {
  .review-top-layout {
    flex-direction: column;
  }

  #lichessLoader {
    width: 100% !important;
  }

  #reviewPgn {
    max-width: 100% !important;
  }
}





/* üü° Golden hover highlight */
.lichess-game-item:hover {
  background: linear-gradient(
    90deg,
    rgba(245, 200, 66, 0.25),
    rgba(245, 200, 66, 0.08)
  );
  box-shadow: inset 0 0 0 1px rgba(245, 200, 66, 0.35);
}

/* üîµ Selected (clicked) game */
.lichess-game-active {
  background: linear-gradient(
    90deg,
    rgba(59,130,246,0.22),
    rgba(59,130,246,0.08)
  );
  border-left: 4px solid #3b82f6;
}

/* Selected always wins over hover */
.lichess-game-item.lichess-game-active:hover {
  background: linear-gradient(
    90deg,
    rgba(59,130,246,0.28),
    rgba(59,130,246,0.12)
  );
  box-shadow: none;
}



/* ===============================
   ‚ôüÔ∏è LICHESS FETCH BOX
   =============================== */

.analysis-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.lichess-box {
  display: flex;
  align-items: center;
  gap: 8px;
}

.lichess-box input {
  width: 140px;
  padding: 6px 8px;
  border-radius: 6px;
  border: none;
  background: #2a2d4a;
  color: #fff;
  font-size: 13px;
}

.lichess-box input:focus {
  outline: 2px solid #ffd700;
}

.lichess-box button {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  background: #ffd700;
  color: #101225;
  font-size: 13px;
  font-weight: bold;
}

.lichess-info {
  display: flex;
  gap: 10px;
  margin-left: 10px;
  font-size: 12px;
  color: #ddd;
}

.hidden {
  display: none;
}


#analysisGameSelect {
  max-width: 260px;
  padding: 6px;
  border-radius: 6px;
  background: #2a2d4a;
  color: #fff;
  border: none;
  font-size: 12px;
}




#analysisGameSelect {
  max-width: 420px;
  max-height: 260px;
  overflow-y: auto;
  padding: 6px;
  border-radius: 8px;
  background: #2a2d4a;
  color: #fff;
  border: 1px solid #3a3f66;
  font-size: 12px;
}

#analysisGameSelect option {
  padding: 6px;
}



.lichess-fetch-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
}

.lichess-dropdown {
  position: absolute;
  top: 110%;
  left: 0;
  width: 420px;
  max-height: 260px;
  background: #1c1f35;
  border: 1px solid #3a3f66;
  border-radius: 10px;
  overflow-y: auto;
  z-index: 9999;
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
}

.lichess-dropdown-item {
  padding: 8px 10px;
  font-size: 12px;
  color: #eee;
  cursor: pointer;
  border-bottom: 1px solid #2a2d4a;
}

.lichess-dropdown-item:hover {
  background: #ffd700;
  color: #101225;
}

.hidden {
  display: none !important;
}




/* ===============================
   üîç LICHESS SEARCH BUTTON
   =============================== */

#analysisFetchLichessBtn {
  padding: 8px 14px;
  border-radius: 10px;
  border: none;
  position: relative;
  top: -7px;
  background: linear-gradient(135deg, #ffd700, #f5c400);
  color: #101225;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 6px 16px rgba(255, 215, 0, 0.35);
  transition: all 0.18s ease;
}

#analysisFetchLichessBtn:hover {
  transform: translateY(-1px);
  box-shadow: 0 10px 24px rgba(255, 215, 0, 0.55);
}

#analysisFetchLichessBtn:active {
  transform: translateY(0);
  box-shadow: 0 4px 10px rgba(255, 215, 0, 0.35);
}

#analysisFetchLichessBtn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  box-shadow: none;
}



/* ===============================
   ‚ñ∂Ô∏è LICHESS LOAD GAME BUTTON
   =============================== */

#analysisLoadGameBtn {
  padding: 8px 16px;
  border-radius: 10px;
  border: none;
  background: linear-gradient(135deg, #4ade80, #22c55e);
  color: #0b2e1a;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 6px 16px rgba(34, 197, 94, 0.35);
  transition: all 0.18s ease;
}

#analysisLoadGameBtn:hover {
  transform: translateY(-1px);
  box-shadow: 0 10px 24px rgba(34, 197, 94, 0.55);
}

#analysisLoadGameBtn:active {
  transform: translateY(0);
  box-shadow: 0 4px 10px rgba(34, 197, 94, 0.35);
}

#analysisLoadGameBtn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  box-shadow: none;
}




/* =====================================================
üì± OLYMPUS ‚Äî MOBILE CENTER (NO CLIP, NO DRIFT)
===================================================== */
@media (max-width: 768px) {

  /* Lock horizontal scroll but don't clip children */
  html, body {
    overflow-x: hidden !important;
  }

  /* Let board wrappers overflow safely */
  #board-section,
  #board-section .analysis-board,
  #board-section .board-layout,
  #board-section .board-wrapper {
    overflow: visible !important;
    max-width: 100% !important;
    width: 100% !important;
    margin-left: auto !important;
    margin-right: auto !important;
  }

  /* True centered board */
  #board-section #chessboard,
  #board-section #computerBoard,
  #board-section #studyBoard,
  #board-section #editorBoard,
  #board-section .practice-board,
  #board-section .chessboard {
    width: min(92vw, 340px) !important;
    aspect-ratio: 1 / 1;

    margin: 16px auto !important;
    display: block !important;

    position: relative !important;
    left: 5% !important;
    transform: translateX(-50%) !important;
  }
}

@media (max-width: 768px) {

  /* Make the board section a flex column */
  .analysis-board,
  .board-wrapper,
  .chess-container {
    display: flex;
    flex-direction: column;
  }

  /* Board stays on top */
  #chessboard,
  .chessboard {
    order: 1;
    margin: 0 auto;
  }

  /* Submit button goes under board */
  #submitBtn {
    order: 2;
    display: block !important;
    margin: 14px auto 8px auto;
    width: 90%;
    max-width: 340px;
    padding: 12px 20px;
    font-size: 16px;
  }

  /* Prev / Next goes under submit button */
  #bulkNav {
    order: 3;
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 10px;
  }
  #submitBtn,
#bulkNav {
  margin-left: -10px;   /* increase this = more left */
  margin-right: auto;
}
#bulkNav {
  margin-left: 50px;   /* increase = more right */
}


}


@media (max-width: 768px) {

  /* ========================= */
  /* SECTION WIDTH FIX */
  /* ========================= */
  #knightfog-section {
    max-width: 100%;
    padding: 0 12px;
  }

  /* ========================= */
  /* BOARD RESPONSIVE FIX */
  /* ========================= */
  #kfqBoard {
    width: 92vw;
    height: 92vw;
    max-width: 360px;
    max-height: 360px;

    padding: 6px;
    margin: 14px auto;
  }

  /* Knight + squares scale down */
  #kfqBoard .kfq-square {
    font-size: 18px;
  }

  #kfqBoard .kfq-knight {
    font-size: 22px;
  }

  /* ========================= */
  /* MODE BUTTONS FIX */
  /* ========================= */
  #knightfog-section .kfq-modes {
    flex-direction: column;
    align-items: stretch;
    gap: 12px;
  }

  #knightfog-section .kfq-mode {
    min-width: 100%;
    padding: 14px 12px;
    font-size: 16px;
    border-radius: 12px;
  }

  #knightfog-section .kfq-mode span {
    font-size: 13px;
  }

  /* ========================= */
  /* GAME TOP BAR WRAP FIX */
  /* ========================= */
  #kfqGame .memory-top {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    text-align: center;
  }

  #kfqGame .memory-top > div {
    flex: 1 1 45%;
    font-size: 13px;
  }

  /* ========================= */
  /* EXIT BUTTON */
  /* ========================= */
  #kfqGame .btn-secondary {
    display: block;
    width: 90%;
    max-width: 300px;
    margin: 12px auto 0 auto;
  }
}





@media (max-width: 768px) {

  /* Files (a‚Äìh) ‚Äî distance from board */
  #coordtrain-section .cfc-files {
    margin-top: -10px;   /* tweak this */
    padding-top: 0;
  }
  
@media (max-width: 768px) {
  #coordtrain-section .mini-board {
    margin-top: -40px;   /* was -15px on desktop ‚Äî tweak this */
  }
}
@media (max-width: 768px) {

  /* Tighten vertical spacing between 1‚Äì8 */
  #coordtrain-section .cfc-ranks span {
    line-height: 0.01;   /* was ~1 or default */
    margin: 0px;         /* remove extra gaps */
    padding: 0px;        /* remove internal spacing */
    font-size: 14px;  /* optional: keep consistent size */
  }
}

@media (max-width: 768px) {

  /* Stop ranks from being forced apart */
  #coordtrain-section .cfc-ranks {
    justify-content: flex-start !important; /* kill space-between */
    gap: 28px;                               /* control spacing here */
    margin-right: -10px;   /* üî• THIS controls distance to board */

  }

  /* Optional fine-tune text size */
  #coordtrain-section .cfc-ranks span {
    line-height: 1;
    font-size: 15px;
  }
}

 
}




@media (max-width: 768px) {

  /* ========================= */
  /* COLOR CHAOS ‚Äì MOBILE FIT */
  /* ========================= */

  /* Let card grow (prevents clipping) */
  #colorchaos-section .cfc-card,
  #colorchaos-section #cfcGame {
    min-height: auto;
    overflow: visible;
  }

  /* Wrapper: tight & centered */
  #colorchaos-section .cfc-board-wrapper {
    grid-template-columns: 18px 1fr;  /* ranks | board */
    grid-template-rows: 1fr 18px;     /* board | files */
    gap: 2px;
    margin: 6px auto 10px;
  }

  /* Board size for phones */
  #colorchaos-section #cfcBoard {
    width: 80vw;
    height: 80vw;
    max-width: 260px;
    max-height: 260px;
    margin: 6px auto;
  }

  /* RANKS (1‚Äì8) */
  #colorchaos-section .cfc-ranks {
    gap: 25px;
    font-size: 12px;
  }

  /* FILES (a‚Äìh) */
  #colorchaos-section .cfc-files {
    margin-top: 1px;
    gap: 6px;
    font-size: 12px;
  }

@media (max-width: 768px) {

  /* Override desktop board size so all squares fit */
  #colorchaos-section #cfcBoard {
    width: 92vw !important;
    height: 92vw !important;
    max-width: 320px !important;
    max-height: 320px !important;

    margin: 8px auto !important;
    box-sizing: border-box;
  }

}


@media (max-width: 768px) {

  /* Make squares always fit inside the board */
  #colorchaos-section #cfcBoard .cfc-square {
    box-sizing: border-box;
    width: 100%;
    height: 100%;

    /* Keep them square and prevent overflow */
    aspect-ratio: 1 / 1;

    /* Reduce size pressure on small screens */
    font-size: 22px;   /* üîß tweak if knight feels too big */
    line-height: 1;
    padding: 0;
    margin: 0;
  }
}

}







@media (max-width: 768px) {

  /* ========================= */
  /* BOARD FREEZE ‚Äì MOBILE FIT */
  /* ========================= */

  /* Wrapper stays centered and tight */
  #boardfreeze-section .bf-board-wrapper {
    gap: 4px;
    margin: 10px auto;
  }

  /* Board scales to phone width */
  #boardfreeze-section #bfBoard {
    width: 85vw;
    height: 85vw;
    max-width: 300px;
    max-height: 300px;

    border-radius: 10px;
  }

  /* RANKS (1‚Äì8) closer + smaller */
  #boardfreeze-section .bf-ranks {
    font-size: 11px;
    padding-right: 2px;
  }

  /* FILES (a‚Äìh) closer + smaller */
  #boardfreeze-section .bf-files {
    font-size: 11px;
    padding-top: 2px;
  }

  /* Pieces scale down nicely */
  #boardfreeze-section #bfBoard img {
    width: 75%;
    height: 75%;
  }
}




@media (max-width: 768px) {

  /* =============================== */
  /* üëë KNIGHT DEFENSE ‚Äì MOBILE FIT */
  /* =============================== */

  /* Scale board to phone width */
  #kndBoard {
    width: 95vw;
    height: 95vw;

    max-width: 390px;
    max-height: 390px;

    padding: 6px;
    border-radius: 12px;
  }

  /* Force 10√ó10 grid to shrink evenly */
  #kndBoard {
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
  }

  /* Squares auto-scale with board */
  #kndBoard .knd-square {
    width: 100%;
    height: 100%;
    font-size: 22px;
  }

  /* Piece scaling */
  #kndBoard .king {
    font-size: 26px;
  }

  #kndBoard .knight {
    font-size: 24px;
  }

  #kndBoard .monster {
    font-size: 22px;
  }
}




@media (max-width: 768px) {

  /* =============================== */
  /* üî• KLF ‚Äì MOBILE BOARD SCALE */
  /* =============================== */

  #klfBoard {
    width: 88vw;
    height: 88vw;

    max-width: 320px;
    max-height: 320px;

    margin: 12px auto;
    border-radius: 10px;
  }

  /* Force perfect 10√ó10 grid on mobile */
  #klfBoard {
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
  }

  /* =============================== */
  /* üî• KLF ‚Äì MOBILE SQUARE FIT */
  /* =============================== */

  /* Force squares to obey grid size */
  #klfBoard .klf-square {
    width: 100% !important;
    height: 100% !important;

    display: flex;
    align-items: center;
    justify-content: center;

    /* Auto-scale emoji/pieces so they don't push out */
    font-size: clamp(18px, 6vw, 28px);
    line-height: 1;

    box-sizing: border-box;
    overflow: hidden;
  }

  /* Slightly reduce effects for clarity */
  #klfBoard .klf-knight {
    font-size: 24px;
  }

  #klfBoard .klf-lava {
    box-shadow:
      inset 0 0 6px rgba(255,180,0,0.6),
      inset 0 0 12px rgba(255,80,0,0.8);
  }

}





@media (max-width: 768px) {

  /* Scale unit for mobile */
  #kgBoard {
    --kg-size: min(80vw, 300px);

    width: var(--kg-size) !important;
    height: var(--kg-size) !important;

    grid-template-columns: repeat(8, 1fr) !important;
    grid-template-rows: repeat(8, 1fr) !important;

    margin-top: -20px;
  }

  /* Square obeys grid cell */
  .kg-square {
    width: 100% !important;
    height: 100% !important;
  }

  /* Knight image scales down */
  .kg-square img {
    width: 100%;
    height: 100%;
  }

  /* Ranks scale to board */
  .kg-ranks {
    grid-template-rows: repeat(8, 1fr);
    font-size: 11px;
    padding-top: 9px;
  }

  /* Files scale to board */
  .kg-files {
    grid-template-columns: repeat(8, 1fr);
    font-size: 11px;
    margin-top: 1px;
  }

}

@media (max-width: 768px) {

  /* Give breathing space between rank numbers */
  .kg-ranks {
    row-gap: 22px;        /* üîß increase = more vertical space */
    padding-right: 2px; /* üîß push ranks away from board */
    transform: translateY(-10px);  /* ‚¨ÜÔ∏è increase = more up */
  }

  /* Give breathing space between file letters */
  .kg-files {
    column-gap: 30px;    /* üîß increase = more horizontal space */
    margin-top: -2px;  /* üîß move files slightly closer/farther */
    transform: translateX(10px);   /* ‚û°Ô∏è increase = more right */
    
  }

}






@media (max-width: 768px) {

  /* =============================== */
  /* KNIGHT vs MONSTER ‚Äì MOBILE FIT */
  /* =============================== */

  /* Board scales to phone width */
  #kvmBoard {
    width: 88vw;
    height: 88vw;

    max-width: 300px;
    max-height: 300px;

    margin: 10px auto;

    display: grid !important;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
  }

  /* Squares obey grid size */
  #kvmBoard .kp-square {
    width: 100%;
    height: 100%;

    font-size: 26px;   /* üîß tweak for emoji size */
    line-height: 1;

    box-sizing: border-box;
    overflow: hidden;
  }

  /* Emoji scaling inside square */
  #kvmBoard .kp-square span {
    transform: scale(1);
  }

  /* Mode buttons stack nicely on phones */
  .kvm-modes {
    grid-template-columns: 1fr;
    gap: 12px;
  }
}







@media (max-width: 768px) {

  /* ================================ */
  /* KNIGHT FLASH PATH ‚Äî MOBILE FIT */
  /* ================================ */

  /* Board scales to screen */
  #kpBoard {
    width: 88vw;
    height: 88vw;

    max-width: 300px;
    max-height: 300px;

    margin: 8px auto 16px;

    display: grid !important;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
  }

  /* Squares auto-fit inside grid */
  #kpBoard .kp-square {
    width: 100%;
    height: 100%;

    box-sizing: border-box;
    overflow: hidden;
  }

}




@media (max-width: 768px) {

  /* ================================ */
  /* PF MINI BOARD ‚Äî MOBILE SCALE */
  /* ================================ */

  .mini-board {
    width: 88vw;
    height: 88vw;

    max-width: 300px;
    max-height: 300px;

    margin: 8px auto;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
  }

  /* Squares always fit board */
  .pf-square {
    width: 100%;
    height: 100%;

    box-sizing: border-box;
    overflow: hidden;

    font-size: 20px;   /* üîΩ scale emoji for phones */
  }

  /* Flash pieces scale down */
  .pf-piece {
    font-size: 26px;
    line-height: 1;
  }

  /* Queen emphasis (still visible on small screens) */
  .pf-piece.queen {
    font-size: 15px;
  }

}






@media (max-width: 768px) {

  /* Lock board into a true square */
  #knightspeed-section #ksrBoard {
    width: 88vw !important;
    height: 88vw !important;
    max-width: 300px;
    max-height: 300px;

    display: grid !important;
    grid-template-columns: repeat(8, 1fr) !important;
    grid-template-rows: repeat(8, 1fr) !important;

    margin: 10px auto;
  }

  /* FORCE every square to stay square */
  #knightspeed-section .ksr-square,
  #knightspeed-section .kp-square {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: 1 / 1;

    display: flex;
    align-items: center;
    justify-content: center;

    line-height: 1;
  }

  /* Scale pieces so they don‚Äôt stretch grid */
  #knightspeed-section .ksr-knight,
  #knightspeed-section .ksr-star,
  #knightspeed-section .ksr-bomb {
    font-size: 22px;
    max-width: 80%;
    max-height: 80%;
  }

}


@media (max-width: 768px) {

  /* FORCE all squares to stay inside board */
  #knightspeed-section .kp-square,
  #knightspeed-section .ksr-square {
    width: 100% !important;
    height: 100% !important;
    aspect-ratio: 1 / 1;

    display: flex;
    align-items: center;
    justify-content: center;

    line-height: 1;
    overflow: hidden;
  }

  /* Prevent emojis from stretching squares */
  #knightspeed-section .kp-square span,
  #knightspeed-section .kp-square img {
    max-width: 85%;
    max-height: 85%;
    font-size: 22px;
  }

}



@media (max-width: 768px) {

  /* Shrink knight emoji inside Knight Speed Run */
  #knightspeed-section #ksrBoard .kp-square {
    font-size: 20px !important;
    line-height: 1 !important;
  }

}



@media (max-width: 768px) {

  /* Board size */
  #knightescape-section #kemBoard {
    width: 85vw !important;
    height: 85vw !important;
    max-width: 300px;
    max-height: 300px;
    margin: 8px auto;
  }

  /* Square size */
  #knightescape-section #kemBoard .kp-square {
    font-size: 20px !important;
    line-height: 1;
  }

}



@media (max-width: 768px) {

  /* Board fit */
  #knightpath-section #kpBoard {
    width: 85vw !important;
    height: 85vw !important;
    max-width: 300px;
    max-height: 300px;
    margin: 8px auto;
  }

  /* Squares */
  #knightpath-section #kpBoard .kp-square {
    font-size: 20px !important;   /* üî• knight + icons size */
    line-height: 1;
  }

}



@media (max-width: 768px) {

  /* ================================ */
  /* PATHFINDER ‚Äì MOBILE BOARD FIT */
  /* ================================ */

  #pathfinder-section .mini-board,
  #pathfinder-section #pfBoard {
    width: 88vw;
    height: 88vw;
    max-width: 300px;
    max-height: 300px;
    margin: 10px auto;
  }

  /* ================================ */
  /* PATHFINDER ‚Äì MOBILE PIECE SCALE */
  /* ================================ */

  #pathfinder-section .pf-piece,
  #pathfinder-section .pf-queen-emoji,
  #pathfinder-section .pf-home-icon {
    font-size: 22px !important;
    line-height: 1;
  }

  /* Keep coord text readable */
  #pathfinder-section .pf-coord {
    font-size: 9px;
    bottom: 2px;
    right: 3px;
  }
}





@media (max-width: 768px) {

  /* Make cards fluid */
  .mini-game {
    width: 100% !important;
    display: block !important;
  }

  /* PRACTICE BOARD ‚Äî LOCK TO CARD WIDTH */
  .mini-game .practice-board {
    width: 92% !important;
    max-width: 280px;
    margin: 12px auto;

    display: grid !important;
    grid-template-columns: repeat(8, 1fr) !important;
    grid-template-rows: repeat(8, 1fr) !important;

    aspect-ratio: 1 / 1;
    height: auto !important;
    min-height: unset !important;
    max-height: unset !important;

    overflow: hidden;
  }

  /* FORCE PROPER SQUARE BEHAVIOR */
  .mini-game .practice-board > div {
    width: 100% !important;
    height: 100% !important;

    min-width: 0 !important;
    min-height: 0 !important;

    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* SCALE ALL PIECES / EMOJIS / IMAGES */
  .mini-game .practice-board img,
  .mini-game .practice-board span {
    width: 65%;
    height: 65%;
    font-size: clamp(18px, 4vw, 24px);
    object-fit: contain;
  }
}


@media (max-width: 768px) {

  /* =========================
     BOARD FIT
  ========================== */
  .mini-game .practice-board {
    width: 100% !important;
    max-width: 92vw !important;
    margin: 0 auto !important;
  }

  /* =========================
     SQUARE SIZE
  ========================== */
  .mini-game .mini-square {
    width: calc(92vw / 8) !important;
    height: calc(92vw / 8) !important;
    max-width: 44px !important;
    max-height: 44px !important;

    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* =========================
     CHESS PIECES (BIGGER)
  ========================== */
  .mini-game .mini-piece {
    width: 85% !important;
    height: 85% !important;
    object-fit: contain !important;
  }

  /* =========================
     TARGET OBJECTS (BIGGER)
  ========================== */
  .mini-game .target-object {
    width: 75% !important;
    height: 75% !important;
    object-fit: contain !important;
    pointer-events: none;
  }

  /* =========================
     COORDINATES (SMALLER)
  ========================== */
  .mini-game .coord {
    font-size: 8px !important;
    opacity: 0.6 !important;
    bottom: 2px !important;
    right: 2px !important;
  }

}







/* ================================
   üì± MOBILE NAVBAR ‚Äî MODERN DROPDOWN
================================ */
@media (max-width: 768px) {

  /* NAVBAR BASE */
  #topNavbar {
    position: sticky;
    top: 0;
    z-index: 9999;

    display: flex;
    align-items: center;
    justify-content: space-between;

    padding: 10px 14px;
    background: linear-gradient(180deg, #0f172a, #020617);
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  }

  /* Hide all nav buttons by default */
  #topNavbar .nav-btn {
    display: none;
  }

  /* Brand stays visible */
  #topNavbar .brand {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  #topNavbar .brand-logo {
    height: 36px;
  }

  /* üçî HAMBURGER BUTTON */
  #topNavbar::after {
    content: "‚ò∞";
    font-size: 28px;
    color: #facc15;
    cursor: pointer;
    user-select: none;
  }

  /* MOBILE MENU PANEL */
  #topNavbar.mobile-open {
    flex-direction: column;
    align-items: stretch;
  }

  #topNavbar.mobile-open .nav-btn {
    display: flex;
  }

/* MOBILE MENU ITEMS ‚Äî COMPACT ROW STYLE */
#topNavbar .nav-btn {
  display: none; /* still hidden by default */

  padding: 10px 14px;     /* ‚¨áÔ∏è smaller height */
  margin: 4px 0;

  width: 100%;
  text-align: left;

  font-size: 15px;
  border-radius: 8px;    /* ‚¨áÔ∏è less ‚Äúcardy‚Äù */

  background: rgba(30, 41, 59, 0.9);
  border: 1px solid rgba(255,255,255,0.05);
  color: #e5e7eb;

  transition: background 0.15s ease;
}


  #topNavbar .nav-btn:hover {
    background: linear-gradient(135deg, #334155, #1e293b);
    transform: scale(1.02);
  }

  /* USER MENU MOBILE */
  #topNavbar .user-menu {
    width: 100%;
  }

  #topNavbar .user-info {
    width: 100%;
    text-align: left;
    padding: 14px 16px;
    border-radius: 12px;
  }

  /* LOGOUT */
  #topNavbar .btn-logout {
    width: 100%;
    margin-top: 10px;
    border-radius: 12px;
  }

  /* DROPDOWN GLASS PANEL */
  #topNavbar.mobile-open .user-dropdown {
    display: block;
    margin-top: 10px;

    background: rgba(15, 23, 42, 0.85);
    backdrop-filter: blur(10px);

    border-radius: 14px;
    padding: 12px;

    box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  }

  /* Smooth open animation */
  #topNavbar .nav-btn,
  #topNavbar .user-dropdown {
    animation: mobileNavSlide 0.25s ease;
  }

  @keyframes mobileNavSlide {
    from {
      opacity: 0;
      transform: translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
}


/* ================================
   üì± MOBILE HAMBURGER ‚Äî ALWAYS VISIBLE
================================ */
.mobile-menu-btn {
  display: none;
}

@media (max-width: 768px) {
  .mobile-menu-btn {
    display: block;
    position: absolute;
    top: 10px;
    right: 12px;
    z-index: 9999;

    background: linear-gradient(135deg, #facc15, #eab308);
    border: none;
    color: #1f2933;

    font-size: 26px;
    padding: 8px 12px;
    border-radius: 10px;

    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    cursor: pointer;
  }
}






/* ==========================================
   üì± MEMORY GAME ‚Äî MOBILE BOARD FIX
   FULLY ISOLATED
========================================== */
@media (max-width: 768px) {

  /* Keep HUD compact */
  #memory-section .memory-top {
    max-width: 95vw;
    font-size: 16px;
    padding: 6px 10px;
    margin-bottom: 8px;
  }

  /* BOARD FITS SCREEN HEIGHT SAFELY */
  #memory-section .mini-board {
    width: min(92vw, 92vh);   /* üî• fit to viewport */
    height: min(92vw, 92vh);
    max-width: 360px;        /* safety cap */
    max-height: 360px;

    margin: 8px auto;
    aspect-ratio: 1 / 1;
  }

  /* Square always fills cell */
  #memory-section .memory-square {
    width: 100%;
    height: 100%;
  }

  /* Coordinates smaller so they don't steal space */
  #memory-section .memory-coord {
    font-size: 9px;
    top: 2px;
    left: 3px;
  }

  /* Touch-friendly flashing */
  #memory-section .memory-square.flash {
    box-shadow: 0 0 8px rgba(34,197,94,0.7);
  }

  /* Exit button spacing fix */
  #memory-section button {
    margin-top: 8px;
  }
}




/* ================================
   üì± MOBILE ‚Äî HIDE STUDY & EDITOR
   (NO HAMBURGER CONFLICT)
================================ */
@media (max-width: 768px) {

  /* Hide by data-tab */
  #topNavbar .nav-btn[data-tab="study"],
  #topNavbar .nav-btn[data-tab="editor"] {
    display: none !important;
  }

}








/* ==========================================
üì± MOBILE ‚Äî FORCE PGN BAR UNDER BOARD
No JS / No HTML changes
========================================== */
@media (max-width: 768px) {

  /* Make analysis board a positioning anchor */
  #board-section .analysis-board,
  #board-section .board-wrapper,
  #board-section {
    position: relative;
  }

  /* Teleport PGN buttons visually under board */
  #pgnNavButtons {
    position: absolute !important;

    left: 27%;
    transform: translateX(-50%);

    bottom: 40px; /* ‚¨ÖÔ∏è distance under bulk nav ‚Äî adjust if needed */

    display: flex !important;
    gap: 8px;
    flex-wrap: nowrap;

    padding: 8px 12px;
    background: rgba(15, 23, 42, 0.95);
    backdrop-filter: blur(8px);

    border-radius: 14px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.6);

    z-index: 50;
  }

  /* Compact mobile buttons */
  #pgnNavButtons button {
    font-size: 12px;
    padding: 6px 10px;
    border-radius: 10px;
  }

  /* Add space so footer doesn't overlap */
  #board-section {
    padding-bottom: 10px;
  }
}




/* ======================================
üì± MOBILE ‚Äî SHIFT LICHESS DROPDOWN LEFT
====================================== */
@media (max-width: 768px) {

  .lichess-fetch-wrapper {
    position: relative;
  }

  .lichess-dropdown {
    left: -90px !important;   /* ‚¨ÖÔ∏è move left */
    width: calc(100vw - 40px); /* keep it inside screen */
    max-width: 340px;
  }

}



/* =====================================================
üì± MOBILE ONLY ‚Äî HIDE "üéØ Play" NAV BUTTON
Does NOT affect desktop or hamburger logic
===================================================== */
@media (max-width: 768px) {
  .nav-btn[data-tab="computer"] {
    display: none !important;
  }
}




/* ==========================================
   üñ•Ô∏è DESKTOP / LAPTOP ‚Äî FLOATING NAVBAR
   Nav opens OVER content, page never moves
========================================== */

@media (min-width: 769px) {

  /* Take navbar out of layout flow */
  #topNavbar {
    position: fixed !important;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 99999;

    transform: translateZ(0);
  }

  /* Prevent content from hiding behind navbar */
  body {
    padding-top: 72px; /* adjust if navbar height changes */
  }

  /* Dropdowns float instead of pushing layout */
  #topNavbar .user-dropdown,
  #topNavbar .nav-btn {
    position: relative;
    z-index: 99999;
  }

  /* Prevent layout reflow glitches */
  #topNavbar * {
    will-change: transform;
  }

  /* Safety ‚Äî don't let next section jump */
  #topNavbar + * {
    margin-top: 0 !important;
  }

}





/* =====================================================
   üì± MOBILE ONLY ‚Äî DOCK ENGINE UNDER RATING BAR
   Does NOT affect desktop / laptop
   ===================================================== */
@media (max-width: 768px) {

  /* Show engine (you hid it earlier) */
  #board-section #enginePanel {
    display: block !important;
  }

  /* Take engine out of side layout flow */
  #board-section #enginePanel {
    position: relative !important;
    width: 100% !important;
    max-width: 100% !important;
    margin: 8px 0 12px 0 !important;
  }

  /* Make it visually match top bar style */
  #board-section #enginePanel {
    border-radius: 14px;
  }

  /* Slim engine header */
  #board-section .engine-bar {
    padding: 6px 10px !important;
    font-size: 12px !important;
  }

  /* Compact engine lines */
  #board-section .engine-line {
    min-height: 28px;
    font-size: 12px;
    padding: 6px 8px;
  }

}


/* =====================================================
   üì± MOBILE ONLY ‚Äî ENGINE START BUTTON DOCK
   ===================================================== */
@media (max-width: 768px) {

  #mobileEngineActionSlot {
    width: 100%;
    margin: 6px 0 10px 0;
  }

  #mobileEngineActionSlot #analyzeBtn {
    width: 100% !important;
    padding: 10px 0 !important;
    font-size: 14px !important;
    border-radius: 10px !important;
  }
}


/* üö´ STUDENT ‚Äî HIDE STUDY TAB (ALL DEVICES) */
body.student-view .nav-btn[data-tab="study"] {
  display: none !important;
}








/* ===========================
   üì± MOBILE SWIPE FLIP
   =========================== */
@media (max-width: 768px) {
  #chessboard {
    touch-action: none;
  }
}


/* ===========================
   üì± PUZZLE RUSH TAP MOVE
   =========================== */
@media (max-width: 768px) {
  .pr-tap-selected {
    box-shadow: 0 0 0 3px #ffcc00 inset;
    border-radius: 6px;
  }
}



/* DRAW CANVAS */
#drawCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 5000;
  pointer-events: auto;
}

/* TOOLBOX */
.draw-toolbox {
  position: fixed;
  top: 120px;
  right: 40px;
  width: 160px;
  background: #0d111c;
  border: 2px solid red;
  border-radius: 8px;
  z-index: 6000;
  font-family: Arial, sans-serif;
}

.hidden {
  display: none;
}

.toolbox-header {
  background: #ff0000;
  color: white;
  padding: 6px;
  cursor: move;
  text-align: center;
  font-weight: bold;
}

.toolbox-body {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.toolbox-body select,
.toolbox-body input,
.toolbox-body button {
  width: 100%;
  padding: 4px;
  background: #111;
  color: white;
  border: 1px solid #444;
  border-radius: 4px;
}

/* DESKTOP ONLY */
@media (max-width: 900px) {
  #drawToolbox,
  #drawCanvas {
    display: none !important;
  }
}




.toolbox-header {
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  user-select: none;
}

/* Collapsed look */
.draw-collapsed {
  width: 140px;
}

.draw-collapsed .toolbox-body {
  display: none;
}



#previewCanvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 4999;
  pointer-events: none;
}



.student-view #drawToolbox {
  display: none !important;
}

.student-view #drawCanvas,
.student-view #previewCanvas {
  display: none !important;
}






/* ===========================
   OLYMPUS LEADERBOARD UI
=========================== */

.leaderboard-trigger {
  cursor: pointer;
  margin-left: 6px;
  font-size: 16px;
  transition: transform 0.2s ease;
}
.leaderboard-trigger:hover {
  transform: scale(1.2);
}

/* Overlay */
.leaderboard-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

/* Popup */
.leaderboard-popup {
  width: 420px;
  max-width: 95vw;
  max-height: 85vh;
  background: #0e1224;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 0 30px rgba(0,255,255,0.3);
}

/* Header */
.leaderboard-header {
  background: linear-gradient(90deg, #00f2ff, #0077ff);
  color: #000;
  padding: 10px;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.leaderboard-close {
  cursor: pointer;
  font-size: 18px;
}

/* Tabs */
.leaderboard-tabs {
  display: flex;
}

.lb-tab {
  flex: 1;
  background: #111633;
  color: #ccc;
  border: none;
  padding: 8px;
  cursor: pointer;
}

.lb-tab.active {
  background: #00c2ff;
  color: #000;
  font-weight: bold;
}

/* Body */
.leaderboard-body {
  flex: 1;
  overflow: hidden;
}

/* Panels */
.lb-panel {
  display: none;
  height: 100%;
}

.lb-panel.active {
  display: flex;
  flex-direction: column;
}

/* Scroll list */
.lb-list {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
}

.lb-row {
  display: flex;
  justify-content: space-between;
  padding: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  font-size: 14px;
}

.lb-rank {
  color: gold;
  width: 30px;
}

.lb-name {
  flex: 1;
  color: #fff;
}

.lb-score {
  color: #00ffcc;
}

/* Dropdown */
.lb-game-select {
  background: #111633;
  color: white;
  border: none;
  padding: 8px;
  margin: 8px;
}

/* Muted */
.lb-muted {
  text-align: center;
  color: #777;
}

/* MOBILE */
@media (max-width: 600px) {
  .leaderboard-popup {
    width: 100%;
    height: 100%;
    max-height: 100%;
    border-radius: 0;
  }
}





/* ===========================
   OLYMPUS TOP 3 GLOW SYSTEM
=========================== */

.lb-row.top-1 {
  background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), #000);
  box-shadow: 0px 0px 12px 0px gold;
  border-radius: 6px;
  animation: goldPulse 1.5s infinite alternate;
}

.lb-row.top-2 {
  background: linear-gradient(90deg, rgba(192, 192, 192, 0.2), #000);
  box-shadow: 0px 0px 10px 0px silver;
  border-radius: 6px;
}

.lb-row.top-3 {
  background: linear-gradient(90deg, rgba(205, 127, 50, 0.2), #000);
  box-shadow: 0px 0px 8px 0px #cd7f32;
  border-radius: 6px;
}

/* Crown icons */
.lb-rank.crown::before {
  margin-right: 6px;
}

.lb-rank.gold::before {
  content: "üëë";
}

.lb-rank.silver::before {
  content: "ü•à";
}

.lb-rank.bronze::before {
  content: "ü•â";
}

/* Gold animation */
@keyframes goldPulse {
  from { box-shadow: 0px 0px 8px 0px gold; }
  to   { box-shadow: 0px 0px 18px 0px gold; }
}






.mp-card {
  max-width: 420px;
  margin: auto;
  background: #15182b;
  padding: 16px;
  border-radius: 12px;
}

.mp-card h2 {
  text-align: center;
}

.mp-card input,
.mp-card select,
.mp-card button {
  width: 100%;
  margin-top: 10px;
  padding: 12px;
  border-radius: 8px;
  border: none;
}

#mpBoard {
  width: 100%;
  max-width: 500px;
  height: 500px;
  margin: 12px auto;
}




.mp-clock {
  display: flex;
  justify-content: space-between;
  font-size: 18px;
  margin-bottom: 8px;
  color: white;
}





.mp-promo-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.mp-promo-overlay.hidden {
  display: none;
}

.mp-promo-box {
  background: #15182b;
  padding: 16px;
  border-radius: 12px;
  display: flex;
  gap: 12px;
}

.mp-promo-box button {
  width: 52px;
  height: 52px;
  font-size: 26px;
  background: #22264a;
  border: none;
  border-radius: 8px;
  color: white;
  cursor: pointer;
}

.mp-promo-box button:hover {
  background: #3b82f6;
}


/* Grab cursor on Live Match board */
#mpBoard {
  cursor: grab;
}

/* While dragging a piece */
#mpBoard:active {
  cursor: grabbing;
}

/* Chessboard squares inherit grab */
#mpBoard .square-55d63 {
  cursor: grab;
}





/* =========================
   LIVE MATCH UI (ISOLATED)
========================= */

.mp-wrap {
  padding: 12px;
}

.mp-title {
  text-align: center;
  margin-bottom: 12px;
}

.mp-layout {
  display: flex;
  gap: 16px;
  max-width: 1200px;
  margin: auto;
}

/* LEFT PANEL */
.mp-controls {
  width: 320px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.mp-card {
  background: #15182b;
  border-radius: 12px;
  padding: 12px;
}

.mp-label {
  display: block;
  font-size: 12px;
  opacity: 0.8;
  margin-bottom: 4px;
}

.mp-card select,
.mp-card input,
.mp-card button {
  width: 100%;
  padding: 8px;
  border-radius: 8px;
  border: none;
  margin-bottom: 8px;
  font-size: 14px;
}

.mp-room {
  font-size: 13px;
  text-align: center;
  margin-bottom: 6px;
  opacity: 0.9;
}

/* BOARD AREA */
.mp-board-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#mpBoard {
  width: min(70vh, 520px);
  margin: 8px 0;
}

/* PLAYER BARS */
.mp-player {
  width: 100%;
  max-width: 520px;
  display: flex;
  justify-content: space-between;
  padding: 6px 12px;
  background: #1e223f;
  border-radius: 8px;
  font-size: 14px;
}

.mp-opponent {
  margin-bottom: 6px;
}


.mp-you {
  margin-top: 6px;
}

/* CLOCK */
.mp-clock {
  font-weight: bold;
}

.mp-clock.low {
  color: #ff4d4d;
}

/* NOTATION */
.mp-notation {
  height: 260px;
  display: flex;
  flex-direction: column;
}

.mp-notation-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 6px;
  font-size: 13px;
}

#mpMoves {
  flex: 1;
  overflow-y: auto;
  font-size: 13px;
  line-height: 1.5;
  background: #0f1224;
  padding: 6px;
  border-radius: 8px;
}

/* MOBILE */
@media (max-width: 768px) {
  .mp-layout {
    flex-direction: column;
  }

  .mp-controls {
    width: 100%;
  }

  #mpBoard {
    width: 90vw;
  }

  .mp-player {
    max-width: 90vw;
  }
}



/* PLAYER DOT MODE */
.mp-player span:first-child {
  display: none; /* Hide name text */
}

.mp-player::before {
  content: "üü¢ Connected";
  font-size: 16px;
}






/* POV FLIP SYSTEM ‚Äî ISOLATED */
.mp-board-area {
  display: flex;
  flex-direction: column;
}

/* Default = White POV */
.mp-opponent { order: 1; }
#mpBoard     { order: 2; }
.mp-you      { order: 3; }

/* Black POV */
.mp-board-area.black .mp-you {
  order: 1;
}

.mp-board-area.black #mpBoard {
  order: 2;
}

.mp-board-area.black .mp-opponent {
  order: 3;
}




/* =========================
   LIVE MATCH ACTION BAR
========================= */

.mp-actions {
  display: flex;
  justify-content: center;
  gap: 14px;
  margin-top: 10px;
}

.mp-btn {
  min-width: 100px;
  padding: 8px 14px;
  border-radius: 8px;
  border: none;
  font-weight: bold;
  font-size: 14px;
  cursor: pointer;
  transition: 0.2s ease;
}

.mp-btn:hover {
  transform: translateY(-1px);
  opacity: 0.9;
}



.mp-btn.resign {
  background: #ef4444;
  color: white;
}

.mp-btn.rematch {
  background: #22c55e;
  color: #022c22;
}






/* ACTION BUTTON BAR */
.mp-actions {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}

.mp-btn {
  flex: 1;
  padding: 10px;
  border-radius: 10px;
  border: none;
  font-size: 14px;
  cursor: pointer;
  transition: transform 0.1s ease, opacity 0.1s ease;
}

.mp-btn:hover {
  transform: scale(1.03);
  opacity: 0.9;
}

/* BUTTON COLORS */
.mp-btn.flip {
  background: #334155;
  color: #e5e7eb;
}

.mp-btn.resign {
  background: #7f1d1d;
  color: white;
}

.mp-btn.rematch {
  background: #065f46;
  color: white;
}





.mp-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.mp-modal.hidden {
  display: none;
}

.mp-modal-box {
  background: #0f172a;
  color: white;
  padding: 20px;
  border-radius: 12px;
  min-width: 260px;
  text-align: center;
  box-shadow: 0 0 20px rgba(0,0,0,0.6);
}

.mp-modal-actions {
  margin-top: 15px;
  display: flex;
  gap: 10px;
  justify-content: center;
}

.mp-modal-actions button {
  padding: 8px 16px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
}

#mpAcceptBtn {
  background: #16a34a;
  color: white;
}

#mpDeclineBtn {
  background: #dc2626;
  color: white;
}

@media (min-width: 1024px) {
  .mp-opponent {
    margin-bottom: 24px;
  }

  .mp-you {
    margin-top: 24px;
  }
}

@media (max-width: 768px) {
    .mp-opponent {
    margin-bottom: 6px!important;
  }
  .mp-you {
    margin-top: 6px!important;
  }
}

@media (max-width: 768px) {
  #mpBoard {
    width: 100% !important;
    max-width: 90vw !important;
    height: 90vw !important;
    max-height: 500px !important;
    margin: 12px auto !important;
  }
}


/* ===============================
   FLOATING MODAL STYLE
================================ */

.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-overlay.hidden {
  display: none;
}

.modal-card {
  background: #0d1117;
  color: white;
  border-radius: 14px;
  padding: 20px;
  width: min(90vw, 320px);
  box-shadow: 0 0 25px rgba(0,200,255,0.4);
  animation: popIn 0.2s ease;
  text-align: center;
}

.modal-card h3 {
  margin: 0 0 10px;
  color: #00d9ff;
  font-size: 1.2rem;
}

.modal-card p {
  font-size: 1rem;
  opacity: 0.9;
}

.btn-success {
  margin-top: 15px;
  width: 100%;
  padding: 10px;
  border-radius: 10px;
  border: none;
  background: #00c853;
  color: black;
  font-weight: bold;
  cursor: pointer;
}

.btn-success:hover {
  background: #00e676;
}

@keyframes popIn {
  from { transform: scale(0.85); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}




.mp-btn.draw {
  background: #555;
  color: #fff;
}
.mp-btn.draw:hover {
  background: #777;
}


#mpRematchBtn,
#mpRematchModal {
  display: none !important;
}





.mp-howto {
  margin-left: 12px;
  font-size: 14px;
  color: #6cf;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 6px;
  background: rgba(0, 150, 255, 0.15);
  transition: 0.2s;
}

.mp-howto:hover {
  background: rgba(0, 150, 255, 0.3);
}

.mp-howto-modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  padding: 15px;
}

.mp-howto-box {
  background: #0f172a;
  border-radius: 14px;
  max-width: 420px;
  width: 100%;
  padding: 20px;
  color: #e5e7eb;
  box-shadow: 0 20px 40px rgba(0,0,0,0.6);
  animation: popIn 0.2s ease-out;
}

.mp-howto-box h3 {
  margin-top: 0;
  color: #38bdf8;
  text-align: center;
}

.mp-howto-box ul {
  padding-left: 18px;
}

.mp-howto-box li {
  margin-bottom: 8px;
  line-height: 1.4;
}

.mp-tip {
  text-align: center;
  font-size: 12px;
  opacity: 0.7;
  margin-top: 12px;
}

.hidden {
  display: none;
}

@keyframes popIn {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}


#mpBoard {
  position: relative;
}


.mp-subtabs {
display:flex;
gap:10px;
margin-bottom:10px;
}


.mp-subtab {
padding:6px 14px;
border-radius:8px;
border:none;
background:#222;
color:#fff;
cursor:pointer;
}


.mp-subtab.active {
background:#00ff88;
color:#000;
}


.mp-archive-grid {
display:grid;
grid-template-columns:repeat(auto-fill, minmax(160px,1fr));
gap:12px;
}


.mp-archive-card {
background:#111;
padding:8px;
border-radius:8px;
cursor:pointer;
}


.mp-archive-names {
font-size:12px;
text-align:center;
margin-top:4px;
}


.mp-replay-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.75);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

/* Main replay container */
.mp-replay-box {
  background: #000;
  padding: 12px;
  border-radius: 12px;
  width: min(92vw, 520px);   /* Big on desktop, fits mobile */
  max-height: 90vh;
  display: flex;
  flex-direction: column;
}

/* Header */
.mp-replay-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  color: white;
}

/* Board area */
#mpReplayBoard {
  width: 100%;
  aspect-ratio: 1 / 1;     /* Always square */
  margin: 0 auto;
}

/* Controls */
.mp-replay-controls {
  display: flex;
  justify-content: space-between;
  gap: 8px;
  margin-top: 10px;
}

/* Buttons */
.mp-replay-controls button {
  flex: 1;
  padding: 8px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
}






/* ===============================
 FLOATING CHAT UI
=============================== */

#chatBubble {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: #ffd700;
  color: #000;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 9999;
}

#chatWindow {
  position: fixed;
  bottom: 90px;
  right: 20px;
  width: 300px;
  height: 420px;
  background: #1c1f35;
  border-radius: 14px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
  z-index: 9999;
}

.chat-hidden {
  display: none;
}

#chatHeader {
  padding: 10px;
  background: #2a2d4a;
  display: flex;
  justify-content: space-between;
  cursor: move;
  border-radius: 14px 14px 0 0;
}

#chatTabs {
  display: flex;
}

.chat-tab {
  flex: 1;
  padding: 6px;
  background: none;
  border: none;
  color: #aaa;
  cursor: pointer;
}

.chat-tab.active {
  color: #ffd700;
  border-bottom: 2px solid #ffd700;
}

#chatContent {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

#chatMessages div {
  margin-bottom: 6px;
  font-size: 13px;
}

#chatInputBox {
  display: flex;
  padding: 6px;
  gap: 6px;
}

#chatInput {
  flex: 1;
  padding: 6px;
  border-radius: 6px;
  border: none;
}

#chatSend {
  background: #ffd700;
  border: none;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
}

#chatUsers div {
  padding: 6px;
  border-bottom: 1px solid #333;
  cursor: pointer;
}


#chatBubble {
  pointer-events: auto;
}


/* === CHAT SAFETY & MOBILE === */

#chatBubble {
  z-index: 100000 !important;
  touch-action: manipulation;
}

#chatWindow {
  z-index: 99999 !important;
  touch-action: none;
}

@media (max-width: 768px) {
  #chatWindow {
    width: 92vw;
    height: 60vh;
    right: 4vw;
    bottom: 80px;
  }
}



.chat-badge {
  position: absolute;
  top: -8px;
  right: -8px;

  background: #ff2d2d;
  color: #fff;

  font-size: 16px;        /* üî• bigger number */
  font-weight: 700;      /* üî• bold */

  min-width: 22px;       /* üî• wider */
  height: 22px;

  padding: 0 7px;
  border-radius: 11px;   /* perfect circle */

  display: flex;
  align-items: center;
  justify-content: center;

  line-height: 1;
  box-shadow: 0 0 0 2px #ffd700; /* üî• golden ring */
  pointer-events: none;
}


.hidden {
  display: none;
}

#chatBubble {
  position: fixed;
  bottom: 20px;
  right: 20px;
}

#chatBubble .chat-badge {
  top: 0;
  right: 0;
}




body {
  margin: 0;
  background: #0f1224;
  color: #fff;
  font-family: system-ui, sans-serif;
}

.pdf-container {
  padding: 14px;
}

.pdf-upload {
  border: 2px dashed #ffd700;
  padding: 16px;
  border-radius: 10px;
  text-align: center;
  cursor: pointer;
}

.pdf-upload input {
  display: none;
}

.board-thumbs {
  display: grid;
  grid-template-columns: repeat(auto-fill, 80px);
  gap: 12px;
  margin-top: 16px;
}

.board-thumb {
  width: 80px;
  height: 80px;
  border: 2px solid #333;
  border-radius: 6px;
  cursor: pointer;
  overflow: hidden;
}

.board-thumb img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Floating board */
.floating-board {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.75);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.floating-content {
  background: #151836;
  padding: 16px;
  border-radius: 12px;
  display: flex;
  gap: 16px;
}

.floating-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
}




/* ================================
   PDF ‚Üí PGN IFRAME FIX (ISOLATED)
================================ */
#analysis-pdf {
  width: 100%;
}

#analysis-pdf .pdf-board-frame {
  width: 100%;
  height: 600px;      /* adjust if needed */
  border: none;
  border-radius: 12px;
  background: #0f1224;
}



#analysis-pdf .pdf-board-frame {
  height: 100%;
  min-height: 600px;
}




@media (max-width: 768px) {
  .analysis-subtabs {
    display: none !important;
  }
}



/* =========================================
   ANALYSIS SUB TAB BUTTONS (BOARD / PDF)
========================================= */

.analysis-subtabs {
  display: flex;
  gap: 10px;
  margin-top: -17px;
}

/* Base button */
.analysis-subtab {
  display: inline-flex;
  align-items: center;
  gap: 6px;

  padding: 6px 12px;
  font-size: 13px;
  font-weight: 600;

  border-radius: 8px;
  border: 1px solid #2e325a;

  background: linear-gradient(180deg, #1c2042, #141733);
  color: #cfd6ff;

  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
}

/* Hover */
.analysis-subtab:hover {
  background: linear-gradient(180deg, #242a66, #1a1f4d);
  border-color: #f1c40f;
  color: #f1c40f;
}

/* Active tab */
.analysis-subtab.active {
  background: linear-gradient(180deg, #f1c40f, #d4aa00);
  color: #000;
  border-color: #f1c40f;
  box-shadow: 0 0 0 1px rgba(241,196,15,0.3);
}

/* Click feel */
.analysis-subtab:active {
  transform: scale(0.96);
}




.user-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.unread-badge {
  background: #25D366;
  color: #fff;
  border-radius: 12px;
  padding: 2px 8px;
  font-size: 12px;
  font-weight: bold;
  min-width: 20px;
  text-align: center;
  box-shadow: 0 0 6px rgba(37, 211, 102, 0.6);
}



/* Popup frame */
.leaderboard-popup {
  height: 80vh;              /* THIS is the key */
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}

/* Header + tabs fixed */
.leaderboard-header,
.leaderboard-tabs {
  flex-shrink: 0;
}

/* Body takes remaining space */
.leaderboard-body {
  flex: 1;
  display: flex;
  min-height: 0;           /* CRITICAL for scrolling in flex */
}

/* Scroll zone */
.lb-scroll {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  padding-right: 8px;
}

/* Panels */
.lb-panel {
  display: none;
}

.lb-panel.active {
  display: block;
}

/* Premium scrollbar */
.lb-scroll::-webkit-scrollbar {
  width: 8px;
}

.lb-scroll::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
}

.lb-scroll::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, #00f2ff, #0066ff);
  border-radius: 10px;
}

.lb-scroll::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(180deg, #00ffff, #0099ff);
}


.pawn-toggle-btn.active {
  background: #ffd700;
  color: #000;
}


/* ===============================
   STUDY NOTATION TOGGLE
================================ */
.study-notation.hidden {
  display: none !important;
}


#mainPawnToggleBtn.active {
  background: #ffd700;
  color: #000;
}





/* ===============================
   WHATSAPP STYLE PRIVATE CHAT
================================ */

.chat-msg-row {
  display: flex;
  margin: 6px 0;
}

.chat-msg-left {
  justify-content: flex-start;
}

.chat-msg-right {
  justify-content: flex-end;
}

.chat-bubble {
  max-width: 70%;
  padding: 8px 12px;
  border-radius: 12px;
  font-size: 14px;
  line-height: 1.4;
  word-wrap: break-word;
}

/* Other user */
.chat-bubble.other {
  background: #2a2f45;
  color: #fff;
  border-top-left-radius: 4px;
}

/* Mine */
.chat-bubble.mine {
  background: #1fa855;
  color: #fff;
  border-top-right-radius: 4px;
}





.mp-fenbox input {
  width: 100%;
  padding: 8px;
  border-radius: 6px;
  background: #111827;
  border: 1px solid #374151;
  color: white;
  margin-bottom: 8px;
  font-size: 13px;
}

.mp-fenbox button {
  width: 100%;
  background: #7c3aed;
  border: none;
  padding: 8px;
  border-radius: 6px;
  color: white;
  cursor: pointer;
}

.mp-fenbox button:hover {
  background: #6d28d9;
}




.move.active-main {
  background: #2563eb;
  color: white;
  border-radius: 6px;
  padding: 2px 6px;
}

.move.active-variation {
  background: #ca8a04;
  color: black;
  border-radius: 6px;
  padding: 2px 6px;
}



.study-search {
  width: 260px;
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #2a2f55;
  background: #10142a;
  color: #fff;
  outline: none;
}

.study-search::placeholder {
  color: #888;
}

.study-search:focus {
  border-color: #4fa3ff;
}


#studySelect {
  max-height: 240px;
  overflow-y: auto;
}

#studySelect::-webkit-scrollbar {
  width: 8px;
}

#studySelect::-webkit-scrollbar-track {
  background: #10142a;
  border-radius: 8px;
}

#studySelect::-webkit-scrollbar-thumb {
  background: #4fa3ff;
  border-radius: 8px;
}

#studySelect::-webkit-scrollbar-thumb:hover {
  background: #78b8ff;
}

.study-title {
  margin-left: 10px;
  font-size: 14px;
  color: #7dd3fc;
  font-weight: normal;
}



#study-section h2 {
  position: relative;
  display: flex;
  align-items: center;
  font-size: 20px;
  font-weight: 700;
  color: #e5e7eb;
  margin-bottom: 12px;
}

/* Keep üìò Study on the left */
#study-section h2 {
  justify-content: flex-start;
}

/* Center ONLY the study title */
.study-title {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);

  font-size: 24px;
  font-weight: 600;
  color: #7dd3fc;
  white-space: nowrap;
}


.study-row,
.study-layout,
.study-container {
  align-items: flex-start !important; /* üîí STOP vertical centering */
}



.assignments-header {
  display: flex;
  align-items: center;
  gap: 12px;
}

.assignments-search {
  width: 220px;
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid #2a2f55;
  background: #10142a;
  color: #fff;
  outline: none;
  font-size: 14px;
}

.assignments-search::placeholder {
  color: #888;
}

.assignments-search:focus {
  border-color: #4fa3ff;
}



/* ================================
   PUZZLE BATTLE ARENA
================================ */

.battle-card {
  max-width: 420px;
  margin: auto;
  background: #15182b;
  padding: 16px;
  border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
}

.battle-card h2 {
  text-align: center;
  margin-bottom: 12px;
}

/* ROOM CONTROLS */
.battle-section {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.battle-input {
  padding: 10px;
  border-radius: 8px;
  border: none;
  background: #0f1222;
  color: #fff;
  text-align: center;
  font-size: 16px;
  letter-spacing: 2px;
}

.battle-actions {
  display: flex;
  gap: 8px;
}

.battle-btn {
  flex: 1;
  padding: 10px;
  border-radius: 8px;
  border: none;
  background: #1f2340;
  color: #fff;
  cursor: pointer;
  transition: 0.2s;
}

.battle-btn:hover {
  background: #2b2f5a;
}

.battle-btn.primary {
  background: linear-gradient(135deg, #ff4d4d, #ff884d);
}

/* STATUS */
.battle-status {
  margin-top: 10px;
  text-align: center;
  font-size: 14px;
  color: #bbb;
}

/* HUD */
.battle-hud {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
}

.player-box {
  background: #0f1222;
  padding: 8px;
  border-radius: 8px;
  width: 40%;
  text-align: center;
}

.player-box h3 {
  margin: 0;
  font-size: 15px;
  color: #ffd966;
}

.stat {
  font-size: 18px;
  margin-top: 4px;
}

.vs-box {
  font-weight: bold;
  color: #ff5c5c;
}

/* TIMER */
.battle-timer {
  margin-top: 10px;
  text-align: center;
  font-size: 16px;
  color: #7dd3fc;
}

/* BOARD */
.battle-board-wrap {
  margin-top: 12px;
  display: flex;
  justify-content: center;
}

#battleBoard {
  width: 100%;
  max-width: 320px;
}

/* RESULT */
.battle-result {
  margin-top: 12px;
  padding: 10px;
  background: #0f1222;
  border-radius: 8px;
  text-align: center;
  font-size: 15px;
  color: #7cff7c;
}

.hidden {
  display: none;
}

/* MOBILE */
@media (max-width: 480px) {
  #battleBoard {
    max-width: 280px;
  }

  .battle-card {
    padding: 12px;
  }
}






/* =================================
   ‚öîÔ∏è PUZZLE BATTLE ARENA ‚Äî CLEAN LAYOUT
================================= */

/* MAIN LAYOUT */
.battle-layout {
  display: flex;
  justify-content: flex-start;
  align-items: flex-start;
  gap: 40px;
}

/* LEFT PANEL */
.battle-left-wrap {
  width: 360px;
  padding: 24px;
}

/* CENTER BOARD ZONE */
.battle-center-wrap {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding-top: 0;
}

/* CHESS BOARD ‚Äî SAME LEVEL AS CARD */
#puzzleBattleBoard {
  width: 100%;
  max-width: 430px;
  aspect-ratio: 1 / 1;
  margin-top: -400px; /* üî• FORCE SAME HEIGHT */
  border-radius: 12px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
}

/* MOBILE STACK */
@media (max-width: 900px) {
  .battle-layout {
    flex-direction: column;
    align-items: center;
  }

  .battle-left-wrap {
    width: 100%;
    max-width: 360px;
  }

  #puzzleBattleBoard {
    max-width: 320px;
  }
}


/* =========================================
   ‚öîÔ∏è PUZZLE BATTLE ‚Äî REAL MOBILE FIX
   Matches physical device viewport
   ========================================= */

@media (max-width: 768px) {

  /* Stack layout */
  #puzzlebattle-section .battle-layout {
    flex-direction: column;
    align-items: center;
  }

  /* Full width card */
  #puzzlebattle-section .battle-left-wrap {
    width: 100%;
    max-width: 100%;
    padding: 12px;
  }

  /* True center wrapper */
  #puzzlebattle-section .battle-center-wrap {
    width: 100%;
    display: flex;
    justify-content: center;
  }

  /* Board sizing ‚Äî device-safe math */
  #puzzlebattle-section #puzzleBattleBoard {
    width: clamp(260px, 88vmin, 340px);
    aspect-ratio: 1 / 1;
    margin: 12px auto 8px auto;
  }

  /* POV panel moves BELOW board */
  #battlePOVPanel {
    width: 100%;
    margin-top: 12px;
    display: flex;
    justify-content: space-between;
    gap: 8px;
  }

  .pov-card {
    flex: 1;
    min-width: 0;
  }
}



#battleLivesBar {
  display: flex;
  gap: 6px;
  margin-top: 8px;
}

.life {
  font-size: 28px;
  transform: scale(1);
  transition: transform 0.15s ease, opacity 0.15s ease;
}

/* üí• Pop then disappear */
.life.dead {
  transform: scale(1.4);
  opacity: 0;
}



/* RIGHT SIDE POV PANEL */
#battlePOVPanel {
  width: 260px;
  min-height: 360px;
  margin-left: 24px;
  padding: 16px;
  background: linear-gradient(180deg, #0f1225, #15182b);
  border-radius: 14px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  box-shadow: 0 0 25px rgba(255, 215, 0, 0.15);
}

.pov-card {
  padding: 16px;
  border-radius: 12px;
  text-align: center;
  background: rgba(255, 255, 255, 0.04);
  transition: 0.2s ease;
}

.pov-card.active {
  box-shadow: 0 0 20px rgba(0, 255, 150, 0.6);
  transform: scale(1.05);
}

.pov-card h3 {
  margin-bottom: 10px;
  color: gold;
}

.pov-stat {
  font-size: 18px;
  margin-bottom: 10px;
}

.pov-lives {
  font-size: 20px;
  letter-spacing: 6px;
}

.pov-divider {
  text-align: center;
  font-weight: bold;
  color: #888;
  margin: 12px 0;
}


/* DESKTOP POV POSITION TWEAK */
@media (min-width: 1024px) {
  #battlePOVPanel {
    position: absolute;
    right: 75px;     /* push to far right */
    top: 75px;     /* move upward */
    margin-left: 0;
  }

  .battle-layout {
    position: relative; /* anchor for absolute panel */
  }
}

/* HIDE POV PANEL ON MOBILE */
@media (max-width: 1023px) {
  #battlePOVPanel {
    display: none !important;
  }
}

/* Puzzle Battle board only */
#puzzleBattleBoard .square-55d63 {
  cursor: grab;
}

#puzzleBattleBoard .square-55d63:active {
  cursor: grabbing;
}


/* Battle tap highlight */
#puzzleBattleBoard .battle-selected {
  box-shadow: inset 0 0 0 3px gold;
}

















  </style>
</head>


<!-- Floating Drawing Toolbox -->
<div id="drawToolbox" class="draw-toolbox hidden">
 <div class="toolbox-header" id="toolboxHeader">
  <span id="toolboxTitle">‚úèÔ∏è Draw Tools</span>
</div>




  <div class="toolbox-body">
    <input type="color" id="drawColor" value="#ff0000">

    <select id="drawMode">
      <option value="pen">Free Draw</option>
      <option value="line">Line</option>
      <option value="arrow">Arrow</option>
      <option value="circle">Circle</option>
      <option value="cross">Cross</option>
      <option value="erase">Eraser</option>
    </select>

    <input type="range" id="drawSize" min="2" max="20" value="4">

    <button id="clearCanvas">Clear</button>
  </div>
</div>

<canvas id="drawCanvas"></canvas>
<canvas id="previewCanvas"></canvas>





<body>


<!-- üèÜ FIXED MINI GAME SCORES (LEFT) -->
<div class="mini-score-fixed">
  <div class="mini-score-panel">
    <h3>üèÜ My Best Scores</h3>
    <div id="miniScoreList">
      <p class="muted">Loading scores...</p>
    </div>
  </div>
</div>








  <!-- NAVBAR -->
  <div id="topNavbar" class="navbar">

    <div class="brand">
  <img src="favicons.png" alt="Olympus Chess Academy Logo" class="brand-logo">
  
</div>

<button id="mobileMenuBtn" class="mobile-menu-btn">‚ò∞</button>
 <button class="nav-btn" data-tab="livematch" id="navLiveMatch">
üî¥ LIVE
</button>
 <button class="nav-btn" data-tab="assignments">üìö Assignments</button>
 <button class="nav-btn" data-tab="puzzlerush">‚ö° Puzzle </button>
 <button class="nav-btn" data-tab="puzzlebattle">
  ‚öîÔ∏è Puzzle Battle
</button>

<button class="nav-btn" data-tab="quiz">‚öΩÔ∏è Quiz</button>
<button class="nav-btn" data-tab="computer">
  üéØ Play
</button>
<button class="nav-btn" data-tab="board">üî¨ Analysis</button>
 <button class="nav-btn" data-tab="gamereview">
  üíé Game Review
</button>
     <button class="nav-btn" data-tab="coordtrain">üìç Coordinates</button>
     

    <button class="nav-btn" data-tab="piecePractice">
  ü¶ñ Toy Hunt</button>
  
 

<button class="nav-btn" data-tab="memory">üß† IQ Hunt</button>
<button class="nav-btn" data-tab="boardfreeze">‚ùì Guess </button>
<button class="nav-btn" data-tab="color">üß™ Lab Hunt</button>
<button class="nav-btn" data-tab="knightfog">
  üçé Fog Quest
</button>
<button class="nav-btn" data-tab="knightdefense">
  üëë Defend The King
</button>
<button class="nav-btn" data-tab="knightpath">üê¥ Knight Path</button>
<button class="nav-btn" data-tab="knightmonster">üê¥ vs üëπ</button>
<button class="nav-btn" data-tab="knightescape">üè∞ Escape</button>
<button class="nav-btn" data-tab="knightspeed">üê¥ Speed Run</button>
<button class="nav-btn" data-tab="knightlava">üî• Lava Knight</button>
<button class="nav-btn" data-tab="knightgps">üß≠ Knight GPS</button>

<button class="nav-btn" data-tab="kingmath">
  üëë Chess Math
</button>
<button class="nav-btn" data-tab="colorchaos">üé® Rainbow </button>



<button class="nav-btn" data-tab="flashqueen">
   Find The üë∏
</button>
<button class="nav-btn" data-tab="pathfinder">üë∏ Reach Home</button>


<button class="nav-btn" data-tab="study">üìò Study</button>
 
    <button class="nav-btn" data-tab="editor">üß© Editor</button>

    <button class="nav-btn" data-tab="attempts" id="attemptsTab" style="display: none;">üìä HW</button>
    <button class="nav-btn" data-tab="students" id="adminTab" style="display: none;">üë®‚Äçüéì Admin</button>
    <div class="user-menu">
  <button id="userMenuBtn" class="user-info">
    <span id="userInfo">admin ‚Ä¢ admin</span> ‚öôÔ∏è
  </button>

  <div id="userDropdown" class="user-dropdown hidden">

    <!-- ‚ôü Piece Theme -->
    <div class="dropdown-section">
  <strong>‚ôü Piece Theme</strong>

  <button onclick="setPieceTheme('merida')">Merida</button>
  <button onclick="setPieceTheme('olympus-kiwen')">
   Thomas
</button>
<button onclick="setPieceTheme('evergreen')">
  Hunter
</button>



  <button onclick="setPieceTheme('alpha')">Alpha</button>
  <button onclick="setPieceTheme('cburnett')">Classic</button>
  <button onclick="setPieceTheme('pirouetti')">Pirouetti</button>
  <button onclick="setPieceTheme('chessnut')">Chessnut</button>
  <button onclick="setPieceTheme('pixel')">Pixel</button>
  
  <button onclick="setPieceTheme('cardinal')">Cardinal</button>
  
  <button onclick="setPieceTheme('fantasy')">Fantasy</button>
  <button onclick="setPieceTheme('spatial')">Spatial</button>
</div>


    

  </div>
</div>


    <button class="btn-logout" id="logoutBtn">Logout</button>
    
  </div>

  

  <!-- MAIN CONTENT -->
  <div class="container">


    


<!-- üèÜ OLYMPUS RATING BAR -->
<div class="rating-bar">
 


  <!-- LEFT -->
  <div class="rating-left">
     <span>Olympus Rating</span> 
  </div>
 <span class="leaderboard-trigger" id="leaderboardBtn">üèÜ Leaderboard üèÜ</span>
  <!-- CENTER -->
  <div class="rating-center">
  <span class="rating-elo">Elo</span>
  <span class="rating-delta" id="ratingDelta"></span>

  <span class="rating-main" id="olympusRating">1490</span>
  <span class="rating-tier" id="ratingTier">Rook</span>

  




  <!-- Progress grouped with rating -->
  <div class="rating-progress-wrap">
    <div class="rating-progress">
      <div class="rating-progress-fill" id="ratingProgressFill"></div>
    </div>
    <span class="rating-progress-text" id="ratingProgressText"></span>


    
    
  </div>

  <span class="rating-info-trigger" id="ratingInfoBtn">‚ùì</span>
 


<!-- Rating Info Popup -->
<div class="rating-info-popup" id="ratingInfoPopup">
  <div class="rating-info-header">
    üèÜ Olympus Rating Rules
    <span class="rating-info-close" id="ratingInfoClose">‚úï</span>
  </div>

  <div class="rating-info-body">
    <p><strong>Olympus Rating</strong> is calculated from 6 areas:</p>

    <ul>
  <li>‚ö° <strong>Puzzle Rush</strong><br>
    ‚Ä¢ Every run gives XP<br>
    ‚Ä¢ XP gained = ‚åäscore √∑ 2‚åã<br>
    ‚Ä¢ <2 Score = 0 XP <br>
    ‚Ä¢ Higher score = more XP
  </li>

    <li>‚öîÔ∏è <strong>Puzzle Battle</strong><br>
    ‚Ä¢ Every win grant 6XP!<br>
    ‚Ä¢ Time out grant XP<br>
    ‚Ä¢ Win more Battle to get XP! <br>
  </li>

  <li>üî¥ <strong>Live Match</strong><br>
    ‚Ä¢ Every win gives +6XP!<br>
    ‚Ä¢ Loose = 0 XP<br>
    ‚Ä¢ Draw = 0 XP <br>
    ‚Ä¢ Higher wins = More XP
  </li>

  <li>üéØ <strong>Quiz</strong><br>
    ‚Ä¢ Every attempt gives XP<br>
    ‚Ä¢ XP gained = ‚åäscore √∑ 2‚åã<br>
    ‚Ä¢ <2 Score = 0 XP <br>
    ‚Ä¢ Accuracy matters more than speed
  </li>

  <li>üéÆ <strong>Mini-Games</strong><br>
    ‚Ä¢ +1 XP for every attempt (effort reward)<br>
    ‚Ä¢ Bonus XP for improving high score<br>
    ‚Ä¢ Anti-farming protection enabled<br>
    ‚Ä¢ Excluded üê¥Vsüëπ to stop farming
  </li>

  <li>üß© <strong>Assignments</strong><br>
    ‚Ä¢ Completing all puzzles gives <strong>+5 XP</strong><br>
    ‚Ä¢ Reward is given only once per assignment
  </li>
</ul>


  üìä <strong>Rating Progress Bar</strong><br>
  ‚Ä¢ Shows how close you are to the <strong>next ELO</strong><br>
  ‚Ä¢ Example: <strong>60% to 1500</strong> means you are <br>
  60% close to reaching 1500 ELO<br>
  ‚Ä¢ <strong>Final Rating</strong> = ‚åäAverage / 10‚åã √ó 10
<br>
</p>

  </div>
</div>

</div>









  <!-- RIGHT -->
  <div class="rating-breakdown">
    <span>‚ö° Puzzle ‚Äì <strong id="puzzleRating">1280</strong></span>
    <span>üéØ Quiz ‚Äì <strong id="quizRating">980</strong></span>
    <span>üéÆ Game ‚Äì <strong id="gameRating">1150</strong></span>
  </div>

</div>

 
    

    <div class="section" id="live-section">
  <h2>üé• Live Classroom</h2>

  <div class="live-placeholder">
    <p><strong>Status:</strong>
      <span id="liveStatusText">No live class running</span>
    </p>
    <p>This area will host live puzzles, student presence and results.</p>
    <p style="opacity:0.6;">(Live logic coming next)</p>
  </div>

  <!-- Student join live class -->
<button
  id="joinLiveBtn"
  class="btn-success"
  style="display:none; margin-top:12px;"
>
  ‚ñ∂ Join Live Class
</button>
<!-- Student waiting panel -->
<div id="liveWaitingPanel" class="card" style="display:none; margin-top:12px;">
  <p>‚è≥ You have joined the live class.</p>
  <p style="opacity:0.8;">Waiting for the teacher to start activities‚Ä¶</p>
</div>


<!-- Live classroom admin student selector -->
<div id="liveStudentSelector" class="card" style="display:none; margin-top:16px;">
  <h3>üë• Select students for live class</h3>

  <div id="liveStudentsList" class="student-checklist">
    <!-- students will be injected here -->
     
  </div>

  <button id="confirmLiveStudentsBtn" class="btn-success" style="margin-top:12px;">
    Confirm & Start Live Class
  </button>
  <!-- Live joined students list (admin) -->
<div id="liveJoinedBox" style="display:none; margin-top:16px;">
  <h4>üü¢ Joined students</h4>
  <ul id="liveJoinedList"></ul>
</div>

</div>

<!-- Admin controls -->
<div id="liveAdminControls" style="display:none; margin-top:12px;">
  <button id="startLiveBtn" class="btn-success" style="display:none;">
  ‚ñ∂ Start Live Class
</button>

  <button id="endLiveBtn" class="btn-danger" style="display:none;">‚ñ† End Live Class</button>
</div>
</div>


<div class="section" id="study-section">
  
  <h2>
  üìò Study
  <span id="studyTitle" class="study-title"></span>
</h2>

  <input
  type="text"
  id="studySearchBox"
  placeholder="üîç Search PGN..."
  class="study-search"
/>


  <div class="study-layout">

    <!-- LEFT: Study Panel -->
    <div class="study-left">
      <div class="study-header">
  

  <div style="display:flex; gap:8px;">
    <button class="btn-secondary" id="importStudyBtn">
      + Import PGN
    </button>
    <select id="studySelect">
  <option value="">Study</option>
</select>

    

    <button class="btn-secondary" id="uploadStudyBtn">
      üìÇ Upload
    </button>
    
  </div>
  
</div>
<button
  id="pawnOnlyToggleBtn"
  class="btn-secondary pawn-toggle-btn"
  title="Toggle pawn structure view"
>
  ‚ôü King + Pawns
</button>
<button
  id="toggleStudyNotationBtn"
  class="btn-secondary"
  title="Toggle notation"
>
  üìùHide/Show Notation
</button>



      <div class="study-list" id="studyList">
        <div class="study-item active">
          ‚ñ∂ Sample Study
        </div>
        <div class="study-chapter">
          1. Introduction
        </div>
        <div class="study-chapter">
          2. Main Line
        </div>
      </div>
    </div>

    <!-- CENTER: Board -->
<div class="study-center">
  <div id="studyBoardWrapper" style="position: relative; width: 650px; height: 650px; margin: auto;">
    
    <div
      id="studyBoard"
      style="width: 650px; height: 650px;"
    ></div>

    <!-- DRAW LAYER -->
    <canvas id="studyDrawLayer"></canvas>

  
</div>


</div>


    <!-- RIGHT: Engine + Notation -->
    <div class="study-right">

      <div class="study-engine-box">

  <div class="engine-header">
    <span class="engine-title">
      Stockfish <span class="wasm-badge">WASM</span>
    </span>

    <button id="studyEngineToggle" class="engine-toggle off">
      OFF
    </button>
  </div>

  <div class="engine-stats">
    Eval: <span id="studyEval">--</span>
    &nbsp; | &nbsp;
    Depth: <span id="studyDepth">--</span>
  </div>

  <div id="studyPVLines" class="engine-lines"></div>

</div>



      <div class="study-notation">
        <strong>Notation</strong>
        <div class="notation-placeholder" id="studyNotation">
    Select a chapter to view moves
        </div>
      </div>

    </div>

  </div>
</div>


<div id="puzzlebattle-section" class="section battle-layout" style="display:none;">

  <!-- LEFT CARD -->
  <div class="battle-left-wrap">
    <div class="battle-card">
      <h2>‚öîÔ∏è Puzzle Battle Arena</h2>
      

      <div class="battle-section">
        <input
          id="battleRoomCode"
          class="battle-input"
          placeholder="Enter Room Code"
          maxlength="6"
        />

        <div class="battle-actions">
          <button id="createBattleRoom" class="battle-btn primary">
            Create Room
          </button>
          <button id="joinBattleRoom" class="battle-btn">
            Join Room
          </button>
        </div>
      </div>
      

      <div id="battleStatus" class="battle-status">
        Waiting for opponent...
      </div>

      <div class="battle-hud">
        <div class="player-box">
          <h3>You</h3>
          <div class="stat">Score: <span id="p1Score">0</span></div>
          <div class="stat">Lives: <span id="p1Lives">3</span></div>
        </div>

        <div class="vs-box">VS</div>

        <div class="player-box">
          <h3>Opponent</h3>
          <div class="stat">Score: <span id="p2Score">0</span></div>
          <div class="stat">Lives: <span id="p2Lives">3</span></div>
        </div>
      </div>

      <div class="battle-timer">
        ‚è± Time Left: <span id="battleTimer">03:00</span>
      </div>
    </div>
  </div>
  
  <!-- ‚ù§Ô∏è BATTLE LIVES BAR -->
<div id="battleLivesBar">
  <span class="life heart">‚ù§Ô∏è</span>
  <span class="life heart">‚ù§Ô∏è</span>
  <span class="life heart">‚ù§Ô∏è</span>

  <div id="battleResult" class="hidden">
    üèÜ <span id="battleWinnerText"></span>
  </div>
  
</div>


  <!-- CENTER BOARD -->
  <div class="battle-center-wrap">
    
    <div id="puzzleBattleBoard"></div>
    <!-- RIGHT POV PANEL -->
<div id="battlePOVPanel">

   <div class="pov-card opponent">
    
    <h3>ü§∫ Opponent</h3>
    <div class="pov-stat">
  ‚úÖ Correct: <span id="oppStreak">0</span>
</div>
    <div class="pov-lives" id="oppLives">
      ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è
    </div>
  </div>

  <div class="pov-divider">VS</div>
  <div class="pov-card you">
    <h3>üßë You</h3>
   <div class="pov-stat">
  ‚úÖ Correct: <span id="youStreak">0</span>
</div>
    <div class="pov-lives" id="youLives">
      ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è
    </div>
  </div>

 

</div>
    
  </div>



</div>






<div id="livematch-section" class="section mp-wrap" style="display:none;">

  <h2 class="mp-title">
    üî¥ Live Match
    <span id="mpHowToBtn" class="mp-howto">How to Play</span>
  </h2>

  <!-- SUB TABS -->
  <div class="mp-subtabs">
    <button id="mpTabLive" class="mp-subtab active">‚ôü Live</button>
    <button id="mpTabArchive" class="mp-subtab">üìö All Games</button>
  </div>

  <!-- ================= LIVE PANEL ================= -->
  <div id="mpLivePanel">

    <!-- HOW TO MODAL -->
    <div id="mpHowToModal" class="mp-howto-modal hidden">
      <div class="mp-howto-box">
        <h3>üéØ How to Play Live Match</h3>

        <ul>
          <li><b>Create Game:</b> Select your side & time, then click <b>Create Room</b></li>
          <li><b>Join Game:</b> Enter Room Code and click <b>Join</b></li>
          <li><b>Moves:</b> Drag or tap pieces to move</li>
          <li><b>Rematch:</b> Create new room only after the current game finish</li>
          <li><b>IMPORTANT!:</b> Create new room is not allowed while in live Game else app will crash</li>
          <li><b>Premove:</b> NO PREMOVE ALLOWED</li>
        </ul>

        <hr>

        <p>üèÜ <b>XP System</b></p>
        <ul>
          <li>Win ‚Üí <b>+6 XP</b></li>
          <li>Draw ‚Üí <b>+0 XP</b></li>
          <li>Loss ‚Üí <b>+0 XP</b></li>
        </ul>

        <p class="mp-tip">Tap anywhere outside to close</p>
      </div>
    </div>

    <!-- ================= MAIN LAYOUT ================= -->
    <div class="mp-layout">

      <!-- LEFT PANEL -->
      <div class="mp-controls">

        <div class="mp-card">
          <label class="mp-label">Side</label>
          <select id="mpSide">
            <option value="w">Play as White</option>
            <option value="b">Play as Black</option>
          </select>

          <label class="mp-label">Time Control</label>
          <select id="mpTime">
            <option value="60|0">1 min</option>
            <option value="120|0">2 min</option>
            <option value="180|0">3 min</option>
            <option value="300|0">5 min</option>
            <option value="600|0">10 min</option>
            <option value="900|0">15 min</option>
            <option value="1800|0">30 min</option>
          </select>

          <button id="mpCreateBtn">Create Room</button>
          <div id="mpRoomCode" class="mp-room"></div>

          <input id="mpJoinCode" placeholder="Enter Room Code">
          <button id="mpJoinBtn">Join</button>
          <!-- CUSTOM FEN BOX -->
<div class="mp-card mp-fenbox">
  <label class="mp-label">‚ôü Custom FEN</label>
  <input id="mpFenInput" placeholder="Paste FEN position here">
  <button id="mpFenCreateBtn">Create From FEN</button>
</div>

        </div>

        <!-- NOTATION -->
        <div class="mp-card mp-notation">
          <div class="mp-notation-header">
            <span>üìú Game Notation</span>
            <button id="mpCopyPGN">üìã Copy</button>
          </div>
          <div id="mpMoves"></div>
        </div>
      </div>

      <!-- BOARD PANEL -->
      <div class="mp-board-area">

        <!-- OPPONENT -->
        <div class="mp-player mp-opponent">
          <span id="mpOppName">Opponent</span>
          <span id="clockBlack" class="mp-clock">0:00</span>
        </div>

        <div id="mpBoard"></div>

        <div class="mp-actions">
          <button id="mpFlipBtn" class="mp-btn flip">üîÑ Flip</button>
          <button id="mpDrawBtn" class="mp-btn draw">ü§ù Draw</button>
          <button id="mpResignBtn" class="mp-btn resign">üè≥Ô∏è Resign</button>
          <button id="mpRematchBtn" class="mp-btn rematch">üîÅ Rematch</button>
        </div>

        <!-- YOU -->
        <div class="mp-player mp-you">
          <span id="mpYouName">You</span>
          <span id="clockWhite" class="mp-clock">0:00</span>
        </div>

      </div>
    </div>
  </div>

  <!-- ================= ARCHIVE PANEL ================= -->
  <div id="mpArchivePanel" style="display:none">
    <div id="mpArchiveGrid" class="mp-archive-grid"></div>
  </div>

  <!-- ================= REPLAY MODAL ================= -->
  <div id="mpReplayModal" class="mp-replay-modal hidden">
    <div class="mp-replay-box">

      <div class="mp-replay-header">
        <span id="mpReplayTitle">Game Replay</span>
        <button id="mpReplayClose">‚úñ</button>
      </div>

      <div id="mpReplayBoard"></div>

      <div class="mp-replay-controls">
        <button id="mpPrevMove">‚èÆ Prev</button>
        <button id="mpNextMove">Next ‚è≠</button>
        <button id="mpCopyReplayPGN">üìã Copy PGN</button>
      </div>

    </div>
  </div>

</div>










<div id="gamereview-section" class="section">

  <h2 style="margin-bottom:12px;">üìä Game Review (Early Access) TOCA_Beta 1.0</h2>

  <!-- PGN + LICHESS ROW -->
  <div class="game-review-box review-top-layout" style="
    display:flex;
    gap:20px;
    align-items:flex-start;
  ">

    <!-- LEFT: PGN INPUT -->
    <div style="flex:1; max-width:720px;">

      <label for="reviewPgn" style="display:block; margin-bottom:6px;">
        Paste PGN
      </label>

      <textarea
        id="reviewPgn"
        placeholder="Paste your full PGN here..."
        rows="8"
        style="
          width:100%;
          background:#0f1224;
          color:#fff;
          border:1px solid #2f335a;
          border-radius:10px;
          padding:12px;
          resize:vertical;
        "
      ></textarea>

      <br><br>

      <button
        id="startGameReview"
        style="
          padding:10px 18px;
          background:#f5c842;
          color:#000;
          border:none;
          border-radius:8px;
          font-weight:600;
          cursor:pointer;
        "
      >
        ‚ñ∂ Start Review
      </button>

    </div>

    <!-- RIGHT: LICHESS GAME LOADER (RED BOX AREA) -->
    <div id="lichessLoader" style="
      width:340px;
      background:#0f1224;
      border:1px solid #2f335a;
      border-radius:12px;
      padding:12px;
    ">

      <h3 style="margin-bottom:10px;">üíé Load from Lichess</h3>

      <input
        id="lichessUsername"
        placeholder="Lichess username"
        style="
          width:100%;
          padding:8px;
          border-radius:8px;
          border:1px solid #2f335a;
          background:#0b0e1a;
          color:#fff;
          margin-bottom:8px;
        "
      />


 


      <button
        id="fetchLichessGames"
        style="
          width:100%;
          padding:8px;
          background:#3b82f6;
          color:#fff;
          border:none;
          border-radius:8px;
          font-weight:600;
          cursor:pointer;
        "
      >
        Search Games
      </button>

      <div id="lichessGameList"
           style="
             margin-top:10px;
             max-height:280px;
             overflow-y:auto;
             font-size:14px;
           ">
      </div>

    </div>

  </div>

  <!-- ANALYSIS AREA -->
  <div id="gameReviewAnalysis" style="display:none; margin-top:20px;">

    <div style="display:flex; gap:20px; align-items:flex-start;">

      <!-- BOARD -->
      <div id="gameReviewBoard" style="width:380px;"></div>

      <!-- REVIEW PANEL -->
      <div id="gameReviewPanel" style="
        max-height:360px;
        overflow-y:auto;
        padding-right:6px;
      ">
        <h3 style="margin-bottom:8px;">Game Review</h3>
        <div id="gameReviewResults"></div>
      </div>

    </div>

  </div>

</div>

















<div class="section" id="editor-section">
  <h2>üß© Board Editor</h2>

  <div class="board-layout">
    <!-- Board -->
    <div class="board-wrapper">
      <div id="editorBoard"></div>
    </div>

    <!-- Controls -->
    <div class="side-panel">
      <h3>Editor Controls</h3>

      <button class="btn-secondary" id="editorStartPos">
        ‚ôü Starting Position
      </button>

      <button class="btn-secondary" id="editorClear">
        üóë Clear Board
      </button>

      <button class="btn-primary" id="editorApply">
        ‚ñ∂ Use in Analysis Board
      </button>

      <div class="editor-field">
  <label for="editorTurn">Side to move</label>
  <select id="editorTurn">
    <option value="w">White to move</option>
    <option value="b">Black to move</option>
  </select>
</div>


      <textarea
        id="editorFEN"
        rows="3"
        readonly
        placeholder="FEN will appear here"
      ></textarea>
      <button id="copyFenBtn" class="btn-copy-fen">
  üìã Copy FEN
</button>

<span id="fenCopyStatus" class="fen-copy-status hidden">
  ‚úî Copied
</span>
<div class="editor-field">
  <div class="editor-label">Castling rights</div>

  <div class="castling-row">
    <div class="side">White</div>
    <label class="castle-opt">
      <input type="checkbox" id="castleWK"> <span>O-O</span>
    </label>
    <label class="castle-opt">
      <input type="checkbox" id="castleWQ"> <span>O-O-O</span>
    </label>
  </div>

  <div class="castling-row">
    <div class="side">Black</div>
    <label class="castle-opt">
      <input type="checkbox" id="castleBK"> <span>O-O</span>
    </label>
    <label class="castle-opt">
      <input type="checkbox" id="castleBQ"> <span>O-O-O</span>
    </label>
  </div>
</div>




    </div>
  </div>
</div>




<!-- ü§ñ PLAY VS COMPUTER SECTION -->
<div class="section" id="computer-section">
  <h2>ü§ñ Play vs Olympus AI</h2>
  <div id="vsGameResult" class="vs-result hidden"></div>


  <!-- board + clock + controls will go here -->
<div class="card" style="margin-top:16px;">
  <div class="analysis-layout">

    <!-- ü§ñ BOT CHARACTER PANEL -->
<div class="bot-panel">
  <div class="bot-avatar">
    <img id="botImage" src="bots/max.png" alt="Olympus Bot" />

    <!-- üî¥ Fake mouth -->
    <div id="botMouth"></div>
  </div>

  <div class="bot-name" id="botName">Ares Blaster</div>

  <div class="bot-bubble hidden" id="botBubble">
    brr‚Ä¶ zzt‚Ä¶ ‚ôüÔ∏è
  </div>


  
<button id="resignBtn" class="btn-danger takeback-btn">
  üè≥Ô∏è Resign
</button>

  <!-- üîô TAKE BACK (INSIDE BOT PANEL) -->
  <button
    id="takeBackBtn"
    class="btn-secondary takeback-btn"
  >
    ‚¨Ö Take Back
  </button>
</div>





    <!-- ‚ôü BOARD -->
    <div class="board-column">
      <div id="computerBoard" class="chessboard"></div>

      <!-- CLOCKS -->
      <div class="player-bar clock-bar">
  <div class="player white active">
    ‚ôî You ‚Äî <span id="whiteClock">60:00</span>
  </div>
  <div class="player black">
    ü§ñ BOT ‚Äî <span id="blackClock">60:00</span>
  </div>
</div>

    </div>

    
    
    

    <!-- üéõ CONTROLS -->
    <div class="side-panel">

      <h3>üé® Choose Color</h3>
<select id="playerColor">
  <option value="white">White</option>
  <option value="black">Black</option>
  <option value="random">Random</option>
</select>


      <h3>ü§ñ Select your BOT</h3>
      <select id="engineSelect">
  
  <option value="ares">Ares Blaster</option>
  <option value="athena">OlyBot</option>
  
</select>


      <h3>üéØ Difficulty</h3>
<select id="engineLevel">
  <option value="600">üê£ Tiny Tot</option>
  <option value="900">üê• Beginner</option>
  <option value="1200">üê§ Rookie</option>
  <option value="1500">ü¶Å Champion</option>
  <option value="2000">üëë Master</option>
</select>




      <h3>‚åö Format</h3>
      <select id="timeControl">
  <option value="3600">Standard</option>
  
</select>


      <button class="btn-success" id="startVsComputer" style="margin-top:12px;">
        ‚ñ∂ Start Game
      </button>

      <button class="btn-secondary" id="resetVsComputer">
        üîÑ Reset
      </button>

    </div>
    

  </div>
</div>





</div>

<div class="section" id="puzzlerush-section">
  <h2>‚ö° Olympus Tactical Rush ‚ö°</h2>

  <!-- MODE SELECTION -->
  <div class="card" id="puzzleRushMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="rush3">‚è± 3 Min Rush</button>
      <button class="btn-primary" id="rush5">‚è± 5 Min Rush</button>
      <button class="btn-danger" id="survival">üî• Survival</button>
    </div>

    <!-- HOW TO PLAY -->
<div class="how-to-play">
  <h4>üß† How to Play</h4>

  <ul>
    <li>‚ôüÔ∏è Solve as many chess puzzles as you can</li>
    <li>‚è±Ô∏è Each correct move gives you a new puzzle instantly</li>
    <li>‚ùå Wrong move may cost a life or end the run</li>
    <li>üî• Build streaks by solving puzzles continuously</li>
    <li>üèÜ Challenge yourself to beat your best score</li>
    <li>Play more game to earn XP</li>
  </ul>

  <div class="mode-info">
    <span>‚è± 3 Min / 5 Min:</span> Solve max puzzles before time runs out  
    <br>
    <span>üî• Survival:</span> One mistake can end everything
  </div>
</div>


 
</div>


  


  <!-- GAME AREA -->
  <div class="card hidden" id="puzzleRushGame">
    <div class="analysis-layout">

      <!-- BOARD -->
      <div class="board-column">
        <div id="puzzleRushBoard"></div>

        <!-- STATUS BAR -->
        <div class="puzzle-hud">
  <div class="hud-item hud-timer">
    <span class="hud-icon">‚è±</span>
    <span id="prTimer">02:57</span>
  </div>

  <div class="hud-item hud-lives">
    <span class="hud-icon">‚ù§Ô∏è</span>
    <span id="prLives">3</span>
  </div>

  <div class="hud-item hud-streak">
    <span class="hud-icon">üî•</span>
    <span id="prScore">0</span>
  </div>
</div>


      </div>

      <!-- RIGHT PANEL -->
      <div class="side-panel">
        

        <button class="btn-secondary" id="exitPuzzleRush">
          ‚¨Ö Exit
        </button>
      </div>

    </div>
  </div>
</div>

<section id="memory-section" class="section hidden">
  <h2>üß† Memorise the squares</h2>

  <!-- MODE SELECTION -->
  <div class="card" id="memoryMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="mem3">‚è± 3 Min Rush</button>
      <button class="btn-primary" id="mem5">‚è± 5 Min Rush</button>
      <button class="btn-danger" id="memSurvival">üî• Survival</button>
    </div>
    <div class="how-to-play">
  <h4>üß† How to Play</h4>

  <ul>
    <li>üëÄ Watch carefully which squares light up</li>
    <li>üß† Memorise their positions quickly</li>
    <li>üëâ Click the correct squares after they disappear</li>
    <li>‚ùå Wrong square costs a life</li>
    <li>‚≠ê Correct answers increase your score</li>
    <li>Play more game to earn XP</li>
  </ul>

  <div class="mode-info">
    <span>‚è± 3 / 5 Min Rush:</span> Solve as many patterns as possible  
    <br>
    <span>üî• Survival:</span> One mistake can end the game
  </div>
</div>
  </div>
  <!-- HOW TO PLAY -->



  <!-- GAME AREA -->
  <div id="memoryGame" class="hidden">
    <div class="memory-top">
  <div class="timer">‚è± <span id="memoryTimer">0</span>s</div>
  <div class="lives">‚ù§Ô∏è <span id="memoryLives">3</span></div>
  <div class="score">‚≠ê <span id="memoryScore">0</span></div>
</div>


    <div id="memoryBoard" class="mini-board"></div>

    <button class="btn-secondary" id="memoryExit">‚èπ Exit</button>
  </div>
</section>


<section id="pathfinder-section" class="section hidden">
  <h2>üë∏ Help The Queen! </h2>

  <!-- ===== MODE MENU ===== -->
  <div class="card" id="pfMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="pfEasy">üü¢ Easy</button>
      <button class="btn-primary" id="pfMedium">üü° Medium</button>
      <button class="btn-danger" id="pfSurvival">üî• Hard</button>
    </div>
    <div class="how-to-play">
  <h4>üë∏ How to Play</h4>

  <ul>
    <li>üëë The Queen must reach the target square</li>
    <li>üß≠ Click the correct path squares</li>
    <li>‚ö†Ô∏è Avoid blocked or dangerous squares</li>
    <li>‚è±Ô∏è Solve before the timer runs out</li>
    <li>‚≠ê Each correct path increases difficulty</li>
    <li>Play more game to earn XP</li>
  </ul>

  <div class="mode-info">
    <span>üü¢ Easy:</span> More time, fewer obstacles  
    <br>
    <span>üü° Medium:</span> Faster & trickier paths  
    <br>
    <span>üî• Hard:</span> One mistake = game over
  </div>
</div>
  </div>

  <!-- HOW TO PLAY -->




  <!-- ===== GAME AREA ===== -->
  <div id="pfGame" class="hidden">
    <div class="memory-top pf-hud">
  <div class="hud-item timer">‚è± <span id="pfTimer">8</span>s</div>
  <div class="hud-item lives">‚ù§Ô∏è <span id="pfLives">3</span></div>
  <div class="hud-item score">‚≠ê <span id="pfScore">2</span></div>
</div>


    <div id="pfBoard" class="mini-board"></div>

    <button class="btn-secondary" id="pfExit">‚¨Ö Exit</button>
  </div>
</section>

<section id="flashqueen-section" class="section hidden">

  <!-- TITLE -->
  <h2>üë∏ Find the Queen!</h2>

  <!-- MODE MENU -->
  <div class="card" id="flashQueenMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="fqEasy">Easy</button>
      <button class="btn-primary" id="fqMedium">Medium</button>
      <button class="btn-danger" id="fqSurvival">üî• Survival</button>
    </div>
    <div class="how-to-play">
  <h4>üë∏ How to Play</h4>

  <ul>
    <li>üëÄ Watch carefully where the Queen appears</li>
    <li>üß† Memorise her square before she disappears</li>
    <li>üëâ Click the square where the Queen was</li>
    <li>‚ùå Wrong square costs a life</li>
    <li>‚≠ê Correct answers increase your score</li>
    <li>Play more game to earn XP</li>
  </ul>

  <div class="mode-info">
    <span>üü¢ Easy:</span> Slower speed, fewer squares  
    <br>
    <span>üü° Medium:</span> Faster & more confusing  
    <br>
    <span>üî• Survival:</span> One mistake can end the game
  </div>
</div>
  </div>
  <!-- HOW TO PLAY -->



  <!-- GAME AREA -->
  <div id="flashQueenGame" class="hidden">

    <div class="memory-top">
      <div>‚è± <span id="fqTimer">0</span>s</div>
      <div>‚ù§Ô∏è <span id="fqLives">3</span></div>
      <div>‚≠ê <span id="fqScore">0</span></div>
    </div>

    <h3 class="question">üë∏ Where is the Queen?</h3>

    <div id="flashQueenBoard" class="mini-board"></div>

    <button class="btn-secondary" id="fqExit">‚Üê Exit</button>
  </div>

</section>
<section id="knightpath-section" class="section hidden">
  <h2>üê¥ Knight Journey</h2>

  <!-- MODE MENU -->
  <div class="card kp-card" id="kpMenu">
  <h3>Select Mode</h3>

  <div class="kp-modes">
    <button class="kp-mode-btn kp-mode-easy" onclick="startKP('easy')">
      üü¢ Easy
    </button>

    <button class="kp-mode-btn kp-mode-medium" onclick="startKP('medium')">
      üü° Medium
    </button>

    <button class="kp-mode-btn kp-mode-hard" onclick="startKP('hard')">
      üî• Hard
    </button>
  </div>

  <div class="kp-how">
    <h4>üìò How to Play</h4>
    <ul>
      <li>üê¥ A knight appears on the board</li>
      <li>‚ú® Squares flash one by one</li>
      <li>üß† Remember the flashing path</li>
      <li>üëÜ Click the squares in correct order</li>
      <li>‚≠ê Each level adds one more move</li>
      <li>Play more game to earn XP</li>
    </ul>
  </div>
</div>


  <!-- GAME AREA -->
  <div id="kpGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Level: <span id="kpLevel">1</span></div>
      <div>‚ù§Ô∏è Lives: <span id="kpLives">3</span></div>
    </div>

    <div id="kpBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKP()">‚¨Ö Exit</button>
  </div>
</section>
</section>

<!-- =============================== -->
<!-- üß™ LAB MIXER (COLOR MEMORY GAME) -->
<!-- =============================== -->
<section id="color-section" class="section hidden">
  <h2>üß™ Lab Mixer</h2>

  <!-- MODE MENU -->
  <div class="card kp-card" id="lmMenu">
    <h3>Select Mode</h3>

    <div class="kp-modes">
      <button class="kp-mode-btn kp-mode-easy" onclick="startLabMixer('easy')">
        üü¢ Easy
      </button>

      <button class="kp-mode-btn kp-mode-medium" onclick="startLabMixer('medium')">
        üü° Medium
      </button>

      <button class="kp-mode-btn kp-mode-hard" onclick="startLabMixer('hard')">
        üî• Hard
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üé® Colored squares will flash</li>
        <li>üß† Remember the colors</li>
        <li>‚ùì A color will be asked</li>
        <li>üëÜ Click the correct square</li>
        <li>‚≠ê Each round adds difficulty</li>
        <li>Play more game to earn XP</li>
      </ul>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="lmGame" class="hidden">
    <div class="memory-top">
  <div class="lm-round">üß™ Round: <span id="lmRound">1</span></div>

</div>

<div class="lm-find-banner">
  üéØ FIND: <span id="lmTarget">BLUE</span>
</div>

<div id="lmBoard" class="mini-board"></div>


    <button class="btn-secondary" onclick="exitLabMixer()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightmonster-section" class="section hidden">
  <h2>üê¥üëπ Knight vs Monster</h2>

  <!-- MODE MENU -->
  <div class="card" id="kvmMenu">
    <h3>Select Mode</h3>

    <div class="kvm-modes">
  <button class="kvm-mode easy" onclick="startKVM('easy')">
    üü¢ Easy<br><span>1 Monster</span>
  </button>

  <button class="kvm-mode medium" onclick="startKVM('medium')">
    üü° Medium<br><span>2 Monsters</span>
  </button>

  <button class="kvm-mode hard" onclick="startKVM('hard')">
    üî• Hard<br><span>3 Monsters</span>
  </button>
</div>


    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ You control the knight</li>
        <li>üëπ Monsters chase you like a king</li>
        <li>üéØ Survive as many turns as possible</li>
        <li>üíÄ If a monster catches you ‚Äî game over</li>
        <li>Play more game to earn XP</li>
      </ul>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="kvmGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Turns: <span id="kvmTurns">0</span></div>
      <div>üëπ Monsters: <span id="kvmMonsterCount">1</span></div>
    </div>

    <div id="kvmBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKVM()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightescape-section" class="section hidden">
  <h2>üè∞ Knight Escape Maze</h2>

  <!-- MENU -->
  <div class="card" id="kemMenu">
    <h3>Select Mode</h3>

    <div class="kvm-modes">
      <button class="kvm-mode easy" onclick="startKEM('easy')">
        üü¢ Easy<br><span>Few Walls</span>
      </button>

      <button class="kvm-mode medium" onclick="startKEM('medium')">
        üü° Medium<br><span>More Walls</span>
      </button>

      <button class="kvm-mode hard" onclick="startKEM('hard')">
        üî• Hard<br><span>Maze Mode</span>
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ Move the knight legally</li>
        <li>üß± Walls block your path</li>
        <li>üëπ Watch out! they are coming for you!</li>
        <li>üèÅ Reach the exit to win</li>
        <li>Play more game to earn XP</li>
      </ul>
    </div>
  </div>

  <!-- GAME -->
  <div id="kemGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Moves: <span id="kemTurns">0</span></div>
      <div>üèÜ Level: <span id="kemLevel">1</span></div>
    </div>

    <div id="kemBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKEM()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightspeed-section" class="section hidden">
  <h2>üê¥ Knight Speed Run</h2>

  <!-- MENU -->
  <div class="card" id="ksrMenu">
    <h3>Speed Challenge</h3>
    <p>Collect as many ‚≠ê as possible before time runs out!</p>

    <div class="kvm-modes">
      <button class="kvm-mode easy" onclick="startKSR('easy')">
        üü¢ Easy<br><span>40 Seconds</span>
      </button>

      <button class="kvm-mode medium" onclick="startKSR('medium')">
        üü° Medium<br><span>30 Seconds</span>
      </button>

      <button class="kvm-mode hard" onclick="startKSR('hard')">
        üî• Hard<br><span>20 Seconds</span>
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ Move the knight legally</li>
        <li>‚≠ê Collect stars as fast as possible</li>
        <li>üí£ Watch Out for Bombs! </li>
        <li>‚è± Beat the timer</li>
        <li>üèÜ Higher score = better speed</li>
        <li>Play more game to earn XP</li>
      </ul>
    </div>
  </div>

  <!-- GAME -->
  <div id="ksrGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Score: <span id="ksrScore">0</span></div>
      <div>‚è± Time: <span id="ksrTime">30</span>s</div>
    </div>

    <div id="ksrBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKSR()">‚¨Ö Exit</button>
  </div>
</section>

<!-- ================================ -->
<!-- üî• KNIGHT LAVA FLOOR (ISOLATED) -->
<!-- ================================ -->
<section id="knightlava-section" class="section hidden">

  <h2>üî• Knight Lava Floor</h2>

  <!-- MENU -->
<div class="card klf-intro-card" id="klfMenu">

  <div class="klf-intro-left">
    <h3>üî• Survive the Lava</h3>

    <ul class="klf-rules">
      <li>üê¥ Move the knight using <b>legal moves</b></li>
      <li>üî• Lava spreads <b>after every move</b></li>
      <li>‚ò†Ô∏è Step on lava = <b>Game Over</b></li>
      <li>üèÜ Survive as long as you can</li>
      <li>Play more game to earn XP</li>
    </ul>

    <button class="btn-primary klf-start-btn" onclick="startKLF()">
      ‚ñ∂ Start Game
    </button>
  </div>

</div>


  <!-- GAME -->
  <div id="klfGame" class="hidden">

    <div class="memory-top">
      <div>‚è± Turns: <span id="klfTurns">0</span></div>
      <div>üî• Lava: <span id="klfLavaCount">0</span></div>
    </div>

    <div id="klfBoard" class="klf-board"></div>

    <button class="btn-secondary" onclick="exitKLF()">‚¨Ö Exit</button>
  </div>

</section>


<section id="knightfog-section" class="section hidden">
  <h2>üçé Knight Fog Quest</h2>

  <!-- ===================== -->
  <!-- MENU -->
  <!-- ===================== -->
  <div class="card" id="kfqMenu">
    <h3>Find the Hidden Apple!</h3>
    <p>
      Move the knight üê¥ on a 10√ó10 board.<br>
      The board is hidden by fog.<br>
      Find all üçé apples before time runs out!
    </p>

    <!-- SPEED CHALLENGE -->
    <div class="card" style="margin-top:14px;">
      <h3>‚è±Ô∏è Speed Challenge</h3>
      <p>Finish finding apples before the timer ends.</p>

      <div class="kfq-modes">
        <button class="kfq-mode easy" onclick="startKFQTimed(40)">
          üü¢ Easy<br><span>40 Seconds</span>
        </button>

        <button class="kfq-mode medium" onclick="startKFQTimed(30)">
          üü° Medium<br><span>30 Seconds</span>
        </button>

        <button class="kfq-mode hard" onclick="startKFQTimed(20)">
          üî• Hard<br><span>20 Seconds</span>
        </button>
      </div>
    </div>

    <!-- NORMAL MODE -->
    <button class="btn-primary" style="margin-top:12px;" onclick="startKFQ()">
      ‚ñ∂ Free Mode
    </button>
  </div>

  <!-- ===================== -->
  <!-- GAME -->
  <!-- ===================== -->
  <div id="kfqGame" class="hidden">
    <div class="memory-top">
      <div>üéØ Task: <span id="kfqTask">Find üçé</span></div>
      <div>‚≠ê Moves: <span id="kfqMoves">0</span></div>
      <div>üçé Found: <span id="kfqFound">0 / 8</span></div>

      <div>‚è± Time: <span id="kfqTime">0</span>s</div>
    </div>

    <div id="kfqBoard"></div>

    <button class="btn-secondary" onclick="exitKFQ()">‚¨Ö Exit</button>
  </div>
</section>




<section id="knightdefense-section" class="section hidden">
  <h2>üëëüõ°Ô∏è Defend the King </h2>

  <!-- MENU -->
  <div class="card" id="kndMenu">
    <h3>Protect the King!</h3>
    <p>
      üëë King is on <b>e1</b><br>
      
      üê¥ You control the knight<br>
      üëπ Monsters fall from the top!<br>
      Kill them before they reach the King.
    </p>

    <div class="knd-modes">
      <button class="knd-mode easy" onclick="startKND('easy')">
        üü¢ Easy<br><span>3 Monsters</span>
      </button>
      <button class="knd-mode medium" onclick="startKND('medium')">
        üü° Medium<br><span>4 Monsters</span>
      </button>
      <button class="knd-mode hard" onclick="startKND('hard')">
        üî• Hard<br><span>5 Monsters</span>
      </button>
    </div>
  </div>

  <!-- GAME -->
  <div id="kndGame" class="hidden">
    <div class="memory-top">
      <div>üëπ Left: <span id="kndLeft">0</span></div>
      <div>‚è± Time: <span id="kndTime">0</span>s</div>
    </div>

    <div id="kndBoard"></div>

    <button class="btn-secondary" onclick="exitKND()">‚¨Ö Exit</button>
  </div>
</section>



<!-- ================================ -->
<!-- üëë MATH JOURNEY (ISOLATED GAME) -->
<!-- ================================ -->

<section id="kingmath-section" class="section hidden">

  <h2>üëë Chess Math Journey</h2>

  <!-- MENU -->
  <div class="card" id="kmMenu">
    <h3>Select Level</h3>

    <div class="kvm-modes">
      <button class="kvm-mode easy" onclick="startKM('easy')">
        üü¢ Easy
      </button>

      <button class="kvm-mode medium" onclick="startKM('medium')">
        üü° Medium
      </button>

      <button class="kvm-mode hard" onclick="startKM('hard')">
        üî• Hard
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üëë King starts from last rank</li>
        <li> üü¢ Easy = 40 Sec/ üü° Medium = 60 Sec/ üî• Hard = 90 Sec/</li>
        <li>‚ûï Solve the math shown above</li>
        <li>‚¨Ü Choose one of the next 3 squares</li>
        <li>üö© Complete the all the questions within time</li>
        <li>‚ùå Wrong answer = Game Over</li>
        <li>Play more game to earn XP</li>
      </ul>
    </div>
  </div>

  <!-- GAME -->
  <div id="kmGame" class="hidden">

    <div class="memory-top">
      <div>üß† Solve: <span id="kmQuestion">?</span></div>
      <div>‚¨Ü Steps: <span id="kmStep">0</span></div>
    </div>
    <div id="kmTimer" class="km-timer">
  ‚è± Time: <span id="kmTime">90</span>s
</div>



    <div id="kmBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKM()">‚¨Ö Exit</button>
  </div>

</section>


<section id="colorchaos-section" class="section hidden">
  <h2>üé®‚ö° Rainbow Showdwon</h2>

  <!-- MODE MENU -->
  <div class="card cfc-card" id="cfcMenu">
    <h3>Select Mode</h3>

    <div class="cfc-modes">
      <button class="cfc-mode-btn cfc-mode-easy" onclick="startCFC('easy')">
        üü¢ Easy
      </button>

      <button class="cfc-mode-btn cfc-mode-medium" onclick="startCFC('medium')">
        üü° Medium
      </button>

      <button class="cfc-mode-btn cfc-mode-hard" onclick="startCFC('hard')">
        üî• Hard
      </button>
    </div>

    <div class="cfc-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ Control the knight using legal moves</li>
        <li>üé® Board colors change automatically</li>
        <li>‚ö™ Land on WHITE squares</li>
        <li>‚è± Finish before time runs out</li>
        <li>‚≠ê Difficulty only changes available time</li>
        <li>Play more game to earn XP</li>
      </ul>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="cfcGame" class="hidden">
    <div class="memory-top">
      <div>‚ö™ Score: <span id="cfcScore">0</span></div>
      <div>üéØ Target: <span id="cfcTarget">5</span></div>
      <div>‚è± Time: <span id="cfcTime">20</span>s</div>
    </div>

    <!-- BOARD -->
    <div class="cfc-board-wrapper">
  <!-- RANK LABELS -->
  <div class="cfc-ranks">
    <span>8</span>
    <span>7</span>
    <span>6</span>
    <span>5</span>
    <span>4</span>
    <span>3</span>
    <span>2</span>
    <span>1</span>
  </div>

  <!-- BOARD -->
  <div id="cfcBoard" class="mini-board board-8"></div>

  <!-- FILE LABELS -->
  <div class="cfc-files">
    <span>a</span>
    <span>b</span>
    <span>c</span>
    <span>d</span>
    <span>e</span>
    <span>f</span>
    <span>g</span>
    <span>h</span>
  </div>
</div>


    <button class="btn-secondary" onclick="exitCFC()">‚¨Ö Exit</button>
  </div>
</section>

<section id="coordtrain-section" class="section hidden">
  <h2>üìç Board Coordinate Training</h2>

  <!-- MENU -->
  <div class="card" id="ctMenu">
    <h3>Find the Square!</h3>
    <p>
      A square name will flash briefly.<br />
      Click the correct square on the board.
    </p>

    <button class="btn-primary" onclick="startCT()">‚ñ∂ Start</button>
  </div>

  <!-- GAME -->
  <div id="ctGame" class="hidden">
    <div class="memory-top">
      <div>üéØ Target: <span id="ctTarget">e4</span></div>
      <div>‚≠ê Score: <span id="ctScore">0</span></div>
      <div>‚ùå Miss: <span id="ctMiss">0</span></div>
    </div>
    <div style="margin-bottom: 10px; text-align: center;">
  <button class="btn-secondary" id="ctToggleCoords" onclick="toggleCTCoords()">
    üëÅ Hide Files & Ranks
  </button>
</div>


    <div class="cfc-board-wrapper">
      
      <!-- RANKS -->
      <div class="cfc-ranks">
        <span>8</span><span>7</span><span>6</span><span>5</span>
        <span>4</span><span>3</span><span>2</span><span>1</span>
      </div>

      <!-- BOARD -->
      <div id="ctBoard" class="mini-board board-8"></div>

      <!-- FILES -->
      <div class="cfc-files">
        <span>a</span><span>b</span><span>c</span><span>d</span>
        <span>e</span><span>f</span><span>g</span><span>h</span>
      </div>
    </div>

    <button class="btn-secondary" onclick="exitCT()">‚¨Ö Exit</button>
  </div>
</section>

<section id="boardfreeze-section" class="section hidden">
  <h2>üéØ Guess Materials</h2>

  <!-- MENU -->
  <div class="card" id="bfMenu">
    <h3>Snapshot Challenge</h3>
    <p>
      Board flashes for 5 seconds.<br>
      Remember & answer the question.
    </p>

    <button class="btn-primary" onclick="startBF()">‚ñ∂ Start</button>
  </div>

  <!-- GAME -->
  <div id="bfGame" class="hidden">

    <div class="memory-top">
      <div>‚ùì Question: <span id="bfQuestion">‚Äì</span></div>
      <div>‚≠ê Score: <span id="bfScore">0</span></div>
    </div>

    <div class="bf-board-wrapper">

  <!-- RANKS -->
  <div class="bf-ranks">
    <span>8</span><span>7</span><span>6</span><span>5</span>
    <span>4</span><span>3</span><span>2</span><span>1</span>
  </div>

  <!-- BOARD -->
  <div id="bfBoard"></div>

  <!-- FILES -->
  <div class="bf-files">
    <span>a</span><span>b</span><span>c</span><span>d</span>
    <span>e</span><span>f</span><span>g</span><span>h</span>
  </div>

</div>


    <div style="margin-top:16px; text-align:center;">
      <button class="btn-secondary" onclick="bfMinus()">‚àí</button>
      <span id="bfAnswer" style="font-size:24px; margin:0 16px;">0</span>
      <button class="btn-secondary" onclick="bfPlus()">+</button>
    </div>

    <div style="margin-top:12px; text-align:center;">
      <button class="btn-primary" onclick="bfSubmit()">Submit</button>
    </div>

    <button class="btn-secondary" style="margin-top:14px;" onclick="exitBF()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightgps-section" class="section hidden">
  <h2>üß≠ Knight GPS</h2>

  <!-- MENU -->
  <div class="card" id="kgMenu">
    <h3>Reach the Target</h3>
    <p>
      Move the knight using legal moves.<br>
      Barriers block your path.<br>
      Reach üéØ using minimum fuel ‚õΩ
    </p>

    <button class="btn-primary" onclick="startKG()">‚ñ∂ Start</button>
  </div>

  <!-- GAME -->
  <div id="kgGame" class="hidden">

    <div class="memory-top">
      <div>‚õΩ Fuel: <span id="kgFuel">10</span></div>
      <div>üéØ Target: <span id="kgTarget">‚Äì</span></div>
    </div>

    <div class="kg-center">
  <div class="kg-board-grid">

    <!-- RANKS -->
    <div class="kg-ranks">
      <span>8</span><span>7</span><span>6</span><span>5</span>
      <span>4</span><span>3</span><span>2</span><span>1</span>
    </div>

    <!-- BOARD -->
    <div id="kgBoard"></div>

  </div>

  <!-- FILES -->
  <div class="kg-files">
    <span>a</span><span>b</span><span>c</span><span>d</span>
    <span>e</span><span>f</span><span>g</span><span>h</span>
  </div>
</div>


    <button class="btn-secondary" style="margin-top:14px;" onclick="exitKG()">‚¨Ö Exit</button>
  </div>
</section>

















<!-- ========================= -->
<!-- ‚ôüÔ∏è PIECE PRACTICE TAB -->
<!-- ========================= -->
<div class="section hidden" id="piecePractice-section">

  <h2>ü¶ñ Hunt Doddles</h2>

  <div class="card">
    <div class="mini-games-row">

      <!-- ‚ö° Knight -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôò Knight Hunter</span>
        </div>
        <div id="miniBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="stars">0</span></div>
          <div class="misses">‚ùå <span id="knightMisses">0</span></div>
          <button id="startMiniGame">New</button>
        </div>
      </div>

      <!-- ‚ôó Bishop -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôó Bishop Hunter</span>
        </div>
        <div id="bishopBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="bishopStars">0</span></div>
          <div class="misses">‚ùå <span id="bishopMisses">0</span></div>
          <button id="bishopStart">New</button>
        </div>
      </div>

      <!-- ‚ôñ Rook -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôñ Rook Hunter</span>
        </div>
        <div id="rookBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="rookStars">0</span></div>
          <div class="misses">‚ùå <span id="rookMisses">0</span></div>
          <button id="rookStart">New</button>
        </div>
      </div>

      <!-- üëë Queen -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôõ Queen Hunter</span>
        </div>
        <div id="queenBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="queenStars">0</span></div>
          <div class="misses">‚ùå <span id="queenMisses">0</span></div>
          <button id="queenStart">New</button>
        </div>
      </div>
      <!-- ‚ôô Pawn -->
<div class="mini-game">
  <div class="mini-header">
    <span class="mini-title">‚ôô Pawn Hunter</span>
  </div>

  <div id="pawnBoard" class="practice-board"></div>


  <div class="mini-footer">
    <div class="stars">‚≠ê <span id="pawnStars">0</span></div>
    <div class="misses">‚ùå <span id="pawnMisses">0</span></div>
    <button id="pawnStart">New</button>
  </div>
</div>
<!-- üëë King -->
<div class="mini-game">
  <div class="mini-header">
    <span class="mini-title">‚ôö King Hunter</span>
  </div>

  <div id="kingBoard" class="practice-board"></div>


  <div class="mini-footer">
    <div class="stars">‚≠ê <span id="kingStars">0</span></div>
    <div class="misses">‚ùå <span id="kingMisses">0</span></div>
    <button id="kingStart">New</button>
  </div>
</div>



    </div>
  </div>

</div>





<section id="quiz-section" class="section">
    <div id="quizRushScreen" class="quiz-rush">

      <div class="quiz-top">
        <div class="quiz-timer">‚è± <span id="quizTimer">60</span>s</div>
        <div class="quiz-score">Score: <span id="quizScore">0</span></div>
      </div>

      <div class="quiz-title">‚ôüÔ∏è Find the best move</div>

      <div id="quizBoardWrapper">
        <div id="quizBoard"></div>
      </div>

      <div class="quiz-options">
        <button class="quiz-option" data-index="0">Option A</button>
        <button class="quiz-option" data-index="1">Option B</button>
        <button class="quiz-option" data-index="2">Option C</button>
        <button class="quiz-option" data-index="3">Option D</button>
      </div>

    </div>
  </section>




    <!-- CHESS BOARD SECTION -->
    <div class="section active" id="board-section">
      <div id="mobileEngineSlot"></div>
      <div id="mobileEngineActionSlot"></div>

      <div class="analysis-header">
        
  <h2>‚ôüÔ∏è Analysis Board</h2>
  <!-- ============================= -->
<!-- üìÑ PDF TO PGN SUB TAB -->
<!-- ============================= -->

<div class="analysis-subtabs">
  <button class="analysis-subtab active" data-tab="analysis-main">
    ‚ôü Board
  </button>
  <button class="analysis-subtab" data-tab="analysis-pdf">
    üìÑ PDF ‚Üí PGN
  </button>
<button
  id="mainPawnToggleBtn"
  class="analysis-subtab btn-secondary"
  title="Show only Kings and Pawns"
>
  ‚ôü King + Pawns
</button>


</div>

<div id="analysis-pdf" class="analysis-subtab-panel hidden">
<iframe
  src="analysis-pdf/pdf-board.html"
  class="pdf-board-frame"
  loading="lazy">
</iframe>

</div>




  

  <!-- üîó LICHESS QUICK FETCH BOX -->
  <div class="lichess-fetch-wrapper">
  <input
    type="text"
    id="analysisLichessUsername"
    placeholder="Lichess username"
    autocomplete="off"
  />

  <button id="analysisFetchLichessBtn">Search</button>

  <!-- üîΩ Floating dropdown -->
  <div id="analysisGameDropdown" class="lichess-dropdown hidden">
    <div id="analysisGameList"></div>
  </div>
</div>

<button id="analysisLoadGameBtn" class="hidden">Load</button>


<div id="lichessInfo" class="lichess-info hidden">
  <div><strong>Rating:</strong> <span id="lichessRating">‚Äì</span></div>
  <div><strong>Date:</strong> <span id="lichessDate">‚Äì</span></div>
  <div><strong>Result:</strong> <span id="lichessResult">‚Äì</span></div>
</div>
  </div>



      <div id="gameStatus" class="status-indicator" style="display: none;"></div>
      <div id="timerDisplay" class="timer" style="display: none;">
        ‚è±Ô∏è Time: <span id="timer">00:00</span>
      </div>

      <div class="board-layout">
        
        <!-- Board (left) -->
        <div class="board-wrapper">
          <div id="chessboard"></div>

          <button
  class="btn-success"
  onclick="submitSolution()"
  id="submitBtn"
  hidden
>
Submit solution</button>
          
          
          <!-- Player names under board -->
<div class="player-bar">
    <div id="whitePlayer" class="player white">
      ‚ôö White: <span></span>
    </div>
    <div id="blackPlayer" class="player black">
      ‚ôî Black: <span></span>
    </div>
  </div>
  <div id="bulkNav" class="bulk-bar">
  <button onclick="goToPrevBulkPuzzle()">‚¨Ö Prev</button>
  <span id="bulkIndicator">Puzzle 1 / 1</span>
  <button onclick="goToNextBulkPuzzle()">Next ‚û°</button>
  
<div id="mobilePgnMount"></div>

</div>








          <!-- Fixed SVG overlay -->
          <svg id="boardOverlay"></svg>
          
        </div>
        <div id="notationPanel" class="card" aria-live="polite">
          <h4>Notation</h4>
          <div id="notationList" style="max-height:420px; overflow:auto; font-family:ui-monospace;"></div>
        </div>

        <!-- Side panel (right) -->
        <div id="sidePanel" class="side-panel">
          

          <!-- Controls -->
          <div class="control-grid">
            <button class="btn-primary" onclick="resetBoard()">Reset board (R)</button>
            <button class="btn-secondary" onclick="copyPGN()">Copy PGN (P)</button>
            

            <button class="btn-secondary" onclick="flipBoard()">Flip board (F)</button>
            
            <button class="btn-success" onclick="savePosition()">Save Database (S)</button>
            
            
<div id="enginePanel" class="engine-panel">

  <!-- üî• ONE SINGLE HEADER BAR -->
  <div class="engine-bar">
    <span class="engine-title">
   Stockfish <span class="wasm-badge">WASM</span>
</span>


    <span class="engine-stat">
      Eval: <span id="engineEval">‚Äì</span>
    </span>

    <span class="engine-stat">
      Depth: <span id="engineDepth">‚Äì</span>
    </span>
  </div>

  <!-- üîΩ FREE SPACE FOR MULTI ENGINE LINES -->
  <div class="engine-body" id="engineLines">
  <div class="engine-line" id="engineLine1">üî∑</div>
  <div class="engine-line" id="engineLine2">üî∑</div>
  <div class="engine-line" id="engineLine3">üî∑</div>
</div>


    <!-- future -->
    <!-- <div class="engine-line">PV1: ‚Ä¶</div> -->
    <!-- <div class="engine-line">PV2: ‚Ä¶</div> -->
  

</div>








          </div>
          

          <!-- Add this in the side panel after the control-grid div -->

          
          

          <!-- Move input + keypad -->
          

          

          
          
          <!-- PGN viewer + navigation -->
          <div id="pgnContainer" class="hidden" aria-hidden="true">
            <h3>Game PGN</h3>
            <div class="pgn-viewer" id="pgnViewer">No moves yet</div>
            <div style="margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap;">
              <button class="btn-secondary" onclick="copyPGN()">Copy PGN (P)</button>
              
            </div>
            <div id="assignmentModeContainer" style="display:none;">
    <h3>Assignment Loaded successfully</h3>
    <p>Play the correct move in the given position.</p>
</div>

          </div>
          <button
  id="analyzeBtn"
  class="btn-secondary"
  style="margin-top:8px;"
>
  üü¢ Start Analysis
</button>

          <!-- Admin-only PGN / FEN load -->
          <div id="pgnUploadSection" style="display: none;">
            
            <textarea id="pgnInput" placeholder="Paste PGN (e.g., 1. e4 e5 2. Nf3 Nc6)"></textarea>
            <div class="form-row">
              <button class="btn-success" onclick="loadPGN()">Load PGN</button>
            </div>
            
            <input id="fenInput" type="text" placeholder="Paste FEN (optional)" />
            <div class="form-row">
              <button class="btn-secondary" onclick="loadFEN()">Load FEN</button>
            </div>
            

            <div id="pgnNavButtons" style="margin-top:12px; display:flex; gap:8px; flex-wrap:nowrap;">
              <button id="btnFirst" class="btn-secondary" onclick="pgnFirstMove()">‚èÆÔ∏è First (Home)</button>
              <button id="btnPrev" class="btn-secondary" onclick="pgnPrevMove()">‚óÄÔ∏è Prev (‚Üê)</button>
              <button id="btnNext" class="btn-secondary" onclick="pgnNextMove()">Next ‚ñ∂Ô∏è (‚Üí)</button>
              <button id="btnLast" class="btn-secondary" onclick="pgnLastMove()">Last ‚è≠Ô∏è (End)</button>
              
              
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ASSIGNMENTS -->
    <div class="section" id="assignments-section">
      <div class="assignments-header">
  <h2>üìã Assignments</h2>

  <input
    type="text"
    id="assignmentsSearchBox"
    placeholder="üîç Search assignments..."
    class="assignments-search"
  />
</div>

      <div class="assignments-layout" aria-live="polite">
        <div id="assignmentsList" class="assignments-list loading" role="region" aria-label="Assignments list">
          Loading assignments...
        </div>
        <div class="assignments-form" aria-label="Create assignment form">
          <div id="createAssignmentForm" style="display: none;">
            <!-- Assign to specific students (Admin only) -->
<div class="form-row" id="assignStudentsRow" style="display:none;">
  

  <div id="assignStudentsBox"
       style="
         border:1px solid #444;
         border-radius:8px;
         padding:10px;
         max-height:160px;
         overflow-y:auto;
         background:#0f1224;
       ">
    <!-- student checkboxes will be injected here -->
  </div>

  
</div>

<div class="assign-actions" style="
  display:flex;
  gap:8px;
  justify-content:flex-end;
  margin-top:8px;   /* üî• reduced */
">

  <button type="button" class="btn-small" onclick="selectAllStudents()">Select all</button>
  <button type="button" class="btn-small danger" onclick="clearAllStudents()">Clear all</button>
</div>



            <h3>‚ûï Create new assignment</h3>
            <div class="form-row">
              <input type="text" id="assignTitle" placeholder="Assignment title">
              <select id="assignType">
                <option value="tactics">Tactics puzzle</option>
                <option value="endgame">Endgame study</option>
                <option value="opening">Opening practice</option>
                <option value="analysis">Position analysis</option>
                
              </select>
            </div>
            <textarea id="assignDesc" placeholder="Description and instructions..."></textarea>
            <div class="form-row">
              <input type="datetime-local" id="assignDue">
              <input type="text" id="assignFEN" placeholder="Starting FEN (optional)">
            </div>
            <div class="form-row">
              

<textarea
  id="assignPGN"
  placeholder="Paste PGN here or import from file"
  rows="6"
></textarea>

<!-- PGN Import -->
<input
  type="file"
  id="pgnFileInput"
  accept=".pgn"
  style="display:none;"
>

<button
  type="button"
  id="importPgnBtn"
  class="btn-secondary"
  style="margin-top:8px;"
>
  üìÇ Import PGN from computer
</button>

            </div>
            <div class="create-actions">
              <button class="btn-success" onclick="createAssignment()">Create assignment</button>
              <button class="clear-filters-btn" id="clearAssignmentFormBtn" type="button">Clear</button>
            </div>
            
          </div>
          <!-- ================= STUDENT BADGES (STEP 1: EMPTY) ================= -->
<div class="card" id="studentBadgePanel" aria-label="Student Badges">
  <h3>üèÖ Achievements</h3>

  <div id="studentBadgeContent">
    



  </div>
</div>

        </div>
        
        <!-- ================= STUDENT PROGRESS (STUDENT ONLY) ================= -->
<div class="card" id="studentProgressCard">
  <h3>üìä My Assignment History</h3>

  <div id="studentProgressList">
    <p class="muted">
      Your assignment history will appear here.
    </p>
  </div>
</div>

         <!-- ================= RIGHT COLUMN : PGN LIBRARY ================= -->
<div class="card" id="pgnLibraryCard" aria-label="PGN Library">


  <h3>üì¶ PGN Database</h3>

  <!-- Hidden file input -->
  <input
    type="file"
    id="pgnLibraryFileInput"
    accept=".pgn"
    style="display:none"
  />

  <!-- Import button -->
  <button
    class="btn-secondary"
    style="margin-top:10px;"
    onclick="document.getElementById('pgnLibraryFileInput').click()"
  >
    üìÇ Import PGN to Database
  </button>

  <!-- üî• THIS WAS MISSING -->
  <div id="pgnLibraryList">

    <!-- PGNs will render here -->
  </div>

</div>



  </div>

      </div>
    </div>
    

    <!-- ADMIN PANEL -->
    <div class="section" id="students-section">
      <div id="adminContent">
        <h2>üîê Admin panel</h2>
        
        <div class="admin-layout">
          <div class="admin-table" aria-label="Current students">
            <h3>üìã Current students</h3>
            <table>
              <thead>
                <tr>
                  <th style="width:40px;"><input type="checkbox" id="selectAllStudents"></th>
                  <th>Username</th>
                  <th>Status</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="studentsTable">
                <tr><td colspan="4" class="loading">Loading students...</td></tr>
              </tbody>
            </table>
          </div>
          <div class="admin-form" aria-label="Manage students and settings">
            <div>
              <h3>‚ûï Add new student</h3>
              <div class="form-row">
                <input
  type="text"
  id="newStudentUser"
  name="student_create_user"
  placeholder="Username"
  autocomplete="off">
                <div style="position: relative; width: 100%;">
  <input
  type="password"
  id="newStudentPass"
  name="student_create_password"
  placeholder="Password"
  autocomplete="new-password"
  style="padding-right: 44px;"
/>

  <button
    type="button"
    id="togglePassBtn"
    onclick="toggleStudentPassword()"
    style="
      position: absolute;
      right: 10px;
      top: 30%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #ffd700;
      cursor: pointer;
      font-size: 32px;
    "
    title="Show / Hide password"
  >
    üëÅÔ∏è‚Äçüó®Ô∏è
  </button>
</div>


               

              </div>
              <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                <button class="btn-success" onclick="addStudent()">Add student</button>
                <button class="btn-secondary" id="clearAddStudentBtn" type="button">Clear</button>
              </div>
              <h3 style="margin-top:18px;">‚öôÔ∏è Manage system settings</h3>
              <div style="margin-top:8px;">
                <div class="form-row">
                  <label style="width:100%; color:var(--text-muted); font-weight:700; margin-bottom:6px;">Default student status</label>
                  <select id="defaultStudentStatus">
                    <option value="active">Active</option>
                    <option value="inactive">Inactive</option>
                  </select>
                </div>
                <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
                  <button class="btn-secondary" onclick="refreshStudentList()">Refresh list</button>

                </div>
                <p
  id="studentSortHint"
  style="margin-top:8px; font-size:13px; color:#9da0b8;"
></p>

               <div id="adminPgnUploader" class="admin-pgn-box">
  <h3>üì• Upload PGN TO DB</h3>

  <input type="file" id="pgnFileInput" accept=".pgn" hidden />

  <button id="uploadPgnBtn" class="btn btn-success">
    Import PGN
  </button>

  <p id="pgnStatus"></p>
</div>


              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="adminAccessDenied" style="display: none;" class="access-denied">
        <h2>‚õî Access denied</h2>
        <p>This section is restricted to administrators only.</p>
      </div>
    </div>

    <!-- ATTEMPTS -->
    <div class="section" id="attempts-section">
      <h2>üìä Student attempts</h2>
      <div id="attemptsList" class="loading">Loading attempts...</div>
    </div>
  </div>

<input
  type="file"
  id="studyFileInput"
  accept=".pgn"
  style="display:none"
/>

  <!-- Libraries -->
  <!-- Libraries -->
<script defer src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<!-- üî• ADD THESE TWO LINES -->
<script defer src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
<link
  rel="stylesheet"
  href="https://code.jquery.com/ui/1.13.2/themes/smoothness/jquery-ui.css"
/>

<script defer src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.11.0/chess.min.js"></script>


  <script type="module">
    // ============================================
    // IMPORTS & GLOBALS
    // ============================================
    import { supabase } from './supabase-client.js';

    let currentUser = null;
    let currentProfile = null;
    let quizChess = new Chess();
let currentQuizSolution = null;
let currentOptions = [];

let currentPieceTheme =
  localStorage.getItem("pieceTheme") || "merida";





async function saveMiniGameScore(gameKey, newScore) {
  if (!currentProfile) return;

  // ‚ùå games that should NOT affect mini-game rating
  const NON_RATING_GAMES = ["quiz", "puzzlerush", "knightmonster", "knightlava", "puzzlebattle"];

  const { data: existing } = await supabase
    .from("minigame_high_scores")
    .select("score")
    .eq("student_id", currentProfile.id)
    .eq("game_key", gameKey)
    .maybeSingle();

  let ratingToAdd = 0;

  // üü¢ 1Ô∏è‚É£ Effort reward (always, very small)
  if (!NON_RATING_GAMES.includes(gameKey)) {
    ratingToAdd += 1; // üëà motivation point
  }

  // üü¢ 2Ô∏è‚É£ Improvement reward (only if better)
  if (existing && newScore > existing.score) {
    const improvement = newScore - existing.score;

    // improvement-based bonus (uses your /2 logic)
    ratingToAdd += Math.floor(improvement / 2);
  }

  // üü¢ 3Ô∏è‚É£ First time play bonus
  if (!existing) {
    ratingToAdd += Math.floor(newScore / 2);
  }

  // üö´ absolute safety
  if (ratingToAdd > 0 && !NON_RATING_GAMES.includes(gameKey)) {
    applyMiniGameRating(ratingToAdd);
  }

  // üèÜ Save best score ONLY if improved or first time
  if (!existing || newScore > existing.score) {
    const { error } = await supabase
      .from("minigame_high_scores")
      .upsert(
        {
          student_id: currentProfile.id,
          game_key: gameKey,
          score: newScore
        },
        { onConflict: "student_id,game_key" }
      );

    if (error) {
      console.error("‚ùå Upsert failed:", error);
    }
  }

  loadMyBestScores();
}



async function loadMyBestScores() {
  const list = document.getElementById("miniScoreList");
  if (!list || !currentProfile) return;

  list.innerHTML = `<p class="muted">Loading scores...</p>`;

  const { data, error } = await supabase
    .from("minigame_high_scores")
    .select("game_key, score")
    .eq("student_id", currentProfile.id)
    .order("game_key");

  if (error) {
    console.error("‚ùå Score load error", error);
    list.innerHTML = `<p class="muted">Failed to load</p>`;
    return;
  }

  if (!data || data.length === 0) {
    list.innerHTML = `<p class="muted">No scores yet</p>`;
    return;
  }

  list.innerHTML = "";

  data.forEach(row => {
    const div = document.createElement("div");
    div.className = "mini-score-row";
    div.innerHTML = `
      <span class="game-name">${formatGameName(row.game_key)}</span>
      <span class="game-score">${row.score}</span>
    `;
    list.appendChild(div);
  });
}

function formatGameName(key) {
  const map = {
    memory: "üß† IQ Hunt",
    boardfreeze: "‚ùì Guess Materials",
    color: "üß™ Lab Hunt",
    knightfog: "üçé Knight Fog Quest",
    knightdefense: "üëë Defend The King",
    knightpath: "üê¥ Knight Hunt",
    knightmonster: "üê¥ vs üëπ",
    knightescape: "üè∞ Escape",
    knightspeed: "‚ö° Speed Run",
    knightlava: "üî• Lava Knight",
    knightgps: "üß≠ Knight GPS",
    kingmath: "üëë Chess Math",
    colorchaos: "üé® Rainbow Mania",
    flashqueen: "üë∏ Find The Queen",
    pathfinder: "üë∏ Reach Home",
    puzzlerush: "‚ö° Puzzle Rush",
    quiz: "‚öΩ Quiz",
    coordtrain: "üìç Board Coordinates",
    puzzlebattle: "‚öîÔ∏è Puzzle Battle",

  };

  return map[key] || key;
}


function showRatingDelta(delta) {
  const el = document.getElementById("ratingDelta");
  if (!el) return;

  el.className = "rating-delta";

  if (delta > 0) {
    el.textContent = `+${delta} XP`;
    el.classList.add("positive");
  } else {
    el.textContent = "0";
    el.classList.add("zero");
  }

  // SHOW
  requestAnimationFrame(() => {
    el.classList.add("show");
  });

  // HOLD (VISIBLE)
  setTimeout(() => {
    el.classList.remove("show");
    el.classList.add("hide");
  }, 10000); // üëà stays clearly visible

  // CLEANUP
  setTimeout(() => {
    el.className = "rating-delta";
    el.textContent = "";
  }, 10000);
}






async function applyPuzzleRushRating(prScore) {
  if (!currentProfile || prScore <= 0) return;

  // üîª CUT DOWN: 1/2 factor
  const ratingGain = Math.floor(prScore / 2);

  if (ratingGain <= 0) return;

  currentProfile.puzzle_current_score =
    (currentProfile.puzzle_current_score || 0) + ratingGain;

  updateRatingsFromProfile(currentProfile);
  showRatingDelta(ratingGain);

  const { error } = await supabase
    .from("profiles")
    .update({
      puzzle_current_score: currentProfile.puzzle_current_score
    })
    .eq("id", currentProfile.id);

  if (error) {
    console.error("‚ùå Failed to update puzzle rush rating", error);
  }
}







async function applyQuizRating(quizScore) {
  if (!currentProfile || quizScore <= 0) return;

  // üîª CUT DOWN: 1/2 factor
  const ratingGain = Math.floor(quizScore / 2);

  if (ratingGain <= 0) return;

  currentProfile.quiz_current_score =
    (currentProfile.quiz_current_score || 0) + ratingGain;

  updateRatingsFromProfile(currentProfile);
  showRatingDelta(ratingGain);

  const { error } = await supabase
    .from("profiles")
    .update({
      quiz_current_score: currentProfile.quiz_current_score
    })
    .eq("id", currentProfile.id);

  if (error) {
    console.error("‚ùå Failed to update quiz rating", error);
  }
}








async function applyMiniGameRating(score) {
  if (!currentProfile || score <= 0) return;

  const DAILY_CAP = 100;

  const usedToday = getMiniGameUsedToday();
  if (usedToday >= DAILY_CAP) return;

  let ratingGain = Math.ceil(score / 3);

  ratingGain = Math.max(1, Math.min(ratingGain, DAILY_CAP - usedToday));

  // update profile rating (this IS saved in Supabase)
  currentProfile.game_current_score =
    (currentProfile.game_current_score || 0) + ratingGain;

  updateRatingsFromProfile(currentProfile);
  showRatingDelta(ratingGain);

  // store daily usage locally
  setMiniGameUsedToday(usedToday + ratingGain);

  // persist only real rating
  await supabase
    .from("profiles")
    .update({
      game_current_score: currentProfile.game_current_score
    })
    .eq("id", currentProfile.id);
}


function getMiniGameUsedToday() {
  const today = new Date().toISOString().slice(0, 10);
  return Number(localStorage.getItem(`mg_used_${today}`) || 0);
}

function setMiniGameUsedToday(val) {
  const today = new Date().toISOString().slice(0, 10);
  localStorage.setItem(`mg_used_${today}`, val);
}




async function applyAssignmentRating() {
  if (!currentProfile) return;

  const ratingGain = 5;

  currentProfile.game_current_score =
    (currentProfile.game_current_score || 0) + ratingGain;

  updateRatingsFromProfile(currentProfile);

  // ‚úÖ visual feedback for kids
  showRatingDelta(ratingGain);

  const { error } = await supabase
    .from("profiles")
    .update({
      game_current_score: currentProfile.game_current_score
    })
    .eq("id", currentProfile.id);

  if (error) {
    console.error("‚ùå Failed to apply assignment rating", error);
  }
}









function updateRatingsFromProfile(profile) {
  if (!profile) return;

  const puzzleRating = profile.puzzle_current_score || 0;
  const quizRating   = profile.quiz_current_score || 0;
  const gameRating   = profile.game_current_score || 0;

  // üî¢ Raw hidden average
  const rawAverage = (puzzleRating + quizRating + gameRating) / 3;

  // üèÜ Displayed rating (10-point boundary)
  const olympusRating = Math.floor(rawAverage / 10) * 10;


  // üéØ Progress toward NEXT rating
  const prevStep = olympusRating;
  const nextStep = olympusRating + 10;

  let progress =
    ((rawAverage - prevStep) / (nextStep - prevStep)) * 100;

  // Clamp safely
  progress = Math.max(0, Math.min(progress, 100));

  // UI setters
  const set = (id, val) => {
    const el = document.getElementById(id);
    if (el) el.textContent = val;
  };

  set("puzzleRating", puzzleRating);
  set("quizRating", quizRating);
  set("gameRating", gameRating);
  set("olympusRating", olympusRating);
  set("ratingTier", getOlympusTier(olympusRating));

  // Progress UI
  const fill = document.getElementById("ratingProgressFill");
  const text = document.getElementById("ratingProgressText");

  if (fill) fill.style.width = `${progress}%`;
  if (text) text.textContent = `${Math.round(progress)}% to ${nextStep}`;
}

function calculateRatingProgress(profile) {
  const puzzle = profile.puzzle_current_score || 0;
  const quiz   = profile.quiz_current_score || 0;
  const game   = profile.game_current_score || 0;

  const rawAverage = (puzzle + quiz + game) / 3;

  // üîí LOCK slab to displayed ELO logic
  const olympusRating =
    Math.round(rawAverage / 10) * 10;

  const currentStep = olympusRating;
  const nextStep = olympusRating + 10;

  let progress =
    ((rawAverage - currentStep) / 10) * 100;

  progress = Math.max(0, Math.min(progress, 100));

  return {
    progress: Math.round(progress),
    nextStep
  };
}


let liveMatchXPGranted = false

async function grantLiveMatchXPIfWinner(row) {
  if (!currentProfile) return
  if (liveMatchXPGranted) return
  if (row.status !== "finished") return
  if (row.winner !== mySide) return

  liveMatchXPGranted = true

  const XP = 6

  currentProfile.game_current_score =
    (currentProfile.game_current_score || 0) + XP

  updateRatingsFromProfile(currentProfile)
  showRatingDelta(XP)

  await supabase
    .from("profiles")
    .update({
      game_current_score: currentProfile.game_current_score
    })
    .eq("id", currentProfile.id)

  console.log("üèÜ Live Match XP granted:", XP)
}


// ===============================
// üèÜ PUZZLE BATTLE XP REWARD
// ===============================
let battleXPGranted = false;

async function grantPuzzleBattleXP() {
  if (!currentProfile) return;
  if (battleXPGranted) return;
   if (!battleWinnerDeclared) return; // üõë HARD STOP

  battleXPGranted = true;

  const XP = 5;

  currentProfile.game_current_score =
    (currentProfile.game_current_score || 0) + XP;

  updateRatingsFromProfile(currentProfile);
  showRatingDelta(XP);

  await supabase
    .from("profiles")
    .update({
      game_current_score: currentProfile.game_current_score
    })
    .eq("id", currentProfile.id);

  console.log("üèÜ Puzzle Battle XP granted:", XP);
    // ü™ü MODAL ‚Äî XP CONFIRM
  BattleModal.show(
    "‚ú® XP Earned",
    "Your win has been recorded and XP added successfully!"
  );

}





function getOlympusTier(rating) {
  if (rating >= 3000) return "Olympus Immortal";

  if (rating >= 2900) return "Celestial Grandmaster";
  if (rating >= 2800) return "Mythic Grandmaster";
  if (rating >= 2700) return "Supreme Grandmaster";
  if (rating >= 2600) return "Legendary Grandmaster";
  if (rating >= 2500) return "Grandmaster";

  if (rating >= 2400) return "Master Tactician";
  if (rating >= 2300) return "Elite Strategist";
  if (rating >= 2200) return "Supreme Strategist";
  if (rating >= 2100) return "Royal Strategist";
  if (rating >= 2000) return "Champion Strategist";

  if (rating >= 1900) return "Grand Queen";
  if (rating >= 1800) return "Elite Queen";
  if (rating >= 1700) return "Queen";

  if (rating >= 1600) return "Grand Rook";
  if (rating >= 1500) return "Elite Rook";
  if (rating >= 1400) return "Rook";

  if (rating >= 1300) return "Grand Bishop";
  if (rating >= 1200) return "Elite Bishop";
  if (rating >= 1100) return "Bishop";

  if (rating >= 1000) return "Grand Knight";
  if (rating >= 900)  return "Elite Knight";
  if (rating >= 800)  return "Knight";

  if (rating >= 700)  return "Advanced Pawn";
  if (rating >= 600)  return "Skilled Pawn";
  if (rating >= 500)  return "Pawn";

  if (rating >= 400)  return "Rising Learner";
  if (rating >= 300)  return "Active Learner";
  if (rating >= 200)  return "Chess Learner";

  return "Beginner";
}

























    // ===============================
// ‚ôü STOCKFISH ENGINE (CLASSIC JS)
// ===============================
let stockfish = null;
const ENGINE_BULLETS = ["üî∑", "üî∑", "üî∑"];
let engineReady = false;
let engineAnalyzing = false;
let currentPV = [];
const pvMap = {};
let engineRunning = false;   // üî• NEW

let studyEngine = null;
let studyEngineReady = false;

let studyEngineEnabled = false;
let studyPV = {};

document.getElementById("studyEngineToggle").onclick = () => {
  studyEngineEnabled = !studyEngineEnabled;

  const btn = document.getElementById("studyEngineToggle");
  btn.textContent = studyEngineEnabled ? "ON" : "OFF";
  btn.className = "engine-toggle " + (studyEngineEnabled ? "on" : "off");

  if (studyEngineEnabled) {
    initStudyEngine();
    analyzeStudyPosition();
  } else {
    studyEngine.postMessage("stop");
    document.getElementById("studyPVLines").innerHTML = "";
    document.getElementById("studyEval").textContent = "--";
    document.getElementById("studyDepth").textContent = "--";
  }
};





function initEditorBoard() {
  if (editorBoard) return;

  editorChess = new Chess(); // empty logic holder

  editorBoard = Chessboard("editorBoard", {
  position: "start",
  draggable: true,
  sparePieces: true,
  dropOffBoard: "trash",
 pieceTheme: getPieceThemePath(currentPieceTheme),
  onDrop: onEditorDrop
});


  


  syncEditorFEN();
}
function onEditorDrop(source, target, piece) {
  // remove piece from source square
  editorChess.remove(source);

  // detect color and type from piece string (wP, bQ, etc.)
  const color = piece[0] === "w" ? "w" : "b";
  const type = piece[1].toLowerCase();

  // place piece on target square
  editorChess.put({ type, color }, target);

  // üî• force FEN update immediately
  syncEditorFEN();
}



function syncEditorFEN() {
  if (!editorBoard) return;

  setTimeout(() => {
    const boardFen = editorBoard.fen();
    const turn = document.getElementById("editorTurn").value;

    // ==============================
    // üîí CASTLING VALIDATION (FULL)
    // ==============================

    // ---- WHITE ----
    const wKing = editorChess.get("e1");
    const wRookH = editorChess.get("h1");
    const wRookA = editorChess.get("a1");

    if (!wKing || wKing.type !== "k" || wKing.color !== "w") {
      castleWK.checked = false;
      castleWQ.checked = false;
    }
    if (!wRookH || wRookH.type !== "r" || wRookH.color !== "w") {
      castleWK.checked = false;
    }
    if (!wRookA || wRookA.type !== "r" || wRookA.color !== "w") {
      castleWQ.checked = false;
    }

    // ---- BLACK ----
    const bKing = editorChess.get("e8");
    const bRookH = editorChess.get("h8");
    const bRookA = editorChess.get("a8");

    if (!bKing || bKing.type !== "k" || bKing.color !== "b") {
      castleBK.checked = false;
      castleBQ.checked = false;
    }
    if (!bRookH || bRookH.type !== "r" || bRookH.color !== "b") {
      castleBK.checked = false;
    }
    if (!bRookA || bRookA.type !== "r" || bRookA.color !== "b") {
      castleBQ.checked = false;
    }

    // ==============================
    // üîß BUILD CASTLING STRING
    // ==============================
    let castling = "";

    if (castleWK.checked) castling += "K";
    if (castleWQ.checked) castling += "Q";
    if (castleBK.checked) castling += "k";
    if (castleBQ.checked) castling += "q";

    if (!castling) castling = "-";

    const fullFen = `${boardFen} ${turn} ${castling} - 0 1`;
    document.getElementById("editorFEN").value = fullFen;
  }, 0);
}




function normalizeEditorFEN(fen) {
  const parts = fen.trim().split(" ");

  // chessboard.js editor gives only board layout
  if (parts.length === 1) {
    return `${parts[0]} w - - 0 1`;
  }

  // fill missing fields safely
  while (parts.length < 6) {
    if (parts.length === 1) parts.push("w");
    else if (parts.length === 2) parts.push("-");
    else if (parts.length === 3) parts.push("-");
    else if (parts.length === 4) parts.push("0");
    else if (parts.length === 5) parts.push("1");
  }

  return parts.join(" ");
}

document.getElementById("editorTurn").addEventListener("change", () => {
  syncEditorFEN();
});

   // üîí Castling checkbox change ‚Üí re-sync FEN
["castleWK", "castleWQ", "castleBK", "castleBQ"].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener("change", syncEditorFEN);
});


document
  .getElementById("editorStartPos")
  .addEventListener("click", () => {
    if (!editorBoard) return;

    editorBoard.position("start", true);
    syncEditorFEN();
  });

document
  .getElementById("editorClear")
  .addEventListener("click", () => {
    if (!editorBoard) return;

    editorBoard.clear(true);
    syncEditorFEN();
  });

  document.getElementById("editorApply").addEventListener("click", () => {
  if (!editorBoard) return;

  const fen = document.getElementById("editorFEN").value;

  // ‚úÖ switch to Analysis Board tab (correct key)
  const analysisBtn = document.querySelector('[data-tab="board"]');
  if (analysisBtn) analysisBtn.click();

  // ‚úÖ load FEN safely after board is visible
  setTimeout(() => {
    if (board && chess) {
  // üî• HARD RESET engine (critical for castling)
  chess.reset();

  // üî• Load normalized FEN
  const safeFen = normalizeEditorFEN(fen);
  chess.load(safeFen);

  // üî• Force board sync
  board.position(safeFen, false);

  // üîÑ reset UI state
  moveHistory = [];

  if (typeof renderMoveList === "function") {
    renderMoveList();
  }

  stopEngine();
}

  }, 120);
});

document.getElementById("copyFenBtn").addEventListener("click", () => {
  const fenBox = document.getElementById("editorFEN");
  if (!fenBox || !fenBox.value.trim()) return;

  navigator.clipboard.writeText(fenBox.value).then(() => {
    const status = document.getElementById("fenCopyStatus");
    status.classList.remove("hidden");

    setTimeout(() => {
      status.classList.add("hidden");
    }, 1500);
  });
});



/* ================================
   ‚ôüÔ∏è GAME REVIEW EVAL QUEUE (GLOBAL)
   ================================ */

let reviewQueue = [];
let reviewWaiting = null;

function evalFenForReview(fen) {
  return new Promise(resolve => {
    const job = { fen, resolve };

    

    reviewQueue.push(job);
    processReviewQueue();
  });
}



function hardResetEngineForReview(fen) {
  if (!window.reviewEngine) return;

  window.reviewEngine.postMessage("stop");
  window.reviewEngine.postMessage("ucinewgame");
  window.reviewEngine.postMessage(`position fen ${fen}`);
  window.reviewEngine.postMessage("go depth 14");
}




function processReviewQueue() {

  if (reviewWaiting) return;
  if (!reviewQueue.length) return;

  reviewWaiting = reviewQueue.shift();

// üîë initialize buffers ONCE per job
reviewWaiting.cpBuffer = [];
reviewWaiting.pvEvals = {};

// ‚è±Ô∏è START FAILSAFE ONLY WHEN ENGINE STARTS
reviewWaiting.timer = setTimeout(() => {
  console.warn("‚è±Ô∏è Review eval timeout, forcing resolve");
 window.reviewEngine.postMessage("stop");


  reviewWaiting.resolve({ cp: 0, mate: null });
  reviewWaiting = null;
  processReviewQueue();
}, 1200);

hardResetEngineForReview(reviewWaiting.fen);


}

let engineFen = null;




function initStockfish() {
  if (stockfish) return;

  console.log("‚ôü Initializing Stockfish engine‚Ä¶");

  stockfish = new Worker("./stockfish/stockfish.js");

  

  stockfish.onmessage = (e) => {
  const line = e.data;
  if (typeof line !== "string") return;




  


   // ============================
// ‚ôüÔ∏è ENGINE READY HANDSHAKE
// ============================

if (line === "uciok") {
  stockfish.postMessage("setoption name MultiPV value 3");
  stockfish.postMessage("isready");
  return;
}

if (line === "readyok") {
  engineReady = true;
  console.log("‚úÖ Engine ready");
  processReviewQueue(); // üî• UNBLOCK QUEUE
  return;
}


    // ======================
    // INFO (DEPTH / EVAL / MULTI PV)
    // ======================
    if (line.startsWith("info")) {
      

      
      const depthMatch = line.match(/depth (\d+)/);
      const cpMatch = line.match(/score cp (-?\d+)/);
      const mateMatch = line.match(/score mate (-?\d+)/);

     if (depthMatch) {
  const d = parseInt(depthMatch[1], 10);

  // üîí clamp UI depth to requested depth
  const DISPLAY_DEPTH = 14;
  document.getElementById("engineDepth").textContent =
    Math.min(d, DISPLAY_DEPTH);
}


      // üîç detect MultiPV index ONCE
      const multipvMatch = line.match(/multipv (\d+)/);

      // ======================
      // HEADER EVAL (PV1 ONLY)
      // ======================
      if (cpMatch && multipvMatch && multipvMatch[1] === "1") {
  const rawCp = parseInt(cpMatch[1], 10);

  // üî• NORMALIZE TO WHITE POV (ONCE)
 // üîí SAFE: engineFen may be null during review
if (!engineFen) return;
const fenSource = engineFen;


const fenTurn = fenSource.split(" ")[1];
const evalCp = fenTurn === "w" ? rawCp : -rawCp;




  // FAST display ‚Äî no buffering
  document.getElementById("engineEval").textContent =
    (evalCp > 0 ? "+" : "") + (evalCp / 100).toFixed(2);

}


    // ======================
// MATE HANDLING (PV1 ONLY)
// ======================
if (mateMatch && multipvMatch && multipvMatch[1] === "1") {
  const mate = parseInt(mateMatch[1], 10);

  // ‚úÖ Stockfish mate is already POV-correct for UI
  document.getElementById("engineEval").textContent =
    "Mate " + mate;
}


      // ======================
      // MULTI PV HANDLING
      // ======================
      const pvMatch = line.match(/ pv (.+)$/);

      if (multipvMatch && pvMatch) {
        const index = Number(multipvMatch[1]); // 1,2,3
        pvMap[index] = pvMatch[1].split(" ").slice(0, 10);
        renderMultiPV();
      }
      // ======================


    }

    // ======================
    // ANALYSIS END
    // ======================
    if (line.startsWith("bestmove")) {
      engineAnalyzing = false;
    }
  };

  // üîë START UCI HANDSHAKE
  stockfish.postMessage("uci");
  stockfish.postMessage("isready");
}

function startEngine() {


  // üî• STOP OLD ANALYSIS (CRITICAL)
  stockfish.postMessage("stop");

  engineRunning = true;
  engineAnalyzing = true;

  Object.keys(pvMap).forEach(k => delete pvMap[k]);

  for (let i = 1; i <= 3; i++) {
    const el = document.getElementById(`engineLine${i}`);
    if (el) el.textContent = `${i}. ‚Äì`;
  }

  const fen = chess.fen();
  engineFen = fen; // üî• remember which position engine analyzes

  stockfish.postMessage("ucinewgame");
  stockfish.postMessage(`position fen ${fen}`);
  stockfish.postMessage("go depth 14");

  document.getElementById("analyzeBtn").textContent = "üî¥ Stop Analysis";
}


function stopEngine() {
  if (!engineRunning) return;

  engineRunning = false;
  engineAnalyzing = false;

  stockfish.postMessage("stop");

  document.getElementById("analyzeBtn").textContent = "üü¢ Start Analysis";
  document.getElementById("engineEval").textContent = "‚Äì";
document.getElementById("engineDepth").textContent = "‚Äì";

}

document.querySelectorAll(".nav-btn").forEach(btn => {
  if (btn.dataset.tab === "flashqueen") {
    btn.onclick = () => {
      document.querySelectorAll(".section").forEach(s => s.classList.add("hidden"));
      document.getElementById("flashqueen-section").classList.remove("hidden");

      document.getElementById("flashQueenMenu").classList.remove("hidden");
      document.getElementById("flashQueenGame").classList.add("hidden");
    };
  }
});



document.querySelectorAll(".nav-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const tab = btn.dataset.tab;
    switchTab(tab);
  });
});

let piecePracticeInitialized = false;

function switchTab(tab) {
  // hide all sections
  document.querySelectorAll(".section").forEach(sec => {
    sec.classList.remove("active");
    sec.classList.add("hidden");
  });

  // show target section
  const section = document.getElementById(`${tab}-section`);
  if (section) {
    section.classList.add("active");
    section.classList.remove("hidden");
  } else {
    console.error("‚ùå Section not found:", `${tab}-section`);
  }

  // quiz logic untouched
  if (tab === "quiz") {
    initQuizBoard();
    loadQuizPuzzle();
  }

  if (tab === 'gamereview') {
  initGameReview();
}


  // auto-start piece practice ONCE
  if (tab === "piecePractice" && !piecePracticeInitialized) {
    autoStartPiecePractice();
    piecePracticeInitialized = true;
  }
  // üî• Analysis board: create ONLY when visible
// üî• Create analysis board ONLY when board tab is visible
if (tab === "board") {
  setTimeout(() => {
    if (!board) {
      initChessboard(); // create board when visible
    } else {
  board.resize();
  board.position(chess.fen(), false);
}

  }, 0);
}


}






function autoStartPiecePractice() {
  requestAnimationFrame(() => {
    startGame();          // Knight
    startBishopGame();    // Bishop
    startRookGame();      // Rook
    startQueenGame();     // Queen
    startPawnGame();      // Pawn
    startKingGame();      // King
  });
}







/* üî• PUT IT HERE */
function updateEnginePosition() {
  if (!engineRunning) return;

  Object.keys(pvMap).forEach(k => delete pvMap[k]);

  for (let i = 1; i <= 3; i++) {
    document.getElementById(`engineLine${i}`).textContent =
      `${ENGINE_BULLETS[i - 1]} ‚Äì`;
  }

  
  stockfish.postMessage(`position fen ${chess.fen()}`);
  stockfish.postMessage("go infinite");
}


document.getElementById("startVsComputer").addEventListener("click", () => {
  clearVsResult(); // üî• clear old "White wins / Black wins"
  initVsEngine();
  initVsComputerBoard();

  // üîÅ RESET GAME STATE
  engineThinking = false;
  vsGameActive = true;

  const baseTime = parseInt(
    document.getElementById("timeControl").value,
    10
  );

  whiteTime = baseTime;
  blackTime = baseTime;
  updateClockUI();

  // üõë CLEAR ANY OLD CLOCK
  if (clockInterval) clearInterval(clockInterval);

  vsEngineConfig = getVsEngineConfig();

  // ‚ôü COLOR SELECTION
  const colorChoice = document.getElementById("playerColor").value;

  let playerColor = colorChoice;
  if (colorChoice === "random") {
    playerColor = Math.random() < 0.5 ? "white" : "black";
  }

  // üî• PUT IT RIGHT HERE
  vsPlayerColor = playerColor;

  // reset game
  vsChess.reset();

  // set board orientation
  vsBoard.orientation(playerColor);

  vsEngine.postMessage(`setoption name Skill Level value ${vsEngineConfig.skill}`);
  vsEngine.postMessage("ucinewgame");

  // ‚è± CLOCK + FIRST MOVE
  if (playerColor === "white") {
    startWhiteClock(); // player moves first
  } else {
    startBlackClock(); // engine moves first

    // ü§ñ engine first move
    setTimeout(() => {
      vsEngine.postMessage(`position fen ${vsChess.fen()}`);
      vsEngine.postMessage(
        `go depth ${vsEngineConfig.depth} movetime ${vsEngineConfig.time}`
      );
    }, 300);
  }

  console.log("üéÆ VS Computer game started", baseTime, playerColor);
});







document
  .getElementById("resetVsComputer")
  .addEventListener("click", resetVsComputerGame);


  








    // Chessboard.js + chess.js
    let board = null;
    let chess = null;
    let boardOrientation = 'white';
    let currentAssignment = null;
    let isAssignmentMode = false; // üîí engine allowed by default




    window.START_FEN =
  "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

  let quizBoard = null;

function initQuizBoard() {
  if (quizBoard) return;

  quizBoard = Chessboard("quizBoard", {
    position: "start",
    draggable: false,
    pieceTheme: getPieceThemePath(currentPieceTheme),
  });

  console.log("üß© Quiz board initialized (with themed pieces)");
}





  // Board Editor //

  let editorBoard = null;
let editorChess = null;
let quizTimer = null;
let timeLeft = 20;
let quizScore = 0;
let quizActive = false;



  // ===============================
// ü§ñ PLAY VS COMPUTER (BOARD ONLY)
// ===============================
let vsChess = null;
let vsBoard = null;
let vsGameActive = false;
let whiteTime = 0;
let blackTime = 0;
let clockInterval = null;
let engineThinking = false;
let vsPlayerColor = "white"; // default
let botVoiceAudio = null;


const BOT_PERSONALITIES = {
 

  ares: {
    name: "Ares Blaster",
    image: "bots/max.png",
    gibberish: [
  "üòÄ Hello! there",
  "üòÅ Hi! my buddy!",
  "üòÑ Hey! mate!",
  "üòä Hi there!",
  "üëã Hello! there",
  "üòÉ Hey buddy!",
  "üôÇ Hi friend!",
  "ü§ó Hello there!",
  "üòé Hey! my boy",
  "üòé Hi! friend"
],
voice: "bot/voices/ares.mp3"


  },

  athena: {
    name: "Olybot",
    image: "bots/ultra.png",
    gibberish: [
  "üòÄ Hello! there",
  "üòÅ Hi! my buddy!",
  "üòÑ Hey! mate!",
  "üòä Hi there!",
  "üëã Hello! there",
  "üòÉ Hey buddy!",
  "üôÇ Hi friend!",
  "ü§ó Hello there!",
  "üòé Hey! my boy",
  "üòé Hi! friend"
],
voice: "bot/voices/olybot.mp3"


  },

  

 
  
};


// =============================
// ü§ñ BOT SPEECH (SAFE FUNCTION)
// =============================
let botBubbleTimer = null;
let botCaptureAudio = null;


function botSpeak(key) {
  const bubble = document.getElementById("botBubble");
  if (!bubble) return;

  const bot = BOT_PERSONALITIES[key];
  if (!bot) return;

  // üí¨ text
  const lines = bot.gibberish;
  bubble.textContent = lines[Math.floor(Math.random() * lines.length)];
  bubble.classList.remove("hidden");

  // üîä stop previous voice
  if (botVoiceAudio) {
    botVoiceAudio.pause();
    botVoiceAudio.currentTime = 0;
  }

  // üîä play new bot voice
  if (bot.voice) {
    botVoiceAudio = new Audio(bot.voice);
botVoiceAudio.volume = 0.8;
botVoiceAudio.play().catch(() => {});

// üëÑ START MOUTH SYNC (THIS IS THE KEY LINE)
syncMouthWithAudio(botVoiceAudio);

  }

  // ‚è± hide bubble after 2 sec
  if (botBubbleTimer) clearTimeout(botBubbleTimer);
  botBubbleTimer = setTimeout(() => {
    bubble.classList.add("hidden");
  }, 3000);
}



let mouthCtx = null;
let mouthAnalyser = null;
let mouthData = null;
let mouthRAF = null;

function syncMouthWithAudio(audioEl) {
  const mouth = document.getElementById("botMouth");
  if (!mouth || !audioEl) return;

  if (!mouthCtx) {
    mouthCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  // ‚ö†Ô∏è Important: only ONE source per audio element
  if (!audioEl._mouthSource) {
    audioEl._mouthSource = mouthCtx.createMediaElementSource(audioEl);
    mouthAnalyser = mouthCtx.createAnalyser();
    mouthAnalyser.fftSize = 256;

    audioEl._mouthSource.connect(mouthAnalyser);
    mouthAnalyser.connect(mouthCtx.destination);

    mouthData = new Uint8Array(mouthAnalyser.frequencyBinCount);
  }

  function animate() {
    if (audioEl.paused || audioEl.ended) {
      mouth.classList.remove("talk");
      cancelAnimationFrame(mouthRAF);
      return;
    }

    mouthAnalyser.getByteFrequencyData(mouthData);

    let sum = 0;
    for (let i = 0; i < mouthData.length; i++) sum += mouthData[i];
    const avg = sum / mouthData.length;

    if (avg > 15) {
      mouth.classList.add("talk");
    } else {
      mouth.classList.remove("talk");
    }

    mouthRAF = requestAnimationFrame(animate);
  }

  animate();
}








function botReact(eventType) {
  const botKey = document.getElementById("engineSelect").value;
  const bot = BOT_PERSONALITIES[botKey];
  if (!bot) return;

  const bubble = document.getElementById("botBubble");
  if (!bubble) return;

  let lines = [];

  if (eventType === "check") {
  lines = [
    "üò≥ Check!", "ü´£ Uh oh!", "‚ö†Ô∏è OMG!", "üò¨ That's check!",
    "üò≥ Check!", "ü´£ Uh oh!", "‚ö†Ô∏è OMG!", "üò¨ That's check!",
    "üòÆ Whoa!", "üö® Danger!", "üò± Yikes!", "üëÄ Bro!",
    "üòØ Oh no!", "‚ö° Zap! Check!", "üõë Hold on!",
    "üòµ In trouble!", "üî• Pressure!", "üôÄ Watch out!",
    "üòÖ Close call!", "‚ö†Ô∏è Alert!", "üò≤ Ghosss!",
    "üß† Think fast!", "üò¨ Not good!", "üöß Red alert!",
    "üò≥ Check again!", "‚ö†Ô∏è Careful now!", "üò¨ That hurts!",
    "üòÆ Uh-oh!", "üö® King alert!", "üòµ Pressure!",
    "üëÄ Eyes open!", "üò± Yikes!", "üõë Stop!",
    "üî• Danger zone!", "üòì Not good!", "üò≤ Sneaky!",
    "‚ö° Fast check!", "üôÄ Scary!", "üòÖ Close one!",
    "üöß Watch it!", "üò¨ Risky!", "üß† Think!",
    "üòÆ Surprise check!", "‚ö†Ô∏è Trouble!", "üòµ‚Äçüí´ Dizzy!",
    "üö® Red flag!", "üòê Again?", "üò§ Annoying!",
    "üëë King in danger!", "üò≥ Didn‚Äôt see that!",
    "‚ö° Sharp!", "üôà Oops!", "üò¨ Careful king!",
    "üö® Emergency!"
  ];

  // üîä ADD THIS LINE
  playBotCheckSounds()
}

  if (eventType === "capture") {
  lines = [
    "üí• Oof!", "üòµ Taken!", "üò§ Hey!", "‚ö° Bruh!",
    "üí• Oof!", "üòµ Taken!", "üò§ Hey!", "‚ö° Bruh!",
    "üò¨ Whoops!", "üòÆ Gone!", "üí£ Boom!", "üôÉ Lost it!",
    "üò± Nooo!", "ü´† Slipped!", "üòì Uh-oh!", "üî• Smash!",
    "ü§ï Ouch!", "ü´¢ Yoink!", "üòÖ My piece!", "üö´ Blocked!",
    "üéØ Got me!", "üòê Really?", "üíî Pain!", "üòÆ‚Äçüí® Sigh!",
    "üí• Boom!", "üòµ Gone!", "üò§ Not fair!", "‚ö° Snatched!",
    "üò¨ Oops!", "üôÉ Lost one!", "üò± Oh no!", "ü´¢ Taken!",
    "ü§ï That hurt!", "üî• Crushed!", "üòì Slipped away!",
    "üéØ Nice hit!", "üòÆ Vanished!", "ü´† Misstep!",
    "üòÖ My bad!", "üö´ Blocked!", "üí£ Kaboom!",
    "üòê Seriously?", "üò§ Hey now!",
    "üß† Should‚Äôve seen that!", "üò¨ Big mistake!",
    "üôÄ Gone wrong!", "üòÆ‚Äçüí® Painful!",
    "üíî Lost it!", "ü§¶ Oopsie!", "üòµ That‚Äôs rough!",
    "‚ö° Quick grab!", "üò≥ Didn‚Äôt expect that!",
    "üé≠ Tricked!"
  ];

  // üîä ADD THIS LINE
  playBotCaptureSounds();
}

  bubble.textContent = lines[Math.floor(Math.random() * lines.length)];
  bubble.classList.remove("hidden");

  if (botBubbleTimer) clearTimeout(botBubbleTimer);
  botBubbleTimer = setTimeout(() => {
    bubble.classList.add("hidden");
  }, 3000);
}

function playBotCheckSounds() {
  setTimeout(() => {
    try {
      if (!window.botCheckAudio) {
        window.botCheckAudio = null;
      }

      if (window.botCheckAudio) {
        window.botCheckAudio.pause();
        window.botCheckAudio.currentTime = 0;
      }

      const index = Math.floor(Math.random() * 17) + 1;
      const audio = new Audio(
        `bot_reaction_sound/check${index}.mp3`
      );

      audio.volume = 0.5;
      window.botCheckAudio = audio;

      audio.play().catch(() => {});
    } catch (err) {
      console.warn("Check sound error (ignored):", err);
    }
  }, 350);
}


function playBotCaptureSounds() {
  // üî• Defer sound completely out of move stack
  setTimeout(() => {
    try {
      if (!window.botCaptureAudio) {
        window.botCaptureAudio = null;
      }

      if (window.botCaptureAudio) {
        window.botCaptureAudio.pause();
        window.botCaptureAudio.currentTime = 0;
      }

      const index = Math.floor(Math.random() * 14) + 1;
      const audio = new Audio(
        `bot_reaction_sound/capture${index}.mp3`
      );

      audio.volume = 0.5;
      window.botCaptureAudio = audio;

      audio.play().catch(() => {});
    } catch (err) {
      console.warn("Capture sound error (ignored):", err);
    }
  }, 350);
}


const loserSounds = [
  "sounds/loser1.mp3",
  "sounds/loser2.mp3",
  "sounds/loser3.mp3",
  "sounds/loser4.mp3",
  "sounds/loser5.mp3"
];

function playRandomLoserSound() {
  const src = loserSounds[Math.floor(Math.random() * loserSounds.length)];
  const audio = new Audio(src);
  audio.volume = 0.9;
  audio.play().catch(() => {});
}





// =============================
// ü§ñ BOT UI HOOK (SAFE ZONE)
// =============================

const botImage = document.getElementById("botImage");
const botName = document.getElementById("botName");

document.getElementById("engineSelect").addEventListener("change", (e) => {
  const key = e.target.value;

  const bot = BOT_PERSONALITIES[key];
  if (!bot) return;

  botImage.src = bot.image;
  botName.textContent = bot.name;

  botSpeak(key);
});






// ===============================
// ‚è± VS COMPUTER CLOCK HELPERS
// ===============================
function startWhiteClock() {
  clearInterval(clockInterval);
  clockInterval = setInterval(() => {
    if (!vsGameActive) return;
    if (whiteTime > 0) {
      whiteTime--;
      updateClockUI();
    }
  }, 1000);
}

function startBlackClock() {
  clearInterval(clockInterval);
  clockInterval = setInterval(() => {
    if (!vsGameActive) return;
    if (blackTime > 0) {
      blackTime--;
      updateClockUI();
    }
  }, 1000);
}

document.getElementById("takeBackBtn").addEventListener("click", () => {
  if (!vsGameActive) return;

  // üõë stop engine & clock
  clearInterval(clockInterval);
  engineThinking = false;

  // üîô undo engine move (if exists)
  const lastMove = vsChess.history().length;
  if (lastMove >= 1) vsChess.undo(); // engine move
  if (lastMove >= 2) vsChess.undo(); // player move

  // ‚ôü sync board
  vsBoard.position(vsChess.fen());

  // ‚ñ∂Ô∏è restart correct clock
  if (vsPlayerColor === "white") {
    startWhiteClock();
  } else {
    startBlackClock();
  }
});


document.addEventListener("click", () => {
  if (!window._audioUnlocked) {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    ctx.resume();
    window._audioUnlocked = true;
    console.log("üîì Audio unlocked");
  }
});



// ===============================
// ü§ñ VS COMPUTER ENGINE
// ===============================
let vsEngine = null;
let vsEngineConfig = null;
// ‚è± BOT MOVE DELAY (3 seconds)
const BOT_MOVE_DELAY = 2000;
let gameOver = false;







function getVsEngineConfig() {
  const level = document.getElementById("engineLevel").value;

  const map = {
  "600":  { skill: 3,  depth: 6,  time: 120 },  // üçº Tiny Tot
  "900":  { skill: 6,  depth: 8,  time: 200 },  // üå± Beginner
  "1200": { skill: 10, depth: 11, time: 350 },  // ‚öî Rookie
  "1500": { skill: 14, depth: 14, time: 600 },  // üß† Champion
  "2000": { skill: 20, depth: 18, time: 1200 }  // üëë Master
};


  return map[level];
}





function showVsResult(text, type) {
  const el = document.getElementById("vsGameResult");
  if (!el) return;

  el.textContent = text;
  el.classList.remove("hidden"); // üî• THIS WAS MISSING
  el.className = `vs-result ${type}`;
}

function endGameWhiteWins(reason = "resign") {
  gameOver = true;

  // Stop further moves
  if (computerBoard) {
    computerBoard.draggable = false;
  }

  // Show result banner
  const resultBox = document.createElement("div");
  resultBox.className = "vs-result white";
  resultBox.textContent = "üèÜ You played well!";
  document.querySelector("#computer-section").prepend(resultBox);

  // üîä play random loser sound
  playRandomLoserSound();

  console.log("GAME OVER:", reason);
}


function clearVsResult() {
  const el = document.getElementById("vsGameResult");
  if (!el) return;

  el.textContent = "";
  el.classList.add("hidden");
}

function checkVsGameEnd() {
  if (!vsChess.game_over()) return;

  vsGameActive = false;
  clearInterval(clockInterval);

  if (vsChess.in_checkmate()) {
    const winner =
      vsChess.turn() === "w" ? "Black wins!" : "White wins!";

    showVsResult(
      winner,
      winner.startsWith("White") ? "white" : "black"
    );
  } else {
    showVsResult("Draw!", "draw");
  }
}

document.getElementById("resignBtn")?.addEventListener("click", () => {
  if (gameOver) return;

  

  endGameWhiteWins("resign");
});


document.getElementById("studentDetailsModal").addEventListener("click", (e) => {
  if (e.target.id === "studentDetailsModal") {
    closeStudentModal();
  }
});

document.getElementById("rush3").onclick = () => startPuzzleRush("3");
document.getElementById("rush5").onclick = () => startPuzzleRush("5");
document.getElementById("survival").onclick = () => startPuzzleRush("survival");

document.getElementById("exitPuzzleRush").onclick = () => {
  document.getElementById("puzzleRushGame").classList.add("hidden");
  document.getElementById("puzzleRushMenu").classList.remove("hidden");

  puzzleRushMode = null;
};

let puzzleRushMode = null;

async function startPuzzleRush(mode) {

resetPuzzleRushState(); // ‚úÖ MUST BE FIRST
  // üîä Puzzle Rush start sound
puzzleRushStartSound.currentTime = 0;
puzzleRushStartSound.play().catch(() => {});

  puzzleRushMode = mode;

  document.getElementById("puzzleRushMenu").classList.add("hidden");
  document.getElementById("puzzleRushGame").classList.remove("hidden");

  // üîí RESET STATE
  puzzleQueue = [];
  puzzleIndex = 0;
  puzzleSolved = false;


  // ‚è± SET TIME & LIVES
  if (mode === "3") {
    prTimeLeft = 180;
    prLivesLeft = 3;
  } else if (mode === "5") {
    prTimeLeft = 300;
    prLivesLeft = 3;
  } else {
    prTimeLeft = null; // survival
    prLivesLeft = 1;
  }


  updatePuzzleRushUI();

  // ===============================
  // ‚ö° LOAD MATE IN 1 PUZZLES ONLY
  // ===============================
  const puzzles = await loadMateIn1Puzzles();

  puzzleQueue = puzzles.map(p => ({
    fen: p.fen,
    solution: p.solution.replace(/[+#?!]/g, ""), // normalize
    side: p.side_to_move
  }));

  console.log("üß© Puzzle Rush loaded puzzles:", puzzleQueue.length);

  if (!puzzleQueue.length) {
    alert("No Mate in 1 puzzles found.");
    return;
  }

  // üîÄ RANDOMIZE ONCE
  puzzleQueue.sort(() => Math.random() - 0.5);

  // ‚ôü INIT BOARD + LOAD FIRST PUZZLE
  setTimeout(() => {
    initPuzzleRushBoard();
    loadTestPuzzle();
  }, 0);

  // ‚ñ∂Ô∏è START TIMER
  if (prTimerInterval) clearInterval(prTimerInterval);

  if (prTimeLeft !== null) {
    prTimerInterval = setInterval(() => {
      prTimeLeft--;
      updatePuzzleRushUI();

      if (prTimeLeft <= 0) {
        clearInterval(prTimerInterval);
        endPuzzleRush("‚è∞ Time's Up!");

      }
    }, 1000);
  }
}






// ===============================
// ‚ö° PUZZLE RUSH BOARD
// ===============================
let prChess = null;
let prBoard = null;
let prTimerInterval = null;
let prTimeLeft = null;
let prLivesLeft = null;
let prScore = 0;
let currentPuzzle = null;
let puzzleSideToMove = "w"; // default
let puzzleSolved = false;
let prMaxLives = 0; // ‚úÖ ADD THIS

   // ===============================
// ‚ö° PUZZLE RUSH MOVE HANDLER
// (used by drag AND tap)
// ===============================
function handlePuzzleRushMove(source, target) {
  if (!currentPuzzle || puzzleSolved) return "snapback";

  const move = prChess.move({
    from: source,
    to: target,
    promotion: "q"
  });

  if (!move) return "snapback";

  // üîä every move = check sound (mate attempt)
  playPRSound("prCheckSound", 0.5);

  const played = move.san.replace(/[+#?!]/g, "");
  const expected = currentPuzzle.solution.replace(/[+#?!]/g, "");

  // ‚úÖ CORRECT
  if (played === expected) {
    puzzleSolved = true;
    prScore++;

    // üîä correct puzzle solved
    playPRSound("prNextSound", 0.9);
    updatePuzzleRushUI();
    setTimeout(loadTestPuzzle, 500);
    return;
  }

  // ‚ùå WRONG MOVE
  prChess.undo();
  prBoard.position(prChess.fen());

  prLivesLeft--;
  playPRSound("prWrongSound", 0.8);
  updatePuzzleRushUI();

  if (prLivesLeft <= 0) {
    endPuzzleRush("üíÄ No lives left!");
  }

  return "snapback";
}




function initPuzzleRushBoard() {
  if (prBoard) return;

  prChess = new Chess();

  prBoard = Chessboard("puzzleRushBoard", {
    position: "start",
    draggable: true,
    pieceTheme: getPieceThemePath(currentPieceTheme),

    // üîí LOCK FREE PLAY
    onDragStart: (source, piece) => {
      if (!currentPuzzle) return false;
      if (puzzleSolved) return false;

      // allow only puzzle side to move
      if (
        (puzzleSideToMove === "w" && piece.startsWith("b")) ||
        (puzzleSideToMove === "b" && piece.startsWith("w"))
      ) {
        return false;
      }

      return true;
    },

   onDrop: (source, target) => {
  return handlePuzzleRushMove(source, target);
}



  });
 // üì± ENABLE TAP MODE ‚Äî HERE, ONCE
  enablePuzzleRushTapMove();
}

let puzzleRushStartSound = new Audio("sounds/puzzle-rush-start.mp3");
puzzleRushStartSound.volume = 0.9;



// ===============================
// ‚ö° PUZZLE RUSH ‚Äì TEMP QUEUE
// ===============================
let puzzleQueue = [];
let puzzleIndex = 0;

function loadTestPuzzle() {
  if (!puzzleQueue.length) return;

  if (puzzleIndex >= puzzleQueue.length) {
    puzzleIndex = 0;
  }

  currentPuzzle = puzzleQueue[puzzleIndex++];
  puzzleSolved = false;

  prChess.reset();
  prChess.load(currentPuzzle.fen);

  puzzleSideToMove = prChess.turn(); // 'w' or 'b'

  // üî• FIX: SET BOARD ORIENTATION CORRECTLY
  prBoard.orientation(puzzleSideToMove === "w" ? "white" : "black");

  prBoard.position(currentPuzzle.fen);

  console.log("üß© Puzzle loaded:", currentPuzzle);
}






// ===============================
// ‚ö° PGN ‚Üí PUZZLE CONVERTER (STEP 1)
// ===============================




// ===============================
// üìö PUZZLE RUSH ‚Äì LOAD BULK PGNs
// ===============================
async function loadBulkPGNsForPuzzleRush() {
  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("id, pgn, title")
    .eq("is_active", true);

  if (error) {
    console.error("‚ùå Failed to load bulk PGNs", error);
    return [];
  }

  // üîç ADD THIS
  console.log("üì¶ RAW PGN ROWS FROM DB:", data);

  return data;
}


// ===============================
// ‚ôüÔ∏è PUZZLE RUSH ‚Äì PGN ‚Üí PUZZLES
// ===============================
// ===============================
// ‚ôüÔ∏è PUZZLE RUSH ‚Äì PGN ‚Üí PUZZLES
// (compatible with chess.js 0.13.x)
// ===============================
// ===============================
// ‚ôüÔ∏è PUZZLE RUSH ‚Äì SAFE PGN PARSER
// supports FULL + MOVE-ONLY PGNs
// ===============================
function buildPuzzleFromFullPGN(pgn) {
  if (!pgn || typeof pgn !== "string") return null;

  const clean = pgn
    .replace(/\{[^}]*\}/g, "")
    .replace(/\[[^\]]*\]/g, "")
    .replace(/\d+\.(\.\.)?/g, "")
    .replace(/\r?\n/g, " ")
    .trim();

  const tokens = clean.split(/\s+/).filter(Boolean);
  if (tokens.length < 2) return null;

  const game = new Chess();
  let lastMove = null;

  for (const san of tokens) {
  // ‚õî skip game results
  if (
    san === "1-0" ||
    san === "0-1" ||
    san === "1/2-1/2" ||
    san === "*"
  ) {
    continue;
  }

  const move = game.move(san, { sloppy: true });

if (!move) {
  console.warn("‚ùå Invalid SAN skipped:", san);
  continue; // ‚úÖ just ignore and move on
}

lastMove = move;

}


  if (!lastMove) {
  console.warn("‚ö†Ô∏è No valid moves found in PGN");
  return null;
}


  game.undo(); // üëà go back ONE move

  console.log("‚úÖ PUZZLE CREATED", {
  fen: game.fen(),
  solution: lastMove.san
});


  return {
    fen: game.fen(),
    solution: lastMove.san.replace(/[?!+#]/g, "")
  };
}









// ===============================
// ü§ñ PUZZLE RUSH ‚Äì AUTO REPLY MOVE
// ===============================
function playAutoMoveIfNeeded() {
  if (!currentPuzzle || !currentPuzzle.solution) return;
  if (currentPuzzle.index >= currentPuzzle.solution.length) return;


  const san = currentPuzzle.solution[currentPuzzle.index];
  const move = prChess.move(san, { sloppy: true });

  if (!move) return;

  currentPuzzle.index++;
  prBoard.position(prChess.fen());

  // üî• THIS IS THE FIX
  puzzleSideToMove = prChess.turn();
}










    // üî¥ PROMOTION STATE (ADD THIS)
    let pendingPromotion = null;

    // Timer
    let timerInterval = null;
    let startTime = null;
    let elapsedTime = 0;

    // State
    let moveHistory = [];
    let pgnCursor = 0;
    let fullPGNHistory = []; // Store the complete game history for navigation
    let isNavigationMode = false;
    let isPGNLoaded = false;

    // Drawing system variables
    let drawings = new Map(); // Store drawings per FEN
    let isDrawing = false;
    let drawStartSquare = null;
    let currentDrawings = [];
    let isRightMouseDown = false;
    let mousePosition = { x: 0, y: 0 };
    let svgOverlay = null;

    // Assignment system variables
    let expectedMoves = [];
    let assignmentCursor = 0;
    let assignmentColor = "w";
    let attemptCount = 0;
    let bulkPuzzles = [];
    let bulkIndex = 0;
    let pendingDeleteAssignmentId = null;

    let soundUnlocked = false;
    // ================================
// STUDENT BADGE PROGRESS (STEP 4A)
// ================================
let studentSolvedCount = 0;
// ================================
// STUDENT BADGES ‚Äî UNLOCK STATE
// STEP 4D
// ================================
let BADGE_STORAGE_KEY = null;

let unlockedBadges = new Set();



    // ================================
// STUDENT BADGES ‚Äî DEFINITIONS
// ================================
const STUDENT_BADGES = [
  {
    id: "fast_furious",
    icon: "‚ö°",
    title: "Fast & Furious",
    tagline: "3 assignments completed",
    tier: "bronze",
    required: 3
  },
  {
    id: "sharp_shooter",
    icon: "üéØ",
    title: "Sharp Shooter",
    tagline: "Solve with precision",
    tier: "bronze",
    required: 6
  },
  {
    id: "consistency",
    icon: "üî•",
    title: "Consistency",
    tagline: "9 puzzles solved",
    tier: "silver",
    required: 9
  },
  {
    id: "tactician",
    icon: "‚öîÔ∏è",
    title: "Tactician",
    tagline: "Think before you strike",
    tier: "silver",
    required: 12
  },
  {
    id: "deep_thinker",
    icon: "üß†",
    title: "Deep Thinker",
    tagline: "Solved without rushing",
    tier: "silver",
    required: 15
  },
  {
    id: "speed_runner",
    icon: "‚è±Ô∏è",
    title: "Speed Runner",
    tagline: "Solved under time pressure",
    tier: "gold",
    required: 18
  },
  {
  id: "clear_head",
  icon: "üß†",
  title: "Clear Head",
  tagline: "Chose clarity over chaos",
  tier: "silver",
  required: 21
},
{
  id: "bulls_eye",
  icon: "ü¶Ö",
  title: "Bulls Eye",
  tagline: "Spotted the tactic",
  tier: "gold",
  required: 24
},
{
  id: "momentum",
  icon: "üöÄ",
  title: "Momentum",
  tagline: "Multiple solves in a row",
  tier: "gold",
  required: 27
},
{
  id: "olympian",
  icon: "üëë",
  title: "Olympian",
  tagline: "50 assignments completed",
  tier: "platinum",
  required: 30
},
{
  id: "ball_head",
  icon: "üß†",
  title: "ball Head",
  tagline: "Chose clarity over fight",
  tier: "silver",
  required: 33
},
{
  id: "eagle_eye",
  icon: "ü¶Ö",
  title: "Eagle Eye",
  tagline: "Spotted the key tactic",
  tier: "silver",
  required: 36
},
{
  id: "mega",
  icon: "üöÄ",
  title: "Mega",
  tagline: "Multiple solves in a row",
  tier: "gold",
  required: 39
},
{
  id: "iron_wall",
  icon: "üß±",
  title: "Iron Wall",
  tagline: "Nothing got through",
  tier: "gold",
  required: 42
},
{
  id: "calculation_mode",
  icon: "üßÆ",
  title: "Calculation Mode",
  tagline: "Saw it till the end",
  tier: "gold",
  required: 45
},
{
  id: "breakthrough",
  icon: "üåÑ",
  title: "Breakthrough",
  tagline: "Found the winning idea",
  tier: "platinum",
  required: 48
},
{
  id: "champion_spirit",
  icon: "üèÜ",
  title: "Champion Spirit",
  tagline: "Never gave up",
  tier: "platinum",
  required: 51
},
{
  id: "focused_mind",
  icon: "üß†",
  title: "Focused Mind",
  tagline: "Stayed sharp till the end",
  tier: "platinum",
  required: 54
},
{
  id: "recovery",
  icon: "üîÑ",
  title: "Recovery",
  tagline: "Bounced back after a mistake",
  tier: "platinum",
  required: 57
},
{
  id: "break_the_wall",
  icon: "üß®",
  title: "Break the Wall",
  tagline: "Found the breakthrough move",
  tier: "platinum",
  required: 60
},
{
  id: "light_touch",
  icon: "ü™∂",
  title: "Light Touch",
  tagline: "Handled the position smoothly",
  tier: "diamond",
  required: 63
},
{
  id: "mental_fortress",
  icon: "üß†",
  title: "Mental Fortress",
  tagline: "Held strong under pressure",
  tier: "diamond",
  required: 66
},
{
  id: "perfect_harmony",
  icon: "üéº",
  title: "Perfect Harmony",
  tagline: "All pieces worked together",
  tier: "diamond",
  required: 69
},
{
  id: "decisive_cut",
  icon: "ü™ì",
  title: "Decisive Cut",
  tagline: "Ended the position cleanly",
  tier: "diamond",
  required: 72
},
{
  id: "turning_point",
  icon: "üåó",
  title: "Turning Point",
  tagline: "Changed the course of the game",
  tier: "diamond",
  required: 75
},
{
  id: "pattern_spotter",
  icon: "üß©",
  title: "Pattern Spotter",
  tagline: "Recognized the familiar idea",
  tier: "diamond",
  required: 78
},
{
  id: "clinical_finish",
  icon: "üéØ",
  title: "Clinical Finish",
  tagline: "Converted advantage precisely",
  tier: "diamond",
  required: 81
},
{
  id: "positional_dna",
  icon: "üß¨",
  title: "Positional DNA",
  tagline: "Understood the position deeply",
  tier: "diamond",
  required: 84
},
{
  id: "roadblock",
  icon: "üöß",
  title: "Roadblock",
  tagline: "Stopped the opponents plan",
  tier: "diamond",
  required: 87
},
{
  id: "mental_clarity",
  icon: "üß†",
  title: "Mental Clarity",
  tagline: "Found order in complexity",
  tier: "diamond",
  required: 90
},
{
  id: "steady_hand",
  icon: "‚öì",
  title: "Steady Hand",
  tagline: "Never lost control",
  tier: "diamond",
  required: 93
},
{
  id: "clutch_climber",
  icon: "üßó",
  title: "Clutch Climber",
  tagline: "Solved when it mattered most",
  tier: "diamond",
  required: 96
},
{
  id: "discipline",
  icon: "üéñÔ∏è",
  title: "Discipline",
  tagline: "Played by principles",
  tier: "diamond",
  required: 99
},
{
  id: "sense_of_direction",
  icon: "üß≠",
  title: "Sense of Direction",
  tagline: "Always knew where to go",
  tier: "diamond",
  required: 102
},
{
  id: "battle_ready",
  icon: "ü™ñ",
  title: "Battle Ready",
  tagline: "Handled tough positions confidently",
  tier: "diamond",
  required: 105
},
{
  id: "cold_calclation",
  icon: "üß†",
  title: "Cold Calclation",
  tagline: "Calculated without emotion",
  tier: "diamond",
  required: 108
},
{
  id: "finish_line",
  icon: "üèÅ",
  title: "Finish Line",
  tagline: "Completed the task cleanly",
  tier: "diamond",
  required: 111
},
{
  id: "strategic_calm",
  icon: "üß†",
  title: "Strategic Calm",
  tagline: "Kept control in complex play",
  tier: "diamond",
  required: 114
},
{
  id: "key_breaker",
  icon: "üóùÔ∏è",
  title: "Key Breaker",
  tagline: "Unlocked the position",
  tier: "diamond",
  required: 117
},
{
  id: "shield_wall",
  icon: "üõ°Ô∏è",
  title: "Shield Wall",
  tagline: "Defended with precision",
  tier: "diamond",
  required: 120
},
{
  id: "moment_of_brilliance",
  icon: "üå†",
  title: "Moment of Brilliance",
  tagline: "Found the standout move",
  tier: "diamond",
  required: 123
},
{
  id: "composed_thinker",
  icon: "üß†",
  title: "Composed Thinker",
  tagline: "Stayed calm and accurate",
  tier: "diamond",
  required: 126
},
{
  id: "rock_solid",
  icon: "ü™®",
  title: "Rock Solid",
  tagline: "No weaknesses left behind",
  tier: "diamond",
  required: 129
},
{
  id: "calculatio_engine",
  icon: "üßÆ",
  title: "Calculatio Engine",
  tagline: "Counted every variation",
  tier: "diamond",
  required: 132
},
{
  id: "standout_performance",
  icon: "üåü",
  title: "Standout Performance",
  tagline: "Solved with confidence",
  tier: "diamond",
  required: 135
},
{
  id: "balanced_mind",
  icon: "üß†",
  title: "Balanced Mind",
  tagline: "Attack and defense in harmony",
  tier: "diamond",
  required: 138
},
{
  id: "creative_spark",
  icon: "ü™Ñ",
  title: "Creative Spark",
  tagline: "Found an unexpected idea",
  tier: "diamond",
  required: 141
},
{
  id: "pin_master",
  icon: "üß∑",
  title: "Pin Master",
  tagline: "Used restriction to win",
  tier: "diamond",
  required: 144
},
{
  id: "flow_state",
  icon: "üåä",
  title: "Flow State",
  tagline: "Everything felt natural",
  tier: "diamond",
  required: 147
},
{
  id: "silent_killer",
  icon: "üß†",
  title: "Silent Killer",
  tagline: "Won without unnecessary risk",
  tier: "diamond",
  required: 150
},
{
  id: "trap_setter",
  icon: "ü™§",
  title: "Trap Setter",
  tagline: "Lured the opponent in",
  tier: "diamond",
  required: 153
},
{
  id: "firefighter",
  icon: "üßØ",
  title: "Firefighter",
  tagline: "Extinguished the threat",
  tier: "diamond",
  required: 156
},
{
  id: "clarity_moment",
  icon: "üåü",
  title: "Clarity Moment",
  tagline: "Everything made sense",
  tier: "diamond",
  required: 159
},
{
  id: "master_focus",
  icon: "üß†",
  title: "Master Focus",
  tagline: "Locked in from start to finish",
  tier: "diamond",
  required: 162
},
{
  id: "hook_and_win",
  icon: "ü™ù",
  title: "Hook & Win",
  tagline: "Forced the opponent‚Äôs hand",
  tier: "diamond",
  required: 165
},
{
  id: "iron_wall_elite",
  icon: "üß±",
  title: "Iron Wall Elite",
  tagline: "Nothing broke through",
  tier: "diamond",
  required: 168
},
{
  id: "peak_moment",
  icon: "üåü",
  title: "Peak Moment",
  tagline: "Played at your absolute best",
  tier: "diamond",
  required: 171
},
{
  id: "balanced_pressure",
  icon: "‚öñÔ∏è",
  title: "Balanced Under Pressure",
  tagline: "Stayed accurate in tense moments",
  tier: "diamond",
  required: 174
},
{
  id: "endgame_grip",
  icon: "‚ôú",
  title: "Endgame Grip",
  tagline: "Converted with technique",
  tier: "diamond",
  required: 177
},
{
  id: "tactical_instinct",
  icon: "‚ö°",
  title: "Tactical Instinct",
  tagline: "Spotted danger instantly",
  tier: "diamond",
  required: 180
},
{
  id: "positional_anchor",
  icon: "‚öì",
  title: "Positional Anchor",
  tagline: "Held the structure firm",
  tier: "diamond",
  required: 183
},
{
  id: "critical_decision",
  icon: "üß†",
  title: "Critical Decision",
  tagline: "Chose the right moment",
  tier: "diamond",
  required: 186
},
{
  id: "counterplay_master",
  icon: "üîÑ",
  title: "Counterplay Master",
  tagline: "Turned defense into attack",
  tier: "diamond",
  required: 189
},
{
  id: "unstoppable",
  icon: "üöÄ",
  title: "Unstoppable",
  tagline: "Momentum could not be broken",
  tier: "diamond",
  required: 192
},
{
  id: "elite_composure",
  icon: "üßä",
  title: "Elite Composure",
  tagline: "Ice-cold accuracy throughout",
  tier: "diamond",
  required: 195
},
{
  id: "precision_path",
  icon: "üìê",
  title: "Precision Path",
  tagline: "Every move had a purpose",
  tier: "diamond",
  required: 198
},
{
  id: "initiative_holder",
  icon: "üéØ",
  title: "Initiative Holder",
  tagline: "Kept control of the pace",
  tier: "diamond",
  required: 201
},
{
  id: "calm_converter",
  icon: "üß†",
  title: "Calm Converter",
  tagline: "Turned advantage into a win",
  tier: "diamond",
  required: 204
},
{
  id: "resource_finder",
  icon: "üîç",
  title: "Resource Finder",
  tagline: "Found the hidden saving idea",
  tier: "diamond",
  required: 207
},
{
  id: "structural_mastery",
  icon: "üß±",
  title: "Structural Mastery",
  tagline: "Pawn structure under control",
  tier: "diamond",
  required: 210
},
{
  id: "timing_expert",
  icon: "‚è±Ô∏è",
  title: "Timing Expert",
  tagline: "Struck at the perfect moment",
  tier: "diamond",
  required: 213
},
{
  id: "positional_squeeze",
  icon: "üß≤",
  title: "Positional Squeeze",
  tagline: "Slow pressure paid off",
  tier: "diamond",
  required: 216
},
{
  id: "grand_composure",
  icon: "üëë",
  title: "Grand Composure",
  tagline: "Elite calm, elite control",
  tier: "diamond",
  required: 219
},
{
  id: "ultimate_precision",
  icon: "üéØ",
  title: "Ultimate Precision",
  tagline: "Accuracy reached another level",
  tier: "diamond",
  required: 222
},
{
  id: "calculatio_master",
  icon: "üßÆ",
  title: "Calculatio Master",
  tagline: "Nothing left uncalculated",
  tier: "diamond",
  required: 225
},
{
  id: "positional_dominator",
  icon: "üß±",
  title: "Positional Dominator",
  tagline: "Controlled every square",
  tier: "diamond",
  required: 228
},
{
  id: "tactical_supremacy",
  icon: "‚öîÔ∏è",
  title: "Tactical Supremacy",
  tagline: "Tactics decided everything",
  tier: "diamond",
  required: 231
},
{
  id: "grandmaster_mindset",
  icon: "üß†",
  title: "Grandmaster Mindset",
  tagline: "Thinking like an elite player",
  tier: "diamond",
  required: 234
},
{
  id: "unstoppable_force",
  icon: "üöÄ",
  title: "Unstoppable Force",
  tagline: "Nothing could slow you down",
  tier: "diamond",
  required: 237
},
{
  id: "olympus_legend",
  icon: "üèîÔ∏è",
  title: "Olympus Legend",
  tagline: "A true master of Olympus",
  tier: "diamond",
  required: 240
},
{
  id: "mythic_control",
  icon: "üî±",
  title: "Mythic Control",
  tagline: "Ruled the board like a god",
  tier: "mythic",
  required: 243
},
{
  id: "absolute_calculatio",
  icon: "üì°",
  title: "Absolute Calculatio",
  tagline: "Saw beyond all variations",
  tier: "mythic",
  required: 246
},
{
  id: "immovable_empire",
  icon: "üèõÔ∏è",
  title: "Immovable Empire",
  tagline: "Position stood unbreakable",
  tier: "mythic",
  required: 249
},
{
  id: "divine_precision",
  icon: "‚ú®",
  title: "Divine Precision",
  tagline: "Every move felt inevitable",
  tier: "mythic",
  required: 252
},
{
  id: "olympus_ascended",
  icon: "‚ö°",
  title: "Olympus Ascended",
  tagline: "You surpassed legend status",
  tier: "mythic",
  required: 255
},
{
  id: "eternal_focus",
  icon: "üïØÔ∏è",
  title: "Eternal Focus",
  tagline: "Concentration never wavered",
  tier: "mythic",
  required: 258
},
{
  id: "sovereign_pressure",
  icon: "üëë",
  title: "Sovereign Pressure",
  tagline: "Dominated without forcing",
  tier: "mythic",
  required: 261
},
{
  id: "unbreakable_will",
  icon: "üßø",
  title: "Unbreakable Will",
  tagline: "Held firm in impossible positions",
  tier: "mythic",
  required: 264
},
{
  id: "checkmate_instinct",
  icon: "‚ôüÔ∏è",
  title: "Checkmate Instinct",
  tagline: "You sensed the end before it came",
  tier: "mythic",
  required: 267
},
{
  id: "heir_of_olympus",
  icon: "üè∫",
  title: "Heir of Olympus",
  tagline: "Legacy worthy of the gods",
  tier: "mythic",
  required: 270
},
{
  id: "timeless_patience",
  icon: "‚è≥",
  title: "Timeless Patience",
  tagline: "Waited for the perfect moment",
  tier: "mythic",
  required: 273
},
{
  id: "absolute_dominion",
  icon: "üåç",
  title: "Absolute Dominion",
  tagline: "Every square answered to you",
  tier: "mythic",
  required: 276
},
{
  id: "flawless_judgment",
  icon: "‚öñÔ∏è",
  title: "Flawless Judgment",
  tagline: "Never chose the wrong path",
  tier: "mythic",
  required: 279
},
{
  id: "endless_clarity",
  icon: "üí†",
  title: "Endless Clarity",
  tagline: "Complexity became simple",
  tier: "mythic",
  required: 282
},
{
  id: "chosen_of_olympus",
  icon: "üî•",
  title: "Chosen of Olympus",
  tagline: "The gods took notice",
  tier: "mythic",
  required: 285
},
{
  id: "eternal_mastery",
  icon: "‚ôæÔ∏è",
  title: "Eternal Mastery",
  tagline: "Skill that transcends time",
  tier: "mythic",
  required: 288
},
{
  id: "divine_equilibrium",
  icon: "‚òØÔ∏è",
  title: "Divine Equilibrium",
  tagline: "Perfect balance of attack and defense",
  tier: "mythic",
  required: 291
},
{
  id: "omniscient_vision",
  icon: "üëÅÔ∏è",
  title: "Omniscient Vision",
  tagline: "Nothing on the board was hidden",
  tier: "mythic",
  required: 294
},
{
  id: "hand_of_fate",
  icon: "‚úã",
  title: "Hand of Fate",
  tagline: "Games bent to your will",
  tier: "mythic",
  required: 297
},
{
  id: "olympus_immortal",
  icon: "üèõÔ∏è",
  title: "Olympus Immortal",
  tagline: "Your name is carved forever",
  tier: "mythic",
  required: 300
},
{
  id: "beyond_olympus",
  icon: "üúè",
  title: "Beyond Olympus",
  tagline: "Even the gods were left behind",
  tier: "transcendent",
  required: 303
},
{
  id: "silent_ascent",
  icon: "üå´Ô∏è",
  title: "Silent Ascent",
  tagline: "No applause was needed",
  tier: "transcendent",
  required: 306
},
{
  id: "timeless_player",
  icon: "‚åõ",
  title: "Timeless Player",
  tagline: "Time stopped measuring progress",
  tier: "transcendent",
  required: 309
},
{
  id: "board_without_edges",
  icon: "üß≠",
  title: "Board Without Edges",
  tagline: "There were no limits left",
  tier: "transcendent",
  required: 312
},
{
  id: "inevitable_truth",
  icon: "üîÆ",
  title: "Inevitable Truth",
  tagline: "The correct move always appeared",
  tier: "transcendent",
  required: 315
},
{
  id: "calm_before_eternity",
  icon: "üåä",
  title: "Calm Before Eternity",
  tagline: "Nothing rushed, nothing forced",
  tier: "transcendent",
  required: 318
},
{
  id: "observer_of_outcomes",
  icon: "üëÅÔ∏è",
  title: "Observer of Outcomes",
  tagline: "Wins and losses lost meaning",
  tier: "transcendent",
  required: 321
},
{
  id: "the_unending_game",
  icon: "‚ôæÔ∏è",
  title: "The Unending Game",
  tagline: "There was never a finish line",
  tier: "transcendent",
  required: 324
},
{
  id: "motionless_control",
  icon: "ü™∂",
  title: "Motionless Control",
  tagline: "Everything moved without force",
  tier: "transcendent",
  required: 327
},
{
  id: "pattern_dissolved",
  icon: "üí†",
  title: "Pattern Dissolved",
  tagline: "Recognition gave way to intuition",
  tier: "transcendent",
  required: 330
},
{
  id: "ineffable_move",
  icon: "‚ú®",
  title: "Ineffable Move",
  tagline: "It could not be explained",
  tier: "transcendent",
  required: 333
},
{
  id: "beyond_calculatio",
  icon: "üìø",
  title: "Beyond Calculatio",
  tagline: "Numbers stopped helping",
  tier: "transcendent",
  required: 338
},
{
  id: "quiet_dominion",
  icon: "üèîÔ∏è",
  title: "Quiet Dominion",
  tagline: "Control without resistance",
  tier: "transcendent",
  required: 341
},
{
  id: "inevitable_victory",
  icon: "üïäÔ∏è",
  title: "Inevitable Victory",
  tagline: "The end was known long ago",
  tier: "transcendent",
  required: 344
},
{
  id: "clarity_without_thought",
  icon: "üí≠",
  title: "Clarity Without Thought",
  tagline: "Decisions arrived fully formed",
  tier: "transcendent",
  required: 347
},
{
  id: "board_as_language",
  icon: "üìú",
  title: "Board as Language",
  tagline: "Positions spoke for themselves",
  tier: "transcendent",
  required: 350
},
{
  id: "formless_mastery",
  icon: "ü´•",
  title: "Formless Mastery",
  tagline: "No style could define you",
  tier: "transcendent",
  required: 353
},
{
  id: "beyond_opposition",
  icon: "‚ö™",
  title: "Beyond Opposition",
  tagline: "There was no enemy left",
  tier: "transcendent",
  required: 356
},
{
  id: "echo_of_eternity",
  icon: "üîî",
  title: "Echo of Eternity",
  tagline: "Every game still resonates",
  tier: "transcendent",
  required: 359
},
{
  id: "the_final_silence",
  icon: "üåå",
  title: "The Final Silence",
  tagline: "Nothing remained to be proven",
  tier: "transcendent",
  required: 362
}
















  
];

function loadUnlockedBadges() {
  const saved = localStorage.getItem(BADGE_STORAGE_KEY);
  if (saved) {
    try {
      unlockedBadges = new Set(JSON.parse(saved));
    } catch {
      unlockedBadges = new Set();
    }
  }
}



function renderStudentBadges() {
  const container = document.getElementById("studentBadgeContent");
  if (!container) return;

  container.innerHTML = "";

  STUDENT_BADGES.forEach(badge => {
    const isUnlockable = studentSolvedCount >= badge.required;
    const isUnlocked = unlockedBadges.has(badge.id);

    const card = document.createElement("div");
    card.className = "badge-card";
    card.dataset.badgeId = badge.id;

    if (isUnlocked) card.classList.add("unlocked");
    else if (!isUnlockable) card.classList.add("locked");

    let actionHTML = "";

    if (isUnlocked) {
      actionHTML = `<div class="badge-unlocked-mark">üèÜ</div>`;
    } else if (isUnlockable) {
      actionHTML = `<button class="badge-unlock-btn">Unlock</button>`;
    } else {
      actionHTML = `<div class="badge-lock">üîí</div>`;
    }

    card.innerHTML = `
      <div class="badge-icon">${badge.icon}</div>
      <div class="badge-title">${badge.title}</div>
      <div class="badge-tagline">${badge.tagline}</div>
      ${actionHTML}
    `;

    container.appendChild(card);
  });

  attachBadgeUnlockHandlers();
}




// ================================
// STUDENT BADGES ‚Äî UNLOCK HANDLER
// STEP 4D
// ================================
function attachBadgeUnlockHandlers() {
  const buttons = document.querySelectorAll(".badge-unlock-btn");

  buttons.forEach(btn => {
    btn.addEventListener("click", e => {
      const card = e.target.closest(".badge-card");
      const badgeId = card?.dataset.badgeId;
      if (!badgeId) return;

      // üîì mark unlocked
      unlockedBadges.add(badgeId);

      // üíæ persist
      localStorage.setItem(
        BADGE_STORAGE_KEY,
        JSON.stringify([...unlockedBadges])
      );

      // üéâ celebration (glitter + sound)
      triggerCelebration();

      // üèÜ POP OUT ‚Üí POP BACK (2s)
      card.classList.add("badge-pop-animate");

      // üîÑ re-render AFTER animation
      setTimeout(() => {
        renderStudentBadges();
      }, 2000);
    });
  });
}






// ================================
// STUDENT BADGES ‚Äî UNLOCK CHECK
// STEP 4B (NO UI)
// ================================
function getUnlockableBadges() {
  if (!Array.isArray(STUDENT_BADGES)) return [];

  return STUDENT_BADGES.filter(
    badge => studentSolvedCount >= badge.required
  );
}


// ================================
// üéâ CELEBRATION SYSTEM
// ================================
function triggerCelebration() {
  const overlay = document.getElementById("celebrationOverlay");
  const sound = document.getElementById("celebrationSound");

  if (!overlay) return;

  overlay.innerHTML = "";
  overlay.classList.remove("hidden");

  // üîä Play sound (safe for browsers)
  if (sound) {
    sound.currentTime = 0;
    sound.volume = 0.6;
    sound.play().catch(() => {});
  }

  // ‚ú® Create glitter particles
  const COUNT = 300;

const COLORS = [
  "#ffd700",
  "#ff6ec7",
  "#38bdf8",
  "#a855f7",
  "#22c55e",
  "#f97316"
];

for (let i = 0; i < COUNT; i++) {
  const g = document.createElement("div");
  g.className = "glitter";

  const color = COLORS[Math.floor(Math.random() * COLORS.length)];

  g.style.left = Math.random() * 100 + "vw";
  g.style.animationDuration = 3 + Math.random() * 4 + "s";
  g.style.animationDelay = Math.random() * 0.6 + "s";
  g.style.transform = `scale(${0.4 + Math.random() * 1.2})`;

  g.style.background = `radial-gradient(circle, ${color}, white)`;

  overlay.appendChild(g);
}


  // üßπ Cleanup
  setTimeout(() => {
    overlay.classList.add("hidden");
    overlay.innerHTML = "";
  }, 6000);
}




    





    async function joinLiveClass() {
      console.log('‚ñ∂ Join Live Class clicked'); // üëà ADD THIS LINE
  if (!currentProfile) return;

  // get active live session
  const { data: session, error: sessionError } = await supabase
    .from('live_sessions')
    .select('id')
    .eq('status', 'active')
    .single();

  if (sessionError || !session) {
  showModal(
    "üö´ Live Class Unavailable",
    "<p>The live class is not available right now.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}







  // check already joined
  const { data: existing } = await supabase
    .from('live_participants')
    .select('id')
    .eq('session_id', session.id)
    .eq('student_id', currentProfile.id)
    .single();

  if (!existing) {
    await supabase.from('live_participants').insert({
      session_id: session.id,
      student_id: currentProfile.id
    });
  }

  document.getElementById('joinLiveBtn').textContent = '‚úÖ Joined Live Class';
  document.getElementById('joinLiveBtn').disabled = true;
  document.getElementById('joinLiveBtn').style.display = 'none';
document.getElementById('liveWaitingPanel').style.display = 'block';

}

document.getElementById("clearAddStudentBtn")?.addEventListener("click", () => {
  const userInput = document.getElementById("newStudentUser");
  const passInput = document.getElementById("newStudentPass");

  if (userInput) userInput.value = "";
  if (passInput) passInput.value = "";

  // optional: put cursor back on username
  userInput?.focus();
});


// ‚úÖ Load joined students for admin (live view)
async function loadLiveJoinedStudents(sessionId) {
  const list = document.getElementById('liveJoinedList');
  const box = document.getElementById('liveJoinedBox');

  if (!list || !box) return;

  const { data, error } = await supabase
    .from('live_participants')
    .select('student_id, profiles(username)')
    .eq('session_id', sessionId);

  if (error) {
    console.error('Failed to load joined students:', error);
    return;
  }

  list.innerHTML = '';

  if (!data || data.length === 0) {
    list.innerHTML = '<li>No students joined yet</li>';
  } else {
    data.forEach(row => {
      const li = document.createElement('li');
      li.textContent = row.profiles?.username || 'Student';
      list.appendChild(li);
    });
  }

  box.style.display = 'block';
}

// ==============================
// PGN FILE IMPORT (Assignments)
// ==============================
document.getElementById('importPgnBtn')?.addEventListener('click', () => {
  document.getElementById('pgnFileInput').click();
});

document.getElementById('pgnFileInput')?.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  if (!file.name.endsWith('.pgn')) {
  showModal(
    "‚ö†Ô∏è Invalid File",
    "<p>Please select a valid <strong>.pgn</strong> file.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


  const reader = new FileReader();
  reader.onload = () => {
    document.getElementById('assignPGN').value = reader.result.trim();
  };
  reader.readAsText(file);
});

// ================================
// PGN LIBRARY IMPORT (RIGHT PANEL)
// ================================

document.addEventListener("DOMContentLoaded", () => {
  const input = document.getElementById("pgnLibraryFileInput");
  if (!input) return;

  input.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();

    openPGNTitleModal(async (title) => {

  const { error } = await supabase
    .from("bulk_pgn_library")
    .insert({
      title,
      pgn: text,
      is_active: true
    });

  if (error) {
    console.error(error);
    alert("Failed to import PGN");
    return;
  }

  showModal(
  "üìö PGN Imported",
  "<p>PGN imported into the library successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

loadPGNLibrary();

});


    const { error } = await supabase
      .from("bulk_pgn_library")
      .insert({
        title,
        pgn: text,
        is_active: true
      });

    if (error) {
      console.error(error);
      alert("Failed to import PGN");
      return;
    }

    showModal(
  "üìö PGN Imported",
  "<p>PGN imported into the library successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

loadPGNLibrary();

  });
});

const analyzeBtn = document.getElementById("analyzeBtn");
if (analyzeBtn) {
  analyzeBtn.addEventListener("click", () => {
    if (!engineReady) {
      console.warn("‚è≥ Engine not ready");
      return;
    }

    if (isAssignmentMode && currentProfile.role === "student") {
  console.warn("‚õî Student engine blocked during assignment");
  return;
}


    // üîÅ TOGGLE MODE
    if (engineRunning) {
      stopEngine();
    } else {
      startEngine();
    }
  });
}


document.addEventListener("click", (e) => {
  const name = e.target.closest(".student-name");
  if (!name) return;

  const studentId = name.dataset.studentId;
  const username = name.textContent.trim();

  openStudentModal(studentId, username);
});






    // ============================================
    // INIT
    // ============================================
    async function initApp() {
      console.log('üöÄ Initializing application...');

      try {
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
          console.log('No user found, redirecting to login...');
          window.location.href = 'login.html';
          return;
        }
        currentUser = user;

       



        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', user.id)
          .single();

        if (profileError || !profile) {
  showModal(
    "‚ö†Ô∏è Account Issue",
    "<p>Your account is not properly set up.<br>Please contact the administrator.</p>"
  );

  await supabase.auth.signOut();

  setTimeout(() => {
    window.location.href = 'login.html';
  }, 2000);

  return;
}

        if (!profile.active) {
  showModal(
    "üö´ Account Deactivated",
    "<p>Your account has been deactivated.<br>Please contact the administrator.</p>"
  );

  await supabase.auth.signOut();

  setTimeout(() => {
    window.location.href = 'login.html';
  }, 2000);

  return;
}


        currentProfile = profile;

        updateRatingsFromProfile(currentProfile);

        // üèÜ Load Best Scores (AFTER profile is ready)
loadMyBestScores();

        // üîê PER-STUDENT BADGE STORAGE
BADGE_STORAGE_KEY = `unlocked_badges_${currentProfile.id}`;
loadUnlockedBadges();


        

        const joinBtn = document.getElementById('joinLiveBtn');
    if (joinBtn) {
      joinBtn.addEventListener('click', joinLiveClass);
    }
        document.getElementById('userInfo').textContent =
          `${profile.role} ‚Ä¢ ${profile.username || user.email.split('@')[0]}`;

          // üîí ROLE FLAGS (GUARANTEED TO RUN)
document.body.classList.remove("student-view", "teacher-view", "admin-view");

if (profile.role === "admin") {
  document.body.classList.add("admin-view");
} else {
  // EVERYTHING that is not admin = student UI
  document.body.classList.add("student-view");
}

// ‚úÖ STUDENT: load progress once profile is ready
if (profile.role === "student") {
  loadStudentProgress();
}



console.log("ROLE APPLIED:", profile.role, document.body.className);

// ================================
// STUDENT BADGE PANEL VISIBILITY
// ================================
const badgePanel = document.getElementById("studentBadgePanel");

if (badgePanel) {
  if (currentProfile?.role !== "student") {
    badgePanel.remove(); // completely remove for teacher/admin
  }
}





        if (profile.role === 'admin') {
          document.getElementById('adminTab').style.display = 'inline-block';
          document.getElementById('attemptsTab').style.display = 'inline-block';
          document.getElementById('createAssignmentForm').style.display = 'block';
          document.getElementById('adminContent').style.display = 'block';
          document.getElementById('adminAccessDenied').style.display = 'none';
          document.getElementById('pgnUploadSection').style.display = 'block';
          document.getElementById('assignStudentsRow').style.display = 'block';
          // Live classroom admin controls
const liveAdmin = document.getElementById('liveAdminControls');
if (liveAdmin && profile.role === 'admin') {
  liveAdmin.style.display = 'block';
}
// live classroom student selector (checkbox list)
const liveSelector = document.getElementById('liveStudentSelector');
if (liveSelector && profile.role === 'admin') {
  liveSelector.style.display = 'block';
}

if (currentProfile.role !== "admin") {
  document.body.classList.add("student-view");
}


if (currentProfile.role === "student") {
  document.body.classList.add("student-view");
  loadStudentProgress();
}






          loadStudents();
          loadStudentsForAssignment();
          loadStudentsForAssignment2();
          loadAttempts();
        } else {
          document.getElementById('adminTab').style.display = 'none';
          document.getElementById('attemptsTab').style.display = 'none';
          document.getElementById('createAssignmentForm').style.display = 'none';
          document.getElementById('adminContent').style.display = 'none';
          document.getElementById('adminAccessDenied').style.display = 'block';
          const pgnSection = document.getElementById('pgnUploadSection');

// Admin & Student ‚Üí BOTH can load PGN
pgnSection.style.display = 'block';

// Admin-only extras (if you add later)
if (profile.role !== 'admin') {
  // students should NOT see PGN library delete / admin tools
  document.querySelectorAll('.admin-only').forEach(el => {
    el.style.display = 'none';
  });
}


        }

        setupEventListeners();
        loadAssignments();
        loadPGNLibrary();
        loadQuizPuzzle();
        


        initChessboard();
        wireMoveInput();
        setupKeyboardNavigation();
        initStockfish();

        // üî¥üü¢ Live classroom status
        updateLiveClassStatus();
        wireLiveClassButtons();
        setInterval(updateLiveClassStatus, 10000); // optional but recommended
        loadStudentsForLiveClass();
        checkStudentLiveAccess();


        showCreateFormIfAdmin();


        startLiveBtn.addEventListener('click', async () => {
  if (currentProfile.role !== 'admin') return;

  // Check if already running
  const { data } = await supabase
    .from('live_sessions')
    .select('id')
    .eq('status', 'active')
    .limit(1);

  if (data && data.length > 0) {
  showModal(
    "üé• Live Class Started",
    "<p>The live class has started successfully!</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1500);

  return;
}


  const { error } = await supabase
    .from('live_sessions')
    .insert([{
      title: 'Live Class',
      created_by: currentProfile.id,
      status: 'active'
    }]);

  if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to start the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


  updateLiveClassStatus();
});

endLiveBtn.addEventListener('click', async () => {
  if (currentProfile.role !== 'admin') return;

  const { error } = await supabase
    .from('live_sessions')
    .update({ status: 'ended' })
    .eq('status', 'active');

    

  if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to end the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


  updateLiveClassStatus();
});

const confirmLiveBtn = document.getElementById('confirmLiveStudentsBtn');

if (confirmLiveBtn) {
  confirmLiveBtn.addEventListener('click', async () => {
    if (currentProfile.role !== 'admin') return;

    // 1Ô∏è‚É£ Collect selected students
    const checked = document.querySelectorAll(
      '#liveStudentsList input[type="checkbox"]:checked'
    );

    if (checked.length === 0) {
  showModal(
    "‚ö†Ô∏è No Student Selected",
    "<p>Please select at least one student.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}


    // 2Ô∏è‚É£ Create live session (ONE only)
    const { data: session, error: sessionError } = await supabase
      .from('live_sessions')
      .insert([{
        title: 'Live Class',
        created_by: currentProfile.id,
        status: 'active'
      }])
      .select()
      .single();

    if (sessionError) {
  console.error(sessionError);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to start the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


    // 3Ô∏è‚É£ Insert selected students into live_participants
    const participants = [...checked].map(cb => ({
      session_id: session.id,
      student_id: cb.value
    }));

    const { error: partError } = await supabase
      .from('live_participants')
      .insert(participants);

    if (partError) {
  console.error(partError);

  showModal(
    "‚ùå Error",
    "<p>Failed to add students.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


    // 4Ô∏è‚É£ Update UI
    updateLiveClassStatus();

showModal(
  "üé• Live Class Started",
  "<p>Live class started successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);
});
}




        


        document.getElementById('clearAssignmentFormBtn')?.addEventListener('click', () => {
          ['assignTitle','assignType','assignDesc','assignDue','assignFEN','assignPGN'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            if (el.tagName === 'SELECT') el.selectedIndex = 0;
            else el.value = '';
          });
        });

      } catch (error) {
        console.error('Initialization error:', error);
        alert('Error initializing application. Please refresh.');
        window.location.href = 'login.html';
      }
    }

    document.addEventListener("click", async function (event) {
  const action = event.target.dataset.action;
  const id = event.target.dataset.id;

  if (!action) return;

  if (action === "test" || action === "start") {
    console.log("Starting assignment:", id);
    startAssignmentMode(id);
  }

  if (action === "view") {
    openAssignmentDetails(id);
  }
});




    // Add this to your existing event setup
document.getElementById('assignmentsList').addEventListener('click', (e) => {
  const button = e.target.closest('button');
  if (!button) return;
  
  const action = button.dataset.action;
  const assignmentId = button.dataset.id;
  
  if (!action || !assignmentId) return;
  
  if (action === 'start') {
    startAssignmentMode(assignmentId);
  } else if (action === 'test') {
    testAssignment(assignmentId);
  } else if (action === 'view') {
    viewAssignment(assignmentId);
  }
});

function wireLiveClassButtons() {
  const startLiveBtn = document.getElementById('startLiveBtn');
  const endLiveBtn = document.getElementById('endLiveBtn');

  if (startLiveBtn) {
    startLiveBtn.onclick = async () => {
      if (currentProfile.role !== 'admin') return;

      const { error } = await supabase
        .from('live_sessions')
        .insert([{
          title: 'Live Class',
          created_by: currentProfile.id,
          status: 'active'
        }]);

      if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to start the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


      updateLiveClassStatus();
    };
  }

  if (endLiveBtn) {
    endLiveBtn.onclick = async () => {
      const { error } = await supabase
        .from('live_sessions')
        .update({ status: 'ended' })
        .eq('status', 'active');

      if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to end the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


      updateLiveClassStatus();
    };
  }
}

const pgnInput = document.getElementById("pgnLibraryFileInput");

if (pgnInput) {
  pgnInput.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();

    

    const { error } = await supabase
      .from("bulk_pgn_library")
      .insert({
        title,
        pgn: text,
        is_active: true
      });

    if (error) {
      console.error(error);
      alert("Failed to import PGN");
      return;
    }

    showModal(
  "üìö PGN Imported",
  "<p>PGN imported into the library successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

loadPGNLibrary();

  });
}

document.addEventListener("click", async (e) => {
  const btn = e.target.closest(".reattempt-btn");
  if (!btn) return;

  const assignmentId = Number(btn.dataset.assignmentId);
  if (!assignmentId) return;

  await reattemptAssignment(assignmentId);
});

document.addEventListener("click", async (e) => {
  const btn = e.target.closest(".view-details-btn");
  if (!btn) return;

  const assignmentId = Number(btn.dataset.assignmentId);
  if (!assignmentId) return;

  await viewAssignmentDetailsForStudent(assignmentId);
});


// ===============================
// GLOBAL TAB ROUTER (DATA-TAB BASED)
// ===============================
document.addEventListener('click', e => {
  const btn = e.target.closest('.nav-btn[data-tab]')
  if (!btn) return

  const tab = btn.dataset.tab
  const targetId = `${tab}-section`

  // Hide all sections
  document.querySelectorAll('.section').forEach(s => {
    s.style.display = 'none'
  })

  // Show target
  const target = document.getElementById(targetId)
  if (target) {
    target.style.display = 'block'
  } else {
    console.warn('No section found for:', targetId)
  }
})



    // ============================================
    // UI EVENTS
    // ============================================

    function resetQuiz() {
  stopQuizTimer();
  quizActive = false;
  quizScore = 0;
  updateScoreUI();

  timeLeft = 0;
  updateTimerUI();

  const modal = document.getElementById("quizResultModal");
  if (modal) modal.classList.add("hidden");

  console.log("üîÑ Quiz reset");
}


    function stopQuizTimer() {
  if (quizTimer) {
    clearInterval(quizTimer);
    quizTimer = null;
  }
  quizActive = false;
  console.log("üõë Quiz timer stopped");
}
    function setupEventListeners() {
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          const tab = btn.dataset.tab;
          if (tab !== "quiz") {
  resetQuiz();
}

          document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
          document.getElementById(`${tab}-section`).classList.add('active');
          // üß© Board Editor ‚Äì init AFTER section becomes visible
if (tab === 'editor') {
  setTimeout(() => {
    initEditorBoard();

    if (editorBoard) {
      editorBoard.resize(); // üî• required
    }
  }, 50);
}


          // üî¥üü¢ IMPORTANT: when Live tab opens, wire buttons
if (tab === 'live') {
  wireLiveClassButtons();
}

// ü§ñ Play vs Computer ‚Äî init board
if (tab === 'computer') {
  setTimeout(initVsComputerBoard, 0);
}

if (tab === 'study') {
  // init board (ONLY once, function handles guard)
  initStudyBoard();

  // study UI + logic
  loadStudyDropdown();
  initStudyEngine();
  analyzeStudyPosition();
}


if (tab !== "study" && studyEngine) {
  studyEngine.postMessage("stop");
}

          if (tab === 'students' && currentProfile.role !== 'admin') {
            alert('Access denied. Admin only.');
            document.querySelector('[data-tab="board"]').click();
          }
          if (tab === 'attempts' && currentProfile.role !== 'admin') {
            alert('Access denied. Admin only.');
            document.querySelector('[data-tab="board"]').click();
          }
        });
      });

      document.getElementById('logoutBtn').addEventListener('click', () => {
  openGradeConfirm(
    "üö™ Confirm Logout",
    "<p>Are you sure you want to logout?</p>",
    async () => {
      await supabase.auth.signOut();
      sessionStorage.clear();
      window.location.href = 'login.html';
    }
  );
});

document.getElementById("quizResultBtn")?.addEventListener("click", () => {
  document.getElementById("quizResultModal").classList.add("hidden");
});


    }

    function wireMoveInput() {
      const moveInput = document.getElementById('moveInput');
      document.getElementById('applyMoveBtn')?.addEventListener('click', applyMoveFromInput);
      moveInput?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') applyMoveFromInput();
      });
    }

    


    function setupKeyboardNavigation() {
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch(e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            pgnPrevMove();
            break;
          case 'ArrowRight':
            e.preventDefault();
            pgnNextMove();
            break;
          case 'Home':
            e.preventDefault();
            pgnFirstMove();
            break;
          case 'End':
            e.preventDefault();
            pgnLastMove();
            break;
          case 'r':
          case 'R':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              resetBoard();
            }
            break;
          case 'u':
          case 'U':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              undoMove();
              // üî• keep engine in sync
    if (engineRunning) updateEnginePosition();
            }
            break;
          case 'f':
          case 'F':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              flipBoard();
            }
            break;
          case 'p':
          case 'P':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              copyPGN();
            }
            break;
          case 'Escape':
            e.preventDefault();
            if (isPGNLoaded) {
              pgnLastMove();
            }
            clearAllDrawings();
            break;
        }
      });
    }

    function sanitizePGN(raw) {
  if (!raw) return "";

  return raw
    .split("\n")
    .filter(line => !line.startsWith("["))
    .join(" ")
    .replace(/\s+/g, " ")
    .trim();
}




    function showCreateFormIfAdmin() {
      try {
        const form = document.getElementById('createAssignmentForm');
        if (!form) return;
        if (currentProfile && currentProfile.role === 'admin') {
          form.style.display = 'block';
        } else {
          form.style.display = 'none';
        }
      } catch (e) {
        console.warn('showCreateFormIfAdmin error', e);
      }
    }

    // Quiz set up //

    // üîä Quiz Sounds
const quizSounds = {
  next: new Audio("sounds/next.mp3"),
  wrong: new Audio("sounds/wrong.mp3"),
  party: new Audio("sounds/party.mp3")
};

function playQuizSound(type) {
  const s = quizSounds[type];
  if (!s) return;
  s.currentTime = 0;
  s.volume = 0.8;
  s.play().catch(() => {});
}

// üîì unlock audio on first user interaction (IMPORTANT)
document.addEventListener("click", unlockQuizAudio, { once: true });
document.addEventListener("keydown", unlockQuizAudio, { once: true });

function unlockQuizAudio() {
  Object.values(quizSounds).forEach(a => {
    a.volume = 0;
    a.play().then(() => {
      a.pause();
      a.currentTime = 0;
      a.volume = 0.9;
    }).catch(() => {});
  });
}

    

   async function loadQuizPuzzle() {
  console.log("üß© Loading quiz puzzle...");

  // 1Ô∏è‚É£ Get total count
  const { count, error: countError } = await supabase
    .from("puzzle_rush_mate1")
    .select("*", { count: "exact", head: true });

  if (countError || !count) {
    console.error("‚ùå Failed to get puzzle count", countError);
    return;
  }

  // 2Ô∏è‚É£ Pick random index
  const randomIndex = Math.floor(Math.random() * count);

  // 3Ô∏è‚É£ Fetch that one row
  const { data, error } = await supabase
    .from("puzzle_rush_mate1")
    .select("fen, solution, side_to_move")
    .eq("is_active", true)
    .range(randomIndex, randomIndex)
    .single();

  if (error || !data) {
    console.error("‚ùå Failed to load puzzle", error);
    return;
  }

  console.log("‚úÖ Puzzle loaded:", data);
  setupQuizPosition(data);
  playQuizSound("next");

}


function setupQuizPosition(puzzle) {
  if (!quizBoard) {
    console.warn("Quiz board not initialized yet");
    return;
  }

  quizChess.reset();
  quizChess.load(puzzle.fen);

  quizBoard.orientation(
    puzzle.side_to_move === "b" ? "black" : "white"
  );

  quizBoard.position(puzzle.fen);


  // Normalize solution (remove + or # if present)
  currentQuizSolution = puzzle.solution.replace(/[+#]/g, "");

  generateQuizOptions();
  startQuizTimer(); // üî•

  console.log("üéØ Correct solution:", currentQuizSolution);
}

function generateQuizOptions() {
  const legalMoves = quizChess.moves({ verbose: true });

  // Find correct move object
  const correctMove = legalMoves.find(m =>
    m.san.replace(/[+#]/g, "") === currentQuizSolution
  );

  if (!correctMove) {
    console.error("‚ùå Correct move not found in legal moves");
    return;
  }

  // Collect wrong moves
  const wrongMoves = legalMoves
    .filter(m => m !== correctMove)
    .sort(() => Math.random() - 0.5)
    .slice(0, 3);

  // Combine + shuffle
  currentOptions = [correctMove, ...wrongMoves]
    .sort(() => Math.random() - 0.5);

  // Render buttons
  document.querySelectorAll(".quiz-option").forEach((btn, i) => {
    btn.textContent = currentOptions[i].san;
    btn.dataset.correct =
      currentOptions[i] === correctMove ? "1" : "0";
  });

  console.log("üß† Options generated:", currentOptions.map(m => m.san));
}

document.querySelectorAll(".quiz-option").forEach(btn => {
  btn.onclick = () => {
    if (!quizActive) return;

    clearInterval(quizTimer);
    quizActive = false;

    if (btn.dataset.correct === "1") {
      // ‚úÖ CORRECT
      quizScore++;
      updateScoreUI();

      // small delay for UX
      setTimeout(() => {
        loadQuizPuzzle(); // ‚û°Ô∏è NEXT PUZZLE
      }, 300);

    } else {
      // ‚ùå WRONG = GAME OVER
      endQuiz("‚ùå Wrong move!");
      playQuizSound("wrong");

    }
  };
});




function updateTimerUI() {
  document.getElementById("quizTimer").textContent = timeLeft;
}

function updateScoreUI() {
  document.getElementById("quizScore").textContent = quizScore;
}

function startQuizTimer() {
  clearInterval(quizTimer);
  // ‚úÖ RESET warning color
  document
    .querySelector(".quiz-timer")
    .classList.remove("warning");
  timeLeft = 20;
  updateTimerUI();
  quizActive = true;

  quizTimer = setInterval(() => {
    timeLeft--;
    updateTimerUI();

    // ‚ö†Ô∏è low time warning (optional)
    if (timeLeft <= 10) {
      document
        .querySelector(".quiz-timer")
        .classList.add("warning");
    }

    // ‚è± TIME UP = GAME OVER
    if (timeLeft <= 0) {
      clearInterval(quizTimer);
      quizActive = false;
      endQuiz("‚è± Time's up!");
    }
  }, 1000);
}

function endQuiz(reason) {
  stopQuizTimer();
  quizActive = false;

  // ‚úÖ ADD QUIZ XP (cumulative)
  if (quizScore > 0) {
    applyQuizRating(quizScore);
  }

  // üèÜ SAVE BEST SCORE (Quiz)
  saveMiniGameScore("quiz", quizScore);

  // üéØ modal content
  document.getElementById("quizResultTitle").textContent = "Quiz Finished";
  document.getElementById("quizResultText").textContent =
    `${reason}\nFinal Score: ${quizScore}`;

  document.getElementById("quizResultModal").classList.remove("hidden");

  playQuizSound("party");

  // üîÅ reset score AFTER saving
  quizScore = 0;
  updateScoreUI();
}


        document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("mainPawnToggleBtn");
  if (!btn) return;

  btn.addEventListener("click", () => {
    if (!board || !chess) return;

    mainPawnViewActive = !mainPawnViewActive;
    btn.classList.toggle("active", mainPawnViewActive);

    // üîÑ re-render only (NO logic change)
    board.position(chess.fen(), false);
  });
});



// ===============================
// ‚ôüÔ∏è MAIN BOARD PAWN VIEW STATE
// ===============================
let mainPawnViewActive = false;
// ===============================
// ‚ôüÔ∏è MAIN BOARD PIECE THEME RESOLVER
// ===============================
function resolveMainPieceTheme(piece) {
  if (!piece) return "";

  const basePath = getPieceThemePath(currentPieceTheme);
  const type = piece[1].toLowerCase();

  // Pawn + King view
  if (mainPawnViewActive && !["p", "k"].includes(type)) {
    return "";
  }

  return basePath.replace("{piece}", piece);
}




    // ============================================
    // CHESSBOARD.JS SETUP
    // ============================================
    function initChessboard() {
    
      if (typeof Chess === 'undefined') {
        document.getElementById('chessboard').innerHTML =
          '<div style="color:white;text-align:center;padding:40px;">Chess engine failed to load.</div>';
        return;
      }

      chess = new Chess();

      const cfg = {
        draggable: true,
        position: 'start',
        orientation: boardOrientation,
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: resolveMainPieceTheme,

      };



      

      board = Chessboard('chessboard', cfg);
     // üì± Enable mobile swipe flip
enableMobileBoardFlip();
     enableMobileTapMove();


      



      
      // Initialize notation
      initNotation();
      
      // Initialize drawing system
      initDrawingSystem();
      
      window.addEventListener('resize', () => {
  if (board && typeof board.resize === 'function') board.resize();
});






    }

    function onDragStart(source, piece, position, orientation) {
  // ‚ùå Block right-click drag
  if (window.event && window.event.button === 2) {
    return false;
  }

  // ‚ùå Do not allow dragging if game is over
  if (chess.game_over()) return false;

  // ‚ùå Enforce turn
  if (
    (chess.turn() === "w" && piece.search(/^b/) !== -1) ||
    (chess.turn() === "b" && piece.search(/^w/) !== -1)
  ) {
    return false;
  }

  return true;
  
}



async function updateLiveClassStatus() {
  const { data, error } = await supabase
    .from('live_sessions')
    .select('id, status')
    .eq('status', 'active')
    .limit(1);

  if (error) {
    console.error(error);
    return;
  }

  const isLive = data && data.length > 0;

  // UI elements
  const dot = document.getElementById('liveStatusDot');
  const text = document.getElementById('liveStatusText');
  const startBtn = document.getElementById('startLiveBtn');
  const endBtn = document.getElementById('endLiveBtn');



  if (isLive) {
  const activeSessionId = data[0].id;

  dot?.classList.remove('red');
  dot?.classList.add('green');
  if (text) text.textContent = 'Live class is running';

  if (currentProfile.role === 'admin') {
    startBtn.style.display = 'none';
    endBtn.style.display = 'inline-block';

    // ‚úÖ SHOW JOINED STUDENTS (ADMIN ONLY)
    loadLiveJoinedStudents(activeSessionId);
  }
  } else {
    dot?.classList.remove('green');
    dot?.classList.add('red');
    if (text) text.textContent = 'No live class running';

    if (currentProfile.role === 'admin') {
      startBtn.style.display = 'inline-block';
      endBtn.style.display = 'none';
    }
  }
}

async function checkStudentLiveAccess() {
  if (!currentProfile || currentProfile.role !== 'student') return;

  // get active session
  const { data: session } = await supabase
    .from('live_sessions')
    .select('id')
    .eq('status', 'active')
    .single();

  if (!session) return;

  // check if student is allowed
  const { data: allowed } = await supabase
    .from('live_participants')
    .select('id')
    .eq('session_id', session.id)
    .eq('student_id', currentProfile.id)
    .single();

  const joinBtn = document.getElementById('joinLiveBtn');

  if (allowed && joinBtn) {
    joinBtn.style.display = 'inline-block';
  }
}




    function onDrop(source, target) {
  // Assignment mode handling
  if (currentAssignment && expectedMoves.length > 0 && assignmentCursor < expectedMoves.length) {
    const expected = expectedMoves[assignmentCursor];
    
    // Check if it's student's turn
    const studentColor = assignmentColor || "w";
    if (studentColor !== chess.turn()) {
      alert("Not your turn!");
      return "snapback";
    }

    // Student plays move
let move;

// üîÅ Promotion handling (BEFORE chess.move)
if (isPromotionMove(source, target)) {
  showPromotionDialog(source, target);
  return "snapback"; // stop drag, wait for user choice
}

// ‚ñ∂ Normal move (no forced queen)
move = chess.move({
  from: source,
  to: target
});

// ‚ùó correct check
if (!move) return "snapback";

// Check if move matches expected move
if (move.san !== expected.san) {
  attemptCount++;

  playSound('wrong');

  // ‚ùå No alerts
  // ‚ùå No expectedMove.san leakage

  if (currentProfile.role === "admin") {
    showStatus(
      `Wrong move. Attempts: ${attemptCount}`,
      "error"
    );
  } else {
    


    showStatus(
  `Wrong move. Try again. <span style="float:right;">Retry: ${attemptCount}</span>`,
  "error"
);


  }

  chess.undo();
  
  return "snapback";
}
// üîä MOVE / CAPTURE SOUND
if (move.flags.includes('k') || move.flags.includes('q')) {
  // üëë Castling
  playSound('castle');

} else if (move.san.includes('+')) {
  // üîî Check
  playSound('check');

} else if (move.captured) {
  // ‚öîÔ∏è Capture
  playSound('capture');

} else {
  // ‚ôü Normal move
  playSound('move');
}





    // Correct move
    moveHistory.push({
      from: move.from,
      to: move.to,
      san: move.san,
      fen: chess.fen(),
      timestamp: new Date()
    });
    
    fullPGNHistory.push(move);
    pgnCursor++;
    assignmentCursor++;

    

// ================================
// üîÅ BULK PUZZLE COMPLETION CHECK
// ================================
if (currentAssignment.is_bulk && assignmentCursor >= expectedMoves.length) {

  bulkIndex++;

  if (bulkIndex < bulkPuzzles.length) {
    setTimeout(() => {
      playSound("next");
      loadCurrentBulkPuzzle();
    }, 800);
  } else {
    playSound("complete");

    // üèÅ ALL PUZZLES DONE
    showStatus(
      "üéâ All puzzles completed! Submit your assignment.",
      "success"
    );

    // üèÜ +1 rating for completing assignment (ONLY ONCE)
    applyAssignmentRating();

    // Show submit button
    document.getElementById("submitBtn").style.display = "block";
  }

  return; // ‚õî VERY IMPORTANT
}



    // Auto-play opponent's reply if exists
    if (assignmentCursor < expectedMoves.length) {
      const reply = expectedMoves[assignmentCursor];
      setTimeout(() => {
        const autoMove = chess.move(reply.san);
        if (autoMove) {
          // üîä AUTO MOVE SOUND (soft)
  if (autoMove.captured) {
    playSound('capture');
  } else {
    playSound('move');
  }
          fullPGNHistory.push(autoMove);
          pgnCursor++;
          assignmentCursor++;
          board.move(autoMove.from + '-' + autoMove.to);

          updateEnginePosition();
          
          updatePGNViewer();
          renderNotation();
          updateNavigationButtons();
          checkGameEnd();
          

        }
      }, 500);
    }

    
    // üî• UPDATE ENGINE AFTER PLAYER MOVE
updateEnginePosition();

    // Update board + UI
    
    updatePGNViewer();
    renderNotation();
    updateNavigationButtons();
    checkGameEnd();
    // üî• REQUIRED ENGINE RESTART


    // Check if assignment is completed
    if (
  expectedMoves.length > 0 &&
  assignmentCursor >= expectedMoves.length - 1
) {
  showStatus(
    "üéâ Assignment completed! Click 'Submit solution' to submit.",
    "success",
    false
  );
 const btn = document.getElementById('submitBtn');
if (btn) {
  btn.hidden = false;
}

}


    return true;
  }

  // Normal free-play mode (rest of the existing code...)
  // ... existing normal mode code ...



      // Normal free-play mode
let move;

// ‚ôüÔ∏è Promotion check FIRST
if (isPromotionMove(source, target)) {
  showPromotionDialog(source, target);
  return "snapback"; // stop here, wait for user choice
}

// ‚ñ∂ Normal move (no forced queen)
move = chess.move({ from: source, to: target });

// ‚ùå Illegal move
if (!move) {
  return "snapback";
}

// üîä MOVE / CAPTURE SOUND
if (move.flags.includes('k') || move.flags.includes('q')) {
  // üëë Castling
  playSound('castle');

} else if (move.san.includes('+')) {
  // üîî Check
  playSound('check');

} else if (move.captured) {
  // ‚öîÔ∏è Capture
  playSound('capture');

} else {
  // ‚ôü Normal move
  playSound('move');
}




      
      // Update history for normal moves
      moveHistory.push({
        from: move.from,
        to: move.to,
        san: move.san,
        fen: chess.fen(),
        timestamp: new Date()
      });
      
      if (pgnCursor < fullPGNHistory.length) {
        fullPGNHistory = fullPGNHistory.slice(0, pgnCursor);
      }
      fullPGNHistory.push(move);
      pgnCursor++;
      
      updatePGNViewer();
      renderNotation();
      updateNavigationButtons();
      checkGameEnd();
    }

    function onSnapEnd() {
  board.position(chess.fen());

  // ‚úÖ Hide drawings visually when position changes
  clearSVGOnly();

  // Restore grab cursor after snap
  const boardElement = document.getElementById('chessboard');
  if (boardElement) {
    const pieces = boardElement.querySelectorAll('.piece-417db');
    pieces.forEach(p => p.style.cursor = 'grab');
    if (engineRunning) updateEnginePosition();

  }
}


    window.selectAllStudents = function () {
  const checkboxes = document.querySelectorAll(
    "#assignStudentsBox input[type='checkbox']"
  );
  checkboxes.forEach(cb => cb.checked = true);
};

window.clearAllStudents = function () {
  const checkboxes = document.querySelectorAll(
    "#assignStudentsBox input[type='checkbox']"
  );
  checkboxes.forEach(cb => cb.checked = false);
};


    function resetAssignmentPosition() {
  const fen = currentAssignment.fen || "start";
  chess = new Chess(fen);

  assignmentCursor = 0;
  attemptCount = 0;

  fullPGNHistory = [];
  moveHistory = [];
  pgnCursor = 0;

  board.position(chess.fen());

  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();
}


    function checkGameEnd() {
      if (!chess.game_over()) return;

      let message = '';
      if (chess.in_checkmate()) message = 'Checkmate!';
      else if (chess.in_draw()) message = 'Draw!';
      else if (chess.in_stalemate()) message = 'Stalemate!';
      else if (chess.in_threefold_repetition()) message = 'Threefold repetition!';
      else if (chess.insufficient_material()) message = 'Insufficient material!';
      else message = 'Game over!';
      
      document.getElementById('gameStatus').textContent = message;
      document.getElementById('gameStatus').style.display = 'block';
    }

    // ============================================
    // BOARD CONTROLS
    // ============================================
    window.resetBoard = function() {
      stopEngine();

  if (!chess || !board) return;
  chess.reset();
  board.start();
  moveHistory = [];
  fullPGNHistory = [];
  pgnCursor = 0;
  isNavigationMode = false;
  isPGNLoaded = false;
  
  // Reset assignment state
  currentAssignment = null;
  expectedMoves = [];
  assignmentCursor = 0;
  attemptCount = 0;
  assignmentColor = "w";
  
  // Clear all drawings
  clearAllDrawings();
  drawings.clear();
  
  updateBoardCursor();
  updatePGNViewer();
  updateNavigationButtons();
  safeDisable("moveInput", false);
safeDisable("applyMoveBtn", false);

  document.getElementById('gameStatus').style.display = 'none';
  document.getElementById('submitBtn').style.display = 'none';
  document.getElementById('pgnContainer').style.display = 'none';
  renderNotation();
  
  // Stop timer
  stopTimer();
  document.getElementById('timerDisplay').style.display = 'none';
};

function clearSVGOnly() {
  // ‚ùó removes drawings from screen ONLY
  const els = svgOverlay.querySelectorAll('.drawing-arrow, .drawing-circle');
  els.forEach(el => el.remove());
}


    window.flipBoard = function() {
      if (!board) return;
      board.flip();
      boardOrientation = (boardOrientation === 'white') ? 'black' : 'white';
      
      // Redraw drawings with new orientation
      if (chess) {
        loadDrawingsForPosition(chess.fen());
      }
    };

    window.undoMove = function() {
      if (!chess || !board) return;
      const undone = chess.undo();
      if (undone) {
        moveHistory.pop();
        if (fullPGNHistory.length > 0) {
          fullPGNHistory.pop();
          pgnCursor--;
        }
        board.position(chess.fen());
        updatePGNViewer();
        updateNavigationButtons();
        renderNotation();
      }
    };

    window.savePosition = async function () {
  if (!chess || !currentProfile) return;

  if (currentProfile.role !== "admin") {
    showModal("‚õî Access denied", "<p>Only admins can save PGNs.</p>");
    return;
  }

  const rawPGN = chess.pgn();

  if (!rawPGN || rawPGN.trim() === "") {
    showModal(
      "‚ö†Ô∏è No moves found",
      "<p>Please play the full game on the board first.</p>"
    );
    return;
  }

  const title = prompt("Enter PGN title for Database")
  if (!title) return;

  const { error } = await supabase
    .from("bulk_pgn_library")
    .insert({
      title: title.trim(),
      pgn: rawPGN,          // ‚úÖ FULL GAME
      is_active: true,
      created_by: currentProfile.id
    });

  if (error) {
    console.error(error);
    showModal("‚ùå Error", "<p>Failed to save PGN.</p>");
    return;
  }

  showModal(
    "‚úÖ PGN Saved",
    "<p>Full game saved to PGN Library.</p>"
  );

  await loadPGNLibrary();
};

function uciToSAN(uci) {
  try {
    const temp = new Chess(chess.fen());

    const move = temp.move({
      from: uci.slice(0, 2),
      to: uci.slice(2, 4),
      promotion: uci[4] // handles promotion
    });

    if (!move) return uci;

    const moveNumber = Math.ceil(temp.history().length / 2);
    const prefix = move.color === "w"
      ? `${moveNumber}. `
      : `${moveNumber}... `;

    return prefix + move.san;
  } catch {
    return uci;
  }
}
function renderPVLine() {
  if (!currentPV.length) return;

  const temp = new Chess(chess.fen());
  let sanLine = [];
  let moveNumber = temp.history().length / 2 + 1;

  currentPV.forEach((uci, index) => {
    const move = temp.move({
      from: uci.slice(0, 2),
      to: uci.slice(2, 4),
      promotion: uci[4]
    });

    if (!move) return;

    if (move.color === "w") {
      sanLine.push(`${Math.ceil(moveNumber)}.${move.san}`);
    } else {
      sanLine.push(move.san);
      moveNumber++;
    }
  });

  document.getElementById("engineBestMove").textContent =
    sanLine.join(" ");
}

function renderMultiPV() {
  const fen = chess.fen();
  const fenParts = fen.split(" ");

  const sideToMove = fenParts[1];          // "w" or "b"
  let fullMoveNumber = parseInt(fenParts[5], 10); // correct move number

  for (let i = 1; i <= 3; i++) {
    const el = document.getElementById(`engineLine${i}`);
    if (!el || !pvMap[i]) continue;

    const temp = new Chess(fen);
    let san = [];
    let moveNum = fullMoveNumber;

    pvMap[i].forEach(uci => {
      const move = temp.move({
        from: uci.slice(0, 2),
        to: uci.slice(2, 4),
        promotion: uci[4]
      });
      if (!move) return;

      // ‚úÖ Correct numbering
      if (move.color === "w") {
  san.push(`${moveNum}.${move.san}`);
} else {
  san.push(move.san);
  moveNum++;
}

    });

    el.textContent = `${ENGINE_BULLETS[i - 1]} ${san.join(" ")}`;
  }
}


function safeDisable(id, value = true) {
  const el = document.getElementById(id);
  if (!el) return;
  el.disabled = value;
}






    window.copyPGN = function () {
  if (!chess) return;

  const pgn = chess.pgn();

  navigator.clipboard.writeText(pgn).then(() => {
    showModal(
      "üìã Copied",
      "<p>PGN copied to clipboard successfully.</p>"
    );

    setTimeout(() => {
      closeModal();
    }, 1200);
  }).catch(err => {
    console.error(err);

    showModal(
      "‚ùå Copy Failed",
      "<p>Failed to copy PGN to clipboard.</p>"
    );

    setTimeout(() => {
      closeModal();
    }, 2000);
  });
};


    function playNavigationSound(move) {
  if (!move) return;

  // üëë Castling
  if (move.flags?.includes('k') || move.flags?.includes('q')) {
    playSound('castle');
    return;
  }

  // üîî Check
  if (move.san?.includes('+')) {
    playSound('check');
    return;
  }

  // ‚öîÔ∏è Capture
  if (move.captured) {
    playSound('capture');
    return;
  }

  // ‚ôü Normal move
  playSound('move');
}


    // ============================================
    // MOVE INPUT
    // ============================================
    function applyMoveFromInput() {
      if (!chess || !board) return;
      
      if (isNavigationMode && pgnCursor < fullPGNHistory.length) {
        pgnLastMove();
        isNavigationMode = false;
        document.getElementById('moveInput').disabled = false;
        document.getElementById('applyMoveBtn').disabled = false;
      }
      
      const val = document.getElementById('moveInput').value.trim();
      if (!val) return;

      let move = chess.move(val, { sloppy: true });

if (
  !move &&
  /^[a-h][1-8][a-h][1-8][qrbn]?$/i.test(val)
) {
  const from = val.slice(0, 2).toLowerCase();
  const to = val.slice(2, 4).toLowerCase();
  const promo = val.slice(4).toLowerCase();

  // ‚ôüÔ∏è Promotion handling
  if (!promo && isPromotionMove(from, to)) {
    showPromotionDialog(from, to);
    return;
  }

  move = chess.move({
    from,
    to,
    promotion: promo // ‚ùó NO default 'q'
  });
}


      if (move) {
        board.position(chess.fen());
        moveHistory.push({
          from: move.from,
          to: move.to,
          san: move.san,
          fen: chess.fen(),
          timestamp: new Date()
        });
        
        // Update fullPGNHistory
        if (pgnCursor < fullPGNHistory.length) {
          fullPGNHistory = fullPGNHistory.slice(0, pgnCursor);
        }
        fullPGNHistory.push(move);
        pgnCursor++;
        
        updatePGNViewer();
        document.getElementById('moveInput').value = '';
        checkGameEnd();
        updateNavigationButtons();
        renderNotation();
      } else {
        board.position(chess.fen());
        alert('Invalid move!');
      }
    }

    //SOUND SFX START//
    const sounds = {
  move: new Audio('sounds/move.mp3'),
  capture: new Audio('sounds/capture.mp3'),
  castle: new Audio('sounds/castle.mp3'),
  check: new Audio('sounds/check.mp3'),
  wrong: new Audio('sounds/wrong.mp3'),
  next: new Audio('sounds/next.mp3'),
  complete: new Audio('sounds/complete.mp3'),
};

Object.values(sounds).forEach(s => s.volume = 0.4);

function playSound(name) {
  const sound = sounds[name];
  if (!sound) return;
  sound.currentTime = 0;
  sound.play().catch(() => {});
}




// Play with Computer Functions Start //

function updateClockUI() {
  const wMin = Math.floor(whiteTime / 60);
  const wSec = whiteTime % 60;

  document.getElementById("whiteClock").textContent =
    `${String(wMin).padStart(2, "0")}:${String(wSec).padStart(2, "0")}`;

  const bMin = Math.floor(blackTime / 60);
  const bSec = blackTime % 60;

  document.getElementById("blackClock").textContent =
    `${String(bMin).padStart(2, "0")}:${String(bSec).padStart(2, "0")}`;
}


// ===============================
// VS COMPUTER PROMOTION STATE
// ===============================
let vsPendingPromotion = null; // { from, to }


function initVsComputerBoard() {
  if (vsBoard) return; // prevent re-init

  vsChess = new Chess();

  vsBoard = Chessboard("computerBoard", {
    position: "start",
    draggable: true,
    pieceTheme: getPieceThemePath(currentPieceTheme),



    onDragStart: (source, piece) => {
  // block if game over
  if (!vsGameActive) return false;

  // only allow dragging player's color
  if (
    (vsPlayerColor === "white" && piece.startsWith("b")) ||
    (vsPlayerColor === "black" && piece.startsWith("w"))
  ) {
    return false;
  }

  // only allow when it's player's turn
  if (vsChess.turn() !== (vsPlayerColor === "white" ? "w" : "b")) {
    return false;
  }

  return true;
},


    onDrop: (source, target) => {

  // üîÅ Detect promotion square BEFORE move
  const piece = vsChess.get(source);
  const isPromotion =
    piece &&
    piece.type === "p" &&
    ((piece.color === "w" && target[1] === "8") ||
     (piece.color === "b" && target[1] === "1"));

  // üõë HOLD MOVE ‚Üí SHOW VS PROMOTION MODAL
  if (isPromotion) {
    vsPendingPromotion = { from: source, to: target };
    document.getElementById("vsPromotionModal").classList.remove("hidden");
    return;
  }

  // ‚úÖ NORMAL MOVE
  const move = vsChess.move({
    from: source,
    to: target,
    promotion: "q"
  });

  if (!move) return "snapback";

  
  afterVsPlayerMove(move);
}

  });
}

window.completeVsPromotion = function (piece) {
  if (!vsPendingPromotion) return;

  const { from, to } = vsPendingPromotion;

  const move = vsChess.move({
    from,
    to,
    promotion: piece
  });

  vsPendingPromotion = null;
  document.getElementById("vsPromotionModal").classList.add("hidden");

  if (!move) {
    vsBoard.position(vsChess.fen());
    return;
  }

  vsBoard.position(vsChess.fen());
  afterVsPlayerMove(move);
};


function afterVsPlayerMove(move) {

  checkVsGameEnd();

  // üîä PLAYER SOUND
  if (move.flags.includes("k") || move.flags.includes("q")) {
    playSound("castle");
  } else if (move.san.includes("+")) {
    playSound("check");
  } else if (move.captured) {
    playSound("capture");
  } else {
    playSound("move");
  }

  // ü§ñ BOT REACTION
  const studentMoved =
    (vsPlayerColor === "white" && move.color === "w") ||
    (vsPlayerColor === "black" && move.color === "b");

  if (studentMoved) {
    if (vsChess.in_check()) {
      botReact("check");
      playBotCheckSounds();
    } else if (move.captured) {
      botReact("capture");
      playBotCaptureSounds();
    }
  }

  // ü§ñ ENGINE MOVE
  if (vsEngine && vsEngineConfig && vsGameActive) {
    vsEngine.postMessage(`position fen ${vsChess.fen()}`);
    vsEngine.postMessage(
      `go depth ${vsEngineConfig.depth} movetime ${vsEngineConfig.time}`
    );

    engineThinking = true;
    clearInterval(clockInterval);

    clockInterval = setInterval(() => {
      if (!vsGameActive) return;
      if (blackTime > 0) {
        blackTime--;
        updateClockUI();
      }
    }, 1000);
  }
}


function initVsEngine() {
  if (vsEngine) return;

  vsEngine = new Worker("./stockfish/stockfish.js");
  vsEngine.onmessage = handleVsEngineMessage;

  vsEngine.postMessage("uci");
  vsEngine.postMessage("isready");

  console.log("ü§ñ VS Engine initialized");
}

function handleVsEngineMessage(e) {
  const line = e.data;
if (typeof line !== "string") return;

// üß† ENGINE STARTED THINKING ‚Üí START BLACK CLOCK
if (line.startsWith("info") && !engineThinking) {
  engineThinking = true;

  clearInterval(clockInterval);

  clockInterval = setInterval(() => {
    if (!vsGameActive) return;

    if (blackTime > 0) {
      blackTime--;
      updateClockUI();
    }
  }, 1000);
}

// ‚õî ignore everything except bestmove after this
if (!line.startsWith("bestmove")) return;

// üõë ENGINE FINISHED THINKING
engineThinking = false;
const moveUci = line.split(" ")[1];
if (!moveUci || moveUci === "(none)") return;



  // ‚è± DELAY ENGINE MOVE BY 3 SECONDS
setTimeout(() => {
  if (!vsGameActive) return;

  // ‚ôü APPLY ENGINE MOVE
  const engineMove = vsChess.move({
    from: moveUci.slice(0, 2),
    to: moveUci.slice(2, 4),
    promotion: moveUci[4]
  });

  if (!engineMove) return;
  

  // üîä ENGINE MOVE SOUND
  // üîä BOT MOVE SOUND (SAFE ORDER)

// 1Ô∏è‚É£ Capture has TOP priority
if (engineMove.captured) {
  playBotCaptureSound();
}

// 2Ô∏è‚É£ Check (only if NOT capture)
else if (vsChess.in_check()) {
  playBotCheckSound();
}
if (engineMove.flags.includes("k") || engineMove.flags.includes("q")) {
  playSound("castle");
}
else {
  playSound("move");
}


// 3Ô∏è‚É£ Optional normal move sound (later)
// else {
//   playSound("move");
// }


  // ‚úÖ SYNC BOARD
  vsBoard.position(vsChess.fen());
  checkVsGameEnd();

  // ‚è± ENGINE DONE ‚Üí START WHITE CLOCK
  clearInterval(clockInterval);
  clockInterval = setInterval(() => {
    if (!vsGameActive) return;

    if (whiteTime > 0) {
      whiteTime--;
      updateClockUI();
    }
  }, 1000);

}, BOT_MOVE_DELAY);

}

const BOT_SOUND_VOLUME = 0.20; // üîä tweak: 0.25‚Äì0.45
function playBotCheckSound() {
  const i = Math.floor(Math.random() * 8) + 1;
  const audio = new Audio(`bot_happy_sound/botcheck${i}.mp3`);
  audio.volume = BOT_SOUND_VOLUME;
  audio.play().catch(() => {});
}

function playBotCaptureSound() {
  const i = Math.floor(Math.random() * 7) + 1;
  const audio = new Audio(`bot_happy_sound/botcapture${i}.mp3`);
  audio.volume = BOT_SOUND_VOLUME;
  audio.play().catch(() => {});
}






function resetVsComputerGame() {
  clearVsResult();
  console.log("üîÑ Hard reset VS Computer");

  // 1. Stop engine safely
  if (vsEngine) {
    try {
      vsEngine.postMessage("stop");
      vsEngine.postMessage("ucinewgame");
    } catch (e) {
      console.warn("Engine already stopped");
    }
  }

  // 2. Disable game
  vsGameActive = false;

  // 3. Reset chess logic
  if (vsChess) {
    vsChess.reset();
  }

  // 4. Reset board UI
  if (vsBoard) {
    vsBoard.position("start", false);
  }

  // 5. Reset clocks
  document.getElementById("whiteClock").textContent = "05:00";
  document.getElementById("blackClock").textContent = "05:00";

  // 6. Optional: visual feedback
  console.log("‚úÖ VS Computer fully reset");
}


function updatePuzzleRushUI() {
  document.getElementById("prScore").textContent = prScore;
  document.getElementById("prLives").textContent = prLivesLeft;

  if (prTimeLeft === null) {
    document.getElementById("prTimer").textContent = "‚àû";
  } else {
    const m = Math.floor(prTimeLeft / 60);
    const s = prTimeLeft % 60;
    document.getElementById("prTimer").textContent =
      `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  }
}

function resetPuzzleRushState() {
  prScore = 0;
  prLivesLeft = prMaxLives; // now defined
  prTimeLeft = null;

  puzzleSolved = false;
  puzzleQueue = [];
  puzzleIndex = 0;

  updatePuzzleRushUI();
}





function endPuzzleRush(reason) {
  clearInterval(prTimerInterval);
  prTimerInterval = null;

   // ‚úÖ SAVE CURRENT SCORE (for rating)
  applyPuzzleRushRating(prScore);



  // üèÜ SAVE BEST SCORE (Puzzle Rush)
  saveMiniGameScore("puzzlerush", prScore);

  // üîä Puzzle Rush complete sound
  playPRSound("prCompleteSound", 1.0);

  showPuzzleRushResult(reason, prScore);


  document.getElementById("puzzleRushGame").classList.add("hidden");
  document.getElementById("puzzleRushMenu").classList.remove("hidden");

  puzzleRushMode = null;
}



function playPRSound(id, volume = 0.75) {
  const s = document.getElementById(id);
  if (!s) return;
  s.currentTime = 0;
  s.volume = volume;
  s.play().catch(() => {});
}


// Play with Computer Functions End //

    //SOUND SFX END//

    // ============================================
    // NOTATION SYSTEM - FIXED VERSION
    // ============================================
    function renderNotation() {
      const container = document.getElementById('notationList');
      container.innerHTML = '';

      // Always use fullPGNHistory if it has moves, otherwise use current chess history
      let moves = [];
      if (fullPGNHistory.length > 0) {
        // Show all moves from the complete history
        moves = fullPGNHistory;
      } else {
        // No history yet, use current chess moves
        moves = chess.history({ verbose: true });
      }

      // Create notation rows
      for (let i = 0; i < moves.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        const white = moves[i] ? moves[i].san : '';
        const black = moves[i + 1] ? moves[i + 1].san : '';

        const row = document.createElement('div');
        row.className = 'move';
        row.dataset.plyIndex = i; // Store the ply index for clicking
        
        // Mark which plies this row contains
        row.dataset.containsPlies = `${i},${i + 1}`;

        const num = document.createElement('div');
        num.className = 'num';
        num.textContent = moveNum + '.';

        const whiteCell = document.createElement('div');
        whiteCell.className = 'white';
        whiteCell.textContent = white;

        const blackCell = document.createElement('div');
        blackCell.className = 'black';
        blackCell.textContent = black;

        row.appendChild(num);
        row.appendChild(whiteCell);
        row.appendChild(blackCell);
        container.appendChild(row);
      }

      if (moves.length === 0) {
        container.innerHTML = '<div style="padding:12px;color:var(--text-muted); text-align:center;">No moves yet</div>';
      }

      highlightCurrentNotation();
      
      // Scroll to show current move
      setTimeout(() => {
        const currentRows = container.querySelectorAll('.move.current');
        if (currentRows.length > 0) {
          const lastCurrent = currentRows[currentRows.length - 1];
          lastCurrent.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      }, 10);
    }

    function highlightCurrentNotation() {
      const container = document.getElementById('notationList');
      const rows = container.querySelectorAll('.move');
      rows.forEach(r => r.classList.remove('current'));

      if (pgnCursor === 0) return;

      // Find the row that contains the current ply
      const rowIndex = Math.floor((pgnCursor - 1) / 2);
      const target = rows[rowIndex];
      if (target) {
        target.classList.add('current');
      }
    }





    

    function attachNotationClickHandler() {
      const container = document.getElementById('notationList');
      container.addEventListener('click', (e) => {
        let target = e.target;
        
        // Find the move element
        if (!target.classList.contains('move')) {
          target = target.closest('.move');
        }
        if (!target) return;
        
        // Get ply index from data attribute
        const plyIndex = parseInt(target.dataset.plyIndex);
        if (!isNaN(plyIndex)) {
          // Navigate to the position AFTER the white move in this row
          navigateToMove(plyIndex + 1);
        }
      });
    }

    function initNotation() {
      attachNotationClickHandler();
      renderNotation();
    }

    // ============================================
    // PGN NAVIGATION - FIXED VERSION
    // ============================================
    function navigateToMove(targetIndex) {
      if (!chess || !board) return;
      
      // Don't navigate if no moves
      if (fullPGNHistory.length === 0 && targetIndex > 0) return;
      
      // Clamp target index
      targetIndex = Math.max(0, Math.min(targetIndex, fullPGNHistory.length));
      
      // Rebuild game up to target index
      chess.reset();
      
      for (let i = 0; i < targetIndex; i++) {
        const move = fullPGNHistory[i];
        chess.move({
          from: move.from,
          to: move.to,
          promotion: move.promotion

        });
      }
      
      board.position(chess.fen());
      // üî• Keep engine synced during PGN navigation
if (engineRunning) updateEnginePosition();

      // üîä Play sound for PGN navigation move
if (targetIndex > 0) {
  const navMove = fullPGNHistory[targetIndex - 1];
  playNavigationSound(navMove);
}

      pgnCursor = targetIndex;
      isNavigationMode = (targetIndex < fullPGNHistory.length);
      
      // Load drawings for this position
      loadDrawingsForPosition(chess.fen());
      
      updateBoardCursor();
      updatePGNViewer();
      updateNavigationButtons();
      renderNotation();
      highlightCurrentNotation();
      
      // Enable/disable move input based on navigation state
      document.getElementById('moveInput').disabled = isNavigationMode;
      document.getElementById('applyMoveBtn').disabled = isNavigationMode;
      
      // Show game status if at end and game is over
      if (targetIndex === fullPGNHistory.length) {
        checkGameEnd();
      } else {
        document.getElementById('gameStatus').style.display = 'none';
      }
    }

    window.pgnFirstMove = function() {
      navigateToMove(0);
    };

    window.pgnPrevMove = function() {
      if (pgnCursor > 0) {
        navigateToMove(pgnCursor - 1);
      }
    };

    window.pgnNextMove = function() {
      if (pgnCursor < fullPGNHistory.length) {
        navigateToMove(pgnCursor + 1);
      }
    };

    window.pgnLastMove = function() {
      navigateToMove(fullPGNHistory.length);
    };

    function updateNavigationButtons() {
      const btnPrev = document.getElementById('btnPrev');
      const btnNext = document.getElementById('btnNext');
      const btnFirst = document.getElementById('btnFirst');
      const btnLast = document.getElementById('btnLast');
      
      if (btnPrev) btnPrev.disabled = pgnCursor <= 0;
      if (btnNext) btnNext.disabled = pgnCursor >= fullPGNHistory.length;
      if (btnFirst) btnFirst.disabled = pgnCursor <= 0;
      if (btnLast) btnLast.disabled = pgnCursor >= fullPGNHistory.length;
      
      
    }



    // ============================================
    // CURSOR MANAGEMENT FUNCTIONS
    // ============================================
    function updateBoardCursor() {
      const boardElement = document.getElementById('chessboard');
      if (!boardElement) return;
      
      if (isNavigationMode) {
        boardElement.parentElement.classList.add('navigation-mode');
      } else {
        boardElement.parentElement.classList.remove('navigation-mode');
      }
    }

    // ============================================
    // PGN / FEN LOAD
    // ============================================

    // ‚úÖ INTERNAL PGN LOADER (used by Lichess fetch)
window.loadPGNFromString = function (pgnString) {
  if (!chess || !board) return;

  try {
    const tempChess = new Chess();
    const success = tempChess.load_pgn(pgnString);

    if (!success) throw new Error("Invalid PGN");

    const moves = tempChess.history({ verbose: true });

    // Reset everything
    chess.reset();
    fullPGNHistory = [];
    moveHistory = [];
    pgnCursor = 0;

    // Load PGN into main game
    chess.load_pgn(pgnString);
    board.position(chess.fen());

    // Store history
    fullPGNHistory = moves;
    pgnCursor = moves.length;

    moveHistory = moves.map((m, i) => ({
      from: m.from,
      to: m.to,
      san: m.san,
      fen: getFenAtMove(i + 1, moves),
      timestamp: new Date()
    }));

    isPGNLoaded = true;
    isNavigationMode = false;

    // üî• UI sync
    updatePGNViewer();
    renderNotation();
    updateNavigationButtons();

  } catch (e) {
    console.error("PGN load failed:", e);
    showModal("‚ùå PGN Error", "<p>Failed to load PGN.</p>");
    setTimeout(closeModal, 2000);
  }
};


    window.loadPGN = function() {
      if (!chess || !board) return;
      const pgnInput = document.getElementById('pgnInput').value.trim();
      if (!pgnInput) {
  showModal(
    "‚ö†Ô∏è Missing PGN",
    "<p>Please enter a PGN.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}

      try {
        const tempChess = new Chess();
        const success = tempChess.load_pgn(pgnInput);
        

        
        if (!success) {
          throw new Error('Failed to parse PGN');
        }
        
        const moves = tempChess.history({verbose: true});
        fullPGNHistory = moves;
        
        // Load into main chess instance
        chess.load_pgn(pgnInput);
        board.position(chess.fen());
        extractPlayersFromPGN(pgnInput);

        
        pgnCursor = moves.length;
        moveHistory = moves.map((move, index) => ({
          from: move.from,
          to: move.to,
          san: move.san,
          fen: getFenAtMove(index + 1, moves),
          timestamp: new Date()
        }));
        
        isPGNLoaded = true;
        isNavigationMode = false;
        navigateToMove(pgnCursor);

        
        updatePGNViewer();

showModal(
  "‚ôü PGN Loaded",
  "<p>PGN loaded successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

        
        document.getElementById('moveInput').disabled = false;
        document.getElementById('applyMoveBtn').disabled = false;
        updateNavigationButtons();
        renderNotation();
        

        
      } catch (error) {
  console.error("PGN load error:", error);

  showModal(
    "‚ùå PGN Error",
    "<p>‚úÖ PGN loaded successfully!</p>"
  );

  setTimeout(closeModal, 2000);
}

    };



    function getFenAtMove(targetMoveIndex, moves) {
      const tempChess = new Chess();
      for (let i = 0; i < targetMoveIndex && i < moves.length; i++) {
        tempChess.move(moves[i]);
      }
      return tempChess.fen();
    }

    window.loadFEN = function() {
      if (!chess || !board) return;
      const fen = document.getElementById('fenInput').value.trim();
      if (!fen) {
        alert('Please enter FEN');
        return;
      }
      try {
        chess.load(fen);
        board.position(fen);
        moveHistory = [];
        fullPGNHistory = [];
        pgnCursor = 0;
        isNavigationMode = false;
        isPGNLoaded = false;
        updatePGNViewer();
        updateNavigationButtons();
        renderNotation();
       showModal(
  "‚ôü FEN Loaded",
  "<p>FEN loaded successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1200);

      } catch (e) {
        console.error('FEN load error:', e);
        alert('Invalid FEN format');
      }
    };

    function updatePGNViewer() {
  const viewer = document.getElementById("pgnViewer");
  viewer.textContent = chess.pgn() || "No moves yet";
  viewer.scrollTop = viewer.scrollHeight;
}


    // ============================================
    // TIMER
    // ============================================
    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      startTime = Date.now();
      elapsedTime = 0;
      timerInterval = setInterval(() => {
        elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        updateTimerDisplay();
      }, 1000);
      document.getElementById('timerDisplay').style.display = 'block';
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function updateTimerDisplay() {
      const minutes = Math.floor(elapsedTime / 60);
      const seconds = elapsedTime % 60;
      document.getElementById('timer').textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${minutes}m ${secs}s`;
    }

    let mouseDownPos = { x: 0, y: 0 };
const DRAG_THRESHOLD = 6; // pixels (lichess-like)


    // ============================================
    // FIXED DRAWING SYSTEM
    // ============================================
    function initDrawingSystem() {
      // Get or create SVG overlay
      const boardWrapper = document.querySelector('.board-wrapper');
      svgOverlay = document.getElementById('boardOverlay');
      
      // Clear existing content
      svgOverlay.innerHTML = '';
      
      // Add arrow marker definition (SMALLER & CLEAN)
const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
const arrowMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');

arrowMarker.setAttribute('id', 'arrowhead');
arrowMarker.setAttribute('markerWidth', '6');
arrowMarker.setAttribute('markerHeight', '6');
arrowMarker.setAttribute('refX', '5');
arrowMarker.setAttribute('refY', '3');
arrowMarker.setAttribute('orient', 'auto');
arrowMarker.setAttribute('markerUnits', 'strokeWidth'); // ‚≠ê important

const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
polygon.setAttribute('points', '0 0, 6 3, 0 6');
polygon.setAttribute('fill', '#057505'); // deep green

arrowMarker.appendChild(polygon);
defs.appendChild(arrowMarker);
svgOverlay.appendChild(defs);

      
      // Add event listeners to the chessboard element
      const chessboardEl = document.getElementById('chessboard');
      if (chessboardEl) {
        // Prevent default context menu on right-click
        chessboardEl.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          // ‚úÖ Left click clears drawings ONLY if not clicking a piece
chessboardEl.addEventListener('mousedown', (e) => {
  // LEFT click only
  if (e.button !== 0) return;

  // If right-click drawing is active, ignore
  if (isRightMouseDown) return;

  // üõë If clicking on a chess piece, do NOT clear
  if (e.target.closest('.piece-417db')) return;

  // ‚úÖ Safe to clear drawings
  clearAllDrawings();
});

          return false;
        });
        
        // Mouse events for drawing
        chessboardEl.addEventListener('mousedown', handleMouseDown);
        chessboardEl.addEventListener('mousemove', handleMouseMove);
        chessboardEl.addEventListener('mouseup', handleMouseUp);
        chessboardEl.addEventListener('mouseleave', handleMouseLeave);
      }
    }

    function showModal(title, message, onOk) {
  const modal = document.getElementById("floatingModal");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  titleEl.textContent = title;
  bodyEl.innerHTML = message.replace(/\n/g, "<br>");

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    if (typeof onOk === "function") onOk();
  };
}





    function handleMouseDown(e) {
  if (e.button !== 2) return;

  e.preventDefault();
  e.stopPropagation();

  isRightMouseDown = true;

  mouseDownPos.x = e.clientX;
  mouseDownPos.y = e.clientY;

  const square = getSquareFromCoordinates(e.clientX, e.clientY);
  if (!square) return;

  drawStartSquare = square;
  isDrawing = true;
}




    function handleMouseMove(e) {
      // Update mouse position
      mousePosition.x = e.clientX;
      mousePosition.y = e.clientY;
      
      if (isDrawing && isRightMouseDown) {
        updateDrawingPreview(e);
      }
    }

    function handleMouseUp(e) {
  if (e.button !== 2) return;

  e.preventDefault();
  e.stopPropagation();

  const dx = e.clientX - mouseDownPos.x;
  const dy = e.clientY - mouseDownPos.y;
  const distance = Math.sqrt(dx * dx + dy * dy);

  const endSquare = getSquareFromCoordinates(e.clientX, e.clientY);

  // üëâ Case 1: NO DRAG ‚Üí draw circle
  if (distance < DRAG_THRESHOLD) {
    if (endSquare) {
      drawCircle(endSquare);
    }
  }
  // üëâ Case 2: DRAG ‚Üí draw arrow
  else if (drawStartSquare && endSquare && drawStartSquare !== endSquare) {
    drawArrow(drawStartSquare, endSquare);
  }

  // Reset state
  isRightMouseDown = false;
  isDrawing = false;
  drawStartSquare = null;
  clearDrawingPreview();
}


    function handleMouseLeave() {
      // Cancel drawing if mouse leaves while drawing
      if (isDrawing) {
        isDrawing = false;
        drawStartSquare = null;
        clearDrawingPreview();
      }
      isRightMouseDown = false;
    }

    function getSquareFromCoordinates(clientX, clientY) {
      if (!board || !chess) return null;
      
      const boardEl = document.getElementById('chessboard');
      const boardRect = boardEl.getBoundingClientRect();
      
      // Calculate relative position within the board element
      const x = clientX - boardRect.left;
      const y = clientY - boardRect.top;
      
      // Calculate square size based on board dimensions
      const squareSize = boardRect.width / 8;
      
      // Calculate file and rank
      let file, rank;
      
      if (boardOrientation === 'white') {
        file = Math.floor(x / squareSize);
        rank = 7 - Math.floor(y / squareSize);
      } else {
        file = 7 - Math.floor(x / squareSize);
        rank = Math.floor(y / squareSize);
      }
      
      // Convert to algebraic notation
      if (file >= 0 && file < 8 && rank >= 0 && rank < 8) {
        const fileChar = String.fromCharCode(97 + file);
        return fileChar + (rank + 1);
      }
      
      return null;
    }

    function getSquareCoordinates(square) {
      if (!board || !chess) return { x: 0, y: 0 };
      
      const boardEl = document.getElementById('chessboard');
      const boardRect = boardEl.getBoundingClientRect();
      const squareSize = boardRect.width / 8;
      
      const file = square.charCodeAt(0) - 97;
      const rank = parseInt(square[1]) - 1;
      
      let x, y;
      
      if (boardOrientation === 'white') {
        x = (file * squareSize) + (squareSize / 2);
        y = ((7 - rank) * squareSize) + (squareSize / 2);
      } else {
        x = ((7 - file) * squareSize) + (squareSize / 2);
        y = (rank * squareSize) + (squareSize / 2);
      }
      
      // Convert to SVG coordinates (relative to SVG)
      return { x, y };
    }

    function updateDrawingPreview(e) {
      if (!drawStartSquare || !isDrawing) return;
      
      clearDrawingPreview();
      
      const startCoords = getSquareCoordinates(drawStartSquare);
      const currentCoords = { 
        x: e.clientX - svgOverlay.getBoundingClientRect().left,
        y: e.clientY - svgOverlay.getBoundingClientRect().top
      };
      
      // Draw preview line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', startCoords.x);
      line.setAttribute('y1', startCoords.y);
      line.setAttribute('x2', currentCoords.x);
      line.setAttribute('y2', currentCoords.y);
      line.setAttribute('stroke', '#00ff00');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-dasharray', '5,5');
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('class', 'drawing-preview');
      line.setAttribute('opacity', '0.7');
      
      svgOverlay.appendChild(line);
    }

    function clearDrawingPreview() {
      const previews = svgOverlay.querySelectorAll('.drawing-preview');
      previews.forEach(el => el.remove());
    }

    function drawArrow(fromSquare, toSquare) {
      const fromCoords = getSquareCoordinates(fromSquare);
      const toCoords = getSquareCoordinates(toSquare);
      
      // Create arrow
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', fromCoords.x);
      line.setAttribute('y1', fromCoords.y);
      line.setAttribute('x2', toCoords.x);
      line.setAttribute('y2', toCoords.y);
      line.setAttribute('stroke', '#00ff00');
      line.setAttribute('stroke-width', '2.8');
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('marker-end', 'url(#arrowhead)');
      line.setAttribute('class', 'drawing-arrow');
      line.setAttribute('data-from', fromSquare);
      line.setAttribute('data-to', toSquare);
      
      svgOverlay.appendChild(line);
      
      // Store drawing
      saveDrawing('arrow', { from: fromSquare, to: toSquare });
    }

    function drawCircle(square) {
  const coords = getSquareCoordinates(square);
  const boardEl = document.getElementById('chessboard');
  const boardRect = boardEl.getBoundingClientRect();
  const squareSize = boardRect.width / 8;

  // üü¢ LICHESS-BOLD VALUES
  const radius = squareSize * 0.41;          // almost touching square
  const strokeWidth = squareSize * 0.070;     // VERY bold (this was missing)

  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circle.setAttribute('cx', coords.x);
  circle.setAttribute('cy', coords.y);
  circle.setAttribute('r', radius);
  circle.setAttribute('fill', 'none');
  circle.setAttribute('stroke', '#057505');
  circle.setAttribute('stroke-width', strokeWidth);
  circle.setAttribute('opacity', '0.70');
  circle.setAttribute('class', 'drawing-circle');
  circle.setAttribute('data-square', square);

  svgOverlay.appendChild(circle);

  saveDrawing('circle', { square });
}




    function saveDrawing(type, data) {
      const currentFen = chess.fen();
      
      if (!drawings.has(currentFen)) {
        drawings.set(currentFen, []);
      }
      
      drawings.get(currentFen).push({ type, data, timestamp: Date.now() });
      
      // Update current drawings
      currentDrawings = drawings.get(currentFen);
    }

    window.clearAllDrawings = function() {
      // Remove all drawings from SVG
      const arrows = svgOverlay.querySelectorAll('.drawing-arrow, .drawing-circle');
      arrows.forEach(el => el.remove());
      
      // Clear drawings for current position
      const currentFen = chess.fen();
      if (drawings.has(currentFen)) {
        drawings.delete(currentFen);
      }
      
      currentDrawings = [];
    };

    function loadDrawingsForPosition(fen) {
      // Clear existing drawings
      const arrows = svgOverlay.querySelectorAll('.drawing-arrow, .drawing-circle');
      arrows.forEach(el => el.remove());
      
      // Load drawings for this position
      if (drawings.has(fen)) {
        const positionDrawings = drawings.get(fen);
        positionDrawings.forEach(drawing => {
          if (drawing.type === 'arrow') {
            drawArrow(drawing.data.from, drawing.data.to);
          } else if (drawing.type === 'circle') {
            drawCircle(drawing.data.square);
          }
        });
      }
    }

    function updateEngineVisibility() {
  const enginePanel = document.getElementById("enginePanel");
  const analyzeBtn = document.getElementById("analyzeBtn");

  if (!enginePanel || !analyzeBtn) return;

  // üö´ Student + assignment ‚Üí hide
  if (currentProfile.role === "student" && isAssignmentMode) {
    enginePanel.style.display = "none";
    analyzeBtn.style.display = "none";
  } 
  // ‚úÖ Teacher / Admin OR free mode ‚Üí show
  else {
    enginePanel.style.display = "block";
    analyzeBtn.style.display = "block";
  }
}


    function showPuzzleRushResult(reason, score) {
  document.getElementById("prResultReason").textContent = reason;
  document.getElementById("prResultScore").textContent = score;

  document
    .getElementById("puzzleRushResultModal")
    .classList.remove("hidden");
}

function hidePuzzleRushResult() {
  document
    .getElementById("puzzleRushResultModal")
    .classList.add("hidden");

  document.getElementById("puzzleRushGame").classList.add("hidden");
  document.getElementById("puzzleRushMenu").classList.remove("hidden");
}



    // ============================================
    // ASSIGNMENTS
    // ============================================

    

    async function loadAssignments() {
    
  const listEl = document.getElementById('assignmentsList');
  listEl.innerHTML = '<div class="loading">Loading assignments...</div>';

  try {
    let assignments = [];

    if (currentProfile.role === 'admin') {
      const { data, error } = await supabase
        .from('assignments')
        .select('*')
        .order('created_at', { ascending: false });
      if (error) throw error;
      assignments = data || [];
    } else {
      console.log("STUDENT UUID:", currentProfile.id);
      const { data, error } = await supabase
  .from('assignments')
  .select('*')
  .eq('status', 'active')
  .or(
    `is_public.eq.true,assigned_to.cs.["${currentProfile.id}"]`
  )
  .order('created_at', { ascending: false });
      if (error) throw error;
      console.log("STUDENT assignments data:", data);
      assignments = data || [];
    }

    if (assignments.length === 0) {
      listEl.innerHTML = '<div class="card"><p>No assignments available yet.</p></div>';
      return;
    }

    listEl.innerHTML = assignments.map(assign => `
      <div class="card" data-assignment-id="${assign.id}">
        <h4>${assign.title || 'Untitled Assignment'}</h4>
        <p>${assign.description || 'No description provided.'}</p>
        <p><strong>Type:</strong> ${assign.task_type || 'General'} | <strong>Status:</strong> ${assign.status || 'active'}</p>
        ${assign.due_at ? `<p><strong>Due:</strong> ${new Date(assign.due_at).toLocaleDateString()}</p>` : ''}
        <div class="assignment-actions">

  ${currentProfile.role === 'admin'
    ? `
      <button class="btn-secondary" data-action="view" data-id="${assign.id}">
        View Details
      </button>

      <button class="btn-primary" data-action="test" data-id="${assign.id}">
        Test Assignment
      </button>

      <button class="btn-danger" data-action="delete" data-id="${assign.id}">
        üóë Delete
      </button>
    `
    : `
      <button class="btn-primary" data-action="start" data-id="${assign.id}">
        Start Assignment
      </button>
    `
  }
</div>
      </div>
    `).join('');

  } catch (error) {
    console.error('Error loading assignments:', error);
    listEl.innerHTML = '<div class="card"><p style="color: #ff4757;">Error loading assignments. Please try again later.</p></div>';
  }
}

document.getElementById('assignmentsList').addEventListener('click', (e) => {
  const btn = e.target.closest('button');
  if (!btn) return;

  const action = btn.dataset.action;
  const assignmentId = btn.dataset.id;

  if (action === 'delete') {
    confirmDeleteAssignment(assignmentId);
  }
});

function confirmDeleteAssignment(assignmentId) {
  if (currentProfile.role !== "admin") return;

  pendingDeleteAssignmentId = assignmentId;
  document.getElementById("deleteModal").classList.remove("hidden");

}


const prResultBtn = document.getElementById("prResultBtn");
if (prResultBtn) {
  prResultBtn.addEventListener("click", hidePuzzleRushResult);
}

document.addEventListener("DOMContentLoaded", () => {
  const searchBox = document.getElementById("assignmentsSearchBox");
  const list = document.getElementById("assignmentsList");

  if (!searchBox || !list) return;

  searchBox.addEventListener("input", () => {
    const query = searchBox.value.toLowerCase().trim();
    const cards = list.querySelectorAll(".card");

    cards.forEach(card => {
      const title = card.querySelector("h4")?.textContent.toLowerCase() || "";
      const desc = card.querySelector("p")?.textContent.toLowerCase() || "";

      const match =
        title.includes(query) ||
        desc.includes(query);

      card.style.display = match ? "block" : "none";
    });
  });
});







async function deleteAssignmentFromDB(assignmentId) {
  try {
    const { error } = await supabase
      .from("assignments")
      .delete()
      .eq("id", assignmentId);

    if (error) throw error;

    showStatus("üóë Assignment deleted successfully", "success");
    loadAssignments();

  } catch (err) {
    console.error(err);
    showStatus("‚ùå Failed to delete assignment", "error");
  }
}

document.getElementById("cancelDeleteBtn").onclick = () => {
  pendingDeleteAssignmentId = null;
  document.getElementById("deleteModal").classList.add("hidden");
};

document.getElementById("confirmDeleteBtn").onclick = async () => {
  if (!pendingDeleteAssignmentId) return;

  await deleteAssignmentFromDB(pendingDeleteAssignmentId);

  pendingDeleteAssignmentId = null;
  document.getElementById("deleteModal").classList.add("hidden");
};







window.startAssignmentMode = async function (assignmentId) {
  console.log("Fetching assignment:", assignmentId);

  const { data: assignment, error } = await supabase
    .from("assignments")
    .select("*")
    .eq("id", assignmentId)
    .single();

  if (error || !assignment) {
    console.error("Assignment load error:", error);
    alert("Assignment not found.");
    return;
  }

  // Hide only PGN upload tools & admin stuff ‚Äî NOT the whole panel
document.getElementById("pgnUploadSection").style.display = "none";



  // FIXED ‚Äî Auto open Chess Board tab
  document.querySelector('[data-tab="board"]').click();

  // Launch interactive mode
  startInteractiveAssignment(assignment);
};

async function loadStudyDropdown() {
  const select = document.getElementById("studySelect");
  if (!select) return;

  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("id, title")
    .order("created_at", { ascending: false });

  if (error) {
    console.error("‚ùå PGN load error:", error);
    return;
  }

  select.innerHTML = `<option value="">Study</option>`;

  data.forEach(pgn => {
    const opt = document.createElement("option");
    opt.value = pgn.id;
    opt.textContent = pgn.title;
    select.appendChild(opt);
  });
}

function loadStudyFromPGN(pgnText, studyTitle) {
  const list = document.getElementById("studyList");
  list.innerHTML = "";

  const games = pgnText
    .split(/\n\n(?=\[Event)/g) // split multiple games safely
    .filter(Boolean);

  // Study title
  const header = document.createElement("div");
  header.className = "study-item active";
  header.textContent = `‚ñ∂ ${studyTitle}`;
  list.appendChild(header);

  games.forEach((gamePgn, index) => {
    const chapter = document.createElement("div");
    chapter.className = "study-chapter";
    chapter.textContent = `${index + 1}. Chapter ${index + 1}`;

    chapter.addEventListener("click", () => {
      loadStudyChapter(gamePgn);
    });

    list.appendChild(chapter);
  });
}

function loadStudyChapter(pgn) {
  studyChess.reset();
  studyChess.load_pgn(pgn);
  studyBoard.position(studyChess.fen());
  renderStudyNotation(studyChess.history({ verbose: true }));
}


document.addEventListener("change", async (e) => {
  if (e.target.id !== "studySelect") return;

  const pgnId = e.target.value;
  if (!pgnId) return;

  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("pgn, title")
    .eq("id", pgnId)
    .single();

  if (error) return;

  loadStudyFromPGN(data.pgn, data.title);
});

function resetStudyState() {
  studyChess = new Chess();
  studyMoves.length = 0;
  currentMoveIndex = -1;
  document.getElementById("studyNotation").innerHTML = "";
}




async function loadStudentsForAssignment() {
  const select = document.getElementById("assignStudentsSelect");
  if (!select) return;

  select.innerHTML = "";

  const { data, error } = await supabase
    .from("profiles")
    .select("id, username")
    .eq("role", "student")
    .eq("active", true)
    .order("username");

  if (error) {
    console.error("Failed to load students", error);
    return;
  }

  data.forEach(student => {
    const option = document.createElement("option");
    option.value = student.id;
    option.textContent = student.username;
    select.appendChild(option);
  });
}

async function loadStudentsForAssignment2() {
  const box = document.getElementById("assignStudentsBox");
  if (!box) return;

  box.innerHTML = "<div style='opacity:.7'>Loading students‚Ä¶</div>";

  try {
    const { data, error } = await supabase
      .from("profiles")
      .select("id, username")
      .eq("role", "student")
      .eq("active", true)
      .order("username");

    if (error) throw error;

    box.innerHTML = "";

    if (!data || data.length === 0) {
      box.innerHTML = "<div style='opacity:.7'>No students found</div>";
      return;
    }

    data.forEach(student => {
  const row = document.createElement("label");

  row.style.display = "flex";
  row.style.alignItems = "center";
  row.style.justifyContent = "space-between";
  row.style.padding = "6px 10px";
  row.style.cursor = "pointer";
  row.style.borderBottom = "1px solid rgba(255,255,255,0.05)";

  row.innerHTML = `
  <span style="flex:1; text-align:left;">${student.username}</span>
  <span style="width:60px; text-align:right;">
    <input type="checkbox" value="${student.id}">
  </span>
`;


  box.appendChild(row);
});


  } catch (err) {
    console.error("loadStudentsForAssignment error:", err);
    box.innerHTML = "<div style='color:red'>Failed to load students</div>";
  }
}


function getSelectedStudentIds() {
  const box = document.getElementById("assignStudentsBox");
  if (!box) return [];

  return Array.from(
    box.querySelectorAll("input[type='checkbox']:checked")
  ).map(cb => cb.value);
}


function updatePlayerNames(white, black) {
  const whiteContainer = document.getElementById("whitePlayer");
  const blackContainer = document.getElementById("blackPlayer");

  if (whiteContainer) {
    const span = whiteContainer.querySelector("span");
    if (span) span.textContent = white || "White player";
  }

  if (blackContainer) {
    const span = blackContainer.querySelector("span");
    if (span) span.textContent = black || "Black player";
  }
}

function extractPlayersFromPGN(pgn) {
  if (!pgn) {
    updatePlayerNames();
    return;
  }

  const whiteMatch = pgn.match(/\[White\s+"([^"]+)"\]/i);
  const blackMatch = pgn.match(/\[Black\s+"([^"]+)"\]/i);

  const whiteName = whiteMatch ? whiteMatch[1] : null;
  const blackName = blackMatch ? blackMatch[1] : null;

  updatePlayerNames(whiteName, blackName);
}


async function loadStudentsForLiveClass() {
  if (!currentProfile || currentProfile.role !== 'admin') return;

  const list = document.getElementById('liveStudentsList');
  if (!list) return;

  list.innerHTML = 'Loading students...';

  const { data, error } = await supabase
    .from('profiles')
    .select('id, username')
    .eq('role', 'student')
    .eq('active', true)
    .order('username', { ascending: true });

  if (error) {
    console.error(error);
    list.innerHTML = '<p style="color:red">Failed to load students</p>';
    return;
  }

  if (!data || data.length === 0) {
    list.innerHTML = '<p>No active students</p>';
    return;
  }

  list.innerHTML = '';

  data.forEach(student => {
    const row = document.createElement('label');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '8px';
    row.style.marginBottom = '6px';

    row.innerHTML = `
      <input type="checkbox" value="${student.id}">
      <span>${student.username}</span>
    `;

    list.appendChild(row);
  });
}

// PGN DATABASE START //



async function savePGNToLibrary() {
  const titleInput = document.getElementById("assignTitle");
  const pgnInput = document.getElementById("assignPGN");

  if (!titleInput || !pgnInput) {
    alert("Assignment fields not found");
    return;
  }

  const title = titleInput.value.trim();
  const pgn = pgnInput.value.trim();

  if (!title) {
    alert("Please enter a title (this will be used as PGN name)");
    return;
  }

  if (!pgn) {
    alert("Please paste a PGN first");
    return;
  }

  const { error } = await supabase
    .from("bulk_pgn_library")
    .insert({
      title,
      pgn,
      is_active: true
    });

  if (error) {
    console.error("Save PGN failed:", error.message);
    alert("Failed to save PGN (check admin access)");
    return;
  }

  alert("PGN saved to library ‚úÖ");

  // Refresh library panel
  loadPGNLibrary();
}


async function loadPGNLibrary() {
  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("id, title, puzzle_count, created_at, pgn")
    .eq("is_active", true)
    .order("created_at", { ascending: false });

  if (error) {
    console.error("Failed to load PGN library:", error.message);
    return;
  }

  renderPGNLibrary(data || []);
}


function renderPGNLibrary(pgNs) {
  const container = document.getElementById("pgnLibraryList");
  if (!container) return;

  container.innerHTML = "";

  if (!pgNs.length) {
    container.innerHTML = `<p style="opacity:.6;">No PGNs saved yet</p>`;
    return;
  }

  pgNs.forEach(pgn => {
    container.innerHTML += `
  <div class="pgn-item" style="position:relative; margin-bottom:10px;">
    <strong>${pgn.title}</strong>

    <div class="pgn-controls">
  <label>
    <input type="radio" name="pgnMode_${pgn.id}" value="single" checked>
    <span>Single</span>
  </label>

  <label>
    <input type="radio" name="pgnMode_${pgn.id}" value="bulk">
    <span>Bulk</span>
  </label>

  <button class="btn-small" onclick="usePGNFromLibrary(${pgn.id})">
    Use PGN
  </button>

  <button
    class="btn-small danger"
    onclick="deletePGNFromLibrary(${pgn.id})"
  >
    üóë Delete
  </button>
</div>

  </div>
`;

  });
}







// üî• MUST be global
window.usePGNFromLibrary = async function (pgnId) {
  try {
    // 1Ô∏è‚É£ Read mode safely
    let mode = "single";
    const modeInput = document.querySelector(
      `input[name="pgnMode_${pgnId}"]:checked`
    );
    if (modeInput) {
      mode = modeInput.value;
    }

    // 2Ô∏è‚É£ Fetch PGN from Supabase
    const { data, error } = await supabase
      .from("bulk_pgn_library")
      .select("title, pgn")
      .eq("id", pgnId)
      .single();

    if (error || !data) {
      console.error(error);
      alert("Failed to load PGN");
      return;
    }

    // 3Ô∏è‚É£ Fill assignment title if empty
    const titleInput = document.getElementById("assignTitle");
    if (titleInput && !titleInput.value) {
      titleInput.value = data.title;
    }

    // 4Ô∏è‚É£ Fill PGN textarea
    const pgnTextarea = document.getElementById("assignPGN");
    if (!pgnTextarea) {
      alert("Assignment PGN field not found");
      return;
    }

    pgnTextarea.value = data.pgn.trim();

    // 5Ô∏è‚É£ Show form
    const form = document.getElementById("createAssignmentForm");
    if (form) {
      form.style.display = "block";
    }

    pgnTextarea.scrollIntoView({ behavior: "smooth", block: "center" });

    showModal(
  "‚ôü PGN Loaded",
  `<p>PGN loaded as <strong>${mode.toUpperCase()}</strong> successfully.</p>`
);

setTimeout(() => {
  closeModal();
}, 1500);

} catch (err) {
  console.error("usePGNFromLibrary error:", err);

  showModal(
    "‚ùå PGN Load Error",
    "<p>Unexpected error while loading the PGN.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);
}
};



window.deletePGNFromLibrary = function (pgnId) {
  openGradeConfirm(
    "üóëÔ∏è Delete PGN",
    "<p>Are you sure you want to delete this PGN?<br>This action cannot be undone.</p>",
    async () => {
      try {
        const { error } = await supabase
          .from("bulk_pgn_library")
          .update({ is_active: false })
          .eq("id", pgnId);

        if (error) throw error;

        showModal(
          "‚úÖ PGN Deleted",
          "<p>The PGN has been deleted successfully.</p>"
        );

        setTimeout(() => {
          closeModal();
        }, 1500);

        await loadPGNLibrary(); // üî• force refresh

      } catch (err) {
        console.error(err);

        showModal(
          "‚ùå Error",
          "<p>Failed to delete PGN.<br>Please try again.</p>"
        );

        setTimeout(() => {
          closeModal();
        }, 2000);
      }
    }
  );
};




function openPGNTitleModal(onConfirm) {
  const modal = document.getElementById("pgnTitleModal");
  const input = document.getElementById("pgnTitleInput");
  const confirmBtn = document.getElementById("confirmPGNTitle");
  const cancelBtn = document.getElementById("cancelPGNTitle");

  input.value = "";
  modal.classList.remove("hidden");
  input.focus();

  const cleanup = () => {
    modal.classList.add("hidden");
    confirmBtn.onclick = null;
    cancelBtn.onclick = null;
  };

  cancelBtn.onclick = cleanup;

  confirmBtn.onclick = () => {
    const title = input.value.trim();
    if (!title) {
      alert("Title required");
      return;
    }
    cleanup();
    onConfirm(title);
  };
}


function formatSecondsToTime(value) {
  const seconds = Number(value);
  if (!seconds || isNaN(seconds)) return "0s";

  const m = Math.floor(seconds / 60);
  const s = seconds % 60;

  return m > 0 ? `${m}m ${s}s` : `${s}s`;
}




// PGN DATABASE END //

// Puzzle Rush mate in 1 start //
// ===============================
// ‚ö° PUZZLE RUSH ‚Äì LOAD MATE IN 1
// ===============================
async function loadMateIn1Puzzles() {
  const { data, error } = await supabase
    .from("puzzle_rush_mate1")
    .select("id, fen, solution, side_to_move")
    .eq("is_active", true);

  if (error) {
    console.error("‚ùå Failed to load Mate in 1 puzzles", error);
    return [];
  }

  console.log("‚ö° Mate in 1 puzzles loaded:", data.length);
  return data;
}


// puzzle rush mate in 1 end //


// STUDENT PROGRESS FUNCTIONS START //
async function loadStudentProgress() {
  const list = document.getElementById("studentProgressList");
  if (!list) return;

  list.innerHTML = "<p class='muted'>Loading progress...</p>";

  const { data, error } = await supabase
    .from("attempts")
    .select(`
      assignment_id,
      time_spent,
      is_correct,
      submitted_at,
      assignments ( title )
    `)
    .eq("student_id", currentUser.id)
    .order("submitted_at", { ascending: false });

  if (error) {
    console.error("Progress load error:", error);
    list.innerHTML = "<p class='muted'>Failed to load progress.</p>";
    return;
  }

  if (!data || data.length === 0) {
    list.innerHTML = "<p class='muted'>No attempts yet.</p>";
    return;
  }

  // Group by assignment
  const progressMap = {};

  for (const row of data) {
    const id = row.assignment_id;

    if (!progressMap[id]) {
      progressMap[id] = {
  assignmentId: id,
  title: row.assignments?.title || "Unknown assignment",
  attempts: 0,
  status: "Attempted",
  time: row.time_spent,
  lastPlayed: row.submitted_at
};

    }

    progressMap[id].attempts += 1;

    if (row.is_correct) {
      progressMap[id].status = "Solved";
    }
  }

  // ‚úÖ STEP 4A: count EVERY successful submission (not grouped)
const solvedCount = data.filter(row => row.is_correct === true).length;

studentSolvedCount = solvedCount;
console.log("üèÖ Student solved submissions:", studentSolvedCount);

const unlockable = getUnlockableBadges();
console.log(
  "üîì Unlockable badges:",
  unlockable.map(b => `${b.title} (req ${b.required})`)
);

// REQUIRED
loadUnlockedBadges();
renderStudentBadges();



  // Render
  list.innerHTML = "";

  const orderedProgress = Object.values(progressMap).sort(
  (a, b) => new Date(b.lastPlayed) - new Date(a.lastPlayed)
);

orderedProgress.forEach(p => {
  list.innerHTML += `
    <div class="progress-item">
      <strong>${p.title}</strong>
      <div class="progress-meta">
        Attempts: ${p.attempts} |
        Status: ${p.status} |
        Time: ${formatSecondsToTime(p.time)}
      </div>
      <div class="progress-date">
        Last played: ${new Date(p.lastPlayed).toLocaleDateString()}
      </div>
      <div class="progress-actions">
        <button
  class="btn-small reattempt-btn"
  data-assignment-id="${p.assignmentId}"
>
  Re-attempt
</button>



        <button
  class="btn-small view-details-btn"
  data-assignment-id="${p.assignmentId}"
>
  View details
</button>

      </div>
      <hr />
    </div>
  `;
});

}

async function reattemptAssignment(assignmentId) {
  try {
    console.log("Re-attempting assignment:", assignmentId);

    const { data: assignment, error } = await supabase
      .from("assignments")
      .select("*")
      .eq("id", assignmentId)
      .single();

    if (error || !assignment) {
      showStatus("Assignment not found", "error");
      return;
    }

    // üîÅ FULL RESET (important)
    currentAssignment = null;
    expectedMoves = [];
    assignmentCursor = 0;
    attemptCount = 0;
    bulkIndex = 0;
    bulkPuzzles = [];

    // Switch to board
    document.querySelector('[data-tab="board"]').click();

    // Start fresh attempt
    startInteractiveAssignment(assignment);

    showStatus("üîÅ Re-attempt started", "info");

  } catch (err) {
    console.error("Re-attempt failed:", err);
    showStatus("Failed to re-attempt assignment", "error");
  }
}

async function viewAssignmentDetailsForStudent(assignmentId) {
  try {
    const { data: assignment, error } = await supabase
      .from("assignments")
      .select(`
        title,
        description,
        task_type,
        due_at,
        created_at
      `)
      .eq("id", assignmentId)
      .single();

    if (error || !assignment) {
      showModal("‚ùå Error", "<p>Assignment details not found.</p>");
      return;
    }

    const html = `
      <p><strong>Title:</strong> ${assignment.title}</p>
      <p><strong>Type:</strong> ${assignment.task_type}</p>
      <p><strong>Created:</strong> ${new Date(assignment.created_at).toLocaleString()}</p>
      ${assignment.due_at ? `<p><strong>Due:</strong> ${new Date(assignment.due_at).toLocaleString()}</p>` : ""}
      <hr>
      <p><strong>Description:</strong></p>
      <p>${assignment.description || "No description provided."}</p>
    `;

    showModal("üìò Assignment Details", html);

  } catch (err) {
    console.error(err);
    showModal("‚ùå Error", "<p>Something went wrong.</p>");
  }
}






// STUDENT PROGRESS FUNCTIONS END //



function openStudentModal(studentId, username) {
  document.getElementById("studentModalTitle").textContent =
    `üë§ ${username} ‚Äî Full Details`;

  document.getElementById("studentModalBody").innerHTML =
    `<p class="loading">Fetching data‚Ä¶</p>`;

  document.getElementById("studentDetailsModal").classList.remove("hidden");

  // ‚úÖ LOAD REAL DATA
  loadStudentFullDetails(studentId);
}


window.closeStudentModal = function () {
  document
    .getElementById("studentDetailsModal")
    .classList.add("hidden");
};


function calculateRatings(profile) {
  const puzzleRating = profile.puzzle_current_score || 0;
  const quizRating   = profile.quiz_current_score || 0;
  const gameRating   = profile.game_current_score || 0;

  const olympusRating =
    Math.round((puzzleRating + quizRating + gameRating) / 3 / 10) * 10;

  return {
    puzzleRating,
    quizRating,
    gameRating,
    olympusRating,
    tier: getOlympusTier(olympusRating)
  };
}









async function loadStudentFullDetails(studentId) {
  try {
    // 1Ô∏è‚É£ Profile
    const { data: profile, error: profileError } = await supabase
  .from("profiles")
  .select(`
    username,
    active,
    created_at,
    puzzle_current_score,
    quiz_current_score,
    game_current_score
  `)
  .eq("id", studentId)
  .single();

  


    if (profileError) throw profileError;

    // 2Ô∏è‚É£ Attempts + assignments
    const { data: attempts, error: attemptsError } = await supabase
      .from("attempts")
      .select(`
        id,
        submitted_at,
        time_spent,
        attempt_count,
        is_correct,
        assignments ( title )
      `)
      .eq("student_id", studentId)
      .order("submitted_at", { ascending: false });

    if (attemptsError) throw attemptsError;

    // 3Ô∏è‚É£ Mini-game highscores
const { data: miniScores, error: miniError } = await supabase
  .from("minigame_high_scores")
  .select("game_key, score")
  .eq("student_id", studentId)
  .order("score", { ascending: false });

if (miniError) throw miniError;


    // ‚úÖ FINAL RENDER
    renderStudentModal(profile, attempts || [], miniScores || []);
  } catch (err) {
    console.error(err);
    document.getElementById("studentModalBody").innerHTML =
      `<p style="color:#ff6b6b;">Failed to load student data</p>`;
  }
}

function getUnlockedAchievementCount(studentId) {
  try {
    const key = `unlocked_badges_${studentId}`;
    const raw = localStorage.getItem(key);
    if (!raw) return 0;

    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed.length : 0;
  } catch {
    return 0;
  }
}

/* ================================
   üéØ TARGET OBJECT SYSTEM (GLOBAL)
================================ */

// add your 20+ fun images here
const TARGET_IMAGES = [
  "assets/targets/ball.png",
  "assets/targets/burger.png",
  "assets/targets/chocolate.png",
  "assets/targets/cube.png",
  "assets/targets/star.png",
  "assets/targets/popcorn.png",
  "assets/targets/ele.png",
  "assets/targets/lorry.png",
  "assets/targets/duck.png",
  "assets/targets/dino.png",
  "assets/targets/cube.png",
  "assets/targets/robo.png",
  "assets/targets/truck.png",
  "assets/targets/unicorn.png"
  
];

// utility
function randomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function getRandomTarget() {
  return TARGET_IMAGES[Math.floor(Math.random() * TARGET_IMAGES.length)];
}



let misses = 0;
const missEl = document.getElementById("knightMisses");

let knightTarget = null;
let knightTargetImg = null;



const boardEl = document.getElementById("miniBoard");
const starEl = document.getElementById("stars");
const startBtn = document.getElementById("startMiniGame");

let knightPos = { x: 3, y: 3 };
let correctSquares = [];
let stars = 0;

const knightMoves = [
  [1,2],[2,1],[-1,2],[-2,1],
  [1,-2],[2,-1],[-1,-2],[-2,-1]
];

function drawBoard() {
  boardEl.innerHTML = "";
  correctSquares = [];

  // 1Ô∏è‚É£ calculate knight legal moves FIRST
  knightMoves.forEach(([dx, dy]) => {
    const nx = knightPos.x + dx;
    const ny = knightPos.y + dy;
    if (nx >= 0 && ny >= 0 && nx < 8 && ny < 8) {
      correctSquares.push(`${nx}-${ny}`);
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x); // a‚Äìh
      sq.dataset.rank = 8 - y;                        // 8‚Äì1

      // ‚ôò knight
      if (x === knightPos.x && y === knightPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wN.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object (if enabled)
      if (
        typeof knightTarget !== "undefined" &&
        knightTarget &&
        x === knightTarget.x &&
        y === knightTarget.y
      ) {
        const t = document.createElement("img");
        t.src = knightTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  handleClick(sq);
});

      boardEl.appendChild(sq);
    }
  }
}


function handleClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);

  const key = `${x}-${y}`;

  // ‚ùå illegal knight move
  if (!correctSquares.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal move
  square.classList.add("correct");

  // move knight
  knightPos = { x, y };

  // üéØ TARGET REACHED!
  if (knightTarget && x === knightTarget.x && y === knightTarget.y) {
    stars++;
    starEl.textContent = stars;

    setTimeout(startGame, 400); // next puzzle
    return;
  }

  // continue same puzzle
  setTimeout(drawBoard, 300);
}


function startGame() {
  stars = 0;
  starEl.textContent = stars;

  knightPos = randomSquare();

  // üéØ spawn target (not on knight)
  do {
    knightTarget = randomSquare();
  } while (
    knightTarget.x === knightPos.x &&
    knightTarget.y === knightPos.y
  );

  knightTargetImg = getRandomTarget();

  drawBoard();
}


startBtn.onclick = startGame;

function nextKnightRound() {
  knightPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawBoard();
}


let bishopMisses = 0;
const bishopMissEl = document.getElementById("bishopMisses");
let bishopTarget = null;
let bishopTargetImg = null;


const bishopBoard = document.getElementById("bishopBoard");
const bishopStarEl = document.getElementById("bishopStars");
const bishopStartBtn = document.getElementById("bishopStart");

let bishopPos = { x: 3, y: 3 };
let bishopCorrect = [];
let bishopStars = 0;

// ‚ôó Bishop diagonals
const bishopDirections = [
  [1,1], [1,-1], [-1,1], [-1,-1]
];

function drawBishopBoard() {
  bishopBoard.innerHTML = "";
  bishopCorrect = [];

  // 1Ô∏è‚É£ calculate bishop diagonals FIRST
  bishopDirections.forEach(([dx, dy]) => {
    let x = bishopPos.x + dx;
    let y = bishopPos.y + dy;

    while (x >= 0 && y >= 0 && x < 8 && y < 8) {
      bishopCorrect.push(`${x}-${y}`);
      x += dx;
      y += dy;
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // ‚ôó bishop
      if (x === bishopPos.x && y === bishopPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wB.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object
      if (
        bishopTarget &&
        x === bishopTarget.x &&
        y === bishopTarget.y
      ) {
        const t = document.createElement("img");
        t.src = bishopTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  bishopClick(sq);
});

      bishopBoard.appendChild(sq);
    }
  }
}


function bishopClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal bishop move
  if (!bishopCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal move
  square.classList.add("correct");

  bishopPos = { x, y };

  // üéØ target reached
  if (
    bishopTarget &&
    x === bishopTarget.x &&
    y === bishopTarget.y
  ) {
    bishopStars++;
    bishopStarEl.textContent = bishopStars;

    setTimeout(startBishopGame, 400);
    return;
  }

  setTimeout(drawBishopBoard, 300);
}



function nextBishopRound() {
  bishopPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawBishopBoard();
}

function startBishopGame() {
  bishopStars = 0;
  bishopStarEl.textContent = bishopStars;

  bishopPos = randomSquare();

  function sameSquareColor(a, b) {
  return (a.x + a.y) % 2 === (b.x + b.y) % 2;
}

  // üéØ spawn target on SAME COLOR square
  do {
    bishopTarget = randomSquare();
  } while (
    (bishopTarget.x === bishopPos.x && bishopTarget.y === bishopPos.y) ||
    !sameSquareColor(bishopPos, bishopTarget)
  );

  bishopTargetImg = getRandomTarget();

  drawBishopBoard();
}



bishopStartBtn.onclick = startBishopGame;

let rookMisses = 0;
const rookMissEl = document.getElementById("rookMisses");

let rookTarget = null;
let rookTargetImg = null;


const rookBoard = document.getElementById("rookBoard");
const rookStarEl = document.getElementById("rookStars");
const rookStartBtn = document.getElementById("rookStart");

let rookPos = { x: 3, y: 3 };
let rookCorrect = [];
let rookStars = 0;

function drawRookBoard() {
  rookBoard.innerHTML = "";
  rookCorrect = [];

  // 1Ô∏è‚É£ calculate rook moves (same rank & file)
  for (let i = 0; i < 8; i++) {
    if (i !== rookPos.x) rookCorrect.push(`${i}-${rookPos.y}`);
    if (i !== rookPos.y) rookCorrect.push(`${rookPos.x}-${i}`);
  }

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // ‚ôñ rook
      if (x === rookPos.x && y === rookPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wR.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object
      if (
        rookTarget &&
        x === rookTarget.x &&
        y === rookTarget.y
      ) {
        const t = document.createElement("img");
        t.src = rookTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  rookClick(sq);
});

      rookBoard.appendChild(sq);
    }
  }
}



function rookClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal rook move (not same rank/file)
  if (!rookCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal step
  square.classList.add("correct");

  // move rook
  rookPos = { x, y };

  // üéØ target reached
  if (
    rookTarget &&
    x === rookTarget.x &&
    y === rookTarget.y
  ) {
    rookStars++;
    rookStarEl.textContent = rookStars;

    setTimeout(startRookGame, 400);
    return;
  }

  // continue SAME puzzle
  setTimeout(drawRookBoard, 300);
}



function nextRookRound() {
  rookPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawRookBoard();
}

function startRookGame() {
  rookStars = 0;
  rookStarEl.textContent = rookStars;

  rookPos = randomSquare();

  // üéØ target can be ANYWHERE except rook square
  do {
    rookTarget = randomSquare();
  } while (
    rookTarget.x === rookPos.x &&
    rookTarget.y === rookPos.y
  );

  rookTargetImg = getRandomTarget();

  drawRookBoard();
}



rookStartBtn.onclick = startRookGame;


let queenMisses = 0;
const queenMissEl = document.getElementById("queenMisses");

let queenTarget = null;
let queenTargetImg = null;


const queenBoard = document.getElementById("queenBoard");
const queenStarEl = document.getElementById("queenStars");
const queenStartBtn = document.getElementById("queenStart");

let queenPos = { x: 3, y: 3 };
let queenCorrect = [];
let queenStars = 0;

// rook + bishop directions
const queenDirs = [
  [1,0],[-1,0],[0,1],[0,-1],   // rook
  [1,1],[1,-1],[-1,1],[-1,-1] // bishop
];

function drawQueenBoard() {
  queenBoard.innerHTML = "";
  queenCorrect = [];

  // 1Ô∏è‚É£ calculate queen moves (rook + bishop)
  queenDirs.forEach(([dx, dy]) => {
    let x = queenPos.x + dx;
    let y = queenPos.y + dy;

    while (x >= 0 && y >= 0 && x < 8 && y < 8) {
      queenCorrect.push(`${x}-${y}`);
      x += dx;
      y += dy;
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // ‚ôõ queen
      if (x === queenPos.x && y === queenPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wQ.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object (ANYWHERE)
      if (
        queenTarget &&
        x === queenTarget.x &&
        y === queenTarget.y
      ) {
        const t = document.createElement("img");
        t.src = queenTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  queenClick(sq);
});

      queenBoard.appendChild(sq);
    }
  }
}


function queenClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal queen move
  if (!queenCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal step
  square.classList.add("correct");
  queenPos = { x, y };

  // üéØ target reached
  if (
    queenTarget &&
    x === queenTarget.x &&
    y === queenTarget.y
  ) {
    queenStars++;
    queenStarEl.textContent = queenStars;

    setTimeout(startQueenGame, 400);
    return;
  }

  // continue same puzzle
  setTimeout(drawQueenBoard, 300);
}


function nextQueenRound() {
  queenPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawQueenBoard();
}

function startQueenGame() {
  queenStars = 0;
  queenStarEl.textContent = queenStars;

  queenPos = randomSquare();

  // üéØ target can be ANYWHERE except queen square
  do {
    queenTarget = randomSquare();
  } while (
    queenTarget.x === queenPos.x &&
    queenTarget.y === queenPos.y
  );

  queenTargetImg = getRandomTarget();

  drawQueenBoard();
}


queenStartBtn.onclick = startQueenGame;


let pawnMisses = 0;
const pawnMissEl = document.getElementById("pawnMisses");

let pawnTarget = null;
let pawnTargetImg = null;


const pawnBoard = document.getElementById("pawnBoard");
const pawnStarEl = document.getElementById("pawnStars");
const pawnStartBtn = document.getElementById("pawnStart");

let pawnPos = { x: 3, y: 6 }; // white pawn
let pawnCorrect = [];
let pawnStars = 0;

function drawPawnBoard() {
  pawnBoard.innerHTML = "";
  pawnCorrect = [];

  const x = pawnPos.x;
  const y = pawnPos.y;

  // ‚ôô forward one
  if (y - 1 >= 0) {
    pawnCorrect.push(`${x}-${y - 1}`);
  }

  // ‚ôô forward two from starting rank
  if (y === 6 && y - 2 >= 0) {
    pawnCorrect.push(`${x}-${y - 2}`);
  }

  // ‚öîÔ∏è capture diagonals
  if (x - 1 >= 0 && y - 1 >= 0) {
    pawnCorrect.push(`${x - 1}-${y - 1}`);
  }
  if (x + 1 < 8 && y - 1 >= 0) {
    pawnCorrect.push(`${x + 1}-${y - 1}`);
  }

  // draw board
  for (let yy = 0; yy < 8; yy++) {
    for (let xx = 0; xx < 8; xx++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((xx + yy) % 2 ? "dark" : "");

      sq.dataset.x = xx;
      sq.dataset.y = yy;
      sq.dataset.key = `${xx}-${yy}`;
      sq.dataset.file = String.fromCharCode(97 + xx);
      sq.dataset.rank = 8 - yy;

      // ‚ôô pawn
      if (xx === pawnPos.x && yy === pawnPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wP.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target
      if (
        pawnTarget &&
        xx === pawnTarget.x &&
        yy === pawnTarget.y
      ) {
        const t = document.createElement("img");
        t.src = pawnTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  pawnClick(sq);
});

      pawnBoard.appendChild(sq);
    }
  }
}


function pawnClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  if (!pawnCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // üö´ cannot capture forward
  if (
    x === pawnPos.x &&
    pawnTarget &&
    (pawnTarget.x !== x || pawnTarget.y !== y)
  ) {
    square.classList.add("wrong");
    return;
  }

  // üö´ cannot move diagonally unless target is there
  if (
    x !== pawnPos.x &&
    pawnTarget &&
    !(x === pawnTarget.x && y === pawnTarget.y)
  ) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal pawn action
  square.classList.add("correct");
  pawnPos = { x, y };

  // üéØ target reached (move or capture)
  if (
    pawnTarget &&
    x === pawnTarget.x &&
    y === pawnTarget.y
  ) {
    pawnStars++;
    pawnStarEl.textContent = pawnStars;

    setTimeout(startPawnGame, 400);
    return;
  }

  setTimeout(drawPawnBoard, 300);
}


function startPawnGame() {
  pawnStars = 0;
  pawnStarEl.textContent = pawnStars;

  // ‚ôô random file
  const startX = Math.floor(Math.random() * 8);

  // ‚ôô random rank BUT not 1st (7) or last (0)
  // board y: 0 = rank 8, 7 = rank 1
  const startY = Math.floor(Math.random() * 6) + 1; // 1 ‚Üí 6

  pawnPos = { x: startX, y: startY };

  // decide puzzle type
  const canDouble = pawnPos.y === 6;
  const mode = Math.random() < 0.6 ? "move" : "capture";

  if (mode === "move") {
    // ‚ôô forward move
    pawnTarget = {
      x: pawnPos.x,
      y: canDouble && Math.random() < 0.5
        ? pawnPos.y - 2
        : pawnPos.y - 1
    };
  } else {
    // ‚öîÔ∏è diagonal capture
    const dirs = [];
    if (pawnPos.x > 0) dirs.push(-1);
    if (pawnPos.x < 7) dirs.push(1);

    pawnTarget = {
      x: pawnPos.x + dirs[Math.floor(Math.random() * dirs.length)],
      y: pawnPos.y - 1
    };
  }

  pawnTargetImg = getRandomTarget();

  drawPawnBoard();
}



pawnStartBtn.onclick = startPawnGame;


let kingMisses = 0;
const kingMissEl = document.getElementById("kingMisses");

let kingTarget = null;
let kingTargetImg = null;


const kingBoard = document.getElementById("kingBoard");
const kingStarEl = document.getElementById("kingStars");
const kingStartBtn = document.getElementById("kingStart");

let kingPos = { x: 3, y: 3 };
let kingCorrect = [];
let kingStars = 0;

const kingDirs = [
  [-1,-1], [0,-1], [1,-1],
  [-1, 0],         [1, 0],
  [-1, 1], [0, 1], [1, 1]
];

function drawKingBoard() {
  kingBoard.innerHTML = "";
  kingCorrect = [];

  // 1Ô∏è‚É£ calculate king moves (1 square any direction)
  kingDirs.forEach(([dx, dy]) => {
    const x = kingPos.x + dx;
    const y = kingPos.y + dy;
    if (x >= 0 && y >= 0 && x < 8 && y < 8) {
      kingCorrect.push(`${x}-${y}`);
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // üëë king
      if (x === kingPos.x && y === kingPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wK.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object (ANYWHERE)
      if (
        kingTarget &&
        x === kingTarget.x &&
        y === kingTarget.y
      ) {
        const t = document.createElement("img");
        t.src = kingTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  kingClick(sq);
});

      kingBoard.appendChild(sq);
    }
  }
}



function kingClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal king move
  if (!kingCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal step
  square.classList.add("correct");
  kingPos = { x, y };

  // üéØ target reached
  if (
    kingTarget &&
    x === kingTarget.x &&
    y === kingTarget.y
  ) {
    kingStars++;
    kingStarEl.textContent = kingStars;

    setTimeout(startKingGame, 400);
    return;
  }

  // continue same puzzle
  setTimeout(drawKingBoard, 300);
}


function startKingGame() {
  kingStars = 0;
  kingStarEl.textContent = kingStars;

  kingPos = randomSquare();

  // üéØ target can be ANYWHERE except king square
  do {
    kingTarget = randomSquare();
  } while (
    kingTarget.x === kingPos.x &&
    kingTarget.y === kingPos.y
  );

  kingTargetImg = getRandomTarget();

  drawKingBoard();
}


kingStartBtn.onclick = startKingGame;


const memoryNextSound = new Audio("sounds/next.mp3");
memoryNextSound.volume = 0.5;

const memoryPartySound = new Audio("sounds/party.mp3");
memoryPartySound.volume = 0.7;

const memoryStartSound = new Audio("sounds/puzzle-rush-start.mp3");
memoryStartSound.volume = 0.6;
const memoryWrongSound = new Audio("sounds/wrong.mp3");
memoryWrongSound.volume = 0.6;





// =============================
// üß† MEMORY SQUARES GAME
// =============================

const memoryBoard = document.getElementById("memoryBoard");
const memoryTimerEl = document.getElementById("memoryTimer");
const memoryLivesEl = document.getElementById("memoryLives");
const memoryScoreEl = document.getElementById("memoryScore");
const memoryGameEl = document.getElementById("memoryGame");
const memoryMenu = document.getElementById("memoryMenu");

let memoryMode = "";
let memoryTimer = null;

let level = 1;
let round = 1;
let squaresToRemember = 3;

let playerClicks = [];

let lives = 3;
let score = 0;


function drawMemoryBoard() {
  memoryBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {      // üî• FIX: draw from rank 8 ‚Üí 1
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");

      // ‚úÖ Correct chess color orientation
      sq.className = "memory-square " + ((x + y) % 2 === 0 ? "dark" : "");

      // internal key (unchanged logic)
      sq.dataset.key = `${x}-${y}`;

      // ‚ôüÔ∏è FILE‚ÄìRANK LABEL
      const file = String.fromCharCode(97 + x); // a‚Äìh
      const rank = y + 1;                       // 1‚Äì8 (because y is reversed)

      const coord = document.createElement("div");
      coord.className = "memory-coord";
      coord.textContent = `${file}${rank}`;
      sq.appendChild(coord);

      sq.onclick = () => memoryClick(sq);
      memoryBoard.appendChild(sq);
    }
  }
}



function getRandomSquares(count) {
  const all = [];
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      all.push(`${x}-${y}`);
    }
  }

  return all.sort(() => 0.5 - Math.random()).slice(0, count);
}



function startMemoryRound() {
  playerClicks = [];
  correctSquares = getRandomSquares(squaresToRemember);

  drawMemoryBoard();

  // üî¶ FLASH
  document.querySelectorAll(".memory-square").forEach(sq => {
    if (correctSquares.includes(sq.dataset.key)) {
      sq.classList.add("flash");
    }
  });
  

  // ‚è± hide after 1 sec
  setTimeout(() => {
    document.querySelectorAll(".memory-square").forEach(sq =>
      sq.classList.remove("flash")
    );
  }, 1000);
}


function memoryClick(square) {
  const key = square.dataset.key;
  if (playerClicks.includes(key)) return;

  playerClicks.push(key);

  if (correctSquares.includes(key)) {
    square.classList.add("correct");
  } else {
    square.classList.add("wrong");
    
    // üîä WRONG SOUND
  memoryWrongSound.currentTime = 0;
  memoryWrongSound.play().catch(() => {});

    lives--;
    memoryLivesEl.textContent = lives;

    if (lives <= 0) {
      endMemoryGame();
      return;
    }
  }

  // ‚úÖ round complete
  if (playerClicks.length === correctSquares.length) {
  score++;
  memoryScoreEl.textContent = score;

  // üîä NEXT ROUND SOUND
  memoryNextSound.currentTime = 0;
  memoryNextSound.play().catch(() => {});

  round++;
  if (round > 5) {
    level++;
    round = 1;
    squaresToRemember++;
  }

  setTimeout(startMemoryRound, 600);
}

}


function startMemoryGame(mode, time) {

  // üîä GAME START SOUND
  memoryStartSound.currentTime = 0;
  memoryStartSound.play().catch(() => {});

  memoryMode = mode;
  lives = mode === "survival" ? 1 : 3;
  score = 0;
  level = 1;
  round = 1;
  squaresToRemember = 3;

  memoryLivesEl.textContent = lives;
  memoryScoreEl.textContent = score;

  memoryMenu.classList.add("hidden");
  memoryGameEl.classList.remove("hidden");

  drawMemoryBoard();
  startMemoryRound();

  if (time) {
    let t = time;
    memoryTimerEl.textContent = t;
    memoryTimer = setInterval(() => {
      t--;
      memoryTimerEl.textContent = t;
      if (t <= 0) endMemoryGame();
    }, 1000);
  }
}



function endMemoryGame() {
  clearInterval(memoryTimer);

  // üîä PARTY SOUND (play once)
  memoryPartySound.currentTime = 0;
  memoryPartySound.play().catch(() => {});

  showFloatingModal(
    "üß† Memory Squares",
    `
      <strong>Game Over!</strong><br><br>
      ‚≠ê Score: <strong>${score}</strong><br>
      ‚ù§Ô∏è Lives Left: <strong>${lives}</strong>
    `,
    () => {
      exitMemory();
      saveMiniGameScore("memory", score);

    }
  );
}



function exitMemory() {
  clearInterval(memoryTimer);
  memoryGameEl.classList.add("hidden");
  memoryMenu.classList.remove("hidden");
}


document.addEventListener("DOMContentLoaded", () => {
  const mem3 = document.getElementById("mem3");
  const mem5 = document.getElementById("mem5");
  const memSurvival = document.getElementById("memSurvival");
  const memoryExit = document.getElementById("memoryExit");

  if (mem3) mem3.onclick = () => startMemoryGame("rush", 180);
  if (mem5) mem5.onclick = () => startMemoryGame("rush", 300);
  if (memSurvival) memSurvival.onclick = () => startMemoryGame("survival");
  if (memoryExit) memoryExit.onclick = exitMemory;
});





function renderStudentModal(profile, attempts, miniScores = []) {

  const ratings = calculateRatings(profile); // ‚úÖ ADD THIS

  const progressData = calculateRatingProgress(profile);

const fill = document.getElementById("studentProgressFill");
const text = document.getElementById("studentProgressText");

if (fill) fill.style.width = `${progressData.progress}%`;
if (text)
  text.textContent = `${progressData.progress}% to ${progressData.nextStep}`;

  currentStudentTier = ratings.tier || "N/A";


  const total = attempts.length;
  const correct = attempts.filter(a => a.is_correct).length;
  const incorrect = total - correct;
  const totalTime = attempts.reduce((s, a) => s + (a.time_spent || 0), 0);

  const unlockedAchievements = getUnlockedAchievementCount(profile.id);
  const totalAchievements =
    Array.isArray(window.STUDENT_BADGES) ? STUDENT_BADGES.length : 0;

    let miniGameHTML = `
  <h4>üéÆ Mini-Game Best Scores</h4>
`;

if (miniScores.length === 0) {
  miniGameHTML += `<p style="opacity:.7;">No mini-game scores yet.</p>`;
} else {
  miniScores.forEach(row => {
    miniGameHTML += `
      <div style="
        display:flex;
        justify-content:space-between;
        padding:6px 0;
        border-bottom:1px dashed rgba(255,255,255,0.08);
      ">
        <span>${formatGameName(row.game_key)}</span>
        <strong>${row.score}</strong>
      </div>
    `;
  });
}


  let html = `
    <div style="text-align:left;">

      <!-- üèÜ RATING BLOCK (NEW) -->
      <div class="student-rating-box">
        <div class="main-rating">
          <strong>ELO ${ratings.olympusRating}</strong>
          <span class="tier">${ratings.tier}</span>
        </div>

        <div class="rating-breakdown">
          ‚ö° Puzzle: <b>${ratings.puzzleRating}</b>
          üéØ Quiz: <b>${ratings.quizRating}</b>
          üéÆ Game: <b>${ratings.gameRating}</b>
        </div>
      </div>

      <hr>

      <p><strong>Status:</strong> ${profile.active ? "‚úÖ Active" : "‚ùå Inactive"}</p>
      <p><strong>Joined:</strong> ${new Date(profile.created_at).toLocaleDateString()}</p>

      <hr>

      <p><strong>Total assignments:</strong> ${total}</p>
      <p><strong>Correct:</strong> ${correct}</p>
      <p><strong>Incorrect:</strong> ${incorrect}</p>
      <p><strong>Total time spent:</strong> ${formatTime(totalTime)}</p>

      <p>
        <strong>üèÖ Achievements unlocked:</strong>
        ${unlockedAchievements} / ${totalAchievements}
      </p>

      <hr>

      ${miniGameHTML}

<hr>

      

      <h4>üìö Assignment History</h4>
  `;

  if (total === 0) {
    html += `<p style="opacity:.7;">No attempts yet.</p>`;
  } else {
    attempts.forEach(a => {
      html += `
        <div style="padding:8px; border-bottom:1px solid rgba(255,255,255,0.08);">
          <strong>${a.assignments?.title || "Unknown"}</strong><br>
          Submitted: ${new Date(a.submitted_at).toLocaleString()}<br>
          Time: ${formatTime(a.time_spent || 0)} |
          Attempts: ${a.attempt_count || 1} |
          ${a.is_correct ? "‚úÖ Correct" : "‚ùå Incorrect"}
        </div>
      `;
    });
  }

  html += `</div>`;

  document.getElementById("studentModalBody").innerHTML = html;
}



// üåø Study move tree (flat for now)
const studyMoves = [];
let currentMoveIndex = -1;
let activeNotationNode = null; // { type: "main"|"variation", index }
let currentStudyTitle = "";






let studyBoard = null;
let studyChess = null;
const studyState = {
  currentChapterPgn: "",
  chapters: [],
  baseMoveIndex: 0
};

function clearNotationHighlights() {
  document
    .querySelectorAll(".move.active-main, .move.active-variation")
    .forEach(el => {
      el.classList.remove("active-main", "active-variation");
    });
}


// ===============================
// üìò Study Panel Interaction (UI only)
// ===============================

document.addEventListener("DOMContentLoaded", () => {
  const studyHeader = document.querySelector(".study-item");
  const chapters = document.querySelectorAll(".study-chapter");

  // Toggle study open/close
  if (studyHeader) {
    studyHeader.addEventListener("click", () => {
      studyHeader.classList.toggle("active");

      chapters.forEach(ch => {
        ch.style.display =
          ch.style.display === "none" ? "block" : "none";
      });
    });
  }

  // Chapter selection
  chapters.forEach(chapter => {
    chapter.addEventListener("click", () => {
      chapters.forEach(c => c.classList.remove("active"));
      chapter.classList.add("active");

      // üîí placeholder for later:
      // loadChapterPGN(chapter)
    });
  });
});

// ===============================
// üìò Study PGN Import (UI only)
// ===============================

function showFloatingModal(title, message, onClose) {
  const modal = document.getElementById("floatingModal");
  const modalTitle = document.getElementById("modalTitle");
  const modalBody = document.getElementById("modalBody");
  const modalOkBtn = document.getElementById("modalOkBtn");

  if (!modal) return;

  modalTitle.textContent = title;
  modalBody.innerHTML = message;

  modal.classList.remove("hidden");

  modalOkBtn.onclick = () => {
    modal.classList.add("hidden");
    if (onClose) onClose();
  };
}


// ===============================
// üìò Study PGN Import (UI only) ‚Äî FIXED
// ===============================

document.addEventListener("DOMContentLoaded", () => {
  const importBtn = document.getElementById("importStudyBtn");
  const modal = document.getElementById("studyImportModal");
  const cancelBtn = document.getElementById("importStudyCancel");
  const confirmBtn = document.getElementById("importStudyConfirm");
  const studyPgnInput = document.getElementById("studyPgnInput");
  const studyList = document.getElementById("studyList");
  const uploadBtn = document.getElementById("uploadStudyBtn");
const fileInput = document.getElementById("studyFileInput");

uploadBtn.addEventListener("click", () => {
  fileInput.click();
});

fileInput.addEventListener("change", () => {
  const file = fileInput.files[0];
  if (!file) return;

  const reader = new FileReader();

  reader.onload = () => {
    // put file content directly into textarea
    studyPgnInput.value = reader.result;
    modal.classList.remove("hidden");
  };

  reader.readAsText(file);
});
document.getElementById("studySelect").addEventListener("change", async (e) => {
  const pgnId = e.target.value;
  if (!pgnId) return;

  console.log("üìÇ Study selected:", pgnId);

  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("pgn, title")
    .eq("id", pgnId)
    .single();

  if (error || !data) {
    console.error("‚ùå Failed to load PGN:", error);
    return;
  }

  // üîë THIS IS THE MAGIC
  studyPgnInput.value = data.pgn;

  // Optional: show title somewhere
  console.log("üìò Loaded study:", data.title);
  currentStudyTitle = data.title;


  // üîì Open the SAME import modal
  studyImportModal.classList.remove("hidden");
});



  if (!importBtn || !modal) {
    console.error("‚ùå Study PGN elements not found");
    return;
  }

  

  

  // Open modal
  importBtn.addEventListener("click", () => {
    modal.classList.remove("hidden");
  });

  // Cancel modal
  cancelBtn.addEventListener("click", () => {
    modal.classList.add("hidden");
  });

  // Confirm import
  confirmBtn.addEventListener("click", () => {
    const raw = studyPgnInput.value.trim();
    if (!raw) return;

    // split multiple PGNs (Lichess-compatible)
    const games = raw
      .split(/\n\n(?=\[Event|\[ChapterName)/)
      .filter(Boolean);

    studyState.chapters = games.map((pgn, i) => ({
      title: `Chapter ${i + 1}`,
      pgn
    }));

    renderStudyChapters();
    modal.classList.add("hidden");
    studyPgnInput.value = "";
  });


function extractFenFromPgn(pgn) {
  const match = pgn.match(/\[FEN\s+"([^"]+)"\]/);
  return match ? match[1] : null;
}



  function renderStudyChapters() {
  studyList.innerHTML = `
    <div class="study-item active">‚ñ∂ Imported Study</div>
  `;

  studyState.chapters.forEach((ch, idx) => {
    const div = document.createElement("div");
    div.className = "study-chapter";
    div.textContent = `${idx + 1}. ${ch.title}`;

    

    div.addEventListener("click", () => {
      // üîπ Update Study Title (Main PGN + Chapter)
  document.getElementById("studyTitle").textContent =
    `${currentStudyTitle} ‚Ä¢ ${ch.title}`;
     
      
      studyState.currentChapterPgn = ch.pgn;

  // active highlight
  document
    .querySelectorAll(".study-chapter")
    .forEach(c => c.classList.remove("active"));
  div.classList.add("active");

  // reset game
  // üîÅ FULL RESET (SAFE)
studyChess.reset();
studyMoves.length = 0;
currentMoveIndex = -1;

// üîë store current chapter PGN
studyState.currentChapterPgn = ch.pgn;

// üß† load PGN into ONE chess instance
// üîí CLEAN PGN (remove variations & comments for replay safety)
const cleanPgn = ch.pgn
  .replace(/\([^)]*\)/g, "")   // remove ( ... )
  .replace(/\{[^}]*\}/g, ""); // remove { comments }

// üß† load CLEAN PGN into studyChess
const ok = studyChess.load_pgn(cleanPgn, { sloppy: true });
if (!ok) {
  console.error("‚ùå PGN load failed");
  return;
}

if (!ok) {
  console.error("‚ùå PGN load failed");
  return;
}

// ‚ôüÔ∏è collect VERBOSE mainline moves
studyMoves.push(...studyChess.history({ verbose: true }));

// üìù render notation from SAME move source
renderStudyNotation(studyMoves);

// ‚ôüÔ∏è reset board to chapter start (or FEN)
jumpToMove(-1);


  console.log("üìò Chapter selected:", ch.title);
});


    studyList.appendChild(div);
  });
}

});




function jumpToMove(index) {
  studyChess.reset();

  // load base FEN if exists
  const fenMatch =
    studyState.currentChapterPgn.match(/\[FEN\s+"([^"]+)"\]/);

  if (fenMatch) {
    studyChess.load(fenMatch[1]);
  }

  if (index < 0) {
    studyBoard.position(studyChess.fen(), false);
    return;
  }

  for (let i = 0; i <= index; i++) {
    const move = studyMoves[i];
    if (!move) break;

    const result = studyChess.move(move);
    if (!result) {
      console.warn("‚ö†Ô∏è Failed to apply move:", move.san);
      break; // üî• STOP instead of silently failing
    }
  }

  studyBoard.position(studyChess.fen(), false);
}


// ===============================
// ‚å®Ô∏è KEYBOARD NAV ‚Äî MAINLINE ONLY
// ===============================
document.addEventListener("keydown", (e) => {
  // Don't trigger when typing in input/textarea
  if (
    e.target.tagName === "INPUT" ||
    e.target.tagName === "TEXTAREA"
  ) return;

  // ‚û°Ô∏è Right Arrow = Next move
  if (e.key === "ArrowRight") {
    if (currentMoveIndex < studyMoves.length - 1) {
      currentMoveIndex++;
      jumpToMove(currentMoveIndex);
highlightByIndex(currentMoveIndex);

    }
  }

  // ‚¨ÖÔ∏è Left Arrow = Previous move
  if (e.key === "ArrowLeft") {
    if (currentMoveIndex > -1) {
      currentMoveIndex--;
      jumpToMove(currentMoveIndex);
highlightByIndex(currentMoveIndex);

    }
  }
});




function extractFenMoveIndex(pgn) {
  const moveMatch = pgn.match(/\n(\d+)\./);
  return moveMatch ? (parseInt(moveMatch[1], 10) - 1) * 2 : 0;
}






function renderStudyNotation(moves) {
  const notation = document.getElementById("studyNotation");
  if (!notation) return;

  notation.innerHTML = "";

  for (let i = 0; i < moves.length; i += 2) {
    const row = document.createElement("div");
    row.className = "notation-row";

    const num = document.createElement("span");
    num.className = "move-num";
    num.textContent = Math.floor(i / 2) + 1 + ".";
    row.appendChild(num);

    if (moves[i]) {
      const white = document.createElement("span");
      white.className = "move white";
      white.textContent = moves[i].san;

     white.onclick = () => {
  currentMoveIndex = i;
  jumpToMove(i);
  setActiveMainMove(white, i);
};

      row.appendChild(white);
    }

    if (moves[i + 1]) {
      const black = document.createElement("span");
      black.className = "move black";
      black.textContent = moves[i + 1].san;

    black.onclick = () => {
  currentMoveIndex = i + 1;
  jumpToMove(i + 1);
  setActiveMainMove(black, i + 1);
};

      row.appendChild(black);
    }

    notation.appendChild(row);
  }
}



function setActiveMainMove(el, index) {
  clearNotationHighlights();
  el.classList.add("active-main");
  activeNotationNode = { type: "main", index };
}


function highlightByIndex(index) {
  clearNotationHighlights();

  const moves = document.querySelectorAll(".notation-row .move");
  const el = moves[index];
  if (el) {
    el.classList.add("active-main");
  }
}



function appendInlineVariation(san, absoluteIndex, fen) {
  const notation = document.getElementById("studyNotation");
  if (!notation) return;

  const rows = notation.querySelectorAll(".notation-row");
  const lastRow = rows[rows.length - 1];
  if (!lastRow) return;

  const varSpan = document.createElement("span");
  varSpan.className = "move variation";
  varSpan.textContent = ` (${san})`;

  // üî• STORE EVERYTHING ON THE NODE (NO SEARCHING)
  varSpan.dataset.fen = fen;
  varSpan.dataset.index = absoluteIndex;

  varSpan.addEventListener("click", () => {
    clearNotationHighlights();
varSpan.classList.add("active-variation");
activeNotationNode = { type: "variation", index: absoluteIndex };

    // 1Ô∏è‚É£ FULL RESET
    studyChess.reset();

    // 2Ô∏è‚É£ LOAD CHAPTER BASE FEN (IF EXISTS)
    const fenMatch =
      studyState.currentChapterPgn.match(/\[FEN\s+"([^"]+)"\]/);

    if (fenMatch) {
      studyChess.load(fenMatch[1]);
    }

    // 3Ô∏è‚É£ REPLAY MAINLINE UP TO PARENT MOVE
    for (let i = 0; i < absoluteIndex; i++) {
  if (!studyMoves[i]) break;
  studyChess.move(studyMoves[i]);
}


    // 4Ô∏è‚É£ LOAD VARIATION POSITION DIRECTLY
    studyChess.load(varSpan.dataset.fen);
    studyBoard.position(varSpan.dataset.fen, false);

    console.log(
      "‚úÖ Variation rendered via FEN at move:",
      absoluteIndex,
      san
    );
  });

  lastRow.appendChild(varSpan);
}





  




// ===============================
// ‚ôüÔ∏è Init Study Board
// ===============================
window.studyDrawingsByFen = {};
studyChess = new Chess();
// ===============================
// ‚ôüÔ∏è STUDY PAWN VIEW STATE
// ===============================
let studyPawnViewActive = false;


// ===============================
// ‚ôüÔ∏è STUDY PIECE THEME RESOLVER
// ===============================
function resolveStudyPieceTheme(piece) {
  if (!piece) return "";

  const basePath = getPieceThemePath(currentPieceTheme);
  const type = piece[1].toLowerCase();

  // Pawn + King view
  if (studyPawnViewActive && !["p", "k"].includes(type)) {
    return "";
  }

  return basePath.replace("{piece}", piece);
}


function initStudyBoard() {
  initStudyCoordinates(
    document.getElementById("studyBoardWrapper"),
    studyBoard,
    () => studyBoardFlipped
  );

  studyChess = new Chess();

  studyBoard = Chessboard("studyBoard", {
    position: "start",
    draggable: true,
    showNotation: false,

    // ‚úÖ SAFE: render-only filter, no logic break
    pieceTheme: resolveStudyPieceTheme,

    onDrop: onStudyDrop
  });
}


document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("pawnOnlyToggleBtn");
  if (!btn) return;

  btn.addEventListener("click", () => {
    if (!studyBoard || !studyChess) return;

    studyPawnViewActive = !studyPawnViewActive;
    btn.classList.toggle("active", studyPawnViewActive);

    // üîÑ force re-render ONLY
    studyBoard.position(studyChess.fen(), false);
  });
});

// ===============================
// ‚ôüÔ∏è STUDY NOTATION TOGGLE
// ===============================
document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("toggleStudyNotationBtn");
  const notationBox = document.querySelector(".study-notation");

  if (!btn || !notationBox) return;

  let notationVisible = true;

  btn.addEventListener("click", () => {
    notationVisible = !notationVisible;

    notationBox.classList.toggle("hidden", !notationVisible);
    btn.classList.toggle("active", !notationVisible);
  });
});

document.addEventListener("DOMContentLoaded", () => {
  const searchBox = document.getElementById("studySearchBox");
  const studySelect = document.getElementById("studySelect");

  if (!searchBox || !studySelect) return;

  let searchTimeout = null;

  async function searchPGN(query) {
    if (!query.trim()) {
      studySelect.innerHTML = `<option value="">Study</option>`;
      return;
    }

    const { data, error } = await supabase
      .from("bulk_pgn_library")
      .select("id, title")
      .ilike("title", `%${query}%`)
      .order("title", { ascending: true }); // clean sorted list

    if (error) {
      console.error("‚ùå PGN search error:", error);
      return;
    }

    studySelect.innerHTML = `<option value="">Results</option>`;

    data.forEach(row => {
      const opt = document.createElement("option");
      opt.value = row.id;
      opt.textContent = row.title;
      studySelect.appendChild(opt);
    });
  }

  searchBox.addEventListener("input", () => {
    clearTimeout(searchTimeout);

    searchTimeout = setTimeout(() => {
      searchPGN(searchBox.value);
    }, 250); // debounce for performance
  });
});






// ===============================
// ‚ôüÔ∏è STUDY COORDINATES SYSTEM
// ===============================
function initStudyCoordinates(wrapper, board, getFlipped) {
  const fileBar = document.createElement("div");
  const rankBar = document.createElement("div");

  fileBar.style.cssText = `
    position:absolute;
    bottom:-28px;
    left:0;
    width:100%;
    display:flex;
    justify-content:space-between;
    pointer-events:none;
    font-size:25px;
    color:#ddd;
    font-family:monospace;
    user-select:none;
  `;

  rankBar.style.cssText = `
    position:absolute;
    top:0;
    left:-22px;
    height:100%;
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    pointer-events:none;
    font-size:25px;
    color:#ddd;
    font-family:monospace;
    user-select:none;
  `;

  wrapper.style.position = "relative";
  wrapper.appendChild(fileBar);
  wrapper.appendChild(rankBar);

  function render() {
    fileBar.innerHTML = "";
    rankBar.innerHTML = "";

    const flipped = getFlipped();

    const files = flipped
      ? ["h","g","f","e","d","c","b","a"]
      : ["a","b","c","d","e","f","g","h"];

    const ranks = flipped
      ? ["1","2","3","4","5","6","7","8"]
      : ["8","7","6","5","4","3","2","1"];

    files.forEach(f => {
      const el = document.createElement("div");
      el.textContent = f;
      fileBar.appendChild(el);
    });

    ranks.forEach(r => {
      const el = document.createElement("div");
      el.textContent = r;
      rankBar.appendChild(el);
    });
  }

  // üîÑ Responsive updates
  window.addEventListener("resize", render);
  document.addEventListener("studyBoardFlipped", render);

  render();
}




// ================================
// STUDY DRAW INIT (PASTE HERE)
// ================================
const studyWrapper = document.getElementById("studyBoardWrapper");
const studyBoardEl = document.getElementById("studyBoard");
const studyDrawLayer = document.getElementById("studyDrawLayer");

initStudyBoardDrawing(studyWrapper, studyBoardEl, studyDrawLayer);


function onStudyDrop(source, target) {
  if (!studyChess) return "snapback";

  const piece = studyChess.get(source);

  // üî• Detect promotion attempt
  const isPromotion =
    piece &&
    piece.type === "p" &&
    (
      (piece.color === "w" && target[1] === "8") ||
      (piece.color === "b" && target[1] === "1")
    );

  if (isPromotion) {
    studyOpenPromotionModal(source, target);
    return;
  }

  const move = studyChess.move({
    from: source,
    to: target,
    promotion: "q"
  });

  if (!move) return "snapback";

  const absoluteIndex =
    currentMoveIndex >= 0
      ? currentMoveIndex + 1
      : studyMoves.length;

  studyMoves.push({
    san: move.san,
    absoluteIndex,
    fen: studyChess.fen()
  });

  appendInlineVariation(
    move.san,
    absoluteIndex,
    studyChess.fen()
  );

  studyBoard.position(studyChess.fen(), false);

  console.log("‚ôüÔ∏è Study move:", move.san);
}











// üîÑ Study board flip state
let studyBoardFlipped = false;

// ‚å®Ô∏è Keyboard shortcut: F = flip board
document.addEventListener("keydown", (e) => {
  // ignore typing inside inputs / textareas
  if (
    e.target.tagName === "INPUT" ||
    e.target.tagName === "TEXTAREA"
  ) return;

  if (e.key.toLowerCase() === "f") {
    if (!studyBoard) return;

    studyBoardFlipped = !studyBoardFlipped;
    studyBoard.orientation(
      studyBoardFlipped ? "black" : "white"
      
    );
document.dispatchEvent(new Event("studyBoardFlipped"));

    console.log("üîÑ Study board flipped:", studyBoardFlipped);
  }
});


// ===============================
// ‚ôüÔ∏è STUDY PROMOTION SYSTEM (ISOLATED)
// ===============================

let studyPromoPending = null;

// Hook modal buttons without touching live match logic
(function hookStudyPromotionButtons() {
  const modal = document.getElementById("mpPromoModal");
  if (!modal) return;

  modal.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", e => {
      if (!studyPromoPending) return;
      e.stopPropagation();
      studyCompletePromotion(btn.textContent);
    });
  });
})();

function studyOpenPromotionModal(source, target) {
  studyPromoPending = { source, target };
  document.getElementById("mpPromoModal")?.classList.remove("hidden");
}

function studyClosePromotionModal() {
  document.getElementById("mpPromoModal")?.classList.add("hidden");
  studyPromoPending = null;
}

function studyCompletePromotion(pieceSymbol) {
  if (!studyPromoPending) return;

  const map = {
    "‚ôï": "q",
    "‚ôñ": "r",
    "‚ôó": "b",
    "‚ôò": "n"
  };

  const promo = map[pieceSymbol] || "q";
  const { source, target } = studyPromoPending;

  studyClosePromotionModal();
  studyFinishMove(source, target, promo);
}

function studyFinishMove(source, target, promotion) {
  const move = studyChess.move({
    from: source,
    to: target,
    promotion
  });

  if (!move) {
    studyBoard.position(studyChess.fen(), false);
    return;
  }

  // üîë absolute move index
  const absoluteIndex =
    currentMoveIndex >= 0
      ? currentMoveIndex + 1
      : studyMoves.length;

  studyMoves.push({
    san: move.san,
    absoluteIndex,
    fen: studyChess.fen()
  });

  appendInlineVariation(
    move.san,
    absoluteIndex,
    studyChess.fen()
  );

  studyBoard.position(studyChess.fen(), false);

  console.log("‚ôüÔ∏è Study promotion:", move.san);
}




function initStudyBoardDrawing(wrapper, boardEl, canvas) {
  const ctx = canvas.getContext("2d");
  let startSquare = null;
  let isRightDown = false;

  function resizeCanvas() {
    const r = boardEl.getBoundingClientRect();
    canvas.width = r.width;
    canvas.height = r.height;
    canvas.style.width = r.width + "px";
    canvas.style.height = r.height + "px";
    redraw();
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function getSquareFromEvent(e) {
    const rect = boardEl.getBoundingClientRect();
    const size = rect.width / 8;
    const x = Math.floor((e.clientX - rect.left) / size);
    const y = Math.floor((e.clientY - rect.top) / size);
    if (x < 0 || y < 0 || x > 7 || y > 7) return null;
    return String.fromCharCode(97 + x) + (8 - y);
  }

  function squareCenter(square) {
    const file = square.charCodeAt(0) - 97;
    const rank = 8 - parseInt(square[1]);
    const size = canvas.width / 8;
    return {
      x: file * size + size / 2,
      y: rank * size + size / 2
    };
  }

  function getColor(e) {
    if (e.ctrlKey) return "rgba(0,120,255,0.9)";
    if (e.shiftKey) return "rgba(255,60,60,0.9)";
    return "rgba(0,200,0,0.9)";
  }

  function currentFenKey() {
    return studyChess.fen().split(" ").slice(0, 4).join(" ");
  }

  function getDrawings() {
    const k = currentFenKey();
    if (!studyDrawingsByFen[k]) studyDrawingsByFen[k] = [];
    return studyDrawingsByFen[k];
  }

  function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const d of getDrawings()) draw(d);
  }

  function draw(d) {
    ctx.strokeStyle = d.color;
    ctx.lineWidth = 4;
    ctx.lineCap = "round";

    if (d.type === "circle") {
      const c = squareCenter(d.square);
      ctx.beginPath();
      ctx.arc(c.x, c.y, canvas.width / 16 - 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    if (d.type === "arrow") {
      const a = squareCenter(d.from);
      const b = squareCenter(d.to);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();

      const angle = Math.atan2(b.y - a.y, b.x - a.x);
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(
        b.x - 14 * Math.cos(angle - 0.3),
        b.y - 14 * Math.sin(angle - 0.3)
      );
      ctx.lineTo(
        b.x - 14 * Math.cos(angle + 0.3),
        b.y - 14 * Math.sin(angle + 0.3)
      );
      ctx.closePath();
      ctx.fillStyle = d.color;
      ctx.fill();
    }
  }

  wrapper.addEventListener("contextmenu", e => e.preventDefault());

  wrapper.addEventListener("mousedown", e => {
    if (e.button !== 2) return;
    isRightDown = true;
    startSquare = getSquareFromEvent(e);
  });

  wrapper.addEventListener("mouseup", e => {
    if (!isRightDown || e.button !== 2) return;
    isRightDown = false;

    const endSquare = getSquareFromEvent(e);
    if (!startSquare || !endSquare) return;

    const drawings = getDrawings();
    const color = getColor(e);

    if (startSquare === endSquare) {
      const idx = drawings.findIndex(
        d => d.type === "circle" && d.square === startSquare
      );
      if (idx >= 0) drawings.splice(idx, 1);
      else drawings.push({ type: "circle", square: startSquare, color });
    } else {
      const idx = drawings.findIndex(
        d => d.type === "arrow" && d.from === startSquare && d.to === endSquare
      );
      if (idx >= 0) drawings.splice(idx, 1);
      else drawings.push({ type: "arrow", from: startSquare, to: endSquare, color });
    }

    redraw();
  });

  // üî• IMPORTANT: redraw on move navigation
  document.addEventListener("studyPositionChanged", redraw);
}

















function initStudyEngine() {
  if (studyEngine) return;

  studyEngine = new Worker("./stockfish/stockfish.js");

  studyEngine.onmessage = (e) => {
    const line = e.data;
    if (typeof line !== "string") return;
    updateStudyEngineUI(line);
  };

  studyEngine.postMessage("uci");

  // üî• ADD THIS LINE (CRITICAL)
  studyEngine.postMessage("setoption name MultiPV value 3");

  studyEngine.postMessage("isready");
}







function analyzeStudyPosition() {
  if (!studyEngine || !studyChess || !studyEngineEnabled) return;

  // üß† reset UI + engine search state
  studyLastDepth = 0;
  document.getElementById("studyEval").textContent = "‚Ä¶";
  document.getElementById("studyPVLines").innerHTML = "";

  // üõë stop any running search
  studyEngine.postMessage("stop");

  // ‚ôªÔ∏è CRITICAL: clear hash + previous context
  studyEngine.postMessage("ucinewgame");

  // ‚ôüÔ∏è send current position
  studyEngine.postMessage(
    "position fen " + studyChess.fen()
  );

  // üöÄ continuous analysis (best for UI)
  studyEngine.postMessage("go infinite");
}








// ===== ENGINE STATE =====
let studyLastDepth = 0;
const STUDY_MIN_EVAL_DEPTH = 16;

function updateStudyEngineUI(line) {
  if (!studyEngineEnabled) return;
  if (typeof line !== "string") return;
  if (!line.startsWith("info")) return;

  /* ================= DEPTH ================= */
  const depthMatch = line.match(/depth (\d+)/);
  if (depthMatch) {
    studyLastDepth = parseInt(depthMatch[1], 10);
    document.getElementById("studyDepth").textContent = studyLastDepth;
  }

  /* ================= ONLY PV 1 CONTROLS EVAL ================= */
  const isPV1 = /multipv 1\b/.test(line);
  if (!isPV1) {
    // still allow PV rendering later
  }

  const evalBox = document.getElementById("studyEval");
  const cpMatch = line.match(/score cp (-?\d+)/);
  const mateMatch = line.match(/score mate (-?\d+)/);

 
// ===== MATE (PV1 ONLY) =====
if (mateMatch && isPV1) {
  let mate = parseInt(mateMatch[1], 10);

  if (studyChess.turn() === "b") mate = -mate;

  evalBox.textContent = `M${mate}`;
  // ‚ùå DO NOT return ‚Äî let PV rendering continue
}


  // ===== CENTIPAWN (PV1 ONLY + DEPTH GATED) =====
  if (cpMatch && isPV1) {
    if (studyLastDepth < STUDY_MIN_EVAL_DEPTH) return;

    let cp = parseInt(cpMatch[1], 10);
    if (studyChess.turn() === "b") cp = -cp;

    const evalValue = (cp / 100).toFixed(2);
    evalBox.textContent = cp > 0 ? `+${evalValue}` : evalValue;
  }

  /* ================= MULTI-PV DISPLAY ================= */
  const pvMatch = line.match(/multipv (\d+).* pv (.+)/);
  if (!pvMatch) return;

  const index = pvMatch[1];
  const uciPv = pvMatch[2];

  const sanPv = uciLineToSAN(studyChess.fen(), uciPv);
  studyPV[index] = sanPv;

  const pvBox = document.getElementById("studyPVLines");
  pvBox.innerHTML = "";

  Object.keys(studyPV)
    .sort((a, b) => a - b)
    .forEach(i => {
      const div = document.createElement("div");
      div.className = "engine-line";
      div.textContent = studyPV[i];
      pvBox.appendChild(div);
    });
}





function uciLineToSAN(fen, uciLine) {
  const tempChess = new Chess(fen);
  const sanMoves = [];

  const moves = uciLine.trim().split(" ");

  for (const uci of moves) {
    const move = tempChess.move({
      from: uci.slice(0, 2),
      to: uci.slice(2, 4),
      promotion: uci[4] // handles promotion if any
    });

    if (!move) break;
    sanMoves.push(move.san);
  }

  return sanMoves.join(" ");
}








    window.startAssignment = async function(assignmentId) {
  try {
    const { data: assignment, error } = await supabase
      .from('assignments')
      .select('*')
      .eq('id', assignmentId)
      .single();
    if (error) {
      alert('Error loading assignment: ' + error.message);
      return;
    }

    // Reset all assignment state
    currentAssignment = assignment;
    expectedMoves = [];
    assignmentCursor = 0;
    attemptCount = 0;
    isNavigationMode = false;
    isPGNLoaded = false;

    const fen = assignment.fen || "start";
    const pgn = assignment.pgn || "";

    // Create new chess instance with the FEN
    chess = new Chess();
    
    try {
      if (fen === "start") {
        chess.reset();
      } else {
        chess.load(fen);
      }
    } catch (e) {
      alert("Invalid assignment FEN: " + e.message);
      return;
    }

   // --------------------------------------------------
// Parse expected moves from PGN (IF ANY)
// --------------------------------------------------
expectedMoves = [];
assignmentColor = "w";

if (pgn && pgn.trim().length > 0) {
  try {
    const tempChess = fen ? new Chess(fen) : new Chess();

    // Try loading PGN (allow sloppy PGN from lichess)
    tempChess.load_pgn(pgn, { sloppy: true });

    const moves = tempChess.history({ verbose: true });
    

    if (moves.length > 0) {
      // ‚úÖ PGN has solution moves
      expectedMoves = moves;
      assignmentColor = moves[0].color;
      console.log("Loaded expected moves:", expectedMoves.length);
    } else {
      // ‚úÖ Position-only PGN (Mate in N)
      console.log("PGN has NO moves (position-only puzzle)");
    }

  } catch (e) {
    console.warn("PGN parse error:", e);
    expectedMoves = [];
  }
}

// --------------------------------------------------
// Board orientation (safe)
// --------------------------------------------------
boardOrientation = assignmentColor === "b" ? "black" : "white";
board.orientation(boardOrientation);



    // Reset history
    moveHistory = [];
    fullPGNHistory = [];
    pgnCursor = 0;
    
    // Update board
    board.position(chess.fen());
    board.start(); // Ensure board is in the correct state

    // Update UI
    updatePGNViewer();
    renderNotation();
    updateNavigationButtons();
    safeShow("pgnContainer", true);
safeShow("submitBtn", true);
safeShow("gameStatus", false);

    
    // Enable move input
    const moveInput = document.getElementById("moveInput");
const applyMoveBtn = document.getElementById("applyMoveBtn");

if (moveInput) moveInput.disabled = false;
if (applyMoveBtn) applyMoveBtn.disabled = false;


    // Show assignment info
    showModal(
  "‚ôü Assignment Started",
  `
  <strong>${assignment.title}</strong><br><br>
  ${assignment.description || "No description"}<br><br>
  Solve this position on the board.
  `,
  () => {
    // optional: focus board or start timer
    startTimer();
  }
);

    
    // Start timer
    startTimer();

    // Hide only PGN upload tools & admin stuff ‚Äî NOT the whole panel
document.getElementById("pgnUploadSection").style.display = "none";




  } catch (error) {
    console.error('Error starting assignment:', error);
    // Teacher test mode ‚Äì NO browser alert
showStatus("üß™ Testing assignment (teacher mode)", "info");

  }
};

function safeShow(id, show = true) {
  const el = document.getElementById(id);
  if (!el) return;

  el.style.display = show ? "block" : "none";
}



function isPromotionMove(source, target) {
  const piece = chess.get(source);
  if (!piece || piece.type !== "p") return false;

  const rank = parseInt(target[1], 10);

  // Must be last rank
  const reachesLastRank =
    (piece.color === "w" && rank === 8) ||
    (piece.color === "b" && rank === 1);

  if (!reachesLastRank) return false;

  // Must be a legal move
  const legalMoves = chess.moves({ square: source, verbose: true });
  if (!legalMoves.some(m => m.to === target)) return false;

  return true;
}





    window.testAssignment = function(assignmentId) {
      startAssignment(assignmentId);
      safeStyle('submitBtn', 'display', 'none');

    };

    window.viewAssignment = async function (assignmentId) {
  try {
    const { data: assignment, error } = await supabase
      .from("assignments")
      .select("*")
      .eq("id", assignmentId)
      .single();

    if (error || !assignment) {
      showModal("Error", "Failed to load assignment details.");
      return;
    }

    const html = `
      <p><strong>Title:</strong> ${assignment.title}</p>
      <p><strong>Type:</strong> ${assignment.task_type}</p>
      <p><strong>Status:</strong> ${assignment.status}</p>
      <p><strong>Created:</strong> ${new Date(assignment.created_at).toLocaleString()}</p>
      ${assignment.due_at ? `<p><strong>Due:</strong> ${new Date(assignment.due_at).toLocaleString()}</p>` : ""}
      <hr>
      <p><strong>Description:</strong></p>
      <p>${assignment.description || "No description provided."}</p>
      <hr>
      <p><strong>Bulk Assignment:</strong> ${assignment.is_bulk ? "Yes" : "No"}</p>
    `;

    showModal("üìò Assignment Details", html);

  } catch (err) {
    console.error(err);
    showModal("Error", "Unexpected error occurred.");
  }
};




    window.createAssignment = async function () {
  // üîê Admin check
  if (currentProfile.role !== "admin") {
    alert("Access denied. Admin only.");
    return;
  }

  // üì• Read inputs
  const title = document.getElementById("assignTitle").value.trim();
  const description = document.getElementById("assignDesc").value.trim();
  const task_type = document.getElementById("assignType").value;
  const due_at = document.getElementById("assignDue").value;
  const fenInput = document.getElementById("assignFEN").value.trim();
  const pgn = document.getElementById("assignPGN").value.trim();
  const assignedTo = getSelectedStudentIds();
  console.log("Selected students:", assignedTo);



  // ‚ùå Title required
  if (!title) {
  showModal(
    "‚ö†Ô∏è Missing Title",
    "<p>Please enter an assignment title.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}


  // -------------------------------------------------------
  // üß† AUTO-FEN EXTRACTION FROM PGN
  // -------------------------------------------------------
  let autoFEN = null;

  if (pgn) {
    const fenMatch = pgn.match(/\[FEN\s+"([^"]+)"\]/i);
    if (fenMatch) {
      autoFEN = fenMatch[1];
      console.log("Auto-extracted FEN:", autoFEN);
    }
  }

  // -------------------------------------------------------
  // üß† DETECT IF PGN HAS ACTUAL MOVES
  // -------------------------------------------------------
  const hasMoves = /\d+\.\s/.test(pgn);

  // Warn admin if PGN has no moves (Mate in N positions)
  if (pgn && !hasMoves) {
    const proceed = confirm(
      "‚ö†Ô∏è PGN detected but NO MOVES found.\n\n" +
      "This is a POSITION-ONLY assignment (Mate in N).\n\n" +
      "‚Ä¢ Students will NOT be auto-checked\n" +
      "‚Ä¢ This is normal for Lichess studies\n\n" +
      "Click OK to continue\n" +
      "Click Cancel to paste full solution PGN"
    );

    if (!proceed) return;
  }

  // -------------------------------------------------------
  // üß† FINAL FEN PRIORITY
  // User FEN > PGN FEN > null
  // -------------------------------------------------------
  const finalFEN = fenInput || autoFEN || null;

  try {
  const { error } = await supabase
    .from("assignments")
    .insert([
      {
        title,
        description,
        task_type,
        due_at: due_at || null,
        fen: finalFEN,
        pgn: pgn || null,
        is_bulk: true,
        created_by: currentProfile.id,
        status: "active",

        // ‚úÖ CORE LOGIC
        assigned_to: assignedTo.length ? assignedTo : null,
        is_public: assignedTo.length === 0
      }
    ]);

  if (error) throw error;

    showModal(
  "üéâ Success",
  "<p>Assignment created successfully!</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);


    // üßπ Clear form
    [
      "assignTitle",
      "assignDesc",
      "assignDue",
      "assignFEN",
      "assignPGN"
    ].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.value = "";
    });

    // üîÑ Reload list
    loadAssignments();

  } catch (err) {
    console.error("Error creating assignment:", err);
    alert("‚ùå Error creating assignment: " + err.message);
  }
};

window.showPromotionDialog = function(from, to) {
  pendingPromotion = { from, to };
  document.getElementById("promotionModal").classList.remove("hidden");
};



window.completePromotion = function (piece) {
  if (!pendingPromotion) return;

  const { from, to } = pendingPromotion;

  const move = chess.move({
    from,
    to,
    promotion: piece
  });

  pendingPromotion = null;
  document.getElementById("promotionModal").classList.add("hidden");

  if (!move) return;
  // üîä PROMOTION SOUND (ONLY ADDITION)
if (move.flags.includes('k') || move.flags.includes('q')) {
  // üëë Castling
  playSound('castle');

} else if (move.san.includes('+')) {
  // üîî Check
  playSound('check');

} else if (move.captured) {
  // ‚öîÔ∏è Capture
  playSound('capture');

} else {
  // ‚ôü Normal move
  playSound('move');
}




  // ‚úÖ ADD TO HISTORY
  fullPGNHistory.push(move);
  pgnCursor++;

  // ===============================
  // üî• ASSIGNMENT MODE CONTINUATION
  // ===============================
  if (currentAssignment && expectedMoves.length > 0) {
    const expected = expectedMoves[assignmentCursor];

    // ‚ùå wrong promotion choice
    if (move.san !== expected.san) {
      attemptCount++;
      chess.undo();
      board.position(chess.fen());

      showStatus(
        `Wrong promotion. Try again. Attempts: ${attemptCount}`,
        "error"
      );
      return;
    }

    // ‚úÖ correct promotion
    assignmentCursor++;
    

    // üîÅ BULK CHECK
    if (currentAssignment.is_bulk && assignmentCursor >= expectedMoves.length) {
      bulkIndex++;

      if (bulkIndex < bulkPuzzles.length) {
        setTimeout(loadCurrentBulkPuzzle, 600);
      } else {
        showStatus(
          "üéâ All puzzles completed! Submit your assignment.",
          "success"
        );
        document.getElementById("submitBtn").style.display = "block";
      }
      return;
    }

    // ‚ñ∂ AUTO-PLAY OPPONENT MOVE
    if (assignmentCursor < expectedMoves.length) {
      const reply = expectedMoves[assignmentCursor];

      setTimeout(() => {
        const autoMove = chess.move(reply.san);
        if (autoMove) {
          fullPGNHistory.push(autoMove);
          pgnCursor++;
          assignmentCursor++;
          board.position(chess.fen());

          updatePGNViewer();
          renderNotation();
          updateNavigationButtons();
          
        }
      }, 400);
    }
  }

  board.position(chess.fen());
  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();
};


// BULK FUNCTIONS START//
function splitBulkPGNIntoPuzzles(rawPGN) {
  const games = rawPGN
    .split(/\n\n(?=\[Event )/g)
    .map(g => g.trim())
    .filter(Boolean);

  const puzzles = [];

  for (const gamePGN of games) {
    const fenMatch = gamePGN.match(/\[FEN\s+"([^"]+)"\]/i);
    const fen = fenMatch ? fenMatch[1] : "start";

    const temp = new Chess(fen);

    try {
      temp.load_pgn(gamePGN, { sloppy: true });
    } catch (e) {
      console.warn("Skipping invalid PGN:", e);
      continue;
    }

    const moves = temp.history({ verbose: true });

    puzzles.push({
      fen,
      moves,
      sideToMove: moves[0]?.color || "w",
      rawPGN: gamePGN
    });
  }

  return puzzles;
}

function loadCurrentBulkPuzzle() {
  // üî¥ HARD RESET (VERY IMPORTANT)
  assignmentCursor = 0;
  attemptCount = 0;
  expectedMoves = [];

  // Safety check
  if (!bulkPuzzles || bulkPuzzles.length === 0) return;
  if (bulkIndex < 0 || bulkIndex >= bulkPuzzles.length) return;

  const puzzle = bulkPuzzles[bulkIndex];

  // ‚úÖ SAFE FEN RESOLUTION
  const fenToLoad =
    puzzle.fen && puzzle.fen !== "start"
      ? puzzle.fen
      : START_FEN;

  // ‚úÖ Always initialize chess correctly
  chess = new Chess(fenToLoad);

  // Load solution moves
  expectedMoves = puzzle.moves || [];

  // Side to move
  assignmentColor = puzzle.sideToMove || chess.turn();

  // Board setup
  board.orientation(assignmentColor === "w" ? "white" : "black");
  board.position(chess.fen());

  // UI updates
  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();

  showStatus(
    `Puzzle ${bulkIndex + 1} / ${bulkPuzzles.length}`,
    "info",
    false
  );

  // üîπ Update bulk puzzle indicator
  const indicator = document.getElementById("bulkIndicator");
  if (indicator) {
    indicator.textContent = `Puzzle ${bulkIndex + 1} / ${bulkPuzzles.length}`;
  }
}




// ================================
// üîÅ BULK PUZZLE MANUAL NAVIGATION
// ================================

window.goToNextBulkPuzzle = function () {
  if (!currentAssignment?.is_bulk) return;

  if (bulkIndex < bulkPuzzles.length - 1) {
    bulkIndex++;
    loadCurrentBulkPuzzle();
  } else {
    showStatus("You are on the last puzzle", "info");
  }
};

window.goToPrevBulkPuzzle = function () {
  if (!currentAssignment?.is_bulk) return;

  if (bulkIndex > 0) {
    bulkIndex--;
    loadCurrentBulkPuzzle();
  } else {
    showStatus("You are on the first puzzle", "info");
  }
};

window.goToBulkPuzzle = function (index) {
  if (!currentAssignment?.is_bulk) return;
  if (index < 0 || index >= bulkPuzzles.length) return;

  bulkIndex = index;
  loadCurrentBulkPuzzle();
};




// BULK FUNCTIONS END //



function updateEngineUI() {
  const btn = document.getElementById("analyzeBtn");
  if (!btn) return;

  btn.style.display = isAssignmentMode ? "none" : "block";
}





function showStatus(message, type = "info", autoHide = true) {
  const status = document.getElementById("gameStatus");

  status.innerHTML = message;          // ‚úÖ allow HTML
  status.style.display = "block";

  status.className = "status-indicator";
  status.classList.add(type);          // success | error | info

  if (autoHide) {
    setTimeout(() => {
      status.style.display = "none";
    }, 3000);
  }
}

function refreshStudentList() {
  // Read dropdown value ONLY when refresh is clicked
  window.__studentPriorityMode =
    document.getElementById("defaultStudentStatus")?.value || "active";

  loadStudents();
}






    function startInteractiveAssignment(assignment) {
      isAssignmentMode = true;
updateEngineVisibility();

  console.log("Starting interactive assignment:", assignment);
  


  currentAssignment = assignment;

  // üîÅ BULK ASSIGNMENT MODE
  if (assignment.is_bulk && assignment.pgn) {
    console.log("Bulk assignment detected");

    bulkPuzzles = splitBulkPGNIntoPuzzles(assignment.pgn);
    bulkIndex = 0;

    if (!bulkPuzzles || bulkPuzzles.length === 0) {
      alert("No valid puzzles found in this bulk assignment.");
      return;
    }

    // Show assignment UI (same UI for bulk & single)
    document.getElementById("assignmentModeContainer").style.display = "block";
    document.getElementById("submitBtn").style.display = "none"; // shown only after last puzzle
    document.getElementById("timerDisplay").style.display = "block";
    document.getElementById("pgnContainer").classList.remove("hidden");
    document.getElementById("bulkNav").style.display = "block";
    



    startTimer();
    loadCurrentBulkPuzzle();
    return;
  }

  // ==================================================
  // üîÅ SINGLE ASSIGNMENT MODE (YOUR ORIGINAL LOGIC)
  // ==================================================

  const pgn = assignment.pgn || "";
  const fen = assignment.fen || "start";

  // Reset chess instance
  chess = new Chess();

  try {
    if (fen !== "start") {
      chess.load(fen);
    }
  } catch (e) {
    alert("Invalid assignment FEN");
    return;
  }

  // Load PGN sequence
  const temp = new Chess(fen);
  if (pgn && pgn.trim().length > 0) {
    try {
      temp.load_pgn(pgn, { sloppy: true });
      extractPlayersFromPGN(pgn);
    } catch (e) {
      console.error("Invalid PGN:", e);
      alert("Invalid PGN in this assignment.");
      return;
    }
  }

  // Store expected moves
  expectedMoves = temp.history({ verbose: true });

  if (expectedMoves.length === 0) {
    console.log("Position-only puzzle (Mate in N).");
    assignmentColor = chess.turn();
  } else {
    assignmentColor = expectedMoves[0].color || "w";
  }

  // Update board orientation
  board.orientation(assignmentColor === "w" ? "white" : "black");

  // Reset gameplay data
  assignmentCursor = 0;
  attemptCount = 0;
  moveHistory = [];
  fullPGNHistory = [];
  pgnCursor = 0;
  isNavigationMode = false;
  isPGNLoaded = false;

  // Render board
  board.position(chess.fen());

  // Show assignment UI
  document.getElementById("assignmentModeContainer").style.display = "block";
  document.getElementById("submitBtn").style.display = "block";
  document.getElementById("timerDisplay").style.display = "block";
  document.getElementById("pgnContainer").classList.remove("hidden");

  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();

  startTimer();

  console.log("Single assignment fully loaded.");
}




    

    window.submitSolution = async function() {
  if (!currentAssignment || !chess) {
    alert('No active assignment');
    return;
  }

  stopTimer();

  const pgn = chess.pgn();
  const timeSpent = elapsedTime;
  const isComplete = (expectedMoves.length === 0) || (assignmentCursor >= expectedMoves.length);
  
  try {
    const { data, error } = await supabase
      .from('attempts')
      .insert([{
        assignment_id: currentAssignment.id,
        student_id: currentProfile.id,
        pgn: pgn,
        time_spent: timeSpent,
        is_correct: isComplete,
        attempt_count: attemptCount || 1,
        submitted_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    showResultModal(
  "‚úÖ Solution Submitted!",
  `
  <p>‚è± <strong>Time:</strong> ${formatTime(timeSpent)}</p>
  <p>‚ôü <strong>Moves:</strong> ${moveHistory.length}</p>
  <p>üîÅ <strong>Attempts:</strong> ${attemptCount}</p>
  <p style="margin-top:10px; color:#3cff8f;">
    ‚úî Completed successfully!
  </p>
  `
);

// üîÑ Refresh My Progress (student only)
if (currentProfile?.role === "student") {
  loadStudentProgress();
}



    // Reset assignment state
    currentAssignment = null;
    expectedMoves = [];
    assignmentCursor = 0;
    attemptCount = 0;
    assignmentColor = "w";
    
    document.getElementById('submitBtn').style.display = 'none';
    document.getElementById('timerDisplay').style.display = 'none';
    document.getElementById('pgnContainer').style.display = 'none';

    // Reset the board
    resetBoard();

    document.getElementById("sidePanel").style.display = "block";


  } catch (error) {
    console.error('Error submitting solution:', error);
    alert('Error submitting solution: ' + error.message);
  }
};

window.toggleStudentPassword = function () {
  const input = document.getElementById("newStudentPass");
  const btn = document.getElementById("togglePassBtn");
  if (!input || !btn) return;

  const isHidden = input.type === "password";

  input.type = isHidden ? "text" : "password";
  btn.textContent = isHidden ? "üëÅÔ∏è" : "üëÅÔ∏è‚Äçüó®Ô∏è";
};



    // ============================================
    // STUDENTS (ADMIN)
    // ============================================
    async function loadStudents() {
  if (currentProfile.role !== 'admin') return;

  const tableBody = document.getElementById('studentsTable');
  tableBody.innerHTML =
    '<tr><td colspan="4" class="loading">Loading students...</td></tr>';

  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .neq('role', 'admin')
      .order('created_at', { ascending: false });

    if (error) throw error;

    if (!data || data.length === 0) {
      tableBody.innerHTML =
        '<tr><td colspan="4">No students found. Add your first student above.</td></tr>';
      return;
    }

    // ===============================
    // ‚úÖ STEP 1: PRIORITY SORT (SAFE)
    // ===============================
    const priority = window.__studentPriorityMode || 'active';

      
// ‚úÖ STEP 2: UI hint (PUT IT HERE)
const hint = document.getElementById("studentSortHint");
if (hint) {
  hint.textContent =
    priority === "inactive"
      ? "Showing INACTIVE students first"
      : "Showing ACTIVE students first";
}
    // clone array (important ‚Äì no side effects)
    let students = [...data];

    if (priority === 'active') {
      // Active first, inactive later
      students.sort((a, b) => Number(b.active) - Number(a.active));
    }

    if (priority === 'inactive') {
      // Inactive first, active later
      students.sort((a, b) => Number(a.active) - Number(b.active));
    }

    // ===============================
    // RENDER TABLE
    // ===============================
    tableBody.innerHTML = students
      .map(
        (student) => `
        <tr>
          <td><input type="checkbox" value="${student.id}"></td>
          <td>
  <span
    class="student-name"
    style="cursor:pointer; color:#ffd700;"
    data-student-id="${student.id}"
  >
    ${student.username}
  </span>
</td>

          <td>${student.active ? '‚úÖ Active' : '‚ùå Inactive'}</td>
          <td>
            ${
              student.active
                ? `<button class="btn-danger" onclick="toggleStudentStatus('${student.id}', false)">Deactivate</button>`
                : `<button class="btn-success" onclick="toggleStudentStatus('${student.id}', true)">Activate</button>`
            }
          </td>
        </tr>
      `
      )
      .join('');

  } catch (error) {
    console.error('Error loading students:', error);
    tableBody.innerHTML =
      '<tr><td colspan="4" style="color: #ff4757;">Error loading students</td></tr>';
  }
}

window.refreshStudentList = function () {
  // Lock dropdown value at click time
  window.__studentPriorityMode =
    document.getElementById("defaultStudentStatus")?.value || "active";

  loadStudents();
};



    window.addStudent = async function() {
      if (currentProfile.role !== 'admin') {
        alert('Access denied. Admin only.');
        return;
      }

      const username = document.getElementById('newStudentUser').value.trim();
      const password = document.getElementById('newStudentPass').value.trim();

      if (!username || !password) {
  showModal(
    "‚ö†Ô∏è Missing Information",
    "<p>Please enter both username and password.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}

if (password.length < 6) {
  showModal(
    "‚ö†Ô∏è Weak Password",
    "<p>Password must be at least 6 characters long.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}


      const email = `${username}@olympuschess.com`;

      try {
        const { data: authData, error: authError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: { username },
            emailRedirectTo: window.location.origin
          }
        });

        let userId = authData?.user?.id;

        if (authError) {
          if (authError.message.includes('already registered')) {
            const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({ email, password });
            if (signInError) {
  showModal(
    "‚ö†Ô∏è Login Error",
    "<p>User already exists but the password is incorrect.<br>Please use a different username.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2200);

  return;
}

            userId = signInData.user.id;
          } else {
            throw authError;
          }
        }

        const { error: profileError } = await supabase
          .from('profiles')
          .insert([{ 
            id: userId, 
            username, 
            email,
            role: 'student', 
            active: true 
          }]);
        
        if (profileError) {
  if (profileError.message.includes('duplicate')) {
    showModal(
      "‚ö†Ô∏è Duplicate Student",
      "<p>A student with this username already exists.</p>"
    );

    setTimeout(() => {
      closeModal();
    }, 2000);

    return;
  }
  throw profileError;
}


        showModal(
  "üéâ Success",
  "<p>Student added successfully!</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

document.getElementById('newStudentUser').value = '';
document.getElementById('newStudentPass').value = '';
loadStudents();


      } catch (error) {
        console.error('Error adding student:', error);
        alert('‚ùå Error: ' + error.message);
      }
    };

    window.toggleStudentStatus = function (studentId, activate) {
  if (currentProfile.role !== 'admin') return;

  const action = activate ? 'activate' : 'deactivate';

  openGradeConfirm(
    `Confirm ${action}`,
    `<p>Are you sure you want to <strong>${action}</strong> this student?</p>`,
    async () => {
      try {
        const { error: profileError } = await supabase
          .from('profiles')
          .update({ active: activate })
          .eq('id', studentId);

        if (profileError) throw profileError;

        showModal(
          "‚úÖ Success",
          `<p>Student ${action}d successfully!</p>`
        );

        setTimeout(() => {
          closeModal();
        }, 1500);

        loadStudents();

      } catch (error) {
        console.error('Error toggling student status:', error);

        showModal(
          "‚ùå Error",
          `<p>${error.message}</p>`
        );

        setTimeout(() => {
          closeModal();
        }, 2000);
      }
    }
  );
};


    function showResultModal(title, htmlContent) {
  document.getElementById("modalTitle").textContent = title;
  document.getElementById("modalContent").innerHTML = htmlContent;
  document.getElementById("resultModal").classList.remove("hidden");
}

window.closeResultModal = function () {
  const modal = document.getElementById("resultModal");
  modal.classList.add("hidden");
};

window.closeAttemptDetails = function () {
  document.getElementById("attemptDetailsModal").classList.add("hidden");
};

function openAttemptDetails(title, html) {
  document.getElementById("attemptDetailsTitle").textContent = title;
  document.getElementById("attemptDetailsBody").innerHTML = html;
  document.getElementById("attemptDetailsModal").classList.remove("hidden");
}

let pendingGradeAction = null;

window.closeGradeConfirm = function () {
  document.getElementById("gradeConfirmModal").classList.add("hidden");
  pendingGradeAction = null;
};

function openGradeConfirm(title, message, onConfirm) {
  document.getElementById("gradeConfirmTitle").textContent = title;
  document.getElementById("gradeConfirmBody").innerHTML = message;

  const yesBtn = document.getElementById("gradeConfirmYesBtn");
  yesBtn.onclick = () => {
    closeGradeConfirm();
    if (typeof onConfirm === "function") onConfirm();
  };

  document.getElementById("gradeConfirmModal").classList.remove("hidden");
}








    // ============================================
    // ATTEMPTS (ADMIN)
    // ============================================
    async function loadAttempts() {
      if (currentProfile.role !== 'admin') return;

      const attemptsList = document.getElementById('attemptsList');
      attemptsList.innerHTML = '<div class="loading">Loading attempts...</div>';

      try {
        const { data: attempts, error } = await supabase
          .from('attempts')
          .select(`*, assignments (title), profiles (username)`)
          .order('submitted_at', { ascending: false });
        if (error) throw error;

        if (!attempts || attempts.length === 0) {
          attemptsList.innerHTML = '<div class="card"><p>No attempts yet.</p></div>';
          return;
        }

        attemptsList.innerHTML = attempts.map(attempt => `
          <div class="card">
            <h4>Assignment: ${attempt.assignments?.title || 'Unknown'}</h4>
            <p><strong>Student:</strong> ${attempt.profiles?.username || attempt.student_id || 'Unknown'}</p>
            <p><strong>Submitted:</strong> ${new Date(attempt.submitted_at).toLocaleString()}</p>
            <p><strong>Time Spent:</strong> ${formatTime(attempt.time_spent || 0)}</p>
            <p><strong>Attempts:</strong> ${attempt.attempt_count || 1}</p>
            <p><strong>Status:</strong> ${attempt.is_correct ? '‚úÖ Correct' : '‚ùå Needs Review'}</p>
            <p><strong>Score:</strong> ${attempt.score || 'Not graded'}</p>
            ${attempt.pgn ? `<div class="pgn-viewer" style="max-height: 100px;">${(attempt.pgn || '').substring(0, 100)}${attempt.pgn.length > 100 ? '...' : ''}</div>` : ''}
            <div style="margin-top: 10px;">
              <button class="btn-secondary" onclick="viewAttempt('${attempt.id}')">View Details</button>
              <button class="btn-success" onclick="gradeAttempt('${attempt.id}', true)" ${attempt.is_correct ? 'disabled' : ''}>Mark Correct</button>
              <button class="btn-danger" onclick="gradeAttempt('${attempt.id}', false)" ${!attempt.is_correct ? 'disabled' : ''}>Mark Incorrect</button>
            </div>
          </div>
        `).join('');

      } catch (error) {
        console.error('Error loading attempts:', error);
        attemptsList.innerHTML = '<div class="card"><p style="color: #ff4757;">Error loading attempts</p></div>';
      }
    }

    window.viewAttempt = async function (attemptId) {
  try {
    const { data: attempt, error } = await supabase
      .from("attempts")
      .select(`
        *,
        assignments(title, is_bulk),
        profiles(username)
      `)
      .eq("id", attemptId)
      .single();

    if (error || !attempt) throw error;

    let html = `
      <p><strong>Student:</strong> ${attempt.profiles?.username || "Unknown"}</p>
      <p><strong>Submitted:</strong> ${new Date(attempt.submitted_at).toLocaleString()}</p>
      <p><strong>Total Time:</strong> ${formatTime(attempt.time_spent || 0)}</p>
      <p><strong>Attempts:</strong> ${attempt.attempt_count}</p>
      <p><strong>Status:</strong> ${attempt.is_correct ? "‚úÖ Correct" : "‚ùå Incorrect"}</p>
      <hr>
    `;

    // üîÅ BULK ASSIGNMENT DETAILS
    if (attempt.assignments?.is_bulk && attempt.pgn) {
      const puzzles = splitBulkPGNIntoPuzzles(attempt.pgn);

      html += `<h4>üì¶ Bulk Puzzle Breakdown</h4>`;

      puzzles.forEach((p, i) => {
        html += `
          <div style="padding:10px; margin-bottom:8px; border:1px solid #333; border-radius:8px;">
            <strong>Puzzle ${i + 1}</strong><br>
            Side to move: ${p.sideToMove === "w" ? "White" : "Black"}<br>
            Moves in solution: ${p.moves.length}<br>
            Status: ${attempt.is_correct ? "‚úÖ Solved" : "‚ùå Failed"}
          </div>
        `;
      });
    } else {
      html += `<p>This is a single-puzzle assignment.</p>`;
    }

    openAttemptDetails(
      `Assignment: ${attempt.assignments?.title || "Unknown"}`,
      html
    );

  } catch (err) {
    console.error(err);
    alert("Failed to load attempt details");
  }
};


    window.gradeAttempt = function (attemptId, isCorrect) {
  const actionText = isCorrect ? "mark this attempt as CORRECT" : "mark this attempt as INCORRECT";

  openGradeConfirm(
    "Confirm Grading",
    `
      <p>Are you sure you want to <strong>${actionText}</strong>?</p>
      <p style="opacity:.8; margin-top:6px;">This action will update the student record.</p>
    `,
    async () => {
      try {
        const { error } = await supabase
          .from("attempts")
          .update({
            is_correct: isCorrect,
            graded_at: new Date().toISOString(),
            score: isCorrect ? 100 : 0
          })
          .eq("id", attemptId);

        if (error) throw error;

        showStatus(
          isCorrect ? "‚úÖ Attempt marked correct" : "‚ùå Attempt marked incorrect",
          "success"
        );

        loadAttempts(); // refresh list

      } catch (err) {
        console.error(err);
        alert("Failed to update attempt");
      }
    }
  );
};






/* =====================================
   üëë QUEEN MEMORY PATH (ISOLATED)
===================================== */

const pfBoardEl   = document.getElementById("pfBoard");
const pfTimerEl   = document.getElementById("pfTimer");
const pfLivesEl   = document.getElementById("pfLives");
const pfScoreEl   = document.getElementById("pfScore");
const pfExitBtn   = document.getElementById("pfExit");
const BASE_BLOCKS = 2;
const BASE_BOMBS = 1;


let pfTimer = 0;
let pfLives = 3;
let pfScore = 0;
let pfInterval = null;
let flashDuration = 1200; // milliseconds (1.2s memory flash)

let partyAudio = null;

function playPartySound() {
  if (partyAudio) {
    partyAudio.pause();
    partyAudio.currentTime = 0;
  }

  partyAudio = new Audio("./sounds/party.mp3");
  partyAudio.volume = 0.7; // pleasant, not loud
  partyAudio.play().catch(() => {});
}

let startGameAudio = null;

function playGameStartSound() {
  if (startGameAudio) {
    startGameAudio.pause();
    startGameAudio.currentTime = 0;
  }

  startGameAudio = new Audio("./sounds/puzzle-rush-start.mp3");
  startGameAudio.volume = 0.7;
  startGameAudio.play().catch(() => {});
}

let wrongAudio = null;

function playWrongSound() {
  if (wrongAudio) {
    wrongAudio.pause();
    wrongAudio.currentTime = 0;
  }

  wrongAudio = new Audio("./sounds/wrong.mp3");
  wrongAudio.volume = 0.7;
  wrongAudio.play().catch(() => {});
}

let nextAudio = null;

function playNextSound() {
  if (nextAudio) {
    nextAudio.pause();
    nextAudio.currentTime = 0;
  }

  nextAudio = new Audio("./sounds/next.mp3");
  nextAudio.volume = 0.8;
  nextAudio.play().catch(() => {});
}

let hitAudio = null;

function playHitSound() {
  if (hitAudio) {
    hitAudio.pause();
    hitAudio.currentTime = 0;
  }

  hitAudio = new Audio("./sounds/hit.mp3");
  hitAudio.volume = 0.7;
  hitAudio.play().catch(() => {});
}



// STEP 1: fixed home square (temporary)
 let qpHome = { x: 4, y: 4 };



let pfQueen = null;


let pfBombs = [];
let pfBlocks = [];
let pfPhase = "flash"; // flash | play


let pfMode = "easy"; // easy | medium | survival

function applyPfMode(mode) {
  pfMode = mode;

  if (mode === "easy") {
    flashDuration = 500;
    pfLives = 3;
  }

  if (mode === "medium") {
    flashDuration = 300;
    pfLives = 3;
  }

  if (mode === "survival") {
    flashDuration = 200;
    pfLives = 1;
  }

  pfLivesEl.textContent = pfLives;
}

document.getElementById("pfEasy").onclick = () => {
  applyPfMode("easy");
  startPfGame();
};

document.getElementById("pfMedium").onclick = () => {
  applyPfMode("medium");
  startPfGame();
};

document.getElementById("pfSurvival").onclick = () => {
  applyPfMode("survival");
  startPfGame();
};


function startPfGame() {
  playGameStartSound(); // üîä PLAY HERE (user click ‚Üí allowed)
  document.getElementById("pfMenu").classList.add("hidden");
  document.getElementById("pfGame").classList.remove("hidden");
  pfStart();
}


pfExitBtn.onclick = () => {
  pfStop();
  document.getElementById("pfGame").classList.add("hidden");
  document.getElementById("pfMenu").classList.remove("hidden");
};



/* ---------- helpers ---------- */
function pfRand() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function pfSame(a, b) {
  return a.x === b.x && a.y === b.y;
}

/* ---------- board draw ---------- */
function drawPfBoard(showFlash = false) {
  pfBoardEl.innerHTML = "";

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {

      const sq = document.createElement("div");
      sq.className = `pf-square ${(x + y) % 2 ? "dark" : "light"}`;
      
      
      sq.dataset.x = x;
      sq.dataset.y = y;

      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = 8 - y;                       // 8‚Äì1

const coord = document.createElement("div");
coord.className = "pf-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);


      // üè† HOME square (always visible)
if (x === qpHome.x && y === qpHome.y) {
  sq.classList.add("qp-home");
  const home = document.createElement("div");
home.className = "pf-home-icon";
home.textContent = "üè†";
sq.appendChild(home);

}


      if (showFlash) {
        if (pfBlocks.some(b => b.x === x && b.y === y))
          sq.classList.add("pf-grey");
        if (pfBombs.some(b => b.x === x && b.y === y))
          sq.classList.add("pf-red");
        
      }

      if (pfSame(pfQueen, { x, y })) {
  const q = document.createElement("div");
  q.className = "pf-queen-emoji";
  q.textContent = "üë∏";   // üëë QUEEN EMOJI
  sq.appendChild(q);
}


      

      sq.onclick = () => pfHandleClick(x,y);
      pfBoardEl.appendChild(sq);
    }
  }
}

/* ---------- click ---------- */
function pfHandleClick(x, y) {
  if (pfPhase !== "play") return;

  // illegal move (queen logic simplified: row / col / diag)
  const dx = Math.abs(x - pfQueen.x);
  const dy = Math.abs(y - pfQueen.y);
  if (!(dx === 0 || dy === 0 || dx === dy)) return;

  // blocked path
  if (pfBlocks.some(b => b.x === x && b.y === y)) {
    playHitSound();
    return;
  }

  pfQueen = {x,y};

  // üè† HOME reached
if (x === qpHome.x && y === qpHome.y) {
  console.log("üè† Home reached");

  playNextSound(); // üîä NEXT PUZZLE SOUND

  // ‚≠ê INCREMENT SCORE FIRST
  pfScore++;
  pfScoreEl.textContent = pfScore;

  // ‚û°Ô∏è THEN start next round
  startNewPfRound();
  return;
}



  if (pfBombs.some(b => b.x === x && b.y === y)) {
    playWrongSound(); // üîä WRONG MOVE SOUND
  pfLives--;
  pfLivesEl.textContent = pfLives;

  if (pfLives <= 0) {
    pfPhase = "over";

    // üèÜ SAVE BEST SCORE (Queen Memory Path)
  saveMiniGameScore("pathfinder", pfScore);

    playPartySound(); // üéâ PLAY SOUND HERE

    showPfModal(
      "üí• Game Over",
      `You survived ${pfScore} rounds!`,
      () => {
        pfStop(); // go back to menu
      }
    );

    return;
  }
}


  


  drawPfBoard(false);
}

function handlePfSuccess() {
  // ‚≠ê increase score
  pfScore++;
  pfScoreEl.textContent = pfScore;

  // üîä success sound (optional)
  playSound?.("next.mp3");

  // ‚è≥ short pause feels nice
  setTimeout(() => {
    startNewPfRound();
  }, 400);
}

function startNewPfRound() {

  // üß™ DEBUG ‚Äî difficulty check
  console.log(
    "ROUND:", pfScore,
    "GREY:", BASE_BLOCKS + Math.floor(pfScore / 2),
    "RED:", BASE_BOMBS + Math.floor(pfScore / 2)
  );

  // üîÑ reset arrays
  pfBlocks = [];
  pfBombs = [];

  // ‚ôï random queen
  pfQueen = randomPfSquare();

  // üè† random home (not same as queen)
  do {
  qpHome = randomPfSquare();
} while (pfSame(qpHome, pfQueen));


  // üéö difficulty scaling
  const extra = Math.floor(pfScore / 2);

  generatePfBlocks(BASE_BLOCKS + extra);
  generatePfBombs(BASE_BOMBS + extra);

  // üëÅ memory flash
  drawPfBoard(true);

  setTimeout(() => {
    pfPhase = "play";
    drawPfBoard(false);
  }, flashDuration);
}



function randomPfSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function generatePfBlocks(count) {
  while (pfBlocks.length < count) {
    const pos = pfRand();

    if (pfSame(pos, pfQueen)) continue;
    if (pfSame(pos, qpHome)) continue;
    if (pfBlocks.some(b => pfSame(b, pos))) continue;

    pfBlocks.push(pos);
  }
}


function generatePfBombs(count) {
  

  while (pfBombs.length < count) {
    const pos = pfRand();

    if (pfSame(pos, pfQueen)) continue;
    if (pfSame(pos, qpHome)) continue;
    if (pfBlocks.some(b => pfSame(b, pos))) continue;
    if (pfBombs.some(b => pfSame(b, pos))) continue;

    pfBombs.push(pos);
  }
}



/* ---------- round ---------- */


/* ---------- start / stop ---------- */
function pfStart() {
  pfLives = 3;
  pfScore = 0;
  pfTimer = 0;

  pfLivesEl.textContent = pfLives;
  pfScoreEl.textContent = pfScore;
  pfTimerEl.textContent = pfTimer;

  clearInterval(pfInterval);
  pfInterval = setInterval(() => {
    pfTimer++;
    pfTimerEl.textContent = pfTimer;
  }, 1000);

  pfPhase = "flash";
startNewPfRound();

}

function pfStop() {
  clearInterval(pfInterval);
  pfInterval = null;

  pfPhase = "flash";

  // hide game
  document.getElementById("pfGame").classList.add("hidden");

  // show menu
  document.getElementById("pfMenu").classList.remove("hidden");
}


/* ---------- exit ---------- */
pfExitBtn.onclick = pfStop;

/* ---------- NAV HOOK ---------- */
document.querySelectorAll(".nav-btn").forEach(btn => {
  if (btn.dataset.tab === "pathfinder") {
    btn.onclick = () => {
      document.querySelectorAll(".section").forEach(s => s.classList.add("hidden"));
      document.getElementById("pathfinder-section").classList.remove("hidden");
      pfStart();
    };
  }
});

document.querySelectorAll(".nav-btn").forEach(btn => {
  if (btn.dataset.tab === "pathfinder") {
    btn.onclick = () => {
      document.querySelectorAll(".section")
        .forEach(s => s.classList.add("hidden"));

      document.getElementById("pathfinder-section")
        .classList.remove("hidden");

      document.getElementById("pfGame").classList.add("hidden");
      document.getElementById("pfMenu").classList.remove("hidden");
    };
  }
});


function showPfModal(title, message, onClose) {
  const overlay = document.getElementById("floatingModal");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  titleEl.textContent = title;
  bodyEl.textContent = message;

  overlay.classList.remove("hidden");

  okBtn.onclick = () => {
    overlay.classList.add("hidden");
    if (typeof onClose === "function") onClose();
  };
}

// ===============================
// üß† Flash Queen Game State
// ===============================

let fqTimer = 0;
let fqInterval = null;

let audioUnlocked = false;

function unlockAudioOnce() {
  if (audioUnlocked) return;

  const a = new Audio("./sounds/next.mp3");
  a.volume = 0;
  a.play().then(() => {
    a.pause();
    a.currentTime = 0;
    audioUnlocked = true;
    console.log("üîì Audio unlocked");
  }).catch(() => {});
}

document.addEventListener("click", unlockAudioOnce, { once: true });







const flashBoardEl = document.getElementById("flashQueenBoard");



function startFlashQueen(mode) {
  playGameStartSound();

  document.getElementById("flashQueenMenu").classList.add("hidden");
  document.getElementById("flashQueenGame").classList.remove("hidden");

 

  flashQueenState = {
    mode,
    level: 1,
    lives: 3,
    score: 0
  };

  document.getElementById("fqLives").textContent = 3;
  document.getElementById("fqScore").textContent = 0;

  startFlashQueenRound();
   startFQTimer(); 
}



const FQ_SIZE = 8;

const PIECES = [
  "üê±","üê∂","üê∏","ü¶Ñ","üêº","üêµ",
  "üêØ","ü¶ä","üê∞","üê∑","üê®","üêÆ",
  "üéà","üé≤","üçé","üç©","üç≠","‚öΩ", "üçé", "üçå", "üçì", "üçí","üèÄ", "üéæ","üêî", "üêß","üê≤", "üêâ",
  "üöó","‚úàÔ∏è","üöÄ","üéÅ"
];
 // random distractors
const QUEEN = "üë∏";

function startFQTimer() {
  stopFQTimer(); // safety
  fqTimer = 0;
  document.getElementById("fqTimer").textContent = fqTimer;

  fqInterval = setInterval(() => {
    fqTimer++;
    document.getElementById("fqTimer").textContent = fqTimer;
  }, 1000);
}

function stopFQTimer() {
  if (fqInterval) {
    clearInterval(fqInterval);
    fqInterval = null;
  }
}


function fqRandSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function fqSame(a, b) {
  return a.x === b.x && a.y === b.y;
}



const FlashQueen = {
  state: {
    level: 1,
    lives: 3,
    score: 0,
    mode: "easy",
    queenPos: null,
    pieces: [],
    phase: "flash"
  },

  start(mode) {
    this.state.mode = mode;
    this.state.level = 1;
    this.state.score = 0;
    this.state.lives = mode === "survival" ? 1 : 3;

    document.getElementById("fqScore").textContent = 0;
    document.getElementById("fqLives").textContent = this.state.lives;

    document.getElementById("flashQueenMenu").classList.add("hidden");
    document.getElementById("flashQueenGame").classList.remove("hidden");

    startFQTimer();
    this.startRound();
  },

  startRound() {
    this.state.phase = "flash";
    this.generatePosition();
    this.draw(true);

    setTimeout(() => {
      this.state.phase = "guess";
      this.draw(false);
    }, this.getFlashTime());
  },

getFlashTime() {
  if (this.state.mode === "easy") return 600;
  if (this.state.mode === "medium") return 350;
  return Math.max(180, 600 - this.state.level * 45);
},

  generatePosition() {
    this.state.pieces = [];
    const count = Math.min(1 + this.state.level, 50);

    this.state.queenPos = fqRandSquare();
    this.state.pieces.push({
  ...this.state.queenPos,
  piece: "üë∏",
  isQueen: true
});


    while (this.state.pieces.length < count) {
      const pos = fqRandSquare();
      if (this.state.pieces.some(p => fqSame(p, pos))) continue;

      this.state.pieces.push({
        ...pos,
        piece: PIECES[Math.floor(Math.random() * PIECES.length)]
      });
    }
  },

  draw(show) {
    const board = document.getElementById("flashQueenBoard");
    board.innerHTML = "";

    for (let y = 0; y < 8; y++) {
      for (let x = 0; x < 8; x++) {
        const sq = document.createElement("div");
        sq.className = `pf-square ${(x + y) % 2 ? "dark" : "light"}`;
              // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
      const file = String.fromCharCode(97 + x); // a‚Äìh
      const rank = 8 - y;                       // 8‚Äì1

      const coord = document.createElement("div");
      coord.className = "pf-coord";
      coord.textContent = `${file}${rank}`;
      sq.appendChild(coord);


        if (show) {
          const p = this.state.pieces.find(o => o.x === x && o.y === y);
          if (p) {
  sq.textContent = p.piece;
  sq.classList.add("pf-piece");

  if (p.isQueen) {
    sq.classList.add("pf-queen");
  }
}

        }

        sq.onclick = () => this.handleGuess(x, y);
        board.appendChild(sq);
      }
    }
  },

  handleGuess(x, y) {
    if (this.state.phase !== "guess") return;

    if (x === this.state.queenPos.x && y === this.state.queenPos.y) {
     playNextSound();

      this.state.score++;
      this.state.level++;
      document.getElementById("fqScore").textContent = this.state.score;
      
      this.startRound();
    } else {
      playWrongSound();
      this.state.lives--;
      document.getElementById("fqLives").textContent = this.state.lives;

      if (this.state.lives <= 0) {
      stopFQTimer();     // ‚úÖ STOP TIMER
      // üèÜ SAVE BEST SCORE (Flash Queen)
  saveMiniGameScore("flashqueen", this.state.score);
        playPartySound();

        showFloatingModal("Game Over", `Score: ${this.state.score}`);
      }
    }
  }
};













document.getElementById("fqEasy").onclick = () => FlashQueen.start("easy");
document.getElementById("fqMedium").onclick = () => FlashQueen.start("medium");
document.getElementById("fqSurvival").onclick = () => FlashQueen.start("survival");


document.getElementById("fqExit").onclick = () => {
stopFQTimer();     // ‚úÖ STOP TIMER
  document.getElementById("flashQueenGame").classList.add("hidden");
  document.getElementById("flashQueenMenu").classList.remove("hidden");
};





// ================================
// üê¥ KNIGHT FLASH PATH ‚Äì NO LIVES
// ================================

const kpBoard = document.getElementById("kpBoard");
const kpLevelEl = document.getElementById("kpLevel");

// ---------- GAME STATE ----------
let kpLevel = 1;
let kpKnightPos = null;
let kpPath = [];
let kpTargetSquare = null;
let kpWaitingForClick = false;
let kpStepIndex = 0;

let kpDifficulty = "easy";

const KP_FLASH_TIME = {
  easy:   { on: 500, off: 300 },
  medium: { on: 350, off: 220 },
  hard:   { on: 220, off: 150 }
};



// ---------- KNIGHT MOVES ----------
const KNIGHT_MOVES = [
  [1, 2], [2, 1], [-1, 2], [-2, 1],
  [1, -2], [2, -1], [-1, -2], [-2, -1]
];


function playKnightMoveSound() {
  const sound = new Audio("sounds/move.mp3");
  sound.volume = 0.5;
  sound.currentTime = 0;
  sound.play();
}

function playKnightWrongSound() {
  const sound = new Audio("sounds/wrong.mp3");
  sound.volume = 0.5;
  sound.currentTime = 0;
  sound.play();
}

function playKnightNextSound() {
  const sound = new Audio("sounds/next.mp3");
  sound.volume = 0.6;
  sound.currentTime = 0;
  sound.play();
}

function playKnightFlashSound() {
  const sound = new Audio("sounds/flash.mp3");
  sound.volume = 0.25; // keep it soft
  sound.currentTime = 0;
  sound.play();
}

    let knightAudioUnlocked = false;

function unlockKnightAudio() {
  if (knightAudioUnlocked) return;

  const audio = new Audio("sounds/flash.mp3");
  audio.volume = 0;
  audio.play().catch(() => {});
  knightAudioUnlocked = true;
}





// ================================
// START GAME
// ================================
window.startKP = function (mode) {
  unlockKnightAudio();   // üîì REQUIRED FOR FLASH SOUND
  kpDifficulty = mode;   // ‚úÖ THAT‚ÄôS IT
  kpLevel = 1;

  kpKnightPos = kpRandomSquare();
  showKnightPathGame();
  drawKPBoard();
  startLevel();
};


// ================================
// EXIT GAME
// ================================
window.exitKP = function () {
  // üèÜ SAVE BEST SCORE (Knight Flash Path)
  const finalScore = Math.max(0, kpLevel - 1);
  saveMiniGameScore("knightpath", finalScore);
  document.getElementById("kpGame").classList.add("hidden");
  document.getElementById("kpMenu").classList.remove("hidden");
};

// ================================
// START LEVEL
// ================================
function startLevel() {
  kpWaitingForClick = false;
  kpStepIndex = 0; // üî• reset step
 


  kpPath = generateKPPath();

  kpLevelEl.textContent = kpLevel;

  flashPath(0);
}


// ================================
// GENERATE PATH
// ================================
function generateKPPath() {
  let path = [];
  let pos = { ...kpKnightPos };

  for (let i = 0; i < kpLevel; i++) {
    const moves = KNIGHT_MOVES
      .map(([dx, dy]) => ({ x: pos.x + dx, y: pos.y + dy }))
      .filter(p => p.x >= 0 && p.x < 8 && p.y >= 0 && p.y < 8);

    pos = moves[Math.floor(Math.random() * moves.length)];
    path.push(pos);
  }
  return path;
}

// ================================
// FLASH PATH
// ================================
function flashPath(i) {
  if (i >= kpPath.length) {
    kpWaitingForClick = true;
    return;
  }

  const { x, y } = kpPath[i];
  const sq = document.querySelector(`[data-pos="${x}-${y}"]`);
  if (!sq) return;

  const { on, off } = KP_FLASH_TIME[kpDifficulty];

  sq.classList.add("flash");

  // üîä play flash sound
playKnightFlashSound();

  setTimeout(() => {
    sq.classList.remove("flash");
    setTimeout(() => flashPath(i + 1), off);
  }, on);
}


// ================================
// HANDLE CLICK
// ================================
function handleKPClick(x, y) {
  if (!kpWaitingForClick) return;

  const expected = kpPath[kpStepIndex];

  // ‚úÖ CORRECT NEXT STEP
  if (x === expected.x && y === expected.y) {

    // üîä correct move sound
    playKnightMoveSound();

    // move knight step-by-step
    kpKnightPos = { x, y };
    drawKPBoard();

    kpStepIndex++;

    // üèÅ finished full path
    if (kpStepIndex >= kpPath.length) {
      kpLevel++;

      // ‚≠ê animate level change
      kpLevelEl.classList.add("pop");
      setTimeout(() => kpLevelEl.classList.remove("pop"), 150);

      kpWaitingForClick = false;

      // ‚è≥ 1 SECOND GAP BEFORE NEXT LEVEL
      setTimeout(() => {
        startLevel();
      }, 1000);
    }

  } else {
    // ‚ùå wrong square
    playKnightWrongSound();
    // retry same step (no life system)
  }
}



// ================================
// DRAW BOARD
// ================================
function drawKPBoard() {
  kpBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";

      const isLight = (x + y) % 2 === 1;

      sq.classList.add(isLight ? "light" : "dark");

      sq.dataset.pos = `${x}-${y}`;

      // ‚ôüÔ∏è file & rank labels
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "kp-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);


      if (kpKnightPos.x === x && kpKnightPos.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("knight");
      }

      sq.onclick = () => handleKPClick(x, y);
      kpBoard.appendChild(sq);
    }
  }
}

// ================================
// RANDOM START
// ================================
function kpRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// SHOW GAME UI
// ================================
function showKnightPathGame() {
  document.getElementById("kpMenu").classList.add("hidden");
  document.getElementById("kpGame").classList.remove("hidden");
}




let lmMode = "easy";
let lmRound = 1;
let lmQuestionIndex = 0;
let lmTotalQuestions = 8;

let lmMap = [];           // [{x,y,color}]
let lmTargetColor = null;
let lmWaitingForClick = false;


const LM_COLORS = ["red", "green", "blue", "yellow", "orange", "violet"];

const LM_DIFFICULTY = {
  easy:   { squares: 6,  flashOn: 180, flashOff: 110 },
  medium: { squares: 7,  flashOn: 150, flashOff: 90 },
  hard:   { squares: 9,  flashOn: 130, flashOff: 70 }
};



window.startLabMixer = function (mode) {
  unlockKnightAudio(); // üîì AUDIO UNLOCK (REUSED)
  lmMode = mode;
  lmRound = 1;
  lmQuestionIndex = 0;

  document.getElementById("lmMenu").classList.add("hidden");
  document.getElementById("lmGame").classList.remove("hidden");

  nextLabQuestion();
}

function playLabNextSound() {
  const sound = new Audio("sounds/next.mp3");
  sound.volume = 0.6;
  sound.currentTime = 0;
  sound.play().catch(() => {});
}

function playLabFlashSound() {
  const sound = new Audio("sounds/flash.mp3");
  sound.volume = 0.25;   // soft, kid-friendly
  sound.currentTime = 0;
  sound.play().catch(() => {});
}

function playLabWrongSound() {
  const sound = new Audio("sounds/wrong.mp3");
  sound.volume = 0.6;
  sound.currentTime = 0;
  sound.play().catch(() => {});
}




function nextLabQuestion() {
  if (lmQuestionIndex >= lmTotalQuestions) {
    // round complete
    
    lmQuestionIndex = 0;
  }

  lmQuestionIndex++;
  document.getElementById("lmRound").textContent = lmRound;

  generateLabColors();
  drawLabBoard();
  flashLabColors(0);
}


function generateLabColors() {
  lmMap = [];
  lmWaitingForClick = false;

  const cfg = LM_DIFFICULTY[lmMode];
  const used = new Set();

  while (lmMap.length < cfg.squares) {
    const x = Math.floor(Math.random() * 8);
    const y = Math.floor(Math.random() * 8);
    const key = `${x}-${y}`;
    if (used.has(key)) continue;
    used.add(key);

    const color = LM_COLORS[Math.floor(Math.random() * LM_COLORS.length)];
    lmMap.push({ x, y, color });
  }

  lmTargetColor = lmMap[Math.floor(Math.random() * lmMap.length)].color;

const banner = document.querySelector("#color-section .lm-find-banner");

// remove old color classes
banner.classList.remove(
  "find-red",
  "find-green",
  "find-blue",
  "find-yellow",
  "find-orange",
  "find-violet"
);

// apply new color
banner.classList.add(`find-${lmTargetColor}`);

document.getElementById("lmTarget").textContent = lmTargetColor.toUpperCase();

}


function flashLabColors(i = 0) {
  if (i >= lmMap.length) {
    lmWaitingForClick = true;
    return;
  }

  const { x, y, color } = lmMap[i];
  const sq = document.querySelector(`#lmBoard [data-pos="${x}-${y}"]`);
  if (!sq) return;

  const overlay = sq.querySelector(".lm-overlay");
  const { flashOn, flashOff } = LM_DIFFICULTY[lmMode];

  // üõë Prevent re-flashing same square
  if (overlay.dataset.flashed === "1") {
    flashLabColors(i + 1);
    return;
  }

  overlay.dataset.flashed = "1"; // mark as flashed

  overlay.className = `lm-overlay lm-${color} show`;
  playLabFlashSound();

  setTimeout(() => {
    overlay.className = "lm-overlay";
    setTimeout(() => flashLabColors(i + 1), flashOff);
  }, flashOn);
}




function handleLabClick(x, y) {
  if (!lmWaitingForClick) return;

  const hit = lmMap.find(p => p.x === x && p.y === y);

  if (hit && hit.color === lmTargetColor) {
  playLabNextSound();

  lmWaitingForClick = false;

  // üî• INCREASE ROUND ON EVERY CORRECT ANSWER
  lmRound++;

  // update round number
document.getElementById("lmRound").textContent = lmRound;

// update round color ONLY if badge exists
const roundEl = document.querySelector("#color-section .lm-round");
if (roundEl) {
  roundEl.classList.remove(
    "round-1",
    "round-2",
    "round-3",
    "round-4",
    "round-5"
  );
  roundEl.classList.add(`round-${Math.min(lmRound, 5)}`);
}


  setTimeout(() => {
    nextLabQuestion();
  }, 600);
  }
  // ‚ùå WRONG CLICK
  else {
    playLabWrongSound(); // üîä wrong.mp3
}


}


function drawLabBoard() {
  const board = document.getElementById("lmBoard");
  board.innerHTML = "";
  // reset flash markers
document.querySelectorAll("#lmBoard .lm-overlay").forEach(o => {
  delete o.dataset.flashed;
});


  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");

      // KEEP original square styles
      sq.className = "kp-square lm-square";
      sq.dataset.pos = `${x}-${y}`;

      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "lm-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);


      const isLight = (x + y) % 2 === 1;

      sq.classList.add(isLight ? "light" : "dark");

      // üëâ isolated overlay
      const overlay = document.createElement("div");
      overlay.className = "lm-overlay";
      sq.appendChild(overlay);

      sq.onclick = () => handleLabClick(x, y);
      board.appendChild(sq);
    }
  }
}



window.exitLabMixer = function () {

  // üèÜ SAVE BEST SCORE (Lab Mixer)
  saveMiniGameScore("color", Math.max(0, lmRound - 1));

  document.getElementById("lmGame").classList.add("hidden");
  document.getElementById("lmMenu").classList.remove("hidden");
  
}





// ================================
// KNIGHT VS MONSTER (ISOLATED)
// ================================

// STATE
let kvmMode = "easy";
let kvmKnight = null;
let kvmMonsters = [];
let kvmTurns = 0;
let kvmWaiting = false;
let kvmLevel = 1;           // future-proof
let kvmBlockedSquares = []; // üß± level 1 only



const kvmBoard = document.getElementById("kvmBoard");
const kvmTurnsEl = document.getElementById("kvmTurns");
const kvmMonsterCountEl = document.getElementById("kvmMonsterCount");


function generateKVMBlockedSquares(count) {
  const blocks = [];

  while (blocks.length < count) {
    const sq = kvmRandomSquare();

    // ‚ùå avoid knight start
    if (sq.x === kvmKnight.x && sq.y === kvmKnight.y) continue;

    // ‚ùå avoid monsters
    if (kvmMonsters.some(m => m.x === sq.x && m.y === sq.y)) continue;

    // ‚ùå avoid duplicates
    if (blocks.some(b => b.x === sq.x && b.y === sq.y)) continue;

    blocks.push(sq);
  }

  return blocks;
}



// ================================
// Knight vs Monster - Game Over Sound
// ================================
function playKVMGameOverSound() {
  try {
    const audio = new Audio("./sounds/party.mp3");
    audio.volume = 0.6; // üîä not too loud
    audio.play();
  } catch (e) {
    console.warn("üîá party.mp3 could not play", e);
  }
}

// ================================
// Knight vs Monster - Move Sound
// ================================
function playKVMMoveSound() {
  try {
    const audio = new Audio("./sounds/move.mp3");
    audio.volume = 0.5; // balanced, not loud
    audio.play();
  } catch (e) {
    console.warn("üîá move.mp3 could not play", e);
  }
}



// ================================
// START GAME
// ================================
window.startKVM = function (mode) {
  kvmMode = mode;
  kvmTurns = 0;

  document.getElementById("kvmMenu").classList.add("hidden");
  document.getElementById("kvmGame").classList.remove("hidden");

  kvmKnight = kvmRandomSquare();
  kvmMonsters = [];

  const monsterCount =
    mode === "easy" ? 1 : mode === "medium" ? 2 : 3;

  for (let i = 0; i < monsterCount; i++) {
    kvmMonsters.push(kvmRandomSquare());
  }

  // ‚úÖ STEP 3 ‚Äî BLOCK SQUARES (LEVEL 1 ONLY)
  kvmLevel = 1;

  if (kvmLevel === 1) {
    const blockCount =
      mode === "easy" ? 5 : mode === "medium" ? 4 : 4;

    kvmBlockedSquares = generateKVMBlockedSquares(blockCount);
  } else {
    kvmBlockedSquares = [];
  }

  kvmMonsterCountEl.textContent = monsterCount;
  kvmTurnsEl.textContent = 0;

  drawKVMBoard();
  kvmWaiting = true;
};


// ================================
// EXIT GAME
// ================================
window.exitKVM = function () {
  document.getElementById("kvmGame").classList.add("hidden");
  document.getElementById("kvmMenu").classList.remove("hidden");
};

// ================================
// RANDOM SQUARE
// ================================
function kvmRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// HANDLE KNIGHT CLICK
// ================================
function handleKVMClick(x, y) {
  if (!kvmWaiting) return;

  const dx = Math.abs(x - kvmKnight.x);
  const dy = Math.abs(y - kvmKnight.y);

  // üê¥ knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // üö´ blocked square (level 1 only)
  if (
    kvmLevel === 1 &&
    kvmBlockedSquares.some(b => b.x === x && b.y === y)
  ) {
    return;
  }

  // ‚úÖ MOVE KNIGHT
  kvmKnight = { x, y };
  playKVMMoveSound();

  kvmTurns++;
  kvmTurnsEl.textContent = kvmTurns;

  moveMonsters();

  if (isKnightCaught()) {
    showKVMGameOver(kvmTurns);
    return;
  }

  drawKVMBoard();
}


// ================================
// MOVE MONSTERS
// ================================
function moveMonsters() {
  const newPositions = [];

  for (let i = 0; i < kvmMonsters.length; i++) {
    const m = kvmMonsters[i];

    let bestMove = null;
    let bestDist = Infinity;

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;

        const nx = m.x + dx;
        const ny = m.y + dy;

        // board bounds
        if (nx < 0 || nx >= KND_SIZE || ny < 0 || ny >= KND_SIZE) continue;


        // üö´ avoid occupied monster squares
        if (newPositions.some(p => p.x === nx && p.y === ny)) continue;

        const dist =
          Math.abs(nx - kvmKnight.x) +
          Math.abs(ny - kvmKnight.y);

        if (dist < bestDist) {
          bestDist = dist;
          bestMove = { x: nx, y: ny };
        }
      }
    }

    // if no legal free square ‚Üí stay
    newPositions.push(bestMove || { ...m });
  }

  kvmMonsters = newPositions;
}


// ================================
// CHECK CAUGHT
// ================================
function isKnightCaught() {
  return kvmMonsters.some(
    m => m.x === kvmKnight.x && m.y === kvmKnight.y
  );
}

// ================================
// DRAW BOARD
// ================================
function drawKVMBoard() {
  kvmBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";
      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "kvm-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);

     sq.classList.add((x + y) % 2 === 1 ? "light" : "dark");

      sq.onclick = () => handleKVMClick(x, y);

      // üß± blocked square (level 1 only)
      if (
        kvmLevel === 1 &&
        kvmBlockedSquares.some(b => b.x === x && b.y === y)
      ) {
        sq.textContent = "üß±";
        sq.style.fontSize = "32px";
        sq.style.opacity = "0.85";
      }

      // üê¥ knight
      if (kvmKnight.x === x && kvmKnight.y === y) {
        sq.textContent = "üê¥";
      }

      // üëπ monsters
      for (const m of kvmMonsters) {
        if (m.x === x && m.y === y) {
          sq.textContent = "üëπ";
        }
      }

      kvmBoard.appendChild(sq);
    }
  }
}




function showKVMGameOver(turns) {
   playKVMGameOverSound(); // üéâ PLAY SOUND ON GAME OVER
      // üèÜ SAVE BEST SCORE (Knight vs Monster)
   saveMiniGameScore("knightmonster", turns);

  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  if (!modal || !title || !body || !okBtn) {
    console.error("‚ùå Floating modal not found");
    return;
  }

  title.textContent = "üëπ Game Over!";
  body.innerHTML = `
    <p style="font-size:16px; line-height:1.6;">
      The monster caught your knight üê¥<br><br>
      ‚≠ê <b>Turns survived:</b> ${turns}
    </p>
  `;

  modal.classList.remove("hidden");

  // Close behavior ONLY for this game
  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKVM(); // üëà safely exit Knight vs Monster only
  };
}


// ================================
// KNIGHT ESCAPE MAZE (ISOLATED)
// ================================

// STATE
let kemMode = "easy";
let kemKnight = null;
let kemExit = null;
let kemWalls = [];
let kemMonsters = [];
let kemTurns = 0;
let kemLevel = 1;
let kemWaiting = false;

const kemBoard = document.getElementById("kemBoard");
const kemTurnsEl = document.getElementById("kemTurns");
const kemLevelEl = document.getElementById("kemLevel");


// ================================
// Knight Escape Maze - Next Level Sound
// ================================
function playKEMNextSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("üîá next.mp3 could not play", e);
  }
}


// ================================
// RANDOM SQUARE
// ================================
function kemRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// GENERATE WALLS
// ================================
function generateKEMWalls(count) {
  const walls = [];

  while (walls.length < count) {
    const sq = kemRandomSquare();

    if (
      (sq.x === kemKnight.x && sq.y === kemKnight.y) ||
      (sq.x === kemExit.x && sq.y === kemExit.y) ||
      kemMonsters.some(m => m.x === sq.x && m.y === sq.y)
    ) continue;

    if (walls.some(w => w.x === sq.x && w.y === sq.y)) continue;

    walls.push(sq);
  }
  return walls;
}

// ================================
// START GAME
// ================================
window.startKEM = function (mode) {
  kemMode = mode;
  kemTurns = 0;
  kemLevel = 1;

  document.getElementById("kemMenu").classList.add("hidden");
  document.getElementById("kemGame").classList.remove("hidden");

  initKEMLevel();
};

// ================================
// INIT LEVEL
// ================================
function initKEMLevel() {
  kemKnight = kemRandomSquare();
  kemExit = kemRandomSquare();

  while (kemExit.x === kemKnight.x && kemExit.y === kemKnight.y) {
    kemExit = kemRandomSquare();
  }

  const monsterCount =
    kemMode === "easy" ? 1 :
    kemMode === "medium" ? 2 : 3;

  kemMonsters = [];
  for (let i = 0; i < monsterCount; i++) {
    kemMonsters.push(kemRandomSquare());
  }

  const wallBase =
    kemMode === "easy" ? 6 :
    kemMode === "medium" ? 10 : 14;

  kemWalls = generateKEMWalls(wallBase + kemLevel);

  kemTurnsEl.textContent = kemTurns;
  kemLevelEl.textContent = kemLevel;

  kemWaiting = true;
  drawKEMBoard();
}

// ================================
// EXIT GAME
// ================================
window.exitKEM = function () {
  document.getElementById("kemGame").classList.add("hidden");
  document.getElementById("kemMenu").classList.remove("hidden");
};

// ================================
// HANDLE CLICK
// ================================
function handleKEMClick(x, y) {
  if (!kemWaiting) return;

  const dx = Math.abs(x - kemKnight.x);
  const dy = Math.abs(y - kemKnight.y);

  // knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // blocked by wall
  if (kemWalls.some(w => w.x === x && w.y === y)) return;

  kemKnight = { x, y };
  kemTurns++;
  kemTurnsEl.textContent = kemTurns;

  playKVMMoveSound?.();

  moveKEMMonsters();

  // üíÄ CAUGHT
  if (isKEMKnightCaught()) {
    showKEMGameOver();
    return;
  }

  // üèÅ NEXT LEVEL
  if (x === kemExit.x && y === kemExit.y) {
   playKEMNextSound();   // üîä LEVEL UP SOUND
    kemLevel++;
    initKEMLevel();
    return;
  }

  drawKEMBoard();
}

// ================================
// MOVE MONSTERS (CHASE)
// ================================
function moveKEMMonsters() {
  const newPositions = [];

  for (const m of kemMonsters) {
    let bestMove = null;
    let bestDist = Infinity;

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;

        const nx = m.x + dx;
        const ny = m.y + dy;
if (nx < 0 || nx >= KND_SIZE || ny < 0 || ny >= KND_SIZE) continue;

        if (kemWalls.some(w => w.x === nx && w.y === ny)) continue;
        if (newPositions.some(p => p.x === nx && p.y === ny)) continue;

        const dist =
          Math.abs(nx - kemKnight.x) +
          Math.abs(ny - kemKnight.y);

        if (dist < bestDist) {
          bestDist = dist;
          bestMove = { x: nx, y: ny };
        }
      }
    }
    newPositions.push(bestMove || { ...m });
  }

  kemMonsters = newPositions;
}

// ================================
// CHECK CAUGHT
// ================================
function isKEMKnightCaught() {
  return kemMonsters.some(
    m => m.x === kemKnight.x && m.y === kemKnight.y
  );
}

// ================================
// DRAW BOARD
// ================================
function drawKEMBoard() {
  kemBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";
      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "kem-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);

      sq.classList.add((x + y) % 2 === 1 ? "light" : "dark");

      sq.onclick = () => handleKEMClick(x, y);

      if (kemWalls.some(w => w.x === x && w.y === y)) {
        sq.textContent = "üß±";
      }

      if (kemExit.x === x && kemExit.y === y) {
        sq.textContent = "üèÅ";
      }

      // üëπ MONSTERS (bigger)
for (const m of kemMonsters) {
  if (m.x === x && m.y === y) {
    sq.textContent = "üëπ";
    sq.style.fontSize = "34px";
    sq.style.transform = "scale(1.1)";
  }
}

// üê¥ KNIGHT (bigger & priority)
if (kemKnight.x === x && kemKnight.y === y) {
  sq.textContent = "üê¥";
  sq.style.fontSize = "30px";
  sq.style.transform = "scale(1.15)";
      }

      kemBoard.appendChild(sq);
    }
  }
}

// ================================
// GAME OVER (ONLY HERE MODAL)
// ================================
function showKEMGameOver() {
  playKVMGameOverSound?.();
    // üèÜ SAVE BEST SCORE (Knight Escape Maze)
  saveMiniGameScore("knightescape", kemLevel);


  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = "üëπ Game Over!";
  body.innerHTML = `
    <p style="font-size:16px;">
      The monster caught your knight üê¥<br><br>
      üèÜ Level reached: <b>${kemLevel}</b><br>
      ‚≠ê Moves: <b>${kemTurns}</b>
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKEM();
  };
}



// ================================
// ‚ö° KNIGHT SPEED RUN (WITH BOMBS)
// ================================

// STATE
let ksrMode = "medium";
let ksrKnight = null;
let ksrTarget = null;
let ksrBombs = [];
let ksrScore = 0;
let ksrTime = 30;
let ksrTimer = null;
let ksrRunning = false;

// ELEMENTS
const ksrBoard = document.getElementById("ksrBoard");
const ksrScoreEl = document.getElementById("ksrScore");
const ksrTimeEl = document.getElementById("ksrTime");

// ================================
// RANDOM SQUARE
// ================================
function ksrRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// GENERATE BOMBS
// ================================
function generateKSRBombs(count) {
  const bombs = [];

  while (bombs.length < count) {
    const sq = ksrRandomSquare();

    if (
      (ksrKnight && sq.x === ksrKnight.x && sq.y === ksrKnight.y) ||
      (ksrTarget && sq.x === ksrTarget.x && sq.y === ksrTarget.y)
    ) continue;

    if (bombs.some(b => b.x === sq.x && b.y === sq.y)) continue;

    bombs.push(sq);
  }
  return bombs;
}

// ================================
// SPAWN TARGET
// ================================
function spawnKSRTarget() {
  do {
    ksrTarget = ksrRandomSquare();
  } while (
    ksrKnight &&
    ksrTarget.x === ksrKnight.x &&
    ksrTarget.y === ksrKnight.y
  );
}

// ================================
// START GAME
// ================================
window.startKSR = function (mode = "medium") {
  ksrMode = mode;

  document.getElementById("ksrMenu").classList.add("hidden");
  document.getElementById("ksrGame").classList.remove("hidden");

  ksrScore = 0;
  ksrRunning = true;

  ksrTime =
    mode === "easy" ? 40 :
    mode === "medium" ? 30 : 20;

  ksrKnight = ksrRandomSquare();
  spawnKSRTarget();

  const bombCount =
    mode === "easy" ? 3 :
    mode === "medium" ? 5 : 7;

  ksrBombs = generateKSRBombs(bombCount);

  ksrScoreEl.textContent = ksrScore;
  ksrTimeEl.textContent = ksrTime;

  drawKSRBoard();
  startKSRTimer();
};

// ================================
// EXIT GAME
// ================================
window.exitKSR = function () {
  stopKSRTimer();
  ksrRunning = false;

  document.getElementById("ksrGame").classList.add("hidden");
  document.getElementById("ksrMenu").classList.remove("hidden");
};

// ================================
// TIMER
// ================================
function startKSRTimer() {
  stopKSRTimer();

  ksrTimer = setInterval(() => {
    if (!ksrRunning) return;

    ksrTime--;
    ksrTimeEl.textContent = ksrTime;

    if (ksrTime <= 0) {
      stopKSRTimer();
      showKSRGameOver();
    }
  }, 1000);
}

function stopKSRTimer() {
  if (ksrTimer) {
    clearInterval(ksrTimer);
    ksrTimer = null;
  }
}

// ================================
// HANDLE CLICK
// ================================
function handleKSRClick(x, y) {
  if (!ksrRunning) return;

  const dx = Math.abs(x - ksrKnight.x);
  const dy = Math.abs(y - ksrKnight.y);

  // üê¥ Knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // ‚úÖ Move knight
  ksrKnight = { x, y };
  playKVMMoveSound?.();

  // üí• BOMB HIT (CHECK IMMEDIATELY)
  if (ksrBombs.some(b => b.x === x && b.y === y)) {
    showKSRGameOver(true);
    return;
  }

  // ‚≠ê STAR COLLECT
  if (x === ksrTarget.x && y === ksrTarget.y) {
    ksrScore++;
    ksrScoreEl.textContent = ksrScore;
    playKEMNextSound?.();
    spawnKSRTarget();
  }

  // üí£ NOW regenerate bombs AFTER survival
  const bombCount =
    ksrMode === "easy" ? 9 :
    ksrMode === "medium" ? 12 : 15;

  ksrBombs = generateKSRBombs(bombCount);

  drawKSRBoard();
}


// ================================
// DRAW BOARD
// ================================
function drawKSRBoard() {
  ksrBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";
      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "ksr-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);

     sq.classList.add((x + y) % 2 === 1 ? "light" : "dark");

      sq.onclick = () => handleKSRClick(x, y);

      // üí£ BOMBS
      for (const b of ksrBombs) {
        if (b.x === x && b.y === y) {
          sq.textContent = "üí£";
          sq.style.fontSize = "30px";
        }
      }

      // ‚≠ê TARGET
      if (ksrTarget && ksrTarget.x === x && ksrTarget.y === y) {
        sq.textContent = "‚≠ê";
        sq.style.fontSize = "30px";
      }

      // üê¥ KNIGHT (TOP PRIORITY)
      if (ksrKnight && ksrKnight.x === x && ksrKnight.y === y) {
        sq.textContent = "üê¥";
        sq.style.fontSize = "36px";
        sq.style.transform = "scale(1.15)";
      }

      ksrBoard.appendChild(sq);
    }
  }
}

// ================================
// GAME OVER
// ================================
function showKSRGameOver(hitBomb = false) {
  ksrRunning = false;
  stopKSRTimer();
  playKVMGameOverSound?.();
    // üèÜ SAVE BEST SCORE (Knight Speed Run)
  saveMiniGameScore("knightspeed", ksrScore);


  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = hitBomb ? "üí• BOOM!" : "‚è± Time's Up!";
  body.innerHTML = `
    <p style="font-size:16px; line-height:1.6;">
      ${hitBomb ? "You hit a bomb üí£" : "Speed Run Complete"}<br><br>
      ‚≠ê <b>Stars:</b> ${ksrScore}<br>
      üéÆ <b>Mode:</b> ${ksrMode.toUpperCase()}
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKSR();
  };
}


// =================================
// üî• KNIGHT LAVA FLOOR (ISOLATED)
// =================================

// -------- CONFIG --------
const KLF_SIZE = 10;          // change to 10 for 10x10
const KLF_LAVA_PER_TURN = 3;

// -------- STATE --------
let klfKnight = { x: 0, y: 0 };
let klfLava = [];
let klfTurns = 0;
let klfAlive = false;



// -------- ELEMENTS --------
const klfBoard = document.getElementById("klfBoard");
const klfMenu = document.getElementById("klfMenu");
const klfGame = document.getElementById("klfGame");
const klfTurnsEl = document.getElementById("klfTurns");
const klfLavaEl = document.getElementById("klfLavaCount");

// -------- KNIGHT MOVES --------
const KLF_KNIGHT_MOVES = [
  [1, 2], [2, 1], [-1, 2], [-2, 1],
  [1, -2], [2, -1], [-1, -2], [-2, -1]
];

// =========================================
// üî• Knight Lava Floor ‚Äì Game Over Sound
// =========================================
function playKLFGameOverSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.6; // üîä not too loud
    audio.play();
  } catch (e) {
    console.warn("üîá complete.mp3 could not play", e);
  }
}

// =========================================
// üî• Knight Lava Floor ‚Äì Knight Move Sound
// =========================================
function playKLFMoveSound() {
  try {
    const audio = new Audio("./sounds/alert.mp3");
    audio.volume = 0.3; // üîä soft, non-annoying
    audio.play();
  } catch (e) {
    console.warn("üîá alert.mp3 could not play", e);
  }
}

// =========================================
// üî• Knight Lava Floor ‚Äì Game Start Sound
// =========================================
function playKLFStartSound() {
  try {
    const audio = new Audio("./sounds/puzzle-rush-start.mp3");
    audio.volume = 0.6; // üîä pleasant, not loud
    audio.play();
  } catch (e) {
    console.warn("üîá puzzle-rush-start.mp3 could not play", e);
  }
}




// =================================
// START GAME
// =================================
window.startKLF = function () {

  // üîä start game sound
  playKLFStartSound();

  klfMenu.classList.add("hidden");
  klfGame.classList.remove("hidden");

  klfTurns = 0;
  klfLava = [];
  klfAlive = true;

  klfKnight = {
    x: Math.floor(KLF_SIZE / 2),
    y: Math.floor(KLF_SIZE / 2)
  };

  updateKLFUI();
  drawKLFBoard();
};

// =================================
// EXIT GAME
// =================================
window.exitKLF = function () {
  klfGame.classList.add("hidden");
  klfMenu.classList.remove("hidden");
  klfAlive = false;
};

// =================================
// DRAW BOARD
// =================================
function drawKLFBoard() {
  klfBoard.innerHTML = "";
  klfBoard.style.gridTemplateColumns = `repeat(${KLF_SIZE}, 1fr)`;

  for (let y = KLF_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < KLF_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "klf-square";

      const light = (x + y) % 2 === 0;
      sq.classList.add(light ? "klf-light" : "klf-dark");

      if (isKlfLava(x, y)) {
        sq.classList.add("klf-lava");
        sq.textContent = "üî•";
      }

      if (klfKnight.x === x && klfKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("klf-knight");
      }

      sq.onclick = () => handleKLFMove(x, y);
      klfBoard.appendChild(sq);
    }
  }
}

// =================================
// HANDLE MOVE
// =================================
function handleKLFMove(x, y) {
  if (!klfAlive) return;

  const dx = Math.abs(x - klfKnight.x);
  const dy = Math.abs(y - klfKnight.y);
  const legal = (dx === 1 && dy === 2) || (dx === 2 && dy === 1);

  if (!legal) return;

  // üîä knight move sound
  playKLFMoveSound();


  klfKnight = { x, y };
  klfTurns++;

  spreadKlfLava();

  if (isKlfLava(x, y)) {
    endKLFGame();
    return;
  }

  updateKLFUI();
  drawKLFBoard();
}

// =================================
// LAVA LOGIC
// =================================
function spreadKlfLava() {
  let added = 0;

  while (added < KLF_LAVA_PER_TURN) {
    const x = Math.floor(Math.random() * KLF_SIZE);
    const y = Math.floor(Math.random() * KLF_SIZE);

    if (
      !isKlfLava(x, y) &&
      !(x === klfKnight.x && y === klfKnight.y)
    ) {
      klfLava.push({ x, y });
      added++;
    }
  }
}

function isKlfLava(x, y) {
  return klfLava.some(l => l.x === x && l.y === y);
}

// =================================
// GAME OVER
// =================================
function endKLFGame() {
  klfAlive = false;
  drawKLFBoard();

  // üèÜ SAVE BEST SCORE (Knight Lava Floor)
  saveMiniGameScore("knightlava", klfTurns);

  // üîä game over sound
  playKLFGameOverSound();

  setTimeout(() => {
    showKLFResult();
  }, 300);
}


// =================================
// UI UPDATE
// =================================
function updateKLFUI() {
  klfTurnsEl.textContent = klfTurns;
  klfLavaEl.textContent = klfLava.length;
}



// ===============================
// üî• KLF RESULT MODAL FUNCTIONS
// ===============================

window.showKLFResult = function () {
  document.getElementById("klfResultTitle").textContent = "üî• Game Over";
  document.getElementById("klfResultText").textContent =
    `Turns survived: ${klfTurns}`;

  document.getElementById("klfResultOverlay")
    .classList.remove("hidden");
};

window.closeKLFResult = function () {
  document.getElementById("klfResultOverlay")
    .classList.add("hidden");

  exitKLF(); // safely exit game
};


function closeKLFResult() {
  document.getElementById("klfResultOverlay")
    .classList.add("hidden");

  exitKLF(); // return to menu safely
}



// ================================
// KNIGHT FOG QUEST (ISOLATED)
// ================================

let kfqKnight;
let kfqItems = [];
let kfqMoves = 0;
let kfqFound = 0;
let kfqActive = false;
let kfqTimer = null;
let kfqTimeLeft = 0;
let kfqTimedMode = false;


const kfqBoard = document.getElementById("kfqBoard");
const kfqMovesEl = document.getElementById("kfqMoves");
const kfqFoundEl = document.getElementById("kfqFound");
const kfqTaskEl = document.getElementById("kfqTask");

const KfqSize = 10;
const KfqTargets = 8;

window.startKFQTimed = function (seconds) {
  kfqTimedMode = true;
  kfqTimeLeft = seconds;

  document.getElementById("kfqMenu").classList.add("hidden");
  document.getElementById("kfqGame").classList.remove("hidden");

  kfqKnight = randKFQ();
  kfqMoves = 0;
  kfqFound = 0;
  kfqActive = true;
  kfqFoundEl.textContent = `0 / ${KfqTargets}`;


  spawnKFQItems();
  nextKFQTask();
  drawKFQBoard();

  document.getElementById("kfqTime").textContent = kfqTimeLeft;

  startKFQTimer();
};

function startKFQTimer() {
  clearInterval(kfqTimer);

  kfqTimer = setInterval(() => {
    if (!kfqActive) {
      clearInterval(kfqTimer);
      return;
    }

    kfqTimeLeft--;
    document.getElementById("kfqTime").textContent = kfqTimeLeft;

    if (kfqTimeLeft <= 0) {
      clearInterval(kfqTimer);
      showKFQGameOver("‚è± Time‚Äôs up! You ran out of time.");
    }
  }, 1000);
}


// ================================
// START / EXIT
// ================================
window.startKFQ = function () {

  document.getElementById("kfqMenu").classList.add("hidden");
  document.getElementById("kfqGame").classList.remove("hidden");

  kfqKnight = randKFQ();
  kfqMoves = 0;
  kfqFound = 0;
  kfqFoundEl.textContent = `0 / ${KfqTargets}`;

  kfqActive = true;

  spawnKFQItems();
  nextKFQTask();
  drawKFQBoard();
}

window.exitKFQ = function () {
  clearInterval(kfqTimer);

  document.getElementById("kfqGame").classList.add("hidden");
  document.getElementById("kfqMenu").classList.remove("hidden");

  kfqActive = false;
};



function playKFQNextSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("üîá next.mp3 could not play", e);
  }
}

function playKFQCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.7;
    audio.play();
  } catch (e) {
    console.warn("üîá complete.mp3 could not play", e);
  }
}

function playKNDCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.7;
    audio.play();
  } catch (e) {
    console.warn("üîá complete.mp3 could not play");
  }
}




// ================================
// RANDOM
// ================================
function randKFQ() {
  return {
    x: Math.floor(Math.random() * KfqSize),
    y: Math.floor(Math.random() * KfqSize)
  };
}

// ================================
// SPAWN ITEMS
// ================================
function spawnKFQItems() {
  kfqItems = [];

  const emojis = ["üçé", "‚≠ê", "üí£", "üß±"];

  while (kfqItems.length < 25) {
    const sq = randKFQ();

    if (
      sq.x === kfqKnight.x &&
      sq.y === kfqKnight.y
    ) continue;

    if (kfqItems.some(i => i.x === sq.x && i.y === sq.y)) continue;

    kfqItems.push({
      ...sq,
      emoji: emojis[Math.floor(Math.random() * emojis.length)]
    });
  }
}

// ================================
// TASK SYSTEM
// ================================
function nextKFQTask() {
  kfqTaskEl.textContent = "Find the üçé Apple";
}

// ================================
// CLICK HANDLER
// ================================
function handleKFQClick(x, y) {
  if (!kfqActive) return;

  const dx = Math.abs(x - kfqKnight.x);
  const dy = Math.abs(y - kfqKnight.y);

  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  const block = kfqItems.find(
    i => i.x === x && i.y === y && i.emoji === "üß±"
  );
  if (block) return;

  kfqKnight = { x, y };
  kfqMoves++;
  kfqMovesEl.textContent = kfqMoves;

  const hit = kfqItems.find(i => i.x === x && i.y === y);

  if (hit) {
    if (hit && hit.emoji === "üçé") {
  playKFQNextSound(); // üîä apple collect sound

  kfqFound++;
  kfqFoundEl.textContent = `${kfqFound} / ${KfqTargets}`;


  kfqItems = kfqItems.filter(i => i !== hit);
  nextKFQTask();

  // üéâ WIN CONDITION (TIMED MODE SAFE)
  if (kfqFound >= KfqTargets) {
    clearInterval(kfqTimer);
    showKFQGameOver("üéâ All apples found in time!");
    return;
  }
}


    if (hit && hit.emoji === "üí£") {
  showKFQGameOver("üí£ You stepped on a bomb!");
  return;
}

  }

  drawKFQBoard();
}

// ================================
// DRAW BOARD (FOG)
// ================================
function drawKFQBoard() {
  kfqBoard.innerHTML = "";

  for (let y = KfqSize - 1; y >= 0; y--) {
    for (let x = 0; x < KfqSize; x++) {
      const sq = document.createElement("div");
      sq.className = "kfq-square";
      sq.onclick = () => handleKFQClick(x, y);

      // chess colors
      sq.classList.add(
        (x + y) % 2 === 0 ? "kfq-light" : "kfq-dark"
      );

      const dx = Math.abs(x - kfqKnight.x);
      const dy = Math.abs(y - kfqKnight.y);

      const visible =
        (dx === 0 && dy === 0) ||
        (dx === 2 && dy === 1) ||
        (dx === 1 && dy === 2);

      if (!visible) {
        sq.classList.add("kfq-fog");
      } else {
        const item = kfqItems.find(i => i.x === x && i.y === y);
        if (item) sq.textContent = item.emoji;
      }

      if (kfqKnight.x === x && kfqKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("kfq-knight");
      }

      kfqBoard.appendChild(sq);
    }
  }
}


function showKFQGameOver(reason) {
  kfqActive = false;
  // üèÜ SAVE BEST SCORE (Knight Fog Quest)
  saveMiniGameScore("knightfog", kfqFound);
  playKFQCompleteSound(); // üîä GAME OVER SOUND

  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = "üí• Game Over!";
  body.innerHTML = `
    <p style="font-size:16px;">
      ${reason}<br><br>
      üçé Apples found: <b>${kfqFound}</b><br>
      ‚≠ê Moves used: <b>${kfqMoves}</b>
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKFQ();
    
  };
}



// ================================
// üëë KING DEFENSE (FULLY ISOLATED)
// ================================

let kndKnight, kndKing;
let kndMonsters = [];
let kndMode = "easy";
const KND_SIZE = 10;


const kndBoard = document.getElementById("kndBoard");
const kndLeftEl = document.getElementById("kndLeft");

// ================================
// START GAME
// ================================
window.startKND = function (mode) {
  kndMode = mode;
  playKNDStartSound(); // üîä GAME START SOUND

  document.getElementById("kndMenu").classList.add("hidden");
  document.getElementById("kndGame").classList.remove("hidden");

  kndKing   = { x: 4, y: 0 };
  kndKnight = { x: 5, y: 4 };

 const count =
  mode === "easy"   ? 3:
  mode === "medium" ? 4:
                      5;//hard


  kndMonsters = [];

  // üëπ SPAWN LOGIC (PASTE HERE)
  const usedX = new Set();
  while (kndMonsters.length < count) {
    const x = Math.floor(Math.random() * KND_SIZE);
    if (usedX.has(x)) continue;
    usedX.add(x);
    kndMonsters.push({ x, y: KND_SIZE - 1 });
  }

  kndLeftEl.textContent = kndMonsters.length;
  drawKNDBoard();
};

// ================================
// üîä KND ‚Äì Knight Move Sound
// ================================
function playKNDKnightMoveSound() {
  try {
    const audio = new Audio("./sounds/alert.mp3");
    audio.volume = 0.1;
    audio.play();
  } catch (e) {
    console.warn("üîá alert.mp3 could not play", e);
  }
}

function playKNDStartSound() {
  try {
    const audio = new Audio("./sounds/puzzle-rush-start.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("üîá puzzle-rush-start.mp3 could not play");
  }
}




// ================================
// EXIT
// ================================
window.exitKND = function () {
  document.getElementById("kndGame").classList.add("hidden");
  document.getElementById("kndMenu").classList.remove("hidden");
};

// ================================
// MONSTER MOVEMENT (SAFE & CLEAN)
// ================================
function moveKNDMonstersTowardKing() {
  const occupied = new Set(
    kndMonsters.map(m => `${m.x},${m.y}`)
  );

  for (const m of kndMonsters) {
    occupied.delete(`${m.x},${m.y}`);

    let best = null;
    let bestScore = Infinity;

    // üß† KING-LIKE MOVEMENT (8 DIRECTIONS)
    const directions = [
      [-1,-1],[0,-1],[1,-1],
      [-1, 0],       [1, 0],
      [-1, 1],[0, 1],[1, 1],
    ];

    for (const [dx, dy] of directions) {
      const nx = m.x + dx;
      const ny = m.y + dy;

      if (
        nx < 0 || nx >= KND_SIZE ||
        ny < 0 || ny >= KND_SIZE
      ) continue;

      // üö´ cannot land on knight
      if (nx === kndKnight.x && ny === kndKnight.y) continue;

      // üö´ cannot stack monsters
      if (occupied.has(`${nx},${ny}`)) continue;

      // üéØ distance to king
      const distToKing =
        Math.abs(nx - kndKing.x) +
        Math.abs(ny - kndKing.y);

      // üß± density penalty (prevents stacking lines)
      let densityPenalty = 0;
      for (const o of occupied) {
        const [ox, oy] = o.split(",").map(Number);
        const d = Math.abs(nx - ox) + Math.abs(ny - oy);
        if (d === 1) densityPenalty += 8;
        if (d === 2) densityPenalty += 4;
      }

      // üß† FINAL SCORE
      const score = distToKing * 20 + densityPenalty;

      if (score < bestScore) {
        bestScore = score;
        best = { x: nx, y: ny };
      }
    }

    // üöë ABSOLUTE FAILSAFE (NEVER FREEZE)
    if (!best) {
      for (const [dx, dy] of directions) {
        const nx = m.x + dx;
        const ny = m.y + dy;
        if (
          nx >= 0 && nx < KND_SIZE &&
          ny >= 0 && ny < KND_SIZE &&
          !(nx === kndKnight.x && ny === kndKnight.y) &&
          !occupied.has(`${nx},${ny}`)
        ) {
          best = { x: nx, y: ny };
          break;
        }
      }
    }

    if (best) {
      m.x = best.x;
      m.y = best.y;
    }

    occupied.add(`${m.x},${m.y}`);

    // üëë KING KILLED (ANY DIRECTION)
    if (m.x === kndKing.x && m.y === kndKing.y) {
      showKNDModal("Defeat!", "üëë The King was slain!");
      return;
    }
  }
}









// ================================
// CLICK HANDLER
// ================================
function handleKNDClick(x, y) {
  const dx = Math.abs(x - kndKnight.x);
  const dy = Math.abs(y - kndKnight.y);

  // knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // move knight
  kndKnight = { x, y };

  // üîä play move sound
playKNDKnightMoveSound();

  // üó°Ô∏è kill monster
  const hitIndex = kndMonsters.findIndex(
    m => m.x === x && m.y === y
  );
  if (hitIndex !== -1) {
    kndMonsters.splice(hitIndex, 1);
    kndLeftEl.textContent = kndMonsters.length;

    if (kndMonsters.length === 0) {
      // üèÜ SAVE BEST SCORE (King Defense)
  saveMiniGameScore("knightdefense", kndTotalMonsters);
  showKNDModal("Victory!", "üéâ All monsters defeated!");
  return;
}

  }

  // monsters move AFTER knight
  moveKNDMonstersTowardKing();
  drawKNDBoard();
}

// ================================
// DRAW BOARD (RANK SAFE)
// ================================
function drawKNDBoard() {
  kndBoard.innerHTML = "";

  for (let y = KND_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < KND_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "knd-square";
      sq.classList.add((x + y) % 2 === 0 ? "light" : "dark");
      sq.onclick = () => handleKNDClick(x, y);

      if (kndKing.x === x && kndKing.y === y) {
        sq.textContent = "üëë";
        sq.classList.add("king");
      }
      else if (kndKnight.x === x && kndKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("knight");
      }
      else {
        const m = kndMonsters.find(mm => mm.x === x && mm.y === y);
        if (m) {
          sq.textContent = "üëπ";
          sq.classList.add("monster");
        }
      }

      kndBoard.appendChild(sq);
    }
  }
}



// ================================
// GAME OVER
// ================================
function showKNDGameOver(msg) {
  showKNDModal("Game Over", msg);
  

}




function showKNDModal(title, message) {
  playKNDCompleteSound(); // üîä GAME END SOUND

  const modal = document.getElementById("floatingModal");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  titleEl.textContent = title;
  bodyEl.textContent = message;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKND();
  };
}



// ================================
// üéµ GLOBAL BACKGROUND MUSIC
// ================================

const GAME_MUSIC_TRACKS = [
  "./sounds/sound_track_1.mp3",
  "./sounds/sound_track_2.mp3",
  "./sounds/sound_track_3.mp3",
  "./sounds/sound_track_4.mp3",
  "./sounds/sound_track_5.mp3",
  "./sounds/sound_track_6.mp3",
  "./sounds/sound_track_7.mp3",
  "./sounds/sound_track_8.mp3",
  "./sounds/sound_track_9.mp3",
  "./sounds/sound_track_10.mp3",
];

let gameMusic = null;
let musicMuted = false;
let musicStarted = false;

// ‚ñ∂Ô∏è PLAY SPECIFIC MUSIC (SINGLE SOURCE OF TRUTH)
function playMusic(src) {
  stopGameMusic();

  gameMusic = new Audio(src);
  gameMusic.loop = true;
  gameMusic.volume = 0.02;

  gameMusic.play()
    .then(() => {
      musicStarted = true;
    })
    .catch(() => {
      // autoplay blocked ‚Äì will retry on interaction
    });
}

// ‚ñ∂Ô∏è START RANDOM MUSIC
function startGameMusic() {
  if (musicMuted || musicStarted) return;

  const src =
    GAME_MUSIC_TRACKS[Math.floor(Math.random() * GAME_MUSIC_TRACKS.length)];

  playMusic(src);
}

// ‚èπ STOP MUSIC
function stopGameMusic() {
  if (!gameMusic) return;
  gameMusic.pause();
  gameMusic.currentTime = 0;
  gameMusic = null;
  musicStarted = false;
}

// ================================
// üîá MUTE BUTTON
// ================================

const musicMuteBtn = document.getElementById("musicMuteBtn");

musicMuteBtn.addEventListener("click", () => {
  musicMuted = !musicMuted;

  if (musicMuted) {
    stopGameMusic();
    musicMuteBtn.textContent = "üîá";
  } else {
    musicMuteBtn.textContent = "üîä";
    startGameMusic();
  }
});

// ================================
// üîë FIRST USER INTERACTION UNLOCK
// ================================

["click", "keydown", "touchstart"].forEach(evt => {
  document.addEventListener(evt, startGameMusic, { once: true });
});

// ================================
// üéº MUSIC MENU (HOVER SELECT)
// ================================

const musicControl = document.getElementById("musicControl");
const musicMenu = document.getElementById("musicMenu");

// hover show / hide
musicControl.addEventListener("mouseenter", () => {
  musicMenu.classList.remove("hidden");
});

musicControl.addEventListener("mouseleave", () => {
  musicMenu.classList.add("hidden");
});

// click to select track
musicMenu.querySelectorAll("div").forEach(item => {
  item.addEventListener("click", () => {
    const src = item.dataset.src;
    if (!src) return;

    musicMuted = false;
    musicMuteBtn.textContent = "üîä";

    playMusic(src);
    musicMenu.classList.add("hidden");
  });
});



/* ================================
   üëë KING MATH JOURNEY (FINAL FIX)
================================ */

/* ================================
   üëë KING MATH JOURNEY ‚Äî FINAL
================================ */

const KM_SIZE = 10;

/* -------- GAME STATE -------- */
let kmLevel = "easy";
let kmKing = { x: 0, y: 0 };
let kmUsedQuestions = new Set();
let kmCorrectAnswer = 0;

let kmSteps = 0;
let kmTargetSteps = 0;
let kmDirection = 1; // 1 = up, -1 = down
/* -------- TIMER -------- */
let kmTimeLeft = 0;
let kmTimerInterval = null;

const kmTimeEl = document.getElementById("kmTime");


/* -------- ELEMENTS -------- */ 
const kmBoard = document.getElementById("kmBoard");
const kmQuestionEl = document.getElementById("kmQuestion");
const kmStepEl = document.getElementById("kmStep");

/* ================================
   START / EXIT
================================ */

window.startKM = function (level) {
  kmLevel = level;

  // üîÅ FULL RESET (VERY IMPORTANT)
  kmUsedQuestions.clear();
  kmDirection = 1;

  kmSteps = 0;
  kmTargetSteps = getTargetSteps();
  kmStepEl.textContent = `${kmSteps} / ${kmTargetSteps}`;

  // üëë start from ANY column, LAST RANK
  kmKing = {
    x: rand(0, KM_SIZE - 1),
    y: 0
  };

  document.getElementById("kmMenu").classList.add("hidden");
  document.getElementById("kmGame").classList.remove("hidden");

  nextMath();
  drawKMBoard();
  startKMTimer(); // ‚úÖ HERE
};

window.exitKM = function () {
  stopKMTimer();

  // üèÜ SAVE BEST SCORE (King Math Journey)
  saveMiniGameScore("kingmath", kmSteps);

  document.getElementById("kmGame").classList.add("hidden");
  document.getElementById("kmMenu").classList.remove("hidden");
};

/* ================================
   TARGET STEPS
================================ */

function getTargetSteps() {
  if (kmLevel === "easy") return 25;
  if (kmLevel === "medium") return 35;
  return 40; // hard
}

function playKMNextSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("‚ö†Ô∏è next.mp3 could not play");
  }
}


/* ================================
   MATH GENERATION
================================ */

function generateUniqueMath() {
  let q, a, key;

  do {
    let n1, n2, op;

    if (kmLevel === "easy") {
      n1 = rand(1, 10);
      n2 = rand(1, 10);
      op = Math.random() < 0.5 ? "+" : "-";
    } else if (kmLevel === "medium") {
      n1 = rand(1, 15);
      n2 = rand(1, 10);
      op = ["+", "-", "√ó"][rand(0, 2)];
    } else {
      n2 = rand(1, 10);
      a = rand(1, 10);
      n1 = a * n2;
      op = "√∑";
    }

    a = evalMath(n1, n2, op);
    q = `${n1} ${op} ${n2}`;
    key = q + "=" + a;

  } while (kmUsedQuestions.has(key));

  kmUsedQuestions.add(key);
  return { q, a };
}

function evalMath(a, b, op) {
  if (op === "+") return a + b;
  if (op === "-") return a - b;
  if (op === "√ó") return a * b;
  if (op === "√∑") return a / b;
}

function nextMath() {
  const m = generateUniqueMath();
  kmQuestionEl.textContent = m.q;
  kmCorrectAnswer = m.a;
}

/* ================================
   ANSWER CLICK
================================ */

function chooseAnswer(val, x, y) {
  if (val !== kmCorrectAnswer) {
    showKNDModal("‚ùå Wrong Answer", "Game Over!");
    exitKM(); // exitKM already stops timer
    return;
  }

  // üîä isolated correct answer sound
  playKMNextSound();

  // üëë move king
  kmKing.x = x;
  kmKing.y = y;

  // üîÑ flip direction at edges
  if (kmKing.y >= KM_SIZE - 2) kmDirection = -1;
  if (kmKing.y <= 1) kmDirection = 1;

  kmSteps++;
  kmStepEl.textContent = `${kmSteps} / ${kmTargetSteps}`;

  if (kmSteps >= kmTargetSteps) {
    showKNDModal("üéâ Victory!", "Chess Math Journey Completed!");
    exitKM(); // stops timer
    return;
  }

  nextMath();
  drawKMBoard();
}






/* ================================
   BOARD DRAW (BUG-FREE)
================================ */

function drawKMBoard() {
  kmBoard.innerHTML = "";

  // üß† answer row (SAFE)
  let answerY = kmKing.y + kmDirection;
  if (answerY < 0) answerY = 0;
  if (answerY >= KM_SIZE) answerY = KM_SIZE - 1;

  // üß† ALWAYS 3 valid X positions
  let answerXs = [];

  if (kmKing.x === 0) answerXs = [0, 1, 2];
  else if (kmKing.x === KM_SIZE - 1) answerXs = [KM_SIZE - 3, KM_SIZE - 2, KM_SIZE - 1];
  else answerXs = [kmKing.x - 1, kmKing.x, kmKing.x + 1];

  const answers = shuffle([
    kmCorrectAnswer,
    kmCorrectAnswer + rand(1, 4),
    kmCorrectAnswer - rand(1, 4)
  ]);

  const colors = getRandomAnswerColors();

  for (let y = KM_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < KM_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "square " + ((x + y) % 2 ? "dark" : "light");

      if (x === kmKing.x && y === kmKing.y) {
        sq.textContent = "üëë";
        sq.classList.add("king");
      }

      else if (y === answerY && answerXs.includes(x)) {
        const idx = answerXs.indexOf(x);
        const val = answers[idx];
        const col = colors[idx];

        sq.textContent = val;
        sq.classList.add("answer", col);
        sq.onclick = () => chooseAnswer(val, x, y);
      }

      kmBoard.appendChild(sq);
    }
  }
}

/* ================================
   HELPERS
================================ */

function rand(a, b) {
  return Math.floor(Math.random() * (b - a + 1)) + a;
}

function shuffle(arr) {
  return arr.sort(() => Math.random() - 0.5);
}

function getRandomAnswerColors() {
  return shuffle([
    "answer-green",
    "answer-yellow",
    "answer-blue",
    "answer-purple"
  ]).slice(0, 3);
}


function getLevelTime() {
  if (kmLevel === "easy") return 90;    // 1.5 min
  if (kmLevel === "medium") return 120; // 2 min
  return 150;                           // hard: 2.5 min
}

function startKMTimer() {
  stopKMTimer();

  // ‚è±Ô∏è time per level
  if (kmLevel === "easy") kmTimeLeft = 40;
  else if (kmLevel === "medium") kmTimeLeft = 60;
  else kmTimeLeft = 90;

  const timerEl = document.getElementById("kmTimer");
  const timeEl = document.getElementById("kmTime");

  timerEl.classList.remove("danger");
  timeEl.textContent = kmTimeLeft;

  kmTimerInterval = setInterval(() => {
    kmTimeLeft--;
    timeEl.textContent = kmTimeLeft;

    // üî• ADD THIS HERE (CORRECT PLACE)
    if (kmTimeLeft <= 10) {
      timerEl.classList.add("danger");
    }

    // ‚è∞ time over
    if (kmTimeLeft <= 0) {
      stopKMTimer();
      showKNDModal("‚è∞ Time Up!", "Game Over!");
      exitKM();
    }
  }, 1000);
}

function stopKMTimer() {
  if (kmTimerInterval) {
    clearInterval(kmTimerInterval);
    kmTimerInterval = null;
  }
}


// ================================
// üé® COLOR FLIP CHAOS (ISOLATED)
// ================================

const CFC_SIZE = 8;

// üé® minimum 10 colors (kid friendly)
const CFC_COLORS = [
  "white",
  "#ff6b6b", // red
  "#4dabf7", // blue
  "#51cf66", // green
  "#ffd43b", // yellow
  "#9775fa", // purple
  "#ff922b", // orange
  "#22b8cf", // cyan
  "#f783ac", // pink
  "#94d82d"  // lime
];

// ================================
// STATE
// ================================
let cfcKnight = null;
let cfcWhiteVisited = new Set();
let cfcScore = 0;
let cfcTarget = 10;
let cfcTime = 20;

let cfcTimer = null;
let cfcColorInterval = null;
let cfcColorGrid = [];
let cfcDifficulty = "easy";

// ‚è± FIXED COLOR SPEED (NEVER CHANGES)
const CFC_COLOR_SPEED = 1000;

// ================================
// ELEMENTS
// ================================
const cfcBoard = document.getElementById("cfcBoard");
const cfcScoreEl = document.getElementById("cfcScore");
const cfcTargetEl = document.getElementById("cfcTarget");
const cfcTimeEl = document.getElementById("cfcTime");

// ================================
// START GAME
// ================================
window.startCFC = function (mode = "easy") {
  cfcDifficulty = mode;

  // ‚è± difficulty = TIME ONLY
  if (mode === "easy") {
    cfcTime = 20;
    cfcTarget = 15;
  } else if (mode === "medium") {
    cfcTime = 30;
    cfcTarget = 25;
  } else {
    cfcTime = 40;
    cfcTarget = 35;
  }

  cfcKnight = {
    x: Math.floor(Math.random() * CFC_SIZE),
    y: Math.floor(Math.random() * CFC_SIZE)
  };

  cfcWhiteVisited.clear();
  cfcScore = 0;

  cfcScoreEl.textContent = cfcScore;
  cfcTargetEl.textContent = cfcTarget;
  cfcTimeEl.textContent = cfcTime;

  document.getElementById("cfcMenu").classList.add("hidden");
  document.getElementById("cfcGame").classList.remove("hidden");

  // üé® INIT COLOR GRID (ONCE)
  cfcColorGrid = [];
  for (let y = 0; y < CFC_SIZE; y++) {
    const row = [];
    for (let x = 0; x < CFC_SIZE; x++) {
      row.push(
        CFC_COLORS[Math.floor(Math.random() * CFC_COLORS.length)]
      );
    }
    cfcColorGrid.push(row);
  }

  drawCFCBoard();
  startCFCTimer();
  startColorChaos();
};

// ================================
// COLOR CHAOS (TIME ONLY)
// ================================
function startColorChaos() {
  clearInterval(cfcColorInterval);

  cfcColorInterval = setInterval(() => {
    for (let y = 0; y < CFC_SIZE; y++) {
      for (let x = 0; x < CFC_SIZE; x++) {
        cfcColorGrid[y][x] =
          CFC_COLORS[Math.floor(Math.random() * CFC_COLORS.length)];
      }
    }
    updateCFCBoardColors();
  }, CFC_COLOR_SPEED); // ‚úÖ fixed
}

// ================================
// UPDATE BOARD COLORS (NO REDRAW)
// ================================
function updateCFCBoardColors() {
  const squares = cfcBoard.children;
  let i = 0;

  for (let y = CFC_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < CFC_SIZE; x++) {
      const sq = squares[i++];
      const color = cfcColorGrid[y][x];
      sq.dataset.color = color;
      sq.style.backgroundColor = color;
    }
  }
}

// ================================
// SOUNDS
// ================================
function playCFCWhiteSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch {}
}

function playCFCWrongSound() {
  try {
    const audio = new Audio("./sounds/wrrong.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch {}
}

function playCFCCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch {}
}

// ================================
// EXIT GAME
// ================================
window.exitCFC = function () {
  clearInterval(cfcTimer);
  clearInterval(cfcColorInterval);

  document.getElementById("cfcGame").classList.add("hidden");
  document.getElementById("cfcMenu").classList.remove("hidden");
};

// ================================
// TIMER
// ================================
function startCFCTimer() {
  clearInterval(cfcTimer);

  cfcTimer = setInterval(() => {
    cfcTime--;
    cfcTimeEl.textContent = cfcTime;

    if (cfcTime <= 0) {
      showCFCGameOver(false);
    }
  }, 1000);
}

// ================================
// HANDLE CLICK
// ================================
function handleCFCClick(x, y, el) {
  const dx = Math.abs(x - cfcKnight.x);
  const dy = Math.abs(y - cfcKnight.y);

  // üê¥ Knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  cfcKnight = { x, y };

  if (el.dataset.color === "white") {
    const key = `${x}-${y}`;
    if (!cfcWhiteVisited.has(key)) {
      cfcWhiteVisited.add(key);
      cfcScore++;
      cfcScoreEl.textContent = cfcScore;
      playCFCWhiteSound();
    }
  } else {
    playCFCWrongSound();
  }

  if (cfcScore >= cfcTarget) {
    showCFCGameOver(true);
    return;
  }

  drawCFCBoard();
}

// ================================
// DRAW BOARD (POSITION ONLY)
// ================================
function drawCFCBoard() {
  cfcBoard.innerHTML = "";

  for (let y = CFC_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < CFC_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "cfc-square";

      const color = cfcColorGrid[y][x];
      sq.dataset.color = color;
      sq.style.backgroundColor = color;

      if (cfcKnight.x === x && cfcKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("cfc-knight");
      }

      sq.onclick = () => handleCFCClick(x, y, sq);
      cfcBoard.appendChild(sq);
    }
  }
}

// ================================
// GAME OVER
// ================================
function showCFCGameOver(win) {
  playCFCCompleteSound();
    // üèÜ SAVE BEST SCORE (Color Flip Chaos)
  saveMiniGameScore("colorchaos", cfcScore);


  clearInterval(cfcTimer);
  clearInterval(cfcColorInterval);

  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = win ? "üéâ Chaos Master!" : "‚è± Time Up!";
  body.innerHTML = `
    <p style="font-size:16px;">
      ‚ö™ White Squares Collected: <b>${cfcScore}</b><br>
      üéØ Target: <b>${cfcTarget}</b>
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitCFC();
  };
}


// ================================
// üìç BOARD COORDINATE TRAINING
// ================================

const ctBoardEl = document.getElementById("ctBoard");
const ctMenu = document.getElementById("ctMenu");
const ctGame = document.getElementById("ctGame");

const ctTargetEl = document.getElementById("ctTarget");
const ctScoreEl = document.getElementById("ctScore");
const ctMissEl = document.getElementById("ctMiss");

let ctTarget = "";
let ctScore = 0;
let ctMiss = 0;

// ================================
// üîä COORD TRAINING SOUNDS (ISOLATED)
// ================================

function playCTCorrectSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch (e) {}
}

function playCTWrongSound() {
  try {
    const audio = new Audio("./sounds/wrong.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {}
}


// START
window.startCT = function () {
  ctScore = 0;
  ctMiss = 0;
  ctScoreEl.textContent = "0";
  ctMissEl.textContent = "0";

  ctMenu.classList.add("hidden");
  ctGame.classList.remove("hidden");

  drawCTBoard();
  nextCTTarget();
};

// EXIT
window.exitCT = function () {
  // üèÜ SAVE BEST SCORE (Board Coordinate Training)
  saveMiniGameScore("coordtrain", ctScore);
  ctGame.classList.add("hidden");
  ctMenu.classList.remove("hidden");
};

// DRAW BOARD
function drawCTBoard() {
  ctBoardEl.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");

     const isLight = (x + y) % 2 === 1;

      sq.className = "square " + (isLight ? "light" : "dark");

      const file = String.fromCharCode(97 + x);
      const rank = y + 1;
      const coord = file + rank;

      sq.dataset.coord = coord;

      sq.onclick = () => handleCTClick(coord, sq);

      ctBoardEl.appendChild(sq);
    }
  }
}

// TARGET
function nextCTTarget() {
  const file = String.fromCharCode(97 + Math.floor(Math.random() * 8));
  const rank = Math.floor(Math.random() * 8) + 1;
  ctTarget = file + rank;

  ctTargetEl.textContent = ctTarget;

  // üî• flash effect
  ctTargetEl.style.opacity = "0";
  setTimeout(() => (ctTargetEl.style.opacity = "1"), 100);
}

// CLICK
function handleCTClick(coord, sq) {
  if (coord === ctTarget) {

    playCTCorrectSound(); // üîä correct
    ctScore++;
    ctScoreEl.textContent = ctScore;

    sq.style.boxShadow = "inset 0 0 0 4px #51cf66";

    setTimeout(() => {
      sq.style.boxShadow = "";
      nextCTTarget();
    }, 300);
  } else {

     playCTWrongSound(); // üîä wrong
    ctMiss++;
    ctMissEl.textContent = ctMiss;

    sq.style.boxShadow = "inset 0 0 0 4px #ff6b6b";
    setTimeout(() => (sq.style.boxShadow = ""), 300);
  }
}

// ================================
// üëÅ TOGGLE FILES & RANKS (ISOLATED)
// ================================

let ctCoordsVisible = true;

window.toggleCTCoords = function () {
  ctCoordsVisible = !ctCoordsVisible;

  const ranks = document.querySelector("#coordtrain-section .cfc-ranks");
  const files = document.querySelector("#coordtrain-section .cfc-files");
  const btn = document.getElementById("ctToggleCoords");

  if (ctCoordsVisible) {
    ranks.style.visibility = "visible";
    files.style.visibility = "visible";
    btn.textContent = "üëÄ Hide Files & Ranks";
  } else {
    ranks.style.visibility = "hidden";
    files.style.visibility = "hidden";
    btn.textContent = "üôà Show Files & Ranks";
  }
};


// ======================================
// üß† BOARD FREEZE ‚Äî AUTO QUESTION ENGINE
// FULLY ISOLATED (FIXED)
// ======================================

// ---------- CONFIG ----------
const BF_FLASH_TIME = 2000; // ms

const BF_PIECES = [
  { type: "pawn",   color: "white", img: "./assets/pieces/wP.png" },
  { type: "rook",   color: "white", img: "./assets/pieces/wR.png" },
  { type: "knight", color: "white", img: "./assets/pieces/wN.png" },
  { type: "bishop", color: "white", img: "./assets/pieces/wB.png" },
  { type: "queen",  color: "white", img: "./assets/pieces/wQ.png" },
  { type: "king",   color: "white", img: "./assets/pieces/wK.png" },

  { type: "pawn",   color: "black", img: "./assets/pieces/bP.png" },
  { type: "rook",   color: "black", img: "./assets/pieces/bR.png" },
  { type: "knight", color: "black", img: "./assets/pieces/bN.png" },
  { type: "bishop", color: "black", img: "./assets/pieces/bB.png" },
  { type: "queen",  color: "black", img: "./assets/pieces/bQ.png" },
  { type: "king",   color: "black", img: "./assets/pieces/bK.png" }
];

// ---------- STATE ----------
let bfPieces = [];
let bfCorrectAnswer = 0;
let bfUserAnswer = 0;
let bfScore = 0;

// ---------- DOM (SAFE INIT) ----------
const bfBoard = document.getElementById("bfBoard");
const bfQuestionEl = document.getElementById("bfQuestion");
const bfAnswerEl = document.getElementById("bfAnswer");
const bfScoreEl = document.getElementById("bfScore");
const bfMenu = document.getElementById("bfMenu");
const bfGame = document.getElementById("bfGame");

// ---------- QUESTION BANK ----------
const BF_QUESTIONS = [
  () => countBy(p => p.type === "rook", "How many rooks?"),
  () => countBy(p => p.type === "bishop", "How many bishops?"),
  () => countBy(p => p.type === "queen", "How many queens?"),
  () => countBy(p => p.type === "knight", "How many knights?"),
  () => countBy(p => p.type === "pawn", "How many pawns?"),

  () => countBy(p => p.color === "white", "How many white pieces?"),
  () => countBy(p => p.color === "black", "How many black pieces?"),

  () => countBy(p => p.type === "pawn" && p.color === "white", "How many white pawns?"),
  () => countBy(p => p.type === "pawn" && p.color === "black", "How many black pawns?"),

  () => countBy(p => p.type === "rook" && p.color === "white", "How many white rooks?"),
  () => countBy(p => p.type === "rook" && p.color === "black", "How many black rooks?"),

  () => countBy(p => p.type === "bishop" && p.color === "white", "How many white bishops?"),
  () => countBy(p => p.type === "bishop" && p.color === "black", "How many black bishops?"),

  () => countBy(p => p.type === "queen" && p.color === "white", "How many white queens?"),
  () => countBy(p => p.type === "queen" && p.color === "black", "How many black queens?"),

  () => countBy(p => p.type === "king", "How many kings?"),
  () => countBy(p => p.type === "king" && p.color === "white", "How many white kings?"),
  () => countBy(p => p.type === "king" && p.color === "black", "How many black kings?"),

  () => countBy(p => isDarkSquare(p.x, p.y), "How many pieces on dark squares?"),
  () => countBy(p => !isDarkSquare(p.x, p.y), "How many pieces on light squares?"),

  () => countBy(p => p.type === "pawn" || p.type === "rook", "How many pawns + rooks?"),
  () => countBy(p => p.type === "bishop" || p.type === "knight", "How many bishops + knights?"),

  () => countBy(() => true, "How many total pieces?")
];

// ---------- HELPERS ----------
function isDarkSquare(x, y) {
  return (x + y) % 2 === 1;
}

function countBy(filterFn, questionText) {
  bfCorrectAnswer = bfPieces.filter(filterFn).length;
  bfQuestionEl.textContent = questionText;
}

// ---------- GAME FLOW ----------
window.startBF = function () {
  if (!bfBoard) return;

  bfMenu.classList.add("hidden");
  bfGame.classList.remove("hidden");

  bfScore = 0;
  bfScoreEl.textContent = "0";

  nextBFRound();
};

window.exitBF = function () {
  // üèÜ SAVE BEST SCORE (Board Freeze)
  saveMiniGameScore("boardfreeze", bfScore);
  bfGame.classList.add("hidden");
  bfMenu.classList.remove("hidden");
  
};

// ---------- ROUND ----------
function nextBFRound() {
  bfBoard.innerHTML = "";
  bfUserAnswer = 0;
  bfAnswerEl.textContent = "0";
  bfPieces = [];

  const pieceCount = 8 + Math.floor(Math.random() * 8);

  while (bfPieces.length < pieceCount) {
    const x = Math.floor(Math.random() * 8);
    const y = Math.floor(Math.random() * 8);
    if (bfPieces.some(p => p.x === x && p.y === y)) continue;

    const piece = BF_PIECES[Math.floor(Math.random() * BF_PIECES.length)];
    bfPieces.push({ ...piece, x, y });
  }

  const q = BF_QUESTIONS[Math.floor(Math.random() * BF_QUESTIONS.length)];
  q();

  drawBF(true);
  setTimeout(() => drawBF(false), BF_FLASH_TIME);
}

// ---------- DRAW ----------
function drawBF(show) {
  bfBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = `square ${(x + y) % 2 === 0 ? "dark" : "light"}`;


      if (show) {
        const p = bfPieces.find(o => o.x === x && o.y === y);
        if (p) {
          const img = document.createElement("img");
          img.src = p.img;
          img.style.width = "80%";
          img.style.pointerEvents = "none";
          sq.appendChild(img);
        }
      }
      bfBoard.appendChild(sq);
    }
  }
}

// ---------- ANSWER CONTROLS ----------
window.bfPlus = function () {
  bfUserAnswer++;
  bfAnswerEl.textContent = bfUserAnswer;
};

window.bfMinus = function () {
  if (bfUserAnswer > 0) bfUserAnswer--;
  bfAnswerEl.textContent = bfUserAnswer;
};

window.bfSubmit = function () {
  if (bfUserAnswer === bfCorrectAnswer) {
    bfScore++;
    bfScoreEl.textContent = bfScore;
    playNextSound?.();
  } else {
    playWrongSound?.();
  }
  setTimeout(nextBFRound, 600);
  
};






/* ============================= */
/* üß≠ KNIGHT GPS ‚Äî FREE ROAM MODE */
/* ============================= */

const kgBoard = document.getElementById("kgBoard");
const kgFuelEl = document.getElementById("kgFuel");
const kgTargetEl = document.getElementById("kgTarget");

let kgKnight = { x: 0, y: 7 };
let kgTarget = { x: 7, y: 0 };
let kgFuel = 6;
let kgLevel = 1;

const knightsMoves = [
  [1,2],[2,1],[-1,2],[-2,1],
  [1,-2],[2,-1],[-1,-2],[-2,-1]
];

/* ============================= */
/* üöÄ GAME FLOW */
/* ============================= */


/* ============================= */
/* üîä KNIGHT GPS SOUNDS (ISOLATED) */
/* ============================= */

function playKGMoveSound() {
  try {
    const audio = new Audio("./sounds/move.mp3");
    audio.volume = 0.7;
    audio.play();
  } catch (e) {}
}

function playKGSuccessSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch (e) {}
}

function playKGCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch (e) {}
}




function startKG() {
  document.getElementById("kgMenu").classList.add("hidden");
  document.getElementById("kgGame").classList.remove("hidden");

  kgLevel = 1;
  nextKGLevel();
}

function exitKG() {
  document.getElementById("kgGame").classList.add("hidden");
  document.getElementById("kgMenu").classList.remove("hidden");
}

window.startKG = startKG;
window.exitKG = exitKG;

/* ============================= */
/* üîÅ LEVEL SYSTEM */
/* ============================= */

function nextKGLevel() {
  kgFuel = 5;                 // ‚úÖ FIXED MOVES
  kgKnight = { x: 0, y: 7 };  // a1

  kgTarget = randomTargetSquare();

  kgFuelEl.textContent = kgFuel;
  kgTargetEl.textContent =
    `${String.fromCharCode(97 + kgTarget.x)}${8 - kgTarget.y}`;

  drawKGBoard();
}

/* ============================= */
/* üé≤ RANDOM TARGET */
/* ============================= */

function randomTargetSquare() {
  let sq;
  do {
    sq = {
      x: Math.floor(Math.random() * 8),
      y: Math.floor(Math.random() * 8)
    };
  } while (
    sq.x === kgKnight.x && sq.y === kgKnight.y
  );
  return sq;
}

/* ============================= */
/* üé® DRAW BOARD */
/* ============================= */

function drawKGBoard() {
  kgBoard.innerHTML = "";

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {

      const sq = document.createElement("div");
      sq.className = "kg-square " + ((x + y) % 2 ? "kg-dark" : "kg-light");

      // üéØ target (FREE of square color)
if (x === kgTarget.x && y === kgTarget.y) {
  sq.style.background = "transparent"; // ‚úÖ KILLS dark square
  sq.classList.add("kg-target");

  const target = document.createElement("span");
  target.textContent = "üéØ";
  sq.appendChild(target);
}



      // ‚ôû knight
      if (x === kgKnight.x && y === kgKnight.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wN.png";
        img.draggable = false;
        sq.appendChild(img);
      }

      sq.onclick = () => handleKGMove(x, y);
      kgBoard.appendChild(sq);
    }
  }
}

/* ============================= */
/* ‚ôû MOVE LOGIC */
/* ============================= */

function handleKGMove(x, y) {
  if (kgFuel <= 0) return;

  const legal = knightsMoves.some(
    ([dx, dy]) => kgKnight.x + dx === x && kgKnight.y + dy === y
  );

  if (!legal) return;
  // üîä play move sound ONLY on valid move
  playKGMoveSound();

  kgKnight = { x, y };
  kgFuel--;
  kgFuelEl.textContent = kgFuel;

  // üéâ SUCCESS
  if (x === kgTarget.x && y === kgTarget.y) {
    kgLevel++;
    playKGSuccessSound();
    setTimeout(nextKGLevel, 400);
    return;
  }

  // ‚ùå FAIL
  if (kgFuel === 0) {
  playKGCompleteSound();     // üîä game over sound
  showKGGameOverModal();     // ü™ü floating modal
  return;
}

  drawKGBoard();
}


/* ============================= */
/* ü™ü KNIGHT GPS ‚Äî GAME OVER MODAL */
/* ============================= */

function showKGGameOverModal() {
  try {
    const modal = document.getElementById("floatingModal");
    const title = document.getElementById("modalTitle");
    const body = document.getElementById("modalBody");
    const okBtn = document.getElementById("modalOkBtn");

    if (!modal || !title || !body || !okBtn) return;

    // üèÜ SAVE BEST SCORE (Knight GPS)
    saveMiniGameScore("knightgps", Math.max(0, kgLevel - 1));

    // content (isolated to Knight GPS)
    title.textContent = "‚õΩ Game Over";
    body.innerHTML = `
      <p style="margin-bottom:10px;">
        You ran out of moves.
      </p>
      <p style="font-size:14px; opacity:0.85;">
        Try to reach the target within <b>5 knight moves</b>.
      </p>
    `;

    // reset old handlers safely
    okBtn.onclick = null;

    // Knight GPS specific action
    okBtn.onclick = () => {
      modal.classList.add("hidden");
      exitKG(); // return to Knight GPS menu only
    };

    // show modal
    modal.classList.remove("hidden");
  } catch (e) {}
}










(() => {
  const btn = document.getElementById("userMenuBtn");
  const dropdown = document.getElementById("userDropdown");

  if (!btn || !dropdown) return;

  // move dropdown to body (escape navbar collapse)
  document.body.appendChild(dropdown);

  let hoverInside = false;

  function openDropdown() {
    const rect = btn.getBoundingClientRect();
    dropdown.style.top = rect.bottom + 8 + "px";
    dropdown.style.right = window.innerWidth - rect.right + "px";
    dropdown.classList.remove("hidden");
  }

  function closeDropdown() {
    if (!hoverInside) {
      dropdown.classList.add("hidden");
    }
  }

  // üñ±Ô∏è OPEN ON HOVER
  btn.addEventListener("mouseenter", () => {
    hoverInside = true;
    openDropdown();
  });

  dropdown.addEventListener("mouseenter", () => {
    hoverInside = true;
  });

  // üñ±Ô∏è CLOSE ONLY WHEN CURSOR LEAVES BOTH
  btn.addEventListener("mouseleave", () => {
    hoverInside = false;
    setTimeout(closeDropdown, 120);
  });

  dropdown.addEventListener("mouseleave", () => {
    hoverInside = false;
    setTimeout(closeDropdown, 120);
  });

  // üì± MOBILE TAP SUPPORT
  btn.addEventListener("click", (e) => {
    e.stopPropagation();
    openDropdown();
  });

  // ‚ùå DO NOT auto-close on document click
})();








window.setPieceTheme = function (theme) {
  currentPieceTheme = theme;
  localStorage.setItem("pieceTheme", theme);

  // ===== EDITOR =====
  if (editorBoard) {
    const fen = editorChess.fen();
    document.getElementById("editorBoard").innerHTML = "";
    editorBoard = null;
    initEditorBoard();
    editorChess.load(fen);
    editorBoard.position(fen);
  }

  // ===== ANALYSIS =====
  if (board) {
    const fen = chess.fen();
    document.getElementById("chessboard").innerHTML = "";
    board = null;
    initChessboard();
    chess.load(fen);
    board.position(fen);
  }

  // ===== QUIZ =====
  if (quizBoard) {
    const fen = quizChess.fen();
    document.getElementById("quizBoard").innerHTML = "";
    quizBoard = null;
    initQuizBoard();
    quizChess.load(fen);
    quizBoard.position(fen);
  }

  // ===== PUZZLE RUSH =====
  if (prBoard) {
    const fen = prChess.fen();
    document.getElementById("puzzleRushBoard").innerHTML = "";
    prBoard = null;
    initPuzzleRushBoard();
    prChess.load(fen);
    prBoard.position(fen);
  }

  // ===== VS COMPUTER =====
  if (vsBoard) {
    const fen = vsChess.fen();
    document.getElementById("computerBoard").innerHTML = "";
    vsBoard = null;
    initVsComputerBoard();
    vsChess.load(fen);
    vsBoard.position(fen);
  }

  // ===== STUDY (OPTIONAL) =====
  if (typeof initStudyBoard === "function" && studyBoard) {
    const fen = studyChess.fen();
    document.getElementById("studyBoard").innerHTML = "";
    studyBoard = null;
    initStudyBoard();
    studyChess.load(fen);
    studyBoard.position(fen);
  }
  // ===== LIVE MATCH (REALTIME SAFE REFRESH) =====
if (mpBoard) {
  const fen = mpChess.fen()
  document.getElementById("mpBoard").innerHTML = ""
  mpBoard = null

  initLiveMatchBoard()
  mpChess.load(fen)
  mpBoard.position(fen, false)
}
  // ===== PUZZLE BATTLE (SAFE REFRESH) =====
  if (battleBoard && battleChess) {
    const fen = battleChess.fen();
    document.getElementById("puzzleBattleBoard").innerHTML = "";
    battleBoard = null;

    initPuzzleBattleBoard();
    battleChess.load(fen);
    battleBoard.position(fen, false);
  }


};



function getPieceThemePath(theme) {
  const lichessThemes = [
    "merida",
    "alpha",
    "cburnett",
    "pirouetti",
    "chessnut",
    "pixel",
    "cardinal",
    "fantasy",
    "spatial"
  ];

  if (lichessThemes.includes(theme)) {
    return `https://lichess1.org/assets/piece/${theme}/{piece}.svg`;
  }

  return `./assets/pieces/${theme}/{piece}.svg`;
}









// üîí PREVENT PAGE SCROLL WHEN DRAGGING CHESS PIECES (ANDROID FIX)
document.addEventListener(
  "touchstart",
  function (e) {
    if (e.target.closest("#chessboard, #puzzleRushBoard, .practice-board, .chessboard")) {
      e.preventDefault();
    }
  },
  { passive: false }
);

document.addEventListener(
  "touchmove",
  function (e) {
    if (e.target.closest("#chessboard, .practice-board, .chessboard")) {
      e.preventDefault();
    }
  },
  { passive: false }
);







// üîí MOBILE ‚Äî BLOCK PINCH ZOOM ON CHESS BOARDS
document.addEventListener(
  'gesturestart',
  function (e) {
    if (e.target.closest('#chessboard, #puzzleRushBoard, .practice-board, .chessboard')) {
      e.preventDefault();
    }
  },
  { passive: false }
);

document.addEventListener(
  'touchmove',
  function (e) {
    if (
      e.scale !== undefined &&
      e.scale !== 1 &&
      e.target.closest('#chessboard, #puzzleRushBoard, .practice-board, .chessboard')
    ) {
      e.preventDefault();
    }
  },
  { passive: false }
);






const DIFFICULTY = 1;
const THEME = "mate_in_1";

document.addEventListener("DOMContentLoaded", () => {

  const pgnFileInput = document.getElementById("pgnFileInput");
  const uploadPgnBtn = document.getElementById("uploadPgnBtn");
  const statusEl = document.getElementById("pgnStatus");

  if (!pgnFileInput || !uploadPgnBtn || !statusEl) {
    console.error("‚ùå PGN uploader elements not found");
    return;
  }

  /* --------------------------------------------------
     1Ô∏è‚É£ Button click ‚Üí open computer file chooser
  -------------------------------------------------- */
  uploadPgnBtn.addEventListener("click", () => {
    pgnFileInput.click();
  });

  /* --------------------------------------------------
     2Ô∏è‚É£ File selected ‚Üí parse & upload
  -------------------------------------------------- */
  pgnFileInput.addEventListener("change", async () => {
    const file = pgnFileInput.files[0];
    if (!file) return;

    statusEl.textContent = "‚è≥ Reading PGN...";
    uploadPgnBtn.disabled = true;

    try {
      const text = await file.text();

      const rows = [];
      const blocks = text.split(/\n(?=\[Event )/i);

      for (const block of blocks) {
        try {
          // Extract FEN
          const fenMatch = block.match(/\[FEN\s+"([^"]+)"\]/i);
          if (!fenMatch) continue;

          const fen = fenMatch[1].trim();
          const side = fen.split(" ")[1]; // w / b

          // Extract first move after 1.
          const moveMatch = block.match(/\b1\.\s*([A-Za-z0-9=+#]+)/);
          if (!moveMatch) continue;

          const solution = moveMatch[1]; // keep # for mate

          rows.push({
            fen,
            solution,
            side_to_move: side,
            difficulty: DIFFICULTY,
            theme: THEME,
            is_active: true
          });

        } catch {
          // skip broken PGN block
        }
      }

      if (rows.length === 0) {
        throw new Error("No valid Mate-in-1 puzzles found");
      }

      statusEl.textContent = `üì¶ Found ${rows.length} puzzles. Uploading...`;

      const { error } = await supabase
        .from("puzzle_rush_mate1")
        .insert(rows);

      if (error) throw error;

      statusEl.textContent = `‚úÖ Successfully uploaded ${rows.length} puzzles`;

      // reset input so same file can be uploaded again if needed
      pgnFileInput.value = "";

    } catch (err) {
      console.error(err);
      statusEl.textContent = "‚ùå Error: " + err.message;
    } finally {
      uploadPgnBtn.disabled = false;
    }
  });

});












document.getElementById("printStudentBtn").addEventListener("click", () => {
  generateStudentPDF();
});

let currentStudentTier = "N/A";


function generateStudentPDF() {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF("p", "mm", "a4");

  const logoImg = document.getElementById("academyLogo");

  // ===== CLEAN TEXT =====
  const title = document
    .getElementById("studentModalTitle")
    .innerText
    .replace(/[^\x00-\x7F]/g, "");

  const rawText = document
    .getElementById("studentModalBody")
    .innerText
    .replace(/[^\x00-\x7F]/g, "");

  const lines = rawText
    .split("\n")
    .map(l => l.trim())
    .filter(Boolean);

  let y = 20;

  /* ================= HEADER ================= */
  if (logoImg && logoImg.src) {
    pdf.addImage(logoImg, "PNG", 15, y - 8, 20, 20);
  }

  pdf.setFont("courier", "bold");
  pdf.setFontSize(20);
  pdf.text("THE OLYMPUS CHESS ACADEMY", 40, y);

  pdf.setFontSize(12);
  pdf.setFont("courier", "normal");
  pdf.text("Official Student Performance Report", 40, y + 8);

  y += 26;

  /* ================= STUDENT NAME ================= */
  pdf.setFont("courier", "bold");
  pdf.setFontSize(16);
  pdf.text(title.toUpperCase(), 15, y);

  y += 6;
  pdf.setLineWidth(0.6);
  pdf.line(15, y, 195, y);
  y += 10;

  /* ================= STUDENT SUMMARY ================= */
  pdf.setFont("courier", "bold");
  pdf.setFontSize(14);
  pdf.text("STUDENT SUMMARY", 15, y);
  y += 8;

  pdf.setFont("courier", "normal");
  pdf.setFontSize(12);

  lines.forEach(l => {
    if (
      l.startsWith("ELO") ||
      l.startsWith("Status") ||
      l.startsWith("Joined") ||
      l.startsWith("Total assignments") ||
      l.startsWith("Correct") ||
      l.startsWith("Incorrect") ||
      l.startsWith("Total time")
    ) {
      pdf.text(l, 18, y);
      y += 7;
    }
  });

  y += 6;

  /* ================= RATING TIER ================= */
  

  /* ================= RATING TIER ================= */
pdf.setFont("courier", "bold");
pdf.setFontSize(14);
pdf.rect(15, y, 180, 18);
pdf.text("RATING TIER", 18, y + 7);

pdf.setFont("courier", "normal");
pdf.text(currentStudentTier, 18, y + 14);

y += 30;


  /* ================= MINI-GAME SCORES ================= */
  pdf.setFont("courier", "bold");
  pdf.setFontSize(14);
  pdf.text("MINI-GAME BEST SCORES", 15, y);
  y += 8;

  pdf.setFont("courier", "normal");
  pdf.setFontSize(12);

  let inMiniGame = false;

  lines.forEach(l => {
    if (l.includes("Mini-Game")) {
      inMiniGame = true;
      return;
    }
    if (inMiniGame && l.includes("Assignment")) {
      inMiniGame = false;
    }
    if (inMiniGame) {
      pdf.text(l, 18, y);
      y += 7;
    }
  });

  y += 10;

  /* ================= ASSIGNMENT HISTORY ================= */
  pdf.setFont("courier", "bold");
  pdf.setFontSize(14);
  pdf.text("ASSIGNMENT HISTORY", 15, y);
  y += 8;

  pdf.setFont("courier", "normal");
  pdf.setFontSize(12);

  let currentAssignment = "";

  lines.forEach(l => {
    if (
      !l.startsWith("Submitted") &&
      !l.startsWith("Time") &&
      !l.startsWith("Attempts") &&
      !l.startsWith("Correct") &&
      !l.startsWith("Incorrect") &&
      !l.startsWith("Mini") &&
      !l.startsWith("Achievement")
    ) {
      currentAssignment = l;
    }

    if (currentAssignment && !l.startsWith("Submitted")) return;

    if (l.startsWith("Submitted")) {
      if (y > 270) {
        pdf.addPage();
        y = 20;
      }

      pdf.setFont("courier", "bold");
      pdf.text(currentAssignment, 18, y);
      y += 6;

      pdf.setFont("courier", "normal");
      pdf.text(l, 22, y);
      y += 6;
    }

    if (l.startsWith("Time")) {
      pdf.text(l, 22, y);
      y += 8;
    }
  });

  y += 10;

  /* ================= COACH REMARKS ================= */
  if (y > 235) {
    pdf.addPage();
    y = 20;
  }

  pdf.setFont("courier", "bold");
  pdf.setFontSize(14);
  pdf.text("COACH REMARKS", 15, y);
  y += 6;

  pdf.rect(15, y, 180, 28);
  pdf.setFont("courier", "normal");
  pdf.setFontSize(11);
  pdf.text(
    "Excellent consistency and accuracy. Continue focusing on calculation depth and endgame conversion. We wish you all the very best!",
    18,
    y + 10,
    { maxWidth: 170 }
  );

  y += 38;

  /* ================= SIGNATURE & DATE ================= */
  const today = new Date().toLocaleDateString();

  pdf.setLineWidth(0.4);
  pdf.line(15, y, 80, y);
  pdf.text("Coach: Tirtha Sarkar (Trainer & Mentor)", 15, y + 6);

  pdf.line(120, y, 195, y);
  pdf.text(`Date: ${today}`, 120, y + 6);

  pdf.setFontSize(10);
  pdf.setTextColor(120);
  pdf.text(
  `¬© ${new Date().getFullYear()} The Olympus Chess Academy Official report. All rights reserved.`,
  15,
  287
);


  /* ================= SAVE ================= */
  pdf.save(`${title.replace(/\s+/g, "_")}_Olympus_Official_Report.pdf`);
}






// üîí Global tier (already used by report PDF)


/* =========================================================
   üìú CERTIFICATE PDF ‚Äî FINAL VERSION (WITH ELO)
   ========================================================= */
window.generateStudentCertificatePDF = function () {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF("landscape", "mm", "a4");

  const logoImg = document.getElementById("academyLogo");

  /* ================= STUDENT NAME ================= */
  const studentName = document
    .getElementById("studentModalTitle")
    .innerText
    .replace("‚Äî Full Details", "")
    .replace(/[^\x00-\x7F]/g, "")
    .trim()
    .toUpperCase();

  /* ================= EXTRACT ELO ================= */
  let eloRating = "N/A";
  const bodyText = document
    .getElementById("studentModalBody")
    .innerText
    .replace(/[^\x00-\x7F]/g, "");

  const eloMatch = bodyText.match(/ELO\s+(\d+)/i);
  if (eloMatch) {
    eloRating = eloMatch[1];
  }

  /* ================= META ================= */
  const tier = currentStudentTier || "STUDENT";
  const today = new Date().toLocaleDateString();
  const year = new Date().getFullYear();

  /* ================= BORDER ================= */
  pdf.setLineWidth(1.2);
  pdf.rect(10, 10, 277, 190);

  pdf.setLineWidth(0.4);
  pdf.rect(14, 14, 269, 182);

  /* ================= LOGO ================= */
  if (logoImg && logoImg.src) {
    pdf.addImage(logoImg, "PNG", 135, 20, 30, 30);
  }

  /* ================= HEADER ================= */
  pdf.setFont("times", "bold");
  pdf.setFontSize(26);
  pdf.text("THE OLYMPUS CHESS ACADEMY", 148, 65, { align: "center" });

  pdf.setFontSize(14);
  pdf.setFont("times", "normal");
  pdf.text("CERTIFICATE OF ACHIEVEMENT", 148, 76, { align: "center" });

  /* ================= BODY ================= */
  pdf.setFontSize(16);
  pdf.text("This is proudly presented to", 148, 95, { align: "center" });

  pdf.setFont("times", "bold");
  pdf.setFontSize(30);
  pdf.text(studentName, 148, 112, { align: "center" });

  pdf.setFont("times", "normal");
  pdf.setFontSize(16);
  pdf.text(
    "for demonstrating dedication, discipline, and excellence in chess training",
    148,
    128,
    { align: "center" }
  );

  /* ================= TIER + ELO ================= */
  pdf.setFont("times", "bold");
  pdf.setFontSize(18);
  pdf.text(`Achievement Tier: ${tier}`, 148, 142, { align: "center" });

  pdf.setFont("times", "normal");
  pdf.setFontSize(16);
  pdf.text(`ELO Rating: ${eloRating}`, 148, 152, { align: "center" });

  /* ================= SIGNATURE ================= */
  pdf.setLineWidth(0.5);
  pdf.line(60, 168, 130, 168);
  pdf.text("Coach: Tirtha Sarkar", 60, 176);

  pdf.line(170, 168, 240, 168);
  pdf.text(`Date: ${today}`, 170, 176);

  /* ================= FOOTER ================= */
  pdf.setFontSize(10);
  pdf.setTextColor(120);
  pdf.text(
    `¬© ${year} The Olympus Chess Academy. All rights reserved.`,
    148,
    188,
    { align: "center" }
  );

  /* ================= SAVE ================= */
  pdf.save(`${studentName}_Olympus_Certificate.pdf`);
};







const infoBtn = document.getElementById("ratingInfoBtn");
const infoPopup = document.getElementById("ratingInfoPopup");
const infoClose = document.getElementById("ratingInfoClose");

if (infoBtn && infoPopup) {
  infoBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    infoPopup.style.display =
      infoPopup.style.display === "block" ? "none" : "block";
  });

  infoClose.addEventListener("click", () => {
    infoPopup.style.display = "none";
  });

  document.addEventListener("click", (e) => {
    if (!infoPopup.contains(e.target)) {
      infoPopup.style.display = "none";
    }
  });
}






/* =====================================================
   üéØ OLYMPUS ‚Äî GAME REVIEW (ISOLATED MODULE)
   Safe to paste inside mainUI.js
   ===================================================== */



(function () {
  let gameReviewInitialized = false;

  // üîê Public init (called only when tab opens)
  window.initGameReview = function () {
    if (gameReviewInitialized) return;
    gameReviewInitialized = true;

    console.log('üìä Game Review initialized');

    // üß† Chess instance (isolated)
    const gameReviewChess = new Chess();

    // üß© Cached DOM
    const pgnInput = document.getElementById('reviewPgn');
    const startBtn = document.getElementById('startGameReview');
    const analysisWrap = document.getElementById('gameReviewAnalysis');

    if (!pgnInput || !startBtn) {
      console.warn('Game Review elements not found');
      return;
    }

    // üéØ Main action
    startBtn.addEventListener('click', () => {
      const pgn = pgnInput.value.trim();

      if (!pgn) {
        alert('‚ùó Please paste a PGN first');
        return;
      }
      showReviewMove(0);

      gameReviewChess.reset();

      // ‚ùå Invalid PGN
      if (!gameReviewChess.load_pgn(pgn)
) {
        alert('‚ùå Invalid PGN format');
        return;
      }

      // ‚úÖ Show analysis board
      if (analysisWrap) {
        analysisWrap.style.display = 'block';
      }

      // ‚ôüÔ∏è Load final position on board
      if (window.analysisBoard) {
        window.analysisBoard.position(gameReviewChess.fen());
        window.analysisBoard.resize();
      }

      // üìú Extract moves + FENs (core data)
      const gameReviewMoves = [];
      gameReviewChess.reset();
      gameReviewChess.load_pgn(pgn)
;

      gameReviewChess.history({ verbose: true }).forEach(move => {
        gameReviewMoves.push({
          san: move.san,
          from: move.from,
          to: move.to,
          fen: gameReviewChess.fen()
        });
      });

      console.log('‚úÖ Game Review PGN loaded');
      console.log('Moves:', gameReviewMoves);

      // üîí Store globally (for Stockfish step later)
      window._gameReviewData = {
        pgn,
        moves: gameReviewMoves
      };
    });
  };
})();


document.addEventListener('keydown', (e) => {
  const section = document.getElementById('gamereview-section');
  if (!section || !section.classList.contains('active')) return;

  if (document.activeElement.tagName === 'TEXTAREA') return;

  if (e.key === 'ArrowRight') {
    e.preventDefault();
    showReviewMove(getCurrentReviewIndex() + 1);

  }

  if (e.key === 'ArrowLeft') {
    e.preventDefault();
     showReviewMove(getCurrentReviewIndex() - 1);
  }
});







/* =====================================================
   üìä OLYMPUS ‚Äî GAME REVIEW MODULE (FINAL, STABLE)
   ===================================================== */
(function () {

  // üîí MODULE STATE (ONE PLACE ONLY)
  let gameReviewInitialized = false;
  let gameReviewBoard = null;
  let gameReviewChess = null;
  let currentReviewIndex = -1;
  let gameReviewFlipped = false;


  if (!window.getPlayersFromPGN) {
  window.getPlayersFromPGN = function (pgn) {
    if (!pgn || typeof pgn !== "string") {
      return { white: "White", black: "Black" };
    }

    const chess = new Chess();
    const ok = chess.load_pgn(pgn);

    if (!ok) {
      return { white: "White", black: "Black" };
    }

    const h = chess.header();

    return {
      white: h.White?.trim() || "White",
      black: h.Black?.trim() || "Black"
    };
  };
}

  


  /* -------------------------------
     INIT BOARD (ONCE)
  -------------------------------- */
  function initGameReviewBoard() {
    if (gameReviewBoard) return;

    gameReviewChess = new Chess();

    gameReviewBoard = Chessboard('gameReviewBoard', {
      position: 'start',
      draggable: false,
      sparePieces: false,
      pieceTheme: getPieceThemePath(currentPieceTheme)
    });

    console.log('‚ôüÔ∏è Game Review board + chess initialized');
  }

  /* -------------------------------
     SHOW MOVE BY INDEX (CORE)
  -------------------------------- */
  function showReviewMove(index) {
    window.showReviewMove = showReviewMove;

  const data = window._gameReviewData;
  const players = getPlayersFromPGN(data?.pgn);


  if (!data || !gameReviewChess || !gameReviewBoard) {
    console.warn('showReviewMove blocked', {
      data,
      gameReviewChess,
      gameReviewBoard
    });
    return;
  }

  // clamp index
  if (index < 0) index = 0;
  if (index >= data.moves.length) index = data.moves.length - 1;

  currentReviewIndex = index;

  // ‚ôüÔ∏è rebuild position from start (SAFE)
  gameReviewChess.reset();
  for (let i = 0; i <= index; i++) {
    const ok = gameReviewChess.move(data.moves[i].san);
    if (!ok) {
      console.error('Illegal move:', data.moves[i].san);
      break;
    }
  }

  gameReviewBoard.position(gameReviewChess.fen(), false);
  gameReviewBoard.resize();

  // üî• REVIEW LIST HIGHLIGHT (FIXED)
  document.querySelectorAll('.review-move').forEach(el =>
    el.classList.remove('active')
  );

  const active = document.querySelector(
    `.review-move[data-index="${index}"]`
  );

  if (active) {
    active.classList.add('active');
    active.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }
}


  /* -------------------------------
     PUBLIC INIT (TAB OPEN)
  -------------------------------- */
  window.initGameReview = function () {
    if (gameReviewInitialized) return;
    gameReviewInitialized = true;

    console.log('üìä Game Review initialized');

    const pgnInput = document.getElementById('reviewPgn');
    const startBtn = document.getElementById('startGameReview');
    const analysisWrap = document.getElementById('gameReviewAnalysis');

    if (!pgnInput || !startBtn || !analysisWrap) {
      console.warn('Game Review elements missing');
      return;
    }

    /* ---------------------------
       START REVIEW CLICK
    ---------------------------- */
    startBtn.addEventListener('click', () => {
      const pgn = pgnInput.value.trim();
      if (!pgn) {
        alert('Please paste PGN');
        return;
      }

      // 1Ô∏è‚É£ INIT BOARD + CHESS
      initGameReviewBoard();

      // 2Ô∏è‚É£ VALIDATE PGN
      gameReviewChess.reset();
      if (!gameReviewChess.load_pgn(pgn)) {
        alert('Invalid PGN');
        return;
      }

      // 3Ô∏è‚É£ SHOW ANALYSIS AREA
      analysisWrap.style.display = 'block';

      // 4Ô∏è‚É£ EXTRACT MOVES SAFELY
      const moves = [];
      gameReviewChess.reset();
      gameReviewChess.load_pgn(pgn);

      gameReviewChess.history({ verbose: true }).forEach(m => {
        moves.push({
          san: m.san,
          from: m.from,
          to: m.to
        });
      });

      window._gameReviewData = { pgn, moves };

      console.log('‚úÖ Game Review PGN loaded');
      console.log('Moves:', moves.length);

      // 5Ô∏è‚É£ INITIAL POSITION (FIRST MOVE)
      currentReviewIndex = -1;
      showReviewMove(0);

      // ‚úÖ üëâ CALL IT HERE (LAST LINE)
  runGameReviewAnalysis();

    });
  };

 /* ================================
   ‚ôüÔ∏è ISOLATED STOCKFISH (REVIEW ONLY)
   ================================ */

window.reviewEngine = null;



function initReviewStockfish() {
  if (reviewEngine) return;

 window.reviewEngine = new Worker("./stockfish/stockfish.js");

  window.reviewEngine.postMessage("uci");

  // ============================
// ‚ôüÔ∏è REVIEW ENGINE HANDLER ONLY
// ============================
reviewEngine.onmessage = (e) => {
  const line = e.data;
  if (typeof line !== "string") return;
  if (!reviewWaiting) return;

  // üî• MATE FIRST
  if (line.includes("score mate")) {
    const m = line.match(/score mate (-?\d+)/);
    if (!m) return;

    clearTimeout(reviewWaiting.timer);

  const mateRaw = parseInt(m[1], 10);
const mate = mateRaw; // Stockfish POV is already correct


reviewWaiting.resolve({
  cp: mate > 0 ? 10000 : -10000,
  mate
});


    reviewWaiting = null;
    processReviewQueue();
    return;
  }

  // üìä CP (STABILIZED)
  if (line.includes("score cp")) {
    const m = line.match(/score cp (-?\d+)/);
    if (!m) return;

    const rawCp = parseInt(m[1], 10);
    const fenTurn = reviewWaiting.fen.split(" ")[1];
    const cp = fenTurn === "w" ? rawCp : -rawCp;

    reviewWaiting.cpBuffer.push(cp);
    if (reviewWaiting.cpBuffer.length < 4) return;

    clearTimeout(reviewWaiting.timer);

    const avg =
      reviewWaiting.cpBuffer.reduce((a, b) => a + b, 0) /
      reviewWaiting.cpBuffer.length;

   reviewWaiting.resolve({
  cp: Math.round(avg),
  mate: null
});



    reviewWaiting = null;
    processReviewQueue();
  }
};


  console.log("ü§ñ Review Stockfish ready");
}

















function classifyMove({
  evalBefore,
  evalAfter,
  mateBefore,
  mateAfter,
  materialDelta,
  loss
}) {

  // üíé ENGINE-APPROVED SAC
  if (
    materialDelta < 0 &&
    loss <= 30 &&
    evalAfter > -150
  ) {
    return "üíé Brilliant";
  }

  // üõ°Ô∏è DEFENSIVE BEST (LOSING)
  if (
    evalBefore < -150 &&
    loss <= 30
  ) {
    return "üèÜ Best";
  }

  // üìä NORMAL GRADING
  if (loss <= 15)  return "üèÜ Best";
  if (loss <= 50)  return "‚≠ê Excellent";
  if (loss <= 100) return "‚úÖ Good";
  if (loss <= 200) return "‚ö†Ô∏è Inaccuracy";
  if (loss <= 350) return "‚ùå Mistake";
  return "‚ùì‚ùì Blunder";
}













function materialCount(chess) {
  const values = { p:1, n:3, b:3, r:5, q:9 };
  let total = 0;

  chess.board().forEach(row =>
    row.forEach(p => {
      if (!p) return;
      total += (p.color === 'w' ? 1 : -1) * values[p.type];
    })
  );

  return total;
}

function finishReview(result) {
  reviewWaiting.resolve(result);
  reviewWaiting = null;

  // üöÄ immediately run next job
  processReviewQueue();
}


function calculateAccuracy(s) {
  if (!s.total) return 0;

  const score =
    s.best * 1.0 +
    s.brilliant * 1.0 +
    s.excellent * 0.9 +
    s.good * 0.8 +
    s.inaccuracy * 0.4 +
    s.mistake * 0.2 +
    s.blunder * 0.0;

  return Math.round((score / s.total) * 100);
}





async function runGameReviewAnalysis() {

  initReviewStockfish(); // ‚úÖ ADD THIS LINE

  const data = window._gameReviewData;
  if (!data) return;

    // üß† Extract player names from PGN (ALWAYS)
  const players = getPlayersFromPGN(data.pgn);


  // show analysis section
  document.getElementById("gameReviewAnalysis").style.display = "block";

  const panel = document.getElementById("gameReviewResults");

  // üîπ STRUCTURE INSIDE EXISTING PANEL
 panel.innerHTML = `
  <div id="reviewStatus" style="opacity:.6; margin-bottom:10px;"></div>

  <div class="review-layout">
    <div id="reviewList"></div>
    <div id="reviewSummary"></div>
  </div>
`;


const reviewStats = {
  w: {
    name: players.white,
    total: 0,
    best: 0,
    excellent: 0,
    good: 0,
    inaccuracy: 0,
    mistake: 0,
    blunder: 0,
    brilliant: 0,
    cpLossSum: 0,
    cpMoves: 0
  },
  b: {
    name: players.black,
    total: 0,
    best: 0,
    excellent: 0,
    good: 0,
    inaccuracy: 0,
    mistake: 0,
    blunder: 0,
    brilliant: 0,
    cpLossSum: 0,
    cpMoves: 0
  }
};



  const statusEl = document.getElementById("reviewStatus");
  const listEl   = document.getElementById("reviewList");

  const chess = new Chess();
  const TOTAL = data.moves.length;

  // üî• ADD THIS HERE (ONCE)

const moveResults = [];


  for (let i = 0; i < TOTAL; i++) {

    // ===== STATUS UPDATE =====
    statusEl.textContent = `Analyzing move ${i + 1}/${TOTAL}‚Ä¶`;
    await new Promise(r => requestAnimationFrame(r));

    // ===== BEFORE MOVE =====
    // ===== BEFORE MOVE =====
// ===== BEFORE MOVE =====
const mover = chess.turn();
  const materialBefore = materialCount(chess);

  const rawBefore = await evalFenForReview(chess.fen());
  const evalBefore = rawBefore.cp ?? 0;
  const mateBefore = rawBefore.mate;

  // ===== PLAY MOVE =====
  const move = chess.move(data.moves[i].san);
  if (!move) continue;

  // ===== AFTER MOVE =====
  const materialAfter = materialCount(chess);

  const rawAfter = await evalFenForReview(chess.fen());
  const evalAfter = rawAfter.cp ?? 0;
  const mateAfter = rawAfter.mate;

  // ===== MATERIAL DELTA =====
  const materialDelta =
    mover === "w"
      ? materialAfter - materialBefore
      : materialBefore - materialAfter;

  // ===== LOSS =====
  let loss = Math.max(0, evalBefore - evalAfter);

  if (Math.abs(loss) < 25) loss = 0;

  if (Math.abs(evalBefore) >= 400) {
    if (loss <= 80)  loss = 80;
    if (loss <= 200) loss = 200;
  }

  if (i < 6 && loss < 300) {
    loss = Math.min(loss, 30);
  }

  // ===== STORE =====
  moveResults[i] = {
    san: data.moves[i].san,
    mover,
    loss,
    evalBefore,
    evalAfter,
    mateBefore,
    mateAfter,
    materialDelta
  };

  // ===== RETROACTIVE MATE =====
  if (mateAfter !== null && mateAfter > 0 && i > 0) {
    moveResults[i - 1].loss = 10000;
  }


}

  // =========================
// PASS 2: STATS + UI RENDER (RUN ONCE)
// =========================
listEl.innerHTML = "";

for (let i = 0; i < moveResults.length; i++) {
  const r = moveResults[i];
  const tag = classifyMove(r);

  const stats = reviewStats[r.mover];
  stats.total++;

  if (tag.includes("Brilliant")) stats.brilliant++;
  else if (tag.includes("Best")) stats.best++;
  else if (tag.includes("Excellent")) stats.excellent++;
  else if (tag.includes("Good")) stats.good++;
  else if (tag.includes("Inaccuracy")) stats.inaccuracy++;
  else if (tag.includes("Mistake")) stats.mistake++;
  else if (tag.includes("Blunder")) stats.blunder++;

  stats.cpLossSum += r.loss;
  stats.cpMoves++;

  const moveNo = Math.floor(i / 2) + 1;
  const prefix = i % 2 === 0 ? `${moveNo}.` : `${moveNo}..`;

  listEl.insertAdjacentHTML("beforeend", `
    <div class="review-move"
         data-index="${i}"
         onclick="showReviewMove(${i})">
      <strong>${prefix}</strong> ${r.san}
      <span style="font-weight:700; margin-left:6px;">
        ${tag}
        <small style="opacity:.6;">
          (${Math.round(r.loss)} cp)
        </small>
      </span>
    </div>
  `);
}


  const w = reviewStats.w;
const b = reviewStats.b;

// =========================
// MOVE LOOP FINISHED
// =========================

// ‚úÖ NEW ACCURACY CALC (PUT HERE)
const wACPL = calculateACPL(reviewStats.w);
const bACPL = calculateACPL(reviewStats.b);

const wAcc = acplToAccuracy(wACPL);
const bAcc = acplToAccuracy(bACPL);

// =========================
// RENDER SUMMARY UI
// =========================
document.getElementById("reviewSummary").innerHTML = `
  <div class="review-summary">

    <div class="player-summary white">
      <h3>${reviewStats.w.name}</h3>
      <div class="accuracy">${wAcc}% Accuracy</div>
      <small>ACPL: ${wACPL.toFixed(1)}</small>
      <ul>
        <li>üèÜ Best: ${reviewStats.w.best}</li>
        <li>‚≠ê Excellent: ${reviewStats.w.excellent}</li>
        <li>‚úÖ Good: ${reviewStats.w.good}</li>
        <li>‚ö†Ô∏è Inaccuracy: ${reviewStats.w.inaccuracy}</li>
        <li>‚ùå Mistake: ${reviewStats.w.mistake}</li>
        <li>‚ùì Blunder: ${reviewStats.w.blunder}</li>
      </ul>
    </div>

    <div class="player-summary black">
      <h3>${reviewStats.b.name}</h3>
      <div class="accuracy">${bAcc}% Accuracy</div>
      <small>ACPL: ${bACPL.toFixed(1)}</small>
      <ul>
        <li>üèÜ Best: ${reviewStats.b.best}</li>
        <li>‚≠ê Excellent: ${reviewStats.b.excellent}</li>
        <li>‚úÖ Good: ${reviewStats.b.good}</li>
        <li>‚ö†Ô∏è Inaccuracy: ${reviewStats.b.inaccuracy}</li>
        <li>‚ùå Mistake: ${reviewStats.b.mistake}</li>
        <li>‚ùì Blunder: ${reviewStats.b.blunder}</li>
      </ul>
    </div>

  </div>
`;



  statusEl.textContent = "‚úî Review complete";
}





function highlightReviewMove(index) {
  const moves = document.querySelectorAll("#reviewList .review-move");

  moves.forEach(el => {
    el.classList.remove("active-review-move");
  });

  const active = document.querySelector(
    `#reviewList .review-move[data-index="${index}"]`
  );

  if (active) {
    active.classList.add("active-review-move");
    active.scrollIntoView({ block: "nearest", behavior: "smooth" });
  }
}











function calculateACPL(stats) {
  if (!stats.cpMoves) return 0;
  return Math.max(1, stats.cpLossSum / stats.cpMoves);
}



function acplToAccuracy(acpl) {
  if (acpl <= 10) return 98;
  if (acpl <= 20) return 95;
  if (acpl <= 30) return 92;
  if (acpl <= 50) return 88;
  if (acpl <= 80) return 82;
  if (acpl <= 120) return 75;
  if (acpl <= 200) return 65;
  if (acpl <= 300) return 55;
  return 45;
}






  /* -------------------------------
     KEYBOARD NAVIGATION
  -------------------------------- */
  document.addEventListener('keydown', (e) => {
  const section = document.getElementById('gamereview-section');
  if (!section || !section.classList.contains('active')) return;

  // ignore typing
  const tag = document.activeElement.tagName;
  if (tag === 'TEXTAREA' || tag === 'INPUT') return;

  // ‚û° NEXT MOVE
  if (e.key === 'ArrowRight') {
    e.preventDefault();
    showReviewMove(currentReviewIndex + 1);
  }

  // ‚¨Ö PREV MOVE
  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    showReviewMove(currentReviewIndex - 1);
  }

  // üîÑ FLIP BOARD (F)
  if (e.key === 'f' || e.key === 'F') {
    e.preventDefault();

    if (!gameReviewBoard) return;

    gameReviewFlipped = !gameReviewFlipped;
    gameReviewBoard.orientation(gameReviewFlipped ? 'black' : 'white');

    setTimeout(() => gameReviewBoard.resize(), 50);

    console.log('‚ôªÔ∏è Game Review board flipped:', gameReviewFlipped ? 'black' : 'white');
  }
});










})();





document.addEventListener('click', (e) => {
  const el = e.target.closest('.review-move');
  if (!el) return;

  const idx = Number(el.dataset.index);
  if (Number.isNaN(idx)) return;

  showReviewMove(idx);
});





/* =====================================================
   ‚ôüÔ∏è LICHESS GAME LOADER ‚Äî FINAL STABLE VERSION
   ===================================================== */

/* ---------- STATE ---------- */
let lichessUsernameActive = null;
let lichessLoading = false;
let lichessLastGameTs = null; // pagination anchor

/* ---------- FETCH GAMES (PAGINATED) ---------- */
async function fetchMoreLichessGames(username, batch = 20) {
  if (lichessLoading) return [];
  lichessLoading = true;

  let url =
    `https://lichess.org/api/games/user/${username}` +
    `?max=${batch}&pgnInJson=true`;

  // pagination using "until"
  if (lichessLastGameTs) {
    url += `&until=${lichessLastGameTs}`;
  }

  const res = await fetch(url, {
    headers: { Accept: "application/json" }
  });

  lichessLoading = false;
  if (!res.ok) return [];

  const games = (await res.text())
    .trim()
    .split("\n")
    .map(l => JSON.parse(l));

  // update pagination anchor (oldest game timestamp)
  if (games.length) {
    lichessLastGameTs = games[games.length - 1].createdAt;
  }

  return games;
}

/* ---------- RENDER GAME ITEM ---------- */
function renderGameItem(g) {
  const listEl = document.getElementById("lichessGameList");

 const whiteName = g.players.white.user?.name || "Anon";
const blackName = g.players.black.user?.name || "Anon";

const whiteRating = g.players.white.rating
  ? `(${g.players.white.rating})`
  : "";

const blackRating = g.players.black.rating
  ? `(${g.players.black.rating})`
  : "";

  const result =
    g.winner === "white" ? "1-0" :
    g.winner === "black" ? "0-1" :
    "¬Ω-¬Ω";

  const plies = g.moves.trim().split(/\s+/).length;
const moves = Math.ceil(plies / 2);


  const div = document.createElement("div");
  div.className = "lichess-game-item";

  div.style.cssText =
    "padding:6px;border-bottom:1px solid #2f335a;cursor:pointer";

  div.innerHTML = `
  <strong>${whiteName}</strong>
  <span style="opacity:.6">${whiteRating}</span>
  vs
  <strong>${blackName}</strong>
  <span style="opacity:.6">${blackRating}</span>
  <span style="opacity:.7">(${result})</span><br>
  <small>${moves} moves</small>
`;


  div.onclick = () => {
    document.getElementById("reviewPgn").value = g.pgn;
    document.getElementById("reviewPgn")
      .scrollIntoView({ behavior: "smooth" });
    document.getElementById("startGameReview").click();
  };

  listEl.appendChild(div);
}

/* ---------- LOAD MORE (USED BY BUTTON + SCROLL) ---------- */
async function loadMoreGames() {
  if (!lichessUsernameActive) return;

  const games = await fetchMoreLichessGames(
    lichessUsernameActive,
    20
  );

  games.forEach(renderGameItem);
}

/* ---------- FETCH BUTTON ---------- */
document.addEventListener("DOMContentLoaded", () => {
  const fetchBtn = document.getElementById("fetchLichessGames");
  const listEl  = document.getElementById("lichessGameList");
  const input   = document.getElementById("lichessUsername");

  if (!fetchBtn || !listEl || !input) return;

  fetchBtn.onclick = async () => {
    const username = input.value.trim();
    if (!username) {
      alert("Enter Lichess username");
      return;
    }

    lichessUsernameActive = username;
    lichessLastGameTs = null;
    listEl.innerHTML = "‚è≥ Loading games‚Ä¶";

    const firstBatch = await fetchMoreLichessGames(username, 20);

    listEl.innerHTML = "";
    if (!firstBatch.length) {
      listEl.textContent = "No games found";
      return;
    }

    firstBatch.forEach(renderGameItem);
  };

  /* ---------- ENTER KEY ---------- */
  input.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();
      fetchBtn.click();
    }
  });

  /* ---------- INFINITE SCROLL ---------- */
  listEl.addEventListener("scroll", () => {
    if (
      listEl.scrollTop + listEl.clientHeight >=
      listEl.scrollHeight - 20
    ) {
      loadMoreGames();
    }
  });
});

/* =====================================================
   üîç USERNAME AUTOCOMPLETE (BEST POSSIBLE ‚Äì PUBLIC API)
   ===================================================== */

async function searchLichessUsers(query) {
  if (query.length < 3) return [];

  const res = await fetch(
    `https://lichess.org/api/users?text=${encodeURIComponent(query)}`
  );

  if (!res.ok) return [];
  return await res.json();
}

document.addEventListener("DOMContentLoaded", () => {
  const input = document.getElementById("lichessUsername");
  const box   = document.getElementById("lichessUserSuggestions");

  if (!input || !box) return;

  let timer = null;

  input.addEventListener("input", () => {
    const q = input.value.trim();
    clearTimeout(timer);

    if (q.length < 3) {
      box.style.display = "none";
      return;
    }

    timer = setTimeout(async () => {
      const users = await searchLichessUsers(q);
      if (!users.length) {
        box.style.display = "none";
        return;
      }

      box.innerHTML = "";
      box.style.display = "block";

      users.slice(0, 8).forEach(u => {
        const div = document.createElement("div");
        div.textContent = u.username;
        div.style.cssText = "padding:6px 10px;cursor:pointer";
        div.onclick = () => {
          input.value = u.username;
          box.style.display = "none";
        };
        box.appendChild(div);
      });
    }, 300);
  });
});










/* ===============================
   ‚ôüÔ∏è LICHESS GAME CACHE
   =============================== */
let analysisLichessGames = [];
let selectedLichessGameIndex = null;

/* ===============================
   ‚ôüÔ∏è DROPDOWN POPULATOR
   =============================== */
function populateGameDropdown(games) {
  const dropdown = document.getElementById("analysisGameDropdown");
  const list = document.getElementById("analysisGameList");

  if (!dropdown || !list) return;

  list.innerHTML = "";
  selectedLichessGameIndex = null;

  games.forEach((g, index) => {
    const white = g.players.white.user?.name || "Anon";
    const black = g.players.black.user?.name || "Anon";
    const date = new Date(g.createdAt).toLocaleDateString();
    const speed = g.speed || "‚Äî";
    const result =
      g.winner === "white" ? "1-0" :
      g.winner === "black" ? "0-1" :
      "1/2-1/2";

    const item = document.createElement("div");
    item.className = "lichess-dropdown-item";
    item.textContent = `${date} | ${white} vs ${black} | ${speed} | ${result}`;

    item.addEventListener("click", async () => {
  selectedLichessGameIndex = index;

  // Close dropdown
  dropdown.classList.add("hidden");

  const game = analysisLichessGames[index];
  if (!game?.id) return;

  try {
    // üî• Fetch PGN immediately
    const res = await fetch(
      `https://lichess.org/game/export/${game.id}`,
      { headers: { Accept: "application/x-chess-pgn" } }
    );

    if (!res.ok) throw new Error("PGN fetch failed");

    const pgn = await res.text();

    // üî• Inject into YOUR analysis system
    loadPGNFromString(pgn);

    // üî• FORCE notation panel update
    renderNotation();
    updateNavigationButtons();

  } catch (err) {
    console.error(err);
    showModal("‚ùå Load Error", "<p>Failed to load game.</p>");
    setTimeout(closeModal, 2000);
  }
});


    list.appendChild(item);
  });

  if (games.length > 0) {
    dropdown.classList.remove("hidden");
  }
}

/* ===============================
   ‚ôüÔ∏è LICHESS USER FETCH
   =============================== */
const fetchBtn = document.getElementById("analysisFetchLichessBtn");
const userInput = document.getElementById("analysisLichessUsername");

if (fetchBtn && userInput) {
  fetchBtn.addEventListener("click", async () => {
    const username = userInput.value.trim();
    if (!username) return;

    fetchBtn.disabled = true;
    fetchBtn.textContent = "Loading‚Ä¶";

    try {
      const res = await fetch(
        `https://lichess.org/api/games/user/${username}?max=50`,
        { headers: { Accept: "application/x-ndjson" } }
      );

      if (!res.ok) throw new Error("Lichess fetch failed");

      const text = await res.text();
      const lines = text.trim().split("\n");

      analysisLichessGames = lines.map(line => JSON.parse(line));
      populateGameDropdown(analysisLichessGames);

    } catch (err) {
      console.error(err);
      showModal("‚ùå Lichess Error", "<p>Failed to fetch games.</p>");
      setTimeout(closeModal, 2000);
    } finally {
      fetchBtn.disabled = false;
      fetchBtn.textContent = "Fetch";
    }
  });
}

/* ===============================
   ‚ôüÔ∏è LOAD SELECTED GAME
   =============================== */
const loadBtn = document.getElementById("analysisLoadGameBtn");

if (loadBtn) {
  loadBtn.addEventListener("click", async () => {
    if (selectedLichessGameIndex === null) return;

    const game = analysisLichessGames[selectedLichessGameIndex];
    if (!game) return;

    try {
      const res = await fetch(
        `https://lichess.org/game/export/${game.id}`,
        { headers: { Accept: "application/x-chess-pgn" } }
      );

      if (!res.ok) throw new Error("PGN fetch failed");

      const pgn = await res.text();

      // üî• Inject into YOUR existing analysis system
      loadPGNFromString(pgn);

    } catch (err) {
      console.error(err);
      showModal("‚ùå Load Error", "<p>Failed to load game.</p>");
      setTimeout(closeModal, 2000);
    }
  });
}

/* ===============================
   ‚ôüÔ∏è CLICK OUTSIDE TO CLOSE
   =============================== */
document.addEventListener("click", (e) => {
  const dropdown = document.getElementById("analysisGameDropdown");
  const wrapper = document.querySelector(".lichess-fetch-wrapper");

  if (!dropdown || !wrapper) return;

  if (!wrapper.contains(e.target)) {
    dropdown.classList.add("hidden");
  }
});



/* ===============================
   ‚ôüÔ∏è ENTER KEY = FETCH LICHESS
   =============================== */
const lichessInput = document.getElementById("analysisLichessUsername");
const lichessFetchBtn = document.getElementById("analysisFetchLichessBtn");

if (lichessInput && lichessFetchBtn) {
  lichessInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();

      // üî• Trigger same logic as clicking Fetch
      lichessFetchBtn.click();
    }
  });
}



document.getElementById("mobileMenuBtn").onclick = () => {
  document.getElementById("topNavbar").classList.toggle("mobile-open");
};









function movePgnNavForMobile() {
  const pgn = document.getElementById("pgnNavButtons");
  const mobileMount = document.getElementById("mobilePgnMount");
  const sidePanel = document.getElementById("sidePanel");

  if (!pgn || !mobileMount || !sidePanel) return;

  if (window.innerWidth <= 768) {
    if (!mobileMount.contains(pgn)) {
      mobileMount.appendChild(pgn);
      pgn.style.display = "flex";
    }
  } else {
    if (!sidePanel.contains(pgn)) {
      sidePanel.appendChild(pgn);
      pgn.style.display = "flex";
    }
  }
}

window.addEventListener("resize", movePgnNavForMobile);
window.addEventListener("load", movePgnNavForMobile);








(function () {
  function dockEngineMobile() {
    if (window.innerWidth > 768) return;

    const engine = document.getElementById("enginePanel");
    const slot = document.getElementById("mobileEngineSlot");

    if (engine && slot && !slot.contains(engine)) {
      slot.appendChild(engine);
    }
  }

  window.addEventListener("load", dockEngineMobile);
  window.addEventListener("resize", dockEngineMobile);
})();





(function () {
  function dockAnalyzeBtn() {
    if (window.innerWidth > 768) return;

    const btn = document.getElementById("analyzeBtn");
    const slot = document.getElementById("mobileEngineActionSlot");

    if (btn && slot && !slot.contains(btn)) {
      slot.appendChild(btn);
    }
  }

  window.addEventListener("load", dockAnalyzeBtn);
  window.addEventListener("resize", dockAnalyzeBtn);
})();



function enableMobileBoardFlip() {
  if (window.innerWidth > 768) return;

  const boardEl = document.getElementById("chessboard");
  if (!boardEl) return;

  let startY = 0;
  let startX = 0;
  let isDraggingPiece = false;

  const SWIPE_THRESHOLD = 80; // higher = safer

  // üß≤ Detect piece drag
  boardEl.addEventListener("touchstart", e => {
    const t = e.touches[0];
    startY = t.clientY;
    startX = t.clientX;

    // If touching a piece, assume drag
    isDraggingPiece = !!e.target.closest(".piece-417db");
  }, { passive: true });

  boardEl.addEventListener("touchend", e => {
    // ‚ùå Block flip if piece was dragged
    if (isDraggingPiece) {
      isDraggingPiece = false;
      return;
    }

    const t = e.changedTouches[0];
    const deltaY = t.clientY - startY;
    const deltaX = t.clientX - startX;

    // Ignore sideways
    if (Math.abs(deltaY) < Math.abs(deltaX)) return;

    // Require strong vertical intent
    if (Math.abs(deltaY) < SWIPE_THRESHOLD) return;

    // üîÑ Flip board
    if (board) {
      board.flip();
      boardOrientation =
        boardOrientation === "white" ? "black" : "white";

      if (chess) {
        loadDrawingsForPosition(chess.fen());
      }

      playSound("move");
    }
  }, { passive: true });
}


// ===============================
// üì± MOBILE TAP TO MOVE SYSTEM
// ===============================
let mobileTapBound = false;

function enableMobileTapMove() {
  if (window.innerWidth > 768) return;
  if (mobileTapBound) return; // üõë bind once only

  const boardEl = document.getElementById("chessboard");
  if (!boardEl) return;

  mobileTapBound = true;

  let selectedSquare = null;
  let touchStartedOnSquare = false;

  function clearSelection() {
    document
      .querySelectorAll(".tap-selected")
      .forEach(el => el.classList.remove("tap-selected"));
    selectedSquare = null;
  }

  function getSquareEl(el) {
    return el.closest(".square-55d63");
  }

  // Track where the touch started
  boardEl.addEventListener("touchstart", e => {
    touchStartedOnSquare = !!getSquareEl(e.target);
  }, { passive: true });

  boardEl.addEventListener("touchend", e => {
    // ‚úÖ Only allow tap-move if touch BOTH started AND ended on a square
    if (!touchStartedOnSquare) return;

    const squareEl = getSquareEl(e.target);
    if (!squareEl) return;

    const square = squareEl.getAttribute("data-square");
    if (!square) return;

    // üü¢ First tap = select
    if (!selectedSquare) {
      const piece = chess.get(square);
      if (!piece) return;

      // Enforce turn
      if (
        (chess.turn() === "w" && piece.color !== "w") ||
        (chess.turn() === "b" && piece.color !== "b")
      ) {
        return;
      }

      selectedSquare = square;
      squareEl.classList.add("tap-selected");
      return;
    }

    // üîµ Second tap = move
    let move;

    if (isPromotionMove(selectedSquare, square)) {
      showPromotionDialog(selectedSquare, square);
      clearSelection();
      return;
    }

   // ============================
// üî• ASSIGNMENT MODE SUPPORT
// ============================
if (currentAssignment && expectedMoves.length > 0) {
  const result = onDrop(selectedSquare, square);

  // üß≤ Force visual sync (tap mode doesn't trigger onSnapEnd)
  board.position(chess.fen());

  // Hide drawings like drag mode does
  clearSVGOnly();

  clearSelection();
  return result;
}


    move = chess.move({
      from: selectedSquare,
      to: square
    });

    if (!move) {
      clearSelection();
      return;
    }

    // üîä Sounds
    if (move.flags.includes("k") || move.flags.includes("q")) {
      playSound("castle");
    } else if (move.san.includes("+")) {
      playSound("check");
    } else if (move.captured) {
      playSound("capture");
    } else {
      playSound("move");
    }

   // ============================
// üî• PGN STATE SYNC (CRITICAL)
// ============================
if (pgnCursor < fullPGNHistory.length) {
  fullPGNHistory = fullPGNHistory.slice(0, pgnCursor);
}

fullPGNHistory.push(move);
pgnCursor++;

    // üîÑ Update board + UI
    board.position(chess.fen());
    updatePGNViewer();
    renderNotation();
    updateNavigationButtons();
    checkGameEnd();

    clearSelection();
  }, { passive: true });
}




// ===============================
// üì± PUZZLE RUSH TAP TO MOVE
// ===============================
let prTapBound = false;

function enablePuzzleRushTapMove() {
  if (window.innerWidth > 768) return;
  if (prTapBound) return;

  const boardEl = document.getElementById("puzzleRushBoard");
  if (!boardEl) return;

  prTapBound = true;

  let selectedSquare = null;
  let touchStartedOnSquare = false;

  function clearSelection() {
    document
      .querySelectorAll(".pr-tap-selected")
      .forEach(el => el.classList.remove("pr-tap-selected"));
    selectedSquare = null;
  }

  function getSquareEl(el) {
    return el.closest(".square-55d63");
  }

  boardEl.addEventListener("touchstart", e => {
    touchStartedOnSquare = !!getSquareEl(e.target);
  }, { passive: true });

  boardEl.addEventListener("touchend", e => {
    if (!touchStartedOnSquare) return;

    const squareEl = getSquareEl(e.target);
    if (!squareEl) return;

    const square = squareEl.getAttribute("data-square");
    if (!square) return;

    // üü¢ First tap = select
    if (!selectedSquare) {
      const piece = prChess.get(square);
      if (!piece) return;

      // Enforce puzzle side
      if (
        (puzzleSideToMove === "w" && piece.color !== "w") ||
        (puzzleSideToMove === "b" && piece.color !== "b")
      ) {
        return;
      }

      selectedSquare = square;
      squareEl.classList.add("pr-tap-selected");
      return;
    }

    // üîµ Second tap = move
    const result = handlePuzzleRushMove(
      selectedSquare,
      square
    );

    // üß≤ Visual sync (tap doesn't trigger snap)
    prBoard.position(prChess.fen());

    clearSelection();
    return result;
  }, { passive: true });
}








const toolbox = document.getElementById("drawToolbox");
const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");

const colorPicker = document.getElementById("drawColor");
const sizeSlider = document.getElementById("drawSize");
const modeSelect = document.getElementById("drawMode");
const clearBtn = document.getElementById("clearCanvas");

let drawing = false;
let startX, startY;

// Resize canvas
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Tab detection
document.querySelectorAll(".nav-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const tab = btn.dataset.tab;

    // üîí ALWAYS reset drawing on tab change
    drawEnabled = false;
    updateToolboxUI();

    if (tab === "study" || tab === "board" || tab === "editor") {
      toolbox.classList.remove("hidden");
    } else {
      toolbox.classList.add("hidden");
    }
  });
});


// Drawing
canvas.addEventListener("mousedown", e => {
  if (!drawEnabled) return;
  if (!document.body.classList.contains("admin-view")) return;




  drawing = true;
  startX = e.clientX;
  startY = e.clientY;
});

canvas.addEventListener("mouseup", e => {
  if (!drawing) return;
  drawing = false;

  // Clear preview layer when shape is finalized
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

  const x = e.clientX;
  const y = e.clientY;

  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = sizeSlider.value;
  ctx.lineCap = "round";

  const mode = modeSelect.value;

  ctx.beginPath();

  if (mode === "pen" || mode === "erase") {
    return;
  }

if (mode === "line") {
  ctx.moveTo(startX, startY);
  ctx.lineTo(x, y);
}

if (mode === "arrow") {
  drawArrowPro(startX, startY, x, y);
}


  if (mode === "circle") {
    const radius = Math.hypot(x - startX, y - startY);
    ctx.arc(startX, startY, radius, 0, Math.PI * 2);
  }

  if (mode === "cross") {
    ctx.moveTo(startX - 15, startY - 15);
    ctx.lineTo(startX + 15, startY + 15);
    ctx.moveTo(startX + 15, startY - 15);
    ctx.lineTo(startX - 15, startY + 15);
  }

  ctx.stroke();
});

canvas.addEventListener("mousemove", e => {
  if (!drawing) return;

  const mode = modeSelect.value;

  // Clear preview layer
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

  if (mode === "pen" || mode === "erase") {
    ctx.strokeStyle = mode === "erase" ? "#000000" : colorPicker.value;
    ctx.lineWidth = sizeSlider.value;
    ctx.lineCap = "round";

    ctx.lineTo(e.clientX, e.clientY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(e.clientX, e.clientY);
    return;
  }

  // LIVE PREVIEW FOR SHAPES
  const x = e.clientX;
  const y = e.clientY;

  previewCtx.strokeStyle = colorPicker.value;
  previewCtx.lineWidth = sizeSlider.value;
  previewCtx.setLineDash([6, 4]); // dashed preview
  previewCtx.lineCap = "round";

  previewCtx.beginPath();

  if (mode === "circle") {
    const radius = Math.hypot(x - startX, y - startY);
    previewCtx.arc(startX, startY, radius, 0, Math.PI * 2);
  }

  if (mode === "line") {
    previewCtx.moveTo(startX, startY);
    previewCtx.lineTo(x, y);
  }

  if (mode === "arrow") {
    drawArrowPreview(startX, startY, x, y);
  }

  if (mode === "cross") {
    previewCtx.moveTo(startX - 15, startY - 15);
    previewCtx.lineTo(startX + 15, startY + 15);
    previewCtx.moveTo(startX + 15, startY - 15);
    previewCtx.lineTo(startX - 15, startY + 15);
  }

  previewCtx.stroke();
  previewCtx.setLineDash([]);
});


// Clear
clearBtn.addEventListener("click", () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
});

// Drag toolbox
let drag = false;
let offsetX, offsetY;

document.querySelector(".toolbox-header").addEventListener("mousedown", e => {
  drag = true;
  offsetX = e.clientX - toolbox.offsetLeft;
  offsetY = e.clientY - toolbox.offsetTop;
});

document.addEventListener("mousemove", e => {
  if (!drag) return;
  toolbox.style.left = e.clientX - offsetX + "px";
  toolbox.style.top = e.clientY - offsetY + "px";
});

document.addEventListener("mouseup", () => {
  drag = false;
});

function drawArrowPreview(fromX, fromY, toX, toY) {
  const headLength = 15 + parseInt(sizeSlider.value || 4);
  const angle = Math.atan2(toY - fromY, toX - fromX);

  previewCtx.beginPath();
  previewCtx.moveTo(fromX, fromY);
  previewCtx.lineTo(toX, toY);

  previewCtx.moveTo(toX, toY);
  previewCtx.lineTo(
    toX - headLength * Math.cos(angle - Math.PI / 6),
    toY - headLength * Math.sin(angle - Math.PI / 6)
  );
  previewCtx.moveTo(toX, toY);
  previewCtx.lineTo(
    toX - headLength * Math.cos(angle + Math.PI / 6),
    toY - headLength * Math.sin(angle + Math.PI / 6)
  );
  previewCtx.stroke();
}



function drawArrowPro(fromX, fromY, toX, toY) {

  const headLength = 15 + parseInt(sizeSlider.value); // arrow head size
  const angle = Math.atan2(toY - fromY, toX - fromX);

  // Main line
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();

  // Arrow head
  ctx.beginPath();
  ctx.moveTo(toX, toY);
  ctx.lineTo(
    toX - headLength * Math.cos(angle - Math.PI / 6),
    toY - headLength * Math.sin(angle - Math.PI / 6)
  );
  ctx.lineTo(
    toX - headLength * Math.cos(angle + Math.PI / 6),
    toY - headLength * Math.sin(angle + Math.PI / 6)
  );
  ctx.lineTo(toX, toY);
  ctx.stroke();
}


const previewCanvas = document.getElementById("previewCanvas");
const previewCtx = previewCanvas.getContext("2d");

function resizePreview() {
  previewCanvas.width = window.innerWidth;
  previewCanvas.height = window.innerHeight;
}
resizePreview();
window.addEventListener("resize", resizePreview);



// Detect active tab on load
function checkInitialTab() {
  const activeBtn = document.querySelector(".nav-btn.active");
  if (!activeBtn) return;

  const tab = activeBtn.dataset.tab;

  if (tab === "study" || tab === "board" || tab === "editor") {
    toolbox.classList.remove("hidden");
    canvas.style.display = "block";
  } else {
    toolbox.classList.add("hidden");
    canvas.style.display = "none";
  }
}

// Run on load
window.addEventListener("load", () => {
  drawEnabled = false;      // ‚õî force OFF
  updateToolboxUI();       // apply UI state
});







const toolboxHeader = document.getElementById("toolboxHeader");
const toolboxTitle = document.getElementById("toolboxTitle");

let drawEnabled = false; // ‚õî drawing OFF by default


function updateToolboxUI() {
  if (drawEnabled) {
    toolbox.classList.remove("draw-collapsed");

    // SHOW canvas
    canvas.style.display = "block";

    toolboxTitle.textContent = "‚úèÔ∏è Draw Tools";
  } else {
    toolbox.classList.add("draw-collapsed");

    // HIDE canvas completely
    canvas.style.display = "none";

    toolboxTitle.textContent = "‚úèÔ∏è Open Tools";
  }
}

// Toggle when clicking header
toolboxHeader.addEventListener("click", () => {
  drawEnabled = !drawEnabled;
  updateToolboxUI();
});

// Init state
updateToolboxUI();








// ===============================
// OLYMPUS LEADERBOARD SYSTEM
// ===============================

const lbOverlay = document.getElementById("leaderboardOverlay");
const lbPopup = document.getElementById("leaderboardPopup");
const lbBtn = document.getElementById("leaderboardBtn");
const lbClose = document.getElementById("leaderboardClose");

const ratingList = document.getElementById("ratingLeaderboard");
const gameList = document.getElementById("gameLeaderboard");
const gameSelect = document.getElementById("lbGameSelect");

// OPEN
lbBtn.onclick = () => {
  lbOverlay.style.display = "flex";
  loadRatingLeaderboard();
  loadGameList();
};

// CLOSE
lbClose.onclick = () => lbOverlay.style.display = "none";
lbOverlay.onclick = e => {
  if (!lbPopup.contains(e.target)) {
    lbOverlay.style.display = "none";
  }
};

// TABS
document.querySelectorAll(".lb-tab").forEach(btn => {
  btn.onclick = () => {
    document.querySelectorAll(".lb-tab").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".lb-panel").forEach(p => p.classList.remove("active"));

    btn.classList.add("active");
    document.getElementById("lb-" + btn.dataset.tab).classList.add("active");
  };
});





// ===============================
// RATING LEADERBOARD
// ===============================
async function loadRatingLeaderboard() {
  ratingList.innerHTML = `<p class="lb-muted">Loading...</p>`;

  const { data, error } = await supabase
    .from("profiles")
    .select("username, puzzle_current_score, quiz_current_score, game_current_score");

  if (error || !data) {
    ratingList.innerHTML = `<p class="lb-muted">Failed to load</p>`;
    return;
  }

  const ranked = data
    .map(p => {
      const raw = ((p.puzzle_current_score || 0) +
                  (p.quiz_current_score || 0) +
                  (p.game_current_score || 0)) / 3;
      return {
        name: p.username || "Student",
        rating: Math.floor(raw / 10) * 10
      };
    })
    .sort((a, b) => b.rating - a.rating)
    .slice(0, 50);

  ratingList.innerHTML = "";

ranked.forEach((row, i) => {
  const div = document.createElement("div");

  let rankClass = "";
  let crownClass = "";

  if (i === 0) { rankClass = "top-1"; crownClass = "gold"; }
  else if (i === 1) { rankClass = "top-2"; crownClass = "silver"; }
  else if (i === 2) { rankClass = "top-3"; crownClass = "bronze"; }

  div.className = `lb-row ${rankClass}`;

  div.innerHTML = `
    <span class="lb-rank crown ${crownClass}">#${i + 1}</span>
    <span class="lb-name">${row.name}</span>
    <span class="lb-score">${row.rating}</span>
  `;

  ratingList.appendChild(div);
});

}

// ===============================
// GAME LEADERBOARD
// ===============================
async function loadGameList() {
  gameSelect.innerHTML = "";

  const { data } = await supabase
    .from("minigame_high_scores")
    .select("game_key");

  const games = [...new Set(data.map(d => d.game_key))];

  games.forEach(g => {
    const opt = document.createElement("option");
    opt.value = g;
    opt.textContent = formatGameName(g);
    gameSelect.appendChild(opt);
  });

  if (games.length) {
    loadGameLeaderboard(games[0]);
  }
}

gameSelect.onchange = () => {
  loadGameLeaderboard(gameSelect.value);
};

async function loadGameLeaderboard(gameKey) {
  gameList.innerHTML = `<p class="lb-muted">Loading...</p>`;

  // 1Ô∏è‚É£ Get top scores
  const { data: scores, error } = await supabase
    .from("minigame_high_scores")
    .select("student_id, score")
    .eq("game_key", gameKey)
    .order("score", { ascending: false })
    .limit(50);

  if (error || !scores) {
    console.error("Leaderboard error:", error);
    gameList.innerHTML = `<p class="lb-muted">Failed</p>`;
    return;
  }

  // 2Ô∏è‚É£ Get all user profiles for those scores
  const ids = scores.map(s => s.student_id);

  const { data: users } = await supabase
    .from("profiles")
    .select("id, username")
    .in("id", ids);

  const userMap = {};
  users?.forEach(u => {
    userMap[u.id] = u.username || "Student";
  });

  // 3Ô∏è‚É£ Render leaderboard
  gameList.innerHTML = "";

 scores.forEach((row, i) => {
  const div = document.createElement("div");

  let rankClass = "";
  let crownClass = "";

  if (i === 0) { rankClass = "top-1"; crownClass = "gold"; }
  else if (i === 1) { rankClass = "top-2"; crownClass = "silver"; }
  else if (i === 2) { rankClass = "top-3"; crownClass = "bronze"; }

  div.className = `lb-row ${rankClass}`;

  div.innerHTML = `
    <span class="lb-rank crown ${crownClass}">#${i + 1}</span>
    <span class="lb-name">${userMap[row.student_id] || "Student"}</span>
    <span class="lb-score">${row.score}</span>
  `;

  gameList.appendChild(div);
});

}








/* ===============================
   LIVE MATCH ENGINE (ISOLATED)
================================ */

let mpChess = new Chess()
let mpBoard = null
let mySide = null
let roomId = null
let channel = null
let lastFen = null
let moveLock = false
let serverTurn = 'w'
let mpPendingPromotion = null
let clockTimer = null
let mpGameOver = false
let mpTapSource = null
let localFlip = false
let rematchHandled = false
let lastPgn = ""
let mpLastArrow = null
let mpLastTapTime = 0

let mpReplayBoard = null
let mpReplayMoves = []
let mpReplayIndex = 0
let mpReplayChess = null



const mpReplayModal = document.getElementById('mpReplayModal')
const mpReplayClose = document.getElementById('mpReplayClose')


mpReplayClose.onclick = () => {
mpReplayModal.classList.add('hidden')
}


function mpOpenReplay(game) {
  mpReplayModal.classList.remove('hidden')

  mpReplayChess = new Chess()
  mpReplayChess.load_pgn(game.pgn)

  mpReplayMoves = mpReplayChess.history({ verbose: true })
  mpReplayIndex = 0

  // Reset to start position
  mpReplayChess.reset()

  if (!mpReplayBoard) {
    mpReplayBoard = Chessboard('mpReplayBoard', {
      position: 'start',
      draggable: false,
      pieceTheme: getPieceThemePath(currentPieceTheme)
    })
  }

  mpReplayBoard.position('start', false)

  document.getElementById('mpPrevMove').onclick = () => {
    if (mpReplayIndex <= 0) return

    mpReplayIndex--

    mpReplayChess.reset()
    for (let i = 0; i < mpReplayIndex; i++) {
      mpReplayChess.move(mpReplayMoves[i])
    }

    mpReplayBoard.position(mpReplayChess.fen(), false)
  }

  document.getElementById('mpNextMove').onclick = () => {
    if (mpReplayIndex >= mpReplayMoves.length) return

    mpReplayChess.move(mpReplayMoves[mpReplayIndex])
    mpReplayIndex++

    mpReplayBoard.position(mpReplayChess.fen(), false)
  }

  document.getElementById('mpCopyReplayPGN').onclick = () => {
    navigator.clipboard.writeText(game.pgn)
  }
}




/* ===============================
   LIVE MATCH SOUNDS (ISOLATED)
================================ */



// Mobile unlock
let mpAudioUnlocked = false
document.addEventListener('pointerdown', () => {
  if (mpAudioUnlocked) return
  Object.values(mpSounds).forEach(a => {
    a.volume = 0.7
    a.play().catch(() => {})
    a.pause()
    a.currentTime = 0
  })
  mpAudioUnlocked = true
}, { once: true })

const mpSounds = {
  move: new Audio("sounds/move.mp3"),
  capture: new Audio("sounds/capture.mp3"),
  castle: new Audio("sounds/castle.mp3"),
  check: new Audio("sounds/check.mp3")
}

function mpPlayMoveSoundFromPGN(pgn) {
  if (!pgn) return

  const moves = pgn.trim().split(/\s+/)
  const last = moves[moves.length - 1]
  if (!last) return

  let sound = "move"

  if (last.includes("x")) sound = "capture"
  if (last === "O-O" || last === "O-O-O") sound = "castle"
  if (last.includes("+") || last.includes("#")) sound = "check"

  const audio = mpSounds[sound]
  if (!audio) return

  audio.currentTime = 0
  audio.play().catch(() => {})
}


const mpSideSelect = document.getElementById('mpSide')
const mpMovesBox = document.getElementById('mpMoves')
const mpCopyBtn = document.getElementById('mpCopyPGN')


const mpResignBtn = document.getElementById('mpResignBtn')
const mpRematchBtn = document.getElementById('mpRematchBtn')

const mpRematchModal = document.getElementById('mpRematchModal')
const mpAcceptBtn = document.getElementById('mpAcceptBtn')
const mpDeclineBtn = document.getElementById('mpDeclineBtn')

const mpDrawBtn = document.getElementById('mpDrawBtn')
const mpDrawModal = document.getElementById('mpDrawModal')
const mpDrawAcceptBtn = document.getElementById('mpDrawAcceptBtn')
const mpDrawDeclineBtn = document.getElementById('mpDrawDeclineBtn')



mpCopyBtn.onclick = () => {
  navigator.clipboard.writeText(mpMovesBox.textContent || '')
  mpCopyBtn.textContent = '‚úÖ Copied'
  setTimeout(() => (mpCopyBtn.textContent = 'üìã Copy'), 1000)
}

/* ===============================
   UNIVERSAL FLOATING MODAL
================================ */

const floatModal = document.getElementById('floatingModal')
const modalTitle = document.getElementById('modalTitle')
const modalBody = document.getElementById('modalBody')
const modalOkBtn = document.getElementById('modalOkBtn')

function mpShowModal(title, message) {
  modalTitle.textContent = title
  modalBody.textContent = message
  floatModal.classList.remove('hidden')
}

modalOkBtn.onclick = () => {
  floatModal.classList.add('hidden')
}







const mpTime = document.getElementById('mpTime')
const mpCreateBtn = document.getElementById('mpCreateBtn')
const mpJoinBtn = document.getElementById('mpJoinBtn')
const mpJoinCode = document.getElementById('mpJoinCode')
const mpRoomCode = document.getElementById('mpRoomCode')


/* ===============================
   MOBILE TAP SYSTEM (ISOLATED)
================================ */

document.addEventListener('pointerdown', e => {
  // Only for Live Match board
  const boardRoot = document.getElementById('mpBoard')
  if (!boardRoot || !boardRoot.contains(e.target)) return

  // Find square
  const squareEl = e.target.closest('[data-square]')
  if (!squareEl) return

  const square = squareEl.dataset.square
  const now = performance.now()
if (now - mpLastTapTime < 60) return // prevent double-fire lag
mpLastTapTime = now

  if (!square) return

  // ‚ùå Game guards
  if (mpGameOver) return
  if (moveLock) return
  if (serverTurn !== mySide) return

  // ===============================
  // FIRST TAP = SELECT
  // ===============================
  if (!mpTapSource) {
    const piece = mpChess.get(square)

    if (!piece) return

    // Must be your piece
    if (
      (mySide === 'w' && piece.color !== 'w') ||
      (mySide === 'b' && piece.color !== 'b')
    ) {
      return
    }

    mpTapSource = square
    highlightMpSquare(square)
    return
  }

  // ===============================
  // SECOND TAP = MOVE
  // ===============================
  const from = mpTapSource
  const to = square

  clearMpHighlights()
  mpTapSource = null

  mpInstantMove(from, to)

})



/* ===============================
   NAV FIX (PREVENT BLANK APP)
================================ */
document.getElementById('navLiveMatch').onclick = () => {
  document.querySelectorAll('.section').forEach(s => {
    s.style.display = 'none'
  })
  document.getElementById('livematch-section').style.display = 'block'
 
}

function mpApplyPOV() {
  const boardArea = document.querySelector('.mp-board-area')
  if (!boardArea) return

  if (mySide === 'w') {
    boardArea.classList.remove('black')
  } else {
    boardArea.classList.add('black')
  }
}



/* ===============================
   HELPERS
================================ */

function mpInstantMove(from, to, promotion = 'q') {
  // Apply instantly on board for zero lag feel
  const move = mpChess.move({ from, to, promotion })
  if (!move) return false

  if (mpBoard) {
    mpBoard.position(mpChess.fen(), false) // NO animation = instant
  }

  // Sound + arrow
  mpPlayMoveSound(move)
  mpClearArrow()

  // Lock + sync async
  moveLock = true
  mpAfterMove()

  return true
}






function mpGetLastMoveFromPGN(pgn) {
  if (!pgn) return null

  const parts = pgn.trim().split(/\s+/)
  let san = parts[parts.length - 1]

  // Remove move numbers
  if (san.includes(".")) return null

  try {
    const temp = new Chess()
    temp.load_pgn(pgn)

    const h = temp.history({ verbose: true })
    return h[h.length - 1]
  } catch {
    return null
  }
}







function mpClearArrow() {
  const old = document.getElementById("mpArrowLayer")
  if (old) old.remove()
}

function mpDrawArrow(from, to) {
  const board = document.getElementById("mpBoard")
  if (!board || !mpBoard) return

  // Find real chess grid (inside Chessboard.js)
  const grid = board.querySelector(".board-b72b1")
  if (!grid) return

  // Remove old arrow
  mpClearArrow()

  // Square center helper
  function squareCenter(sq) {
    const files = ["a","b","c","d","e","f","g","h"]
    const size = grid.clientWidth / 8

    const file = files.indexOf(sq[0])
    const rank = parseInt(sq[1], 10) - 1

    let x = file * size + size / 2
    let y = (7 - rank) * size + size / 2

    // Respect board flip
    if (mpBoard.orientation() === "black") {
      x = grid.clientWidth - x
      y = grid.clientHeight - y
    }

    return { x, y }
  }

  const start = squareCenter(from)
  const end = squareCenter(to)

  // SVG overlay
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
  svg.setAttribute("id", "mpArrowLayer")
  svg.setAttribute("viewBox", `0 0 ${grid.clientWidth} ${grid.clientHeight}`)
  svg.style.position = "absolute"
  svg.style.top = "0"
  svg.style.left = "0"
  svg.style.width = grid.clientWidth + "px"
  svg.style.height = grid.clientHeight + "px"
  svg.style.pointerEvents = "none"
  svg.style.zIndex = "20"

  // Arrowhead marker
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs")

  const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker")
  marker.setAttribute("id", "mpArrowHead")
  marker.setAttribute("markerUnits", "strokeWidth")
  marker.setAttribute("markerWidth", "4")
  marker.setAttribute("markerHeight", "4")
  marker.setAttribute("viewBox", "0 0 10 10")
  marker.setAttribute("refX", "9")
  marker.setAttribute("refY", "5")
  marker.setAttribute("orient", "auto")

  const arrowShape = document.createElementNS("http://www.w3.org/2000/svg", "path")
  arrowShape.setAttribute("d", "M 0 0 L 10 5 L 0 10 L 3 5 Z")
  arrowShape.setAttribute("fill", "rgba(0,255,136,0.25)")

  marker.appendChild(arrowShape)
  defs.appendChild(marker)
  svg.appendChild(defs)

  // Line
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line")
  line.setAttribute("x1", start.x)
  line.setAttribute("y1", start.y)
  line.setAttribute("x2", end.x)
  line.setAttribute("y2", end.y)
  line.setAttribute("stroke", "rgba(0,255,136,0.25)")
  line.setAttribute("stroke-width", "3")
  line.setAttribute("stroke-linecap", "round")
  line.setAttribute("marker-end", "url(#mpArrowHead)")

  svg.appendChild(line)

  // Attach to grid, not wrapper
  grid.style.position = "relative"
  grid.appendChild(svg)
}






function mpEndAndUnlock() {
  // Stop everything
  stopClock()

  // Leave realtime room
  if (channel) {
    supabase.removeChannel(channel)
    channel = null
  }

  // Reset core state
  roomId = null
  mpGameOver = true
  moveLock = false
  mpTapSource = null
  localFlip = false
  rematchHandled = false
  lastFen = null
  lastPgn = ""

  // Reset chess engine
  mpChess = new Chess()

  // Reset board
  if (mpBoard) {
    mpBoard.position(mpChess.fen(), false)
    mpBoard.orientation('white')
  }

  // Reset UI
  mpMovesBox.textContent = ""
  mpRoomCode.textContent = ""
  mpJoinCode.value = ""

  mpRematchBtn.disabled = false
  mpRematchBtn.textContent = "Rematch"

  mpDrawBtn.disabled = false
  mpDrawBtn.textContent = "ü§ù Draw"

  mpClearSession()
}






function mpPlayMoveSound(move) {
  if (!move) return

  try {
    if (move.flags.includes('k') || move.flags.includes('q')) {
      mpSounds.castle.play()
    } else if (move.captured) {
      mpSounds.capture.play()
    } else if (mpChess.in_check()) {
      mpSounds.check.play()
    } else {
      mpSounds.move.play()
    }
  } catch {}
}


function mpClearSession() {
  localStorage.removeItem('mp_session')
}


function mpSaveSession() {
  if (!roomId || !mySide) return
  localStorage.setItem('mp_session', JSON.stringify({
    roomId,
    side: mySide
  }))
}


mpDrawBtn.onclick = async () => {
  if (!roomId || mpGameOver) return

  mpDrawBtn.disabled = true
  mpDrawBtn.textContent = '‚è≥ Offered'

  await supabase
    .from('live_match_rooms')
    .update({
      draw_request: true,
      draw_by: mySide,
      updated_at: new Date().toISOString()
    })
    .eq('id', roomId)
}

mpDrawAcceptBtn.onclick = async () => {
  mpDrawModal.classList.add('hidden')

  mpGameOver = true
  stopClock()

  await supabase
    .from('live_match_rooms')
    .update({
      status: 'finished',
      winner: 'draw',
      draw_request: false,
      draw_by: null,
      updated_at: new Date().toISOString()
    })
    .eq('id', roomId)

  mpShowModal('Draw', 'ü§ù Game ended in a draw')
}

mpDrawDeclineBtn.onclick = async () => {
  mpDrawModal.classList.add('hidden')

  await supabase
    .from('live_match_rooms')
    .update({
      draw_request: false,
      draw_by: null,
      updated_at: new Date().toISOString()
    })
    .eq('id', roomId)
}

const mpFlipBtn = document.getElementById('mpFlipBtn')

mpAcceptBtn.onclick = () => {
  mpRematchModal.classList.add('hidden')
  mpAcceptRematch()
}

mpDeclineBtn.onclick = () => {
  mpRematchModal.classList.add('hidden')
  mpDeclineRematch()
}


mpFlipBtn.onclick = () => {
  if (!mpBoard || !mySide) return

  localFlip = !localFlip
  const baseOrientation = mySide === 'b' ? 'black' : 'white'
  mpBoard.orientation(localFlip ? 
    (baseOrientation === 'white' ? 'black' : 'white') 
    : baseOrientation
  )
}


async function mpArchiveSaveGame() {
  try {
    if (!roomId || !lastFen) return

    const white = document.getElementById('mpYouName')?.textContent || 'White'
    const black = document.getElementById('mpOppName')?.textContent || 'Black'

    await supabase
      .from('live_match_archive')
      .insert({
        room_code: mpRoomCode.textContent || roomId, // human or fallback
        white_name: white,
        black_name: black,
        pgn: lastPgn || '',
        final_fen: lastFen,
        winner: mySide
      })
  } catch (e) {
    console.warn('Archive save skipped:', e.message)
  }
}


async function mpLoadArchive() {
  console.log("Loading archive...")
const grid = document.getElementById('mpArchiveGrid')
grid.innerHTML = 'Loading...'


const { data } = await supabase
.from('live_match_archive')
.select('*')
.order('ended_at', { ascending:false })
.limit(50)


if (!data) return


grid.innerHTML = ''


data.forEach(g => {
const card = document.createElement('div')
card.className = 'mp-archive-card'


const boardDiv = document.createElement('div')
boardDiv.style.height = '120px'


const names = document.createElement('div')
names.className = 'mp-archive-names'
names.textContent = `${g.white_name || 'White'} vs ${g.black_name || 'Black'}`


card.appendChild(boardDiv)
card.appendChild(names)
grid.appendChild(card)


const tempBoard = Chessboard(boardDiv, {
  position: g.final_fen,
  draggable: false,
  pieceTheme: getPieceThemePath(currentPieceTheme)
})


card.onclick = () => mpOpenReplay(g)
})
}


async function mpHardResetRoom(newSide = null, keepTime = false) {
  liveMatchXPGranted = false

  if (!roomId) return

  stopClock()

  mpChess = new Chess()
  moveLock = false
  mpGameOver = false
  mpTapSource = null
  mpMovesBox.textContent = ''

  if (newSide) {
    mySide = newSide
    mpApplyPOV()
  }

  const { data } = await supabase
    .from('live_match_rooms')
    .select('base_time, increment')
    .eq('id', roomId)
    .single()

  if (!data) return

  const base = data.base_time

  const update = {
    fen: mpChess.fen(),
    pgn: '',
    turn: 'w',
    w_time: base,
    b_time: base,
    updated_at: new Date().toISOString()
  }

  await supabase
    .from('live_match_rooms')
    .update(update)
    .eq('id', roomId)

  if (mpBoard) {
    mpBoard.orientation(mySide === 'b' ? 'black' : 'white')
    mpBoard.position(mpChess.fen(), false)
  }
}

/* ===============================
   ACTION BUTTONS
================================ */



// RESIGN
/* ===============================
   RESIGN (SERVER AUTHORITATIVE)
================================ */

mpResignBtn.onclick = async () => {
  if (mpGameOver || !roomId) return

  mpGameOver = true
  stopClock()

  const winner = mySide === 'w' ? 'b' : 'w'

  mpShowModal('Game Over', 'üè≥ You resigned. Opponent wins.')

  await supabase
    .from('live_match_rooms')
    .update({
      status: 'finished',
      resigned_by: mySide,
      winner, // üî• THIS IS THE KEY
      updated_at: new Date().toISOString()
    })
    .eq('id', roomId)

  mpClearSession()
  mpEndAndUnlock()

}
// REMATCH (FLIP COLORS)
mpRematchBtn.onclick = async () => {
  if (!roomId) return

  // Prevent spam
  mpRematchBtn.disabled = true
  mpRematchBtn.textContent = '‚è≥ Waiting...'

  await supabase
    .from('live_match_rooms')
    .update({
      rematch_request: true,
      rematch_by: mySide,
      updated_at: new Date().toISOString()
    })
    .eq('id', roomId)
}



async function mpAcceptRematch() {
  if (!roomId) return

  const { data } = await supabase
    .from('live_match_rooms')
    .select('base_time, white_id, black_id')
    .eq('id', roomId)
    .single()

  if (!data) return

  // Swap server roles
  const newWhite = data.black_id
  const newBlack = data.white_id

  const fresh = new Chess()

  await supabase
    .from('live_match_rooms')
    .update({
      fen: fresh.fen(),
      pgn: '',
      turn: 'w',
      w_time: data.base_time,
      b_time: data.base_time,
      white_id: newWhite,
      black_id: newBlack,
      rematch_request: false,
      rematch_by: null,
      status: 'playing',
      updated_at: new Date().toISOString()
    })
    .eq('id', roomId)

  // üî• REJOIN PIPELINE
  setTimeout(() => {
    mpRejoinRoomById(roomId)
  }, 300)
}





function mpAppendPGN(oldPgn, move) {
  if (!move) return oldPgn || ''
  const san = move.san

  // If empty, start move list
  if (!oldPgn || !oldPgn.trim()) {
    return `1. ${san}`
  }

  // Count full moves
  const moveCount = (oldPgn.match(/\d+\./g) || []).length

  // White move
  if (move.color === 'w') {
    return `${oldPgn} ${moveCount + 1}. ${san}`
  }

  // Black move
  return `${oldPgn} ${san}`
}


function genRoomCode() {
  return Math.random().toString(36).substring(2, 7).toUpperCase()
}

function startClock() {
  if (mpGameOver || !roomId) return

  stopClock()

  clockTimer = setInterval(async () => {
  if (mpGameOver || !roomId) return


    const field = serverTurn === 'w' ? 'w_time' : 'b_time'

    const { data, error } = await supabase
      .from('live_match_rooms')
      .select('w_time, b_time')
      .eq('id', roomId)
      .single()

    if (error || !data) return

    let newTime =
      serverTurn === 'w'
        ? Math.max(0, data.w_time - 1)
        : Math.max(0, data.b_time - 1)

    const update = {}
    update[field] = newTime

    await supabase
      .from('live_match_rooms')
      .update(update)
      .eq('id', roomId)

    // ‚õ≥ FLAG FALL ‚Äî FIRE ONCE
   // ‚õ≥ FLAG FALL ‚Äî SERVER AUTHORITATIVE
if (newTime <= 0 && !mpGameOver) {
  mpGameOver = true
  stopClock()

  const winner = serverTurn === 'w' ? 'b' : 'w'

  await supabase
    .from('live_match_rooms')
    .update({
      status: 'finished',
      winner,
      updated_at: new Date().toISOString()
    })
    .eq('id', roomId)

  mpShowModal(
    'Game Over',
    winner === mySide
      ? 'üéâ Opponent ran out of time! You won!'
      : '‚õî Time up! You lost on time.'
  )
mpArchiveSaveGame()
  mpClearSession()
  mpEndAndUnlock()

}

  }, 1000)
}


function stopClock() {
  if (clockTimer) {
    clearInterval(clockTimer)
    clockTimer = null
  }
}



function highlightMpSquare(square) {
  clearMpHighlights()
  const el = document.querySelector(`#mpBoard [data-square="${square}"]`)
  if (el) {
    el.style.boxShadow = 'inset 0 0 0 3px rgba(0,150,255,0.8)'
    el.setAttribute('data-mp-select', '1')
  }
}


function clearMpHighlights() {
  document
    .querySelectorAll('#mpBoard [data-mp-select]')
    .forEach(el => {
      el.style.boxShadow = ''
      el.removeAttribute('data-mp-select')
    })
}

function updateMpPlayerLabels() {
  const you = document.getElementById('mpYouName')
  const opp = document.getElementById('mpOppName')

  if (!you || !opp) return

  if (mySide === 'w') {
    you.textContent = 'You (White)'
    opp.textContent = 'Black'
  } else {
    you.textContent = 'You (Black)'
    opp.textContent = 'White'
  }
}


/* ===============================
   BOARD INIT
================================ */

function initLiveMatchBoard() {
  if (mpBoard) return

  mpBoard = Chessboard('mpBoard', {
    position: mpChess.fen(),
    draggable: true,
    orientation: mySide === 'b' ? 'black' : 'white',
    pieceTheme: getPieceThemePath(currentPieceTheme),

    onDragStart: mpOnDragStart,
    onDrop: onLiveMatchDrop
  })

  // üì± Enable mobile tap system

}

/* ===============================
   DRAG PROTECTION
================================ */

function mpOnDragStart(source, piece) {
  // ‚ùå Move in progress
  if (moveLock) return false

  // ‚ùå Not your turn (server says so)
  if (serverTurn !== mySide) return false

  // ‚ùå Can't move opponent piece
  if (
    (mySide === 'w' && piece.startsWith('b')) ||
    (mySide === 'b' && piece.startsWith('w'))
  ) {
    return false
  }

  // ‚ùå Game over
 if (mpGameOver || mpChess.game_over()) return false

}


/* ===============================
   MOVE HANDLER
================================ */

/* ===============================
   MOVE HANDLER
================================ */

function onLiveMatchDrop(source, target) {
  // Guards
  if (mpGameOver) return 'snapback'
  if (serverTurn !== mySide) return 'snapback'
  if (moveLock) return 'snapback'

  const piece = mpChess.get(source)
  if (!piece) return 'snapback'

  // Promotion
  const isPromo =
    piece.type === 'p' &&
    ((mySide === 'w' && target[1] === '8') ||
     (mySide === 'b' && target[1] === '1'))

  if (isPromo) {
    mpPendingPromotion = { source, target }
    showMpPromotion()
    return 'snapback'
  }

  // üî• LEGALITY CHECK (SYNC)
  const test = new Chess(mpChess.fen())
  const legal = test.move({ from: source, to: target, promotion: 'q' })

  if (!legal) return 'snapback'

  // üîí Lock UI
  moveLock = true

  // Apply move locally
  // Apply move locally + get move object
const move = mpChess.move({ from: source, to: target, promotion: 'q' })

// üîä Play sound
mpPlayMoveSound(move)
mpClearArrow()



  // Fire async server sync
  mpAfterMove()

  return
}

async function mpAfterMove() {
  // ===============================
  // CHECKMATE DETECTION
  // ===============================
  const isMate =
    typeof mpChess.isCheckmate === 'function'
      ? mpChess.isCheckmate()
      : mpChess.in_checkmate()

  if (isMate) {
    await syncMoveToServer()

    mpGameOver = true
    stopClock()

    const winner = mpChess.turn() === 'w' ? 'b' : 'w'

    await supabase
      .from('live_match_rooms')
      .update({
        status: 'finished',
        winner,
        updated_at: new Date().toISOString()
      })
      .eq('id', roomId)

    mpShowModal('Checkmate!', '‚ôüÔ∏è You delivered CHECKMATE!')
    mpClearSession()
    mpEndAndUnlock()
mpArchiveSaveGame()

    return
  }

  // ===============================
  // NORMAL MOVE
  // ===============================
  await syncMoveToServer()
}



function showMpPromotion() {
  document.getElementById('mpPromoModal')
    .classList.remove('hidden');
}

window.mpCompletePromotion = function(piece) {
  document.getElementById('mpPromoModal')
    .classList.add('hidden');

  if (!mpPendingPromotion) return;

  const { source, target } = mpPendingPromotion
  mpPendingPromotion = null

  // üî• Apply move locally
const move = mpChess.move({
  from: source,
  to: target,
  promotion: piece
})

// üîä Play sound
mpPlayMoveSound(move)

  moveLock = true

  // üî• Sync + checkmate handling
  mpAfterMove()
}

// expose to inline HTML buttons
window.showMpPromotion = showMpPromotion;






async function syncMoveToServer() {
  const { data } = await supabase
    .from('live_match_rooms')
    .select('w_time, b_time, increment, pgn')
    .eq('id', roomId)
    .single()

  if (!data) return

  const history = mpChess.history({ verbose: true })
  const lastMove = history[history.length - 1]

  const fullPGN = mpAppendPGN(data.pgn, lastMove)

  const update = {
    fen: mpChess.fen(),
    pgn: fullPGN,
    turn: mpChess.turn(),
    updated_at: new Date().toISOString()
  }

  // ‚è±Ô∏è Apply increment
  if (mySide === 'w') {
    update.w_time = data.w_time + data.increment
  } else {
    update.b_time = data.b_time + data.increment
  }

  await supabase
    .from('live_match_rooms')
    .update(update)
    .eq('id', roomId)

  moveLock = false
}


async function mpRejoinRoomById(id) {
  liveMatchXPGranted = false

  // Stop everything
  stopClock()

  if (channel) {
    supabase.removeChannel(channel)
    channel = null
  }

  // Reset client state
  mpChess = new Chess()
  mpGameOver = false
  moveLock = false
  mpTapSource = null
  localFlip = false
  rematchHandled = false
  lastFen = null
  mpMovesBox.textContent = ''
    // üî• Clear mobile tap state
  mpTapSource = null
  clearMpHighlights()


  // Fetch fresh server state
  const { data, error } = await supabase
    .from('live_match_rooms')
    .select('*')
    .eq('id', id)
    .single()

  if (error || !data) {
    alert('Failed to reload room')
    return
  }

  roomId = data.id

  // Assign side from server (AUTHORITATIVE)
// Assign side from server (AUTHORITATIVE)
// Use creator_side instead of myRole
// üî• Restore side from session (authoritative for this client)
const savedSide = sessionStorage.getItem('mpSide')
if (savedSide) {
  mySide = savedSide
} else {
  // fallback (should never happen)
  mySide = data.creator_side === 'w' ? 'b' : 'w'
}



  updateMpPlayerLabels()
  mpApplyPOV()

  mpChess.load(data.fen)
  lastFen = data.fen
  serverTurn = data.turn   // üî• sync turn from server
moveLock = false        // üîì allow moves after reconnect


  if (!mpBoard) {
  initLiveMatchBoard()
}

mpBoard.orientation(mySide === 'b' ? 'black' : 'white')
mpBoard.position(data.fen, false)


  subscribeRoom()
}



/* ===============================
   CREATE ROOM
================================ */

mpCreateBtn.onclick = async () => {
  liveMatchXPGranted = false

  const [base, inc] = mpTime.value.split('|').map(Number)
  const code = genRoomCode()

  const { data, error } = await supabase
    .from('live_match_rooms')
    .insert({
      room_code: code,
      base_time: base,
      increment: inc,
      fen: mpChess.fen(),
      w_time: base,
      b_time: base,
      status: 'waiting',
      creator_side: mpSideSelect.value,
    white_id: mpSideSelect.value === 'w' ? 'host' : null,
    black_id: mpSideSelect.value === 'b' ? 'host' : null
    })
    .select()
    .single()

  if (error) {
    alert(error.message)
    return
  }

  roomId = data.id
mySide = mpSideSelect.value
sessionStorage.setItem('mpRole', 'host')
sessionStorage.setItem('mpSide', mySide)

mpSaveSession()

updateMpPlayerLabels()

  mpGameOver = false
  mpApplyPOV()




  mpRoomCode.textContent = `Room Code: ${code} (copied)`
  navigator.clipboard.writeText(code).catch(() => {})

  setTimeout(initLiveMatchBoard, 100)
  subscribeRoom()
}

/* ===============================
   JOIN ROOM
================================ */

mpJoinBtn.onclick = async () => {
  liveMatchXPGranted = false

  const code = mpJoinCode.value.trim().toUpperCase()
  if (!code) return

  const { data, error } = await supabase
    .from('live_match_rooms')
    .select('*')
    .eq('room_code', code)
    .single()

  if (error || !data) {
    alert('Room not found')
    return
  }

  if (data.status !== 'waiting') {
    alert('Room already in use')
    return
  }

  roomId = data.id
// Creator chose side ‚Äî we take the opposite
mySide = data.creator_side === 'w' ? 'b' : 'w'
sessionStorage.setItem('mpRole', 'student')
sessionStorage.setItem('mpSide', mySide)

mpSaveSession()

updateMpPlayerLabels()

  mpGameOver = false
  mpApplyPOV()


  mpChess.load(data.fen)

  await supabase
    .from('live_match_rooms')
    .update({
      status: 'playing',
       white_id: mySide === 'w' ? 'student' : data.white_id,
    black_id: mySide === 'b' ? 'student' : data.black_id
    })
    .eq('id', roomId)


    lastFen = mpChess.fen()


 
  setTimeout(initLiveMatchBoard, 100)
  subscribeRoom()
}

const mpFenInput = document.getElementById('mpFenInput')
const mpFenCreateBtn = document.getElementById('mpFenCreateBtn')

mpFenCreateBtn.onclick = async () => {
  const fen = mpFenInput.value.trim()
  if (!fen) {
    mpShowModal("Invalid FEN", "Please paste a FEN string first")
    return
  }

  // ===============================
  // VALIDATE FEN
  // ===============================
  const test = new Chess()
  if (!test.load(fen)) {
    mpShowModal("Invalid FEN", "This FEN position is not valid")
    return
  }

  liveMatchXPGranted = false

  const [base, inc] = mpTime.value.split('|').map(Number)
  const code = genRoomCode()

  // ===============================
  // APPLY FEN LOCALLY FIRST
  // ===============================
  mpChess.load(fen)

  serverTurn = fen.split(' ')[1] || 'w'
  lastFen = fen
  lastPgn = ''
  moveLock = false
  mpGameOver = false
  mpTapSource = null
  mpMovesBox.textContent = ''

  if (mpBoard) {
    mpBoard.orientation(mySide === 'b' ? 'black' : 'white')
    mpBoard.position(fen, false)
  }

  // ===============================
  // CREATE SERVER ROOM
  // ===============================
  const { data, error } = await supabase
    .from('live_match_rooms')
    .insert({
      room_code: code,
      base_time: base,
      increment: inc,

      fen: fen,
      pgn: '',
      turn: serverTurn,

      w_time: base,
      b_time: base,

      status: 'waiting',
      creator_side: mpSideSelect.value,

      white_id: mpSideSelect.value === 'w' ? 'host' : null,
      black_id: mpSideSelect.value === 'b' ? 'host' : null,

      updated_at: new Date().toISOString()
    })
    .select()
    .single()

  if (error) {
    mpShowModal("Server Error", error.message)
    return
  }

  // ===============================
  // FINALIZE CLIENT STATE
  // ===============================
  roomId = data.id
  mySide = mpSideSelect.value

  sessionStorage.setItem('mpRole', 'host')
  sessionStorage.setItem('mpSide', mySide)
  mpSaveSession()

  updateMpPlayerLabels()
  mpApplyPOV()

  mpRoomCode.textContent = `Room Code: ${code} (copied)`
  navigator.clipboard.writeText(code).catch(() => {})

  setTimeout(initLiveMatchBoard, 100)
  subscribeRoom()

  mpShowModal("Custom Game Ready", "‚ôü Game created from FEN ‚Äî waiting for opponent")
}


/* ===============================
   REALTIME SYNC
================================ */

function subscribeRoom() {
  if (channel) return

  channel = supabase
    .channel(`live-match-${roomId}`)
    .on(
      'postgres_changes',
      {
        event: 'UPDATE',
        schema: 'public',
        table: 'live_match_rooms',
        filter: `id=eq.${roomId}`
      },
      payload => {
        const row = payload.new
        if (!row || !row.fen) return
        // üèÜ XP HOOK ‚Äî fires for ALL win types (mate, resign, time)
grantLiveMatchXPIfWinner(row)


        // üîí Reconnect safety ‚Äî always trust server
serverTurn = row.turn
moveLock = false


        // Re-enable rematch button when request clears
if (!row.rematch_request && mpRematchBtn.disabled) {
  mpRematchBtn.disabled = false
  mpRematchBtn.textContent = 'Rematch'
}

                // Reset rematch guard when request clears
      // Reset guard ONLY when server clears the request
if (row.rematch_request === false) {
  rematchHandled = false
}


// üîä Only play sound for OPPONENT moves
if (
  row.pgn &&
  row.pgn !== lastPgn &&
  row.turn === mySide // server turn flips AFTER opponent moves
) {
  mpPlayMoveSoundFromPGN(row.pgn)
}

lastPgn = row.pgn


mpMovesBox.textContent = row.pgn || ''
lastPgn = row.pgn || lastPgn




        // Server is the boss
       serverTurn = row.turn


if (row.status !== 'finished') {
  startClock()
} else {
  stopClock()
}

/* ===============================
   DRAW OFFER (REMOTE)
================================ */
if (
  row.draw_request &&
  row.draw_by !== mySide &&
  !mpGameOver
) {
  mpDrawModal.classList.remove('hidden')
}

// Reset draw button if cleared
if (!row.draw_request && mpDrawBtn.disabled) {
  mpDrawBtn.disabled = false
  mpDrawBtn.textContent = 'ü§ù Draw'
}

       if (row.fen !== lastFen) {
  mpChess.load(row.fen)
  lastFen = row.fen

  const lastMove = mpGetLastMoveFromPGN(row.pgn)

  // üîä Play sound for opponent
  if (lastMove && row.turn === mySide) {
    mpPlayMoveSound(lastMove)
    mpDrawArrow(lastMove.from, lastMove.to)
  }

  if (mpBoard) {
    mpBoard.position(row.fen, true)
  }

  moveLock = false
}


/* ===============================
   DRAW RESULT
================================ */
if (
  row.status === 'finished' &&
  row.winner === 'draw' &&
  !mpGameOver
) {
  mpGameOver = true
  stopClock()
  mpShowModal('Draw', 'ü§ù Game ended in a draw')
  mpArchiveSaveGame()
  mpClearSession()
  mpEndAndUnlock()

  
  return
}


if (
  row.rematch_request &&
  row.rematch_by !== mySide &&
  !rematchHandled
) {
  rematchHandled = true
  mpRematchModal.classList.remove('hidden')
}

/* ===============================
   RESIGN DETECTION (REMOTE)
================================ */

if (
  row.status === 'finished' &&
  row.resigned_by &&
  !mpGameOver
) {
  mpGameOver = true
  stopClock()

  if (row.resigned_by === mySide) {
    mpShowModal('Game Over', 'üè≥ You resigned. Opponent wins.')
  } else {
    mpShowModal('Victory', 'üéâ Opponent resigned. You win!')
  }
  mpArchiveSaveGame()
mpClearSession()
mpEndAndUnlock()



  return
}

/* ===============================
   CHECKMATE (REMOTE)
================================ */

if (
  row.status === 'finished' &&
  row.winner &&
  !mpGameOver
) {
  mpGameOver = true
  stopClock()

  if (row.winner === mySide) {
    mpShowModal('Victory!', '‚ôüÔ∏è You won by CHECKMATE!')
  } else {
    mpShowModal('Defeat', 'üíÄ You were CHECKMATED.')
  }
  mpArchiveSaveGame()
mpClearSession()
mpEndAndUnlock()



  return
}


updateClocks(row)

      }
    )
    .subscribe()
}



/* ===============================
   CLOCK DISPLAY
================================ */

function updateClocks(row) {
  mpUpdateClockUI(clockWhite, row.w_time)
  mpUpdateClockUI(clockBlack, row.b_time)
}

function mpUpdateClockUI(el, sec) {
  const m = Math.floor(sec / 60)
  const s = sec % 60
  el.textContent = `${m}:${s.toString().padStart(2, '0')}`

  if (sec <= 10) el.classList.add('low')
  else el.classList.remove('low')
}





function onMouseoverSquare(square) {
  const moves = mpChess.moves({ square, verbose: true })
  if (!moves.length) return

  moves.forEach(m => {
    const el = document.querySelector(`#mpBoard .square-${m.to}`)
    if (el) el.style.boxShadow = 'inset 0 0 0 3px rgba(0,255,0,0.4)'
  })
}

function onMouseoutSquare() {
  document
    .querySelectorAll('#mpBoard .square-55d63')
    .forEach(sq => (sq.style.boxShadow = ''))
}


/* ===============================
   AUTO REJOIN SYSTEM
================================ */

window.addEventListener('load', async () => {
  const saved = localStorage.getItem('mp_session')
  if (!saved) return

  try {
    const { roomId: savedRoom } = JSON.parse(saved)
    if (!savedRoom) return

    const { data } = await supabase
      .from('live_match_rooms')
      .select('*')
      .eq('id', savedRoom)
      .single()

    if (!data) return

    // Only rejoin if game still running
    if (data.status === 'playing') {
      document.getElementById('navLiveMatch').click()
      mpRejoinRoomById(savedRoom)
      mpShowModal('Reconnected', '‚ôüÔ∏è You are back in the game!')
    } else {
      mpClearSession()
    }
  } catch {
    mpClearSession()
  }
})



const mpHowToBtn = document.getElementById('mpHowToBtn')
const mpHowToModal = document.getElementById('mpHowToModal')

if (mpHowToBtn && mpHowToModal) {
  mpHowToBtn.onclick = e => {
    e.stopPropagation()
    mpHowToModal.classList.remove('hidden')
  }

  // Close when clicking outside box
  mpHowToModal.onclick = () => {
    mpHowToModal.classList.add('hidden')
  }

  // Prevent box clicks from closing modal
  mpHowToModal
    .querySelector('.mp-howto-box')
    .addEventListener('click', e => e.stopPropagation())
}



const mpTabLive = document.getElementById('mpTabLive')
const mpTabArchive = document.getElementById('mpTabArchive')
const mpLivePanel = document.getElementById('mpLivePanel')
const mpArchivePanel = document.getElementById('mpArchivePanel')


mpTabLive.onclick = () => {
mpTabLive.classList.add('active')
mpTabArchive.classList.remove('active')
mpLivePanel.style.display = 'block'
mpArchivePanel.style.display = 'none'
}


mpTabArchive.onclick = () => {
mpTabArchive.classList.add('active')
mpTabLive.classList.remove('active')
mpLivePanel.style.display = 'none'
mpArchivePanel.style.display = 'block'
mpLoadArchive()
}


























/* ==================================================
 FLOATING CHAT ‚Äî SUPABASE FINAL (profiles-based)
================================================== */





document.addEventListener('DOMContentLoaded', () => {
  initChat()
})

let unreadBroadcast = 0
let unreadPrivate = 0
const userCache = {}   // { userId: username }


const bubbleBadge = document.getElementById('chatBubbleBadge')
const broadcastBadge = document.getElementById('broadcastBadge')
const usersBadge = document.getElementById('usersBadge')



function updateBadges() {
  const total = unreadBroadcast + unreadPrivate

  // Bubble badge
  if (total > 0) {
    bubbleBadge.textContent = total
    bubbleBadge.classList.remove('hidden')
  } else {
    bubbleBadge.classList.add('hidden')
  }

  // Broadcast badge
  if (unreadBroadcast > 0) {
    broadcastBadge.textContent = unreadBroadcast
    broadcastBadge.classList.remove('hidden')
  } else {
    broadcastBadge.classList.add('hidden')
  }

  // Users badge
  if (unreadPrivate > 0) {
    usersBadge.textContent = unreadPrivate
    usersBadge.classList.remove('hidden')
  } else {
    usersBadge.classList.add('hidden')
  }
}

const messageSound = new Audio('./sounds/message.mp3')
messageSound.volume = 0.7

function playMessageSound() {
  try {
    messageSound.currentTime = 0
    messageSound.play().catch(() => {})
  } catch (e) {}
}



async function initChat() {

  /* ===============================
     DOM ELEMENTS
  =============================== */
  const bubble = document.getElementById('chatBubble')
  const chat = document.getElementById('chatWindow')
  const minimize = document.getElementById('chatMinimize')
  const sendBtn = document.getElementById('chatSend')
  const input = document.getElementById('chatInput')
  const messagesBox = document.getElementById('chatMessages')
  const usersBox = document.getElementById('chatUsers')
  const tabs = document.querySelectorAll('.chat-tab')
  const contentBox = document.getElementById('chatContent') // üëà SCROLL CONTAINER


  if (!bubble || !chat) return

  /* ===============================
     AUTH USER
  =============================== */
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return

  let currentMode = 'global'      // global | private
  let activeReceiver = null
  const userUnreadMap = {}   // { userId: count }

  const broadcastCache = []
const privateCache = {}

async function preloadUsers() {
  const { data, error } = await supabase
    .from('profiles')
    .select('id, username')

  if (error || !data) return

  data.forEach(p => {
    userCache[p.id] = p.username
  })
}

const isAdmin = async () => {
  const { data } = await supabase
    .from('profiles')
    .select('role')
    .eq('id', user.id)
    .single()

  return data?.role === 'admin'
}


  /* ===============================
     ADMIN CHAT ENABLE CHECK
  =============================== */
  async function isChatEnabled() {
    const { data } = await supabase
      .from('chat_settings')
      .select('chat_enabled')
      .eq('id', 1)
      .single()

    return data?.chat_enabled === true
  }

  /* ===============================
     TOGGLE CHAT
  =============================== */
  function toggleChat() {
    chat.classList.toggle('chat-hidden')
    chat.style.display = chat.classList.contains('chat-hidden') ? 'none' : 'flex'
  }

  bubble.onclick = (e) => {
    e.stopPropagation()
    toggleChat()
  }

  minimize.onclick = (e) => {
    e.stopPropagation()
    chat.classList.add('chat-hidden')
    chat.style.display = 'none'
  }

  /* ===============================
     TAB SWITCHING
  =============================== */
tabs.forEach(tab => {
  tab.onclick = () => {
    tabs.forEach(t => t.classList.remove('active'))
    tab.classList.add('active')

    if (tab.dataset.tab === 'users') {
      currentMode = 'private'
      activeReceiver = null

      unreadPrivate = 0
      updateBadges()

      usersBox.classList.remove('chat-hidden')
      messagesBox.classList.add('chat-hidden')

      loadUsers()
    } else {
      currentMode = 'global'
      activeReceiver = null

      unreadBroadcast = 0
      updateBadges()

      usersBox.classList.add('chat-hidden')
      messagesBox.classList.remove('chat-hidden')

      renderMessages(broadcastCache)
    }
  }
})

  /* ===============================
     LOAD USERS (FROM PROFILES)
  =============================== */
async function loadUsers() {
  usersBox.innerHTML = ''

  const { data, error } = await supabase
    .from('profiles')
    .select('id, username, role')
    .eq('active', true)
    .order('username')

  if (error) {
    usersBox.textContent = 'Failed to load users'
    return
  }

  data.forEach(p => {
    if (p.id === user.id) return

    const div = document.createElement('div')
   const count = userUnreadMap[p.id] || 0
div.classList.add('user-row')

div.innerHTML = `
  <span>${p.username}</span>
  ${count > 0 ? `<span class="unread-badge">${count}</span>` : ''}
`



   if (p.role === 'admin') {
  div.style.fontWeight = 'bold'

  const nameSpan = div.querySelector('span')
  if (nameSpan) {
    nameSpan.textContent += ' (Admin)'
  }
}

 div.onclick = () => {
  userUnreadMap[p.id] = 0
  markPrivateAsRead(p.id)   // üëà HERE

  activeReceiver = p.id
  usersBox.classList.add('chat-hidden')
  messagesBox.classList.remove('chat-hidden')

  if (Array.isArray(privateCache[p.id]) && privateCache[p.id].length > 0) {
  renderMessages(privateCache[p.id])
} else {
  loadPrivateChat() // fallback to DB if cache empty or not ready
}

setTimeout(scrollToBottom, 50) // üëà AUTO JUMP TO LATEST
  loadUsers()
}


    usersBox.appendChild(div)
  })
}

  /* ===============================
     LOAD BROADCAST
  =============================== */
async function loadBroadcast() {
  const { data } = await supabase
    .from('chat_messages')
    .select('*')
    .is('receiver_id', null)
    .eq('deleted', false)   // üëà IMPORTANT
    .order('created_at', { ascending: true })

  broadcastCache.length = 0
  if (Array.isArray(data)) {
    data.forEach(m => broadcastCache.push(m))
  }

  renderMessages(broadcastCache)
}



  /* ===============================
     LOAD PRIVATE CHAT
  =============================== */
async function loadPrivateChat() {
  if (!activeReceiver) return

  const { data } = await supabase
    .from('chat_messages')
    .select('*')
    .or(
      `and(sender_id.eq.${user.id},receiver_id.eq.${activeReceiver}),
       and(sender_id.eq.${activeReceiver},receiver_id.eq.${user.id})`
    )
    .order('created_at', { ascending: true })

 privateCache[activeReceiver] = Array.isArray(data) ? data : []
renderMessages(privateCache[activeReceiver])

}

async function markPrivateAsRead(otherUserId) {
  await supabase
    .from('chat_messages')
    .update({ read_at: new Date().toISOString() })
    .eq('receiver_id', user.id)
    .eq('sender_id', otherUserId)
    .is('read_at', null)
}

function scrollToBottom() {
  requestAnimationFrame(() => {
    contentBox.scrollTop = contentBox.scrollHeight
  })
}


async function preloadUnreadCounts() {
  const { data, error } = await supabase
    .from('chat_messages')
    .select('sender_id')
    .eq('receiver_id', user.id)
    .is('read_at', null)

  if (error || !Array.isArray(data)) return

  data.forEach(m => {
    userUnreadMap[m.sender_id] =
      (userUnreadMap[m.sender_id] || 0) + 1
  })

  unreadPrivate = Object.values(userUnreadMap).reduce((a, b) => a + b, 0)
  updateBadges()
}




  /* ===============================
     SEND MESSAGE
  =============================== */
  sendBtn.onclick = async () => {
    const text = input.value.trim()
    if (!text) return

    const enabled = await isChatEnabled()
    if (!enabled) {
      alert('Chat disabled by admin')
      return
    }

    await supabase.from('chat_messages').insert({
      sender_id: user.id,
      receiver_id: currentMode === 'private' ? activeReceiver : null,
      message: text
    })

    input.value = ''
  }

  // ===============================
// ENTER KEY SEND (ISOLATED)
// ===============================
input.addEventListener('keydown', (e) => {
  // Enter = send
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault()
    sendBtn.click()
  }
})


  /* ===============================
     REALTIME
  =============================== */
supabase
  .channel('olympus-chat')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'chat_messages'
  }, payload => {

    /* ===============================
       SOFT DELETE (ADMIN)
    =============================== */
    if (payload.eventType === 'UPDATE' && payload.new?.deleted === true) {
      const idx = broadcastCache.findIndex(m => m.id === payload.new.id)
      if (idx !== -1) {
        broadcastCache.splice(idx, 1)
        if (currentMode === 'global') {
          renderMessages(broadcastCache)
        }
      }
      return
    }

    if (payload.eventType !== 'INSERT') return

    const msg = payload.new
    const isMine = msg.sender_id === user.id

    /* ===============================
       BROADCAST
    =============================== */
    if (msg.receiver_id === null) {
      broadcastCache.push(msg)

      if (currentMode === 'global' && !chat.classList.contains('chat-hidden')) {
        renderMessages(broadcastCache)
      } else if (!isMine) {
        unreadBroadcast++
        updateBadges()
        playMessageSound()   // üîî ALWAYS PLAY
      }
      return
    }

    /* ===============================
       PRIVATE
    =============================== */
    const other =
      msg.sender_id === user.id ? msg.receiver_id : msg.sender_id

    if (!privateCache[other]) privateCache[other] = []
    privateCache[other].push(msg)

    if (
      currentMode === 'private' &&
      activeReceiver === other &&
      !chat.classList.contains('chat-hidden')
    ) {
      renderMessages(privateCache[other])
   } else if (!isMine) {
  unreadPrivate++
  userUnreadMap[other] = (userUnreadMap[other] || 0) + 1
  updateBadges()
  playMessageSound()
  loadUsers()
}

  })
  .subscribe()





  /* ===============================
     RENDER MESSAGE
  =============================== */
async function renderMessages(list) {
  messagesBox.innerHTML = ''
  if (!Array.isArray(list)) return

  const admin = await isAdmin()

  list.forEach(msg => {
    const isMine = msg.sender_id === user.id

    /* ===============================
       PRIVATE CHAT (WHATSAPP STYLE)
    =============================== */
    if (msg.receiver_id !== null) {
      const row = document.createElement('div')
      row.className = `chat-msg-row ${isMine ? 'chat-msg-right' : 'chat-msg-left'}`

      const bubble = document.createElement('div')
      bubble.className = `chat-bubble ${isMine ? 'mine' : 'other'}`
      bubble.textContent = msg.message

      row.appendChild(bubble)
      messagesBox.appendChild(row)
      return
    }

    /* ===============================
       BROADCAST (UNCHANGED)
    =============================== */
    const row = document.createElement('div')
    row.style.display = 'flex'
    row.style.alignItems = 'center'
    row.style.justifyContent = 'space-between'
    row.style.gap = '8px'

    const text = document.createElement('div')
    text.style.flex = '1'

    const name = userCache?.[msg.sender_id] || 'Unknown'
    text.innerHTML = `<strong>${name}:</strong> ${msg.message}`

    row.appendChild(text)

    // üóëÔ∏è ADMIN DELETE (BROADCAST ONLY)
    if (admin) {
      const del = document.createElement('span')
      del.textContent = 'üóëÔ∏è'
      del.style.cursor = 'pointer'
      del.style.opacity = '0.6'

      del.onclick = async () => {
        const ok = confirm('Delete this message?')
        if (!ok) return

        await supabase
          .from('chat_messages')
          .update({ deleted: true })
          .eq('id', msg.id)

        const idx = broadcastCache.findIndex(m => m.id === msg.id)
        if (idx !== -1) broadcastCache.splice(idx, 1)

        renderMessages(broadcastCache)
      }

      row.appendChild(del)
    }

    messagesBox.appendChild(row)
  })

  scrollToBottom()

}

async function preloadPrivateChats() {
  const { data, error } = await supabase
    .from('chat_messages')
    .select('*')
    .or(`sender_id.eq.${user.id},receiver_id.eq.${user.id}`)
    .eq('deleted', false)
    .order('created_at', { ascending: true })

  if (error) {
    console.error('[CHAT] Preload error:', error)
    return
  }

  if (!Array.isArray(data)) return

  data.forEach(msg => {
    const other =
      msg.sender_id === user.id
        ? msg.receiver_id
        : msg.sender_id

    if (!other) return

    if (!privateCache[other]) {
      privateCache[other] = []
    }

    privateCache[other].push(msg)
  })

  console.log('[CHAT] Preloaded private chats:', Object.keys(privateCache))
}




  /* ===============================
     INITIAL LOAD
  =============================== */
  chat.classList.add('chat-hidden')
  chat.style.display = 'none'
  await preloadUsers()
await preloadPrivateChats()
await preloadUnreadCounts() // üëà PERSIST ALERTS
loadBroadcast()


}











/* =========================================================
   ANALYSIS BOARD SUB-TAB HOOK (FULLY ISOLATED)
========================================================= */
(() => {

  function initAnalysisSubTabs() {
    const root = document.getElementById("board-section");
    if (!root) return;

    const buttons = root.querySelectorAll(
      '.analysis-subtab[data-tab]'
    );

    const panels = root.querySelectorAll(
      '.analysis-subtab-panel'
    );

    if (!buttons.length || !panels.length) return;

    buttons.forEach(btn => {
      btn.addEventListener("click", () => {

        // deactivate all buttons
        buttons.forEach(b =>
          b.classList.remove("active")
        );

        // hide all panels
        panels.forEach(p =>
          p.classList.add("hidden")
        );

        // activate clicked button
        btn.classList.add("active");

        const targetId = btn.getAttribute("data-tab");
        if (!targetId) return;

        const targetPanel = root.querySelector(
          `#${targetId}`
        );

        if (targetPanel) {
          targetPanel.classList.remove("hidden");
        }
      });
    });
  }

  // DOM ready safe
  if (document.readyState === "loading") {
    document.addEventListener(
      "DOMContentLoaded",
      initAnalysisSubTabs
    );
  } else {
    initAnalysisSubTabs();
  }

})();


// ===============================
// ‚öîÔ∏è PUZZLE BATTLE BOARD
// ===============================
let battleBoard = null;
let battleChess = null;

function initPuzzleBattleBoard() {
  if (battleBoard) return;

  battleChess = new Chess();

  battleBoard = Chessboard("puzzleBattleBoard", {
    position: "start",
    draggable: true,
    pieceTheme: getPieceThemePath(currentPieceTheme),

    onDragStart: (source, piece) => {
      if (battleYouFrozen) return false;


    if (!battleCurrentPuzzle) return false;

      if (puzzleSolved) return false;

    if (battleSolved) return false;

if (
  (battleSideToMove === "w" && piece.startsWith("b")) ||
  (battleSideToMove === "b" && piece.startsWith("w"))
)
 {
        return false;
      }

      return true;
    },

    onDrop: (source, target) => {
       return handleBattleMove(source, target);
    }
  });

 enableBattleTapMove();

}

const puzzleBattleBtn = document.querySelector(
  '.nav-btn[data-tab="puzzlebattle"]'
);

if (puzzleBattleBtn) {
  puzzleBattleBtn.addEventListener("click", () => {
    setTimeout(initPuzzleBattleBoard, 100);
  });
}

// ===============================
// ‚öîÔ∏è PUZZLE BATTLE STATE
// ===============================
let battleRoom = null;
let battlePlayerId = null;
let battleRole = null; // "player1" or "player2"
let battleTimer = null;
let battleTimeLeft = 180; // 3 minutes
let battleChannel = null;
let battlePuzzleList = [];
let battlePuzzleIndex = 0;
let battleSeed = 0;
let battleCurrentPuzzle = null;
let battleSolved = false;
let battleSideToMove = "w";
let battleStarted = false;
let battleStartAt = null;
let battleTargetScore = null; // Score to beat
let battleWinnerDeclared = false;
let battleYouFrozen = false;



function freezeBattleBoard() {
  if (battleYouFrozen) return;

  battleYouFrozen = true;

  if (battleBoard) {
    battleBoard.draggable = false;
  }

  const boardEl = document.getElementById("puzzleBattleBoard");
  if (boardEl) {
    boardEl.classList.add("battle-frozen");
  }

  console.log("üßä YOUR board frozen (you lost all lives)");
}





async function forceStartBattle() {
  if (!battleRoom) return;

  // Wait until board exists
  if (!battleBoard) {
    setTimeout(forceStartBattle, 200);
    return;
  }

  if (battleStarted) return;

  const { data: room } = await supabase
    .from("puzzle_battle_rooms")
    .select("status")
    .eq("id", battleRoom.id)
    .single();

  if (!room || room.status !== "active") {
    setTimeout(forceStartBattle, 500);
    return;
  }

  battleStarted = true;
  battleXPGranted = false;


  console.log("‚öîÔ∏è Battle start synced for this client");

  document.getElementById("battleStatus").textContent =
    "‚öîÔ∏è Battle started ‚Äî puzzles loading!";

  // Clean reset
  battleTimeLeft = 180;
  battleTimer = null;
  battlePuzzleList = [];
  battlePuzzleIndex = 0;
  battleSolved = false;

  battleStartAt = Date.now();
startBattleTimer();
loadBattlePuzzles();

}





function seededRandom(seed) {
  let x = Math.sin(seed++) * 10000;
  return x - Math.floor(x);
}

function seededShuffle(array, seed) {
  const arr = [...array];
  let currentSeed = seed;

  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(seededRandom(currentSeed) * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
    currentSeed++;
  }
  return arr;
}

async function loadBattlePuzzles() {
  const { data, error } = await supabase
    .from("puzzle_rush_mate1")
    .select("id, fen, solution, side_to_move")
    .eq("is_active", true);

  if (error || !data?.length) {
    console.error("‚ùå Failed to load puzzles", error);
    return;
  }

  battleSeed = battleRoom.puzzle_seed;
  battlePuzzleList = seededShuffle(data, battleSeed);
  battlePuzzleIndex = 0;

  loadNextBattlePuzzle();
}


function loadNextBattlePuzzle() {
  if (!battlePuzzleList.length) return;

  const puzzle = battlePuzzleList[battlePuzzleIndex++];
  if (!puzzle) return;

  battleCurrentPuzzle = {
    fen: puzzle.fen,
    solution: puzzle.solution.replace(/[?!+#]/g, "").trim(),
    side: puzzle.side_to_move
  };

  battleSolved = false;

  battleChess.reset();
  battleChess.load(battleCurrentPuzzle.fen);

// üî• Force correct side to move
if (battleChess.turn() !== battleCurrentPuzzle.side) {
  const parts = battleCurrentPuzzle.fen.split(" ");
  parts[1] = battleCurrentPuzzle.side;
  const fixedFen = parts.join(" ");
  battleChess.load(fixedFen);
}


  battleSideToMove = battleCurrentPuzzle.side;

  battleBoard.orientation(
    battleSideToMove === "w" ? "white" : "black"
  );

  battleBoard.position(battleCurrentPuzzle.fen, false);

  console.log(
    "‚öîÔ∏è Battle puzzle loaded:",
    battleCurrentPuzzle.fen,
    "Side:",
    battleSideToMove
  );
}


function handleBattleMove(source, target) {
  if (battleYouFrozen) return "snapback";   // üßä STEP 1
  if (!battleCurrentPuzzle || battleSolved) return "snapback";

  const move = battleChess.move({
    from: source,
    to: target,
    promotion: "q"
  });

  if (!move) return "snapback";

  const played = move.san.replace(/[+#]/g, "").trim();
  const expected = battleCurrentPuzzle.solution;

  console.log("‚öîÔ∏è Played:", played, "Expected:", expected);

  // ‚úÖ CORRECT MOVE
  if (played === expected) {
    playBattleCorrectSound();

    battleSolved = true;
    updateBattleScore(true);

    

    setTimeout(() => {
      loadNextBattlePuzzle();
    }, 500);

    return;
  }

  // ‚ùå WRONG MOVE ‚Äî UNDO IT
  battleChess.undo();
  playBattleWrongSound();

  battleBoard.position(battleChess.fen(), false);

  updateBattleScore(false);

  return "snapback";
}



function generateRoomCode() {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}

document.getElementById("createBattleRoom").onclick = async () => {
 const roomCode = generateRoomCode();
const input = document.getElementById("battleRoomCode");

input.value = roomCode;

// üìã Auto-copy
copyToClipboard(roomCode).then(() => {
  document.getElementById("battleStatus").textContent =
    "Room created ‚Äî code copied! Send it to your opponent ‚öîÔ∏è";
});

  document.getElementById("battleRoomCode").value = roomCode;

  const puzzleSeed = Math.floor(Math.random() * 1000000);

  const { data, error } = await supabase
    .from("puzzle_battle_rooms")
   .insert([{
  room_code: roomCode,
  mode: "3",
  puzzle_seed: puzzleSeed,
  player1_id: currentUser.id,
  status: "waiting"
}])
    .select()
    .single();

  if (error) {
    console.error(error);
    return alert("Failed to create room");
  }

  battleRoom = data;
  battleRole = "player1";

  await supabase.from("puzzle_battle_players").insert([{
    room_id: battleRoom.id,
    player_id: currentUser.id
  }]);

  document.getElementById("battleStatus").textContent =
    "Room created ‚Äî waiting for opponent...";

  subscribeToBattleRoom();
  setTimeout(forceStartBattle, 500);

};

document.getElementById("joinBattleRoom").onclick = async () => {
  const code = document.getElementById("battleRoomCode").value.trim();
  if (!code) return alert("Enter room code");

  const { data: room, error } = await supabase
    .from("puzzle_battle_rooms")
    .select("*")
    .eq("room_code", code)
    .eq("status", "waiting")
    .single();

  if (error || !room) {
    return alert("Room not found or already started");
  }

  battleRoom = room;
  battleRole = "player2";

  await supabase.from("puzzle_battle_rooms")
    .update({
      player2_id: currentUser.id,
      status: "active"
    })
    .eq("id", room.id);

  await supabase.from("puzzle_battle_players").insert([{
    room_id: room.id,
    player_id: currentUser.id
  }]);

  document.getElementById("battleStatus").textContent =
    "Opponent joined ‚Äî battle starting!";
    // üîä Pre-unlock audio (user gesture context)
playBattleStartSound();


  subscribeToBattleRoom();
  setTimeout(forceStartBattle, 500);

  
};

function subscribeToBattleRoom() {
  if (battleChannel) return;

  battleChannel = supabase.channel(
    "battle-" + battleRoom.id,
    { config: { broadcast: { self: true }, presence: { key: currentUser.id } } }
  );

  battleChannel
    .on("postgres_changes", {
  event: "UPDATE",
  schema: "public",
  table: "puzzle_battle_rooms"
}, payload => {
  const row = payload.new;
  if (!row || row.id !== battleRoom.id) return;

  // üîÑ Start sync
  if (row.status === "active") {
    forceStartBattle();
  }

  // üèÜ Result sync
if (row.status === "finished" && row.result) {
  // üõë Don't override local winner
  if (battleWinnerDeclared) return;

  freezeBattleBoard();

  if (row.result === "draw") {
    showBattleResultUI("Draw!");
    
  } else if (row.winner_id === currentUser.id) {
    showBattleResultUI("You Win!");
  } else {
    showBattleResultUI("Opponent Wins!");
  }
}

})


    .on("postgres_changes", {
      event: "UPDATE",
      schema: "public",
      table: "puzzle_battle_players"
    }, payload => {
      const row = payload.new;
      console.log("üî• REALTIME EVENT:", row);

      if (!row || row.room_id !== battleRoom.id) return;
      syncBattleHUD(row);
    })

    .subscribe(status => {
      console.log("üîå Realtime status:", status);
      if (status === "SUBSCRIBED") {
        setTimeout(forceStartBattle, 500);
      }
    });
}





function startBattleTimer() {
  if (battleTimer) return;

  const timerEl = document.getElementById("battleTimer");

  battleTimer = setInterval(() => {
    if (!battleStartAt) return;

    const elapsed = Math.floor((Date.now() - battleStartAt) / 1000);
    battleTimeLeft = Math.max(180 - elapsed, 0);

if (battleTimeLeft <= 0) {
  clearInterval(battleTimer);
  battleTimer = null;
  timerEl.textContent = "00:00";

  if (!battleWinnerDeclared) {
    decideWinnerByScore();
  }
  return;
}


    const minutes = Math.floor(battleTimeLeft / 60);
    const seconds = battleTimeLeft % 60;

    timerEl.textContent =
      String(minutes).padStart(2, "0") + ":" +
      String(seconds).padStart(2, "0");
  }, 250); // smoother sync
}

async function decideWinnerByScore() {
  const { data } = await supabase
    .from("puzzle_battle_players")
    .select("player_id,score")
    .eq("room_id", battleRoom.id);

  if (!data || data.length < 2) return;

  const you = data.find(p => String(p.player_id) === String(currentUser.id));
  const opp = data.find(p => String(p.player_id) !== String(currentUser.id));

  if (!you || !opp) return;

  if (you.score > opp.score) {
    declareBattleWinner("you");
  } else {
    declareBattleWinner("opponent");
  }
}

async function checkBattleEndState() {
  if (battleWinnerDeclared) return;

  const { data } = await supabase
    .from("puzzle_battle_players")
    .select("player_id, score, lives")
    .eq("room_id", battleRoom.id);

  if (!data || data.length < 2) return;

  const you = data.find(p => String(p.player_id) === String(currentUser.id));
  const opp = data.find(p => String(p.player_id) !== String(currentUser.id));

  if (!you || !opp) return;

  const youDead = you.lives <= 0;
  const oppDead = opp.lives <= 0;

  // üõë BOTH DEAD ‚Üí DRAW OR SCORE DECIDE
  if (youDead && oppDead) {
    if (you.score > opp.score) {
      declareBattleWinner("you");
    } else if (opp.score > you.score) {
      declareBattleWinner("opponent");
    } else {
      declareBattleDraw(); // ‚öñÔ∏è TRUE DRAW
    }
  }
}

async function declareBattleDraw() {
  if (battleWinnerDeclared) return;
  battleWinnerDeclared = true;

  freezeBattleBoard();

  if (battleRole === "player1") {
    await supabase
      .from("puzzle_battle_rooms")
      .update({
        status: "finished",
        result: "draw",
        winner_id: null
      })
      .eq("id", battleRoom.id);
  }

  showBattleResultUI("Draw!");
  // ü™ü MODAL ‚Äî DRAW RESULT
BattleModal.show(
  "ü§ù It‚Äôs a Draw!",
  "üåü Both of you played great!"
);

}

function showBattleResultUI(text) {
  const resultBox = document.getElementById("battleResult");
  const label = document.getElementById("battleWinnerText");

  if (!resultBox || !label) return;

  label.textContent = text;
  resultBox.classList.remove("hidden");

  if (battleTimer) {
    clearInterval(battleTimer);
    battleTimer = null;
  }

  battleStarted = false;
  battleSolved = true;
}


async function updateBattleScore(correct) {
  if (battleWinnerDeclared) return;


  const { data } = await supabase
    .from("puzzle_battle_players")
    .select("*")
    .eq("room_id", battleRoom.id)
    .eq("player_id", currentUser.id)
    .single();

  if (!data) return;

  const newLives = correct ? data.lives : data.lives - 1;
  const newScore = correct ? data.score + 1 : data.score;

  await supabase
    .from("puzzle_battle_players")
    .update({
      lives: newLives,
      score: newScore
    })
    .eq("id", data.id);

  // ‚ù§Ô∏è Local UI
  renderBattleLives(newLives);

  // üíÄ If YOU died ‚Äî set target score
  if (newLives <= 0 && battleTargetScore === null) {
    freezeBattleBoard();   // üßä YOU died ‚Äî freeze YOU
    battleTargetScore = newScore;
    showBattleTarget();
    
  }

  // üèÜ If target exists and YOU crossed it ‚Äî WIN
if (
  battleTargetScore !== null &&
  newScore > battleTargetScore &&
  !battleWinnerDeclared
) {
  declareBattleWinner("you");
}

// üîç Global end check ‚Äî BOTH players dead?
await checkBattleEndState();

}

function showBattleTarget() {
  const el = document.getElementById("battleStatus");
  if (!el) return;

  el.textContent =
    "üéØ Target set! must score " +
    (battleTargetScore + 1) +
    " to win!";
}


function copyToClipboard(text) {
  if (navigator.clipboard && window.isSecureContext) {
    return navigator.clipboard.writeText(text);
  } else {
    // Fallback for HTTP / older browsers
    const input = document.createElement("input");
    input.value = text;
    document.body.appendChild(input);
    input.select();
    document.execCommand("copy");
    document.body.removeChild(input);
    return Promise.resolve();
  }
}


// ‚ù§Ô∏è Render hearts based on lives
function renderBattleLives(lives) {
  const hearts = document.querySelectorAll("#battleLivesBar .life");

  hearts.forEach((heart, index) => {
    if (index < lives) {
      heart.classList.remove("dead");
    } else {
      heart.classList.add("dead");
    }
  });
}

// üîÑ Live HUD sync
function syncBattleHUD(playerData) {
  if (!playerData) return;
  

  const isYou =
    String(playerData.player_id) === String(currentUser.id);

  console.log("üéØ HUD UPDATE:", isYou ? "YOU" : "OPP", playerData);

  // üèÜ Winner check
// üèÜ Winner check + XP sync
// üíÄ Opponent died ‚Äî set target
if (playerData.lives <= 0 && battleTargetScore === null) {
  battleTargetScore = playerData.score;
  showBattleTarget();
}

// üèÜ Opponent crossed target ‚Äî YOU LOSE
if (
  battleTargetScore !== null &&
  playerData.score > battleTargetScore &&
  !battleWinnerDeclared
) {
  declareBattleWinner("opponent");
}





  if (isYou) {
    // =====================
    // YOU ‚Äî TOP HUD
    // =====================
    document.getElementById("p1Score").textContent =
      playerData.score;
    document.getElementById("p1Lives").textContent =
      playerData.lives;

    // =====================
    // YOU ‚Äî POV PANEL
    // =====================
    document.getElementById("youStreak").textContent =
      playerData.score;

    renderPOVLives(
      document.getElementById("youLives"),
      playerData.lives
    );

    setPOVActive("you");
  } else {
    // =====================
    // OPPONENT ‚Äî TOP HUD
    // =====================
    document.getElementById("p2Score").textContent =
      playerData.score;
    document.getElementById("p2Lives").textContent =
      playerData.lives;

    // =====================
    // OPPONENT ‚Äî POV PANEL
    // =====================
    document.getElementById("oppStreak").textContent =
      playerData.score;

    renderPOVLives(
      document.getElementById("oppLives"),
      playerData.lives
    );

    setPOVActive("opponent");
  }
}





// üèÜ Declare winner
async function declareBattleWinner(winner) {
  if (battleWinnerDeclared) return;
  battleWinnerDeclared = true;

  const youWon = winner === "you";

  // üßä Freeze local board
  freezeBattleBoard();

  // üèÜ Save GLOBAL result so opponent also gets it
  if (battleRole === "player1") {
    await supabase
      .from("puzzle_battle_rooms")
      .update({
        status: "finished",
        result: youWon ? "you" : "opponent",
        winner_id: youWon ? currentUser.id : null
      })
      .eq("id", battleRoom.id);
  }

  // üñ•Ô∏è Show UI locally
  showBattleResultUI(youWon ? "You Win!" : "Opponent Wins!");
    // ü™ü MODAL ‚Äî MATCH RESULT
  BattleModal.show(
    "‚öîÔ∏è Battle Finished",
    youWon
      ? "üåü Awesome job! You played brilliantly!"
       : "üí™ Great effort! Keep practicing!"
  );


  // üèÜ XP ‚Äî ONLY FOR WINNER
  if (youWon) {
    await grantPuzzleBattleXP();
  }
}







// ===============================
// üî• POV STREAK SYSTEM
// ===============================
let youStreak = 0;
let oppStreak = 0;



// ===============================
// üéØ POV CORRECT COUNTER SYSTEM
// ===============================

// Highlight who just scored
function setPOVActive(player) {
  document.querySelector(".pov-card.you")?.classList.remove("active");
  document.querySelector(".pov-card.opponent")?.classList.remove("active");

  if (player === "you") {
    document.querySelector(".pov-card.you")?.classList.add("active");
  } else {
    document.querySelector(".pov-card.opponent")?.classList.add("active");
  }
}

// Render hearts
function renderPOVLives(el, lives) {
  let hearts = "";
  for (let i = 0; i < lives; i++) hearts += "‚ù§Ô∏è ";
  el.innerHTML = hearts.trim();
}

// Hook into YOUR score update
const _updateBattleScore = updateBattleScore;
updateBattleScore = async function(correct) {
  await _updateBattleScore(correct);

  // Read back your row to get TRUE score
  const { data } = await supabase
    .from("puzzle_battle_players")
    .select("score,lives")
    .eq("room_id", battleRoom.id)
    .eq("player_id", currentUser.id)
    .single();

  if (!data) return;

  document.getElementById("youStreak").textContent = data.score;
  renderPOVLives(document.getElementById("youLives"), data.lives);

  if (correct) setPOVActive("you");
};


// ===============================
// üì± PUZZLE BATTLE TAP-TAP MOVE
// ===============================
let battleTapSource = null;

function enableBattleTapMove() {
  const boardEl = document.getElementById("puzzleBattleBoard");
  if (!boardEl) return;

  const TAP_THRESHOLD = 8; // px ‚Äî adjust if needed (6‚Äì12 sweet spot)
  let startX = 0;
  let startY = 0;

  const getSquareFromPoint = (clientX, clientY) => {
    const rect = boardEl.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    const squareSize = size / 8;

    let x = clientX - rect.left;
    let y = clientY - rect.top;

    if (x < 0 || y < 0 || x > size || y > size) return null;

    const fileIndex = Math.floor(x / squareSize);
    const rankIndex = Math.floor(y / squareSize);
    const files = "abcdefgh";

    const isWhite = battleBoard.orientation() === "white";

    const file = isWhite
      ? files[fileIndex]
      : files[7 - fileIndex];

    const rank = isWhite
      ? 8 - rankIndex
      : rankIndex + 1;

    return file + rank;
  };

  boardEl.addEventListener("touchstart", e => {
    const t = e.touches[0];
    startX = t.clientX;
    startY = t.clientY;
  }, { passive: true });

  boardEl.addEventListener("touchend", e => {
    if (battleYouFrozen) return;   // üßä STEP 2 (touch)
    const t = e.changedTouches[0];

    const dx = Math.abs(t.clientX - startX);
    const dy = Math.abs(t.clientY - startY);

    // If finger moved too much, it was a drag ‚Äî ignore
    if (dx > TAP_THRESHOLD || dy > TAP_THRESHOLD) return;

    const square = getSquareFromPoint(t.clientX, t.clientY);
    if (!square) return;

    // FIRST TAP ‚Äî select
    if (!battleTapSource) {
      const piece = battleChess.get(square);
      if (!piece) return;

      if (
        (battleSideToMove === "w" && piece.color !== "w") ||
        (battleSideToMove === "b" && piece.color !== "b")
      ) {
        return;
      }

      battleTapSource = square;
      highlightBattleSquare(square);
      return;
    }

    // SECOND TAP ‚Äî move
    handleBattleMove(battleTapSource, square);
    clearBattleHighlights();
    battleTapSource = null;
  });

  // Desktop fallback
  boardEl.addEventListener("click", e => {
    if (battleYouFrozen) return;   // üßä STEP 3 (click)
    const square = getSquareFromPoint(e.clientX, e.clientY);
    if (!square) return;

    if (!battleTapSource) {
      const piece = battleChess.get(square);
      if (!piece) return;

      if (
        (battleSideToMove === "w" && piece.color !== "w") ||
        (battleSideToMove === "b" && piece.color !== "b")
      ) return;

      battleTapSource = square;
      highlightBattleSquare(square);
      return;
    }

    handleBattleMove(battleTapSource, square);
    clearBattleHighlights();
    battleTapSource = null;
  });
}





function highlightBattleSquare(square) {
  clearBattleHighlights();

  const sq = document.querySelector(
    `#puzzleBattleBoard .square-55d63[data-square="${square}"]`
  );

  if (sq) sq.classList.add("battle-selected");
}

function clearBattleHighlights() {
  document
    .querySelectorAll("#puzzleBattleBoard .battle-selected")
    .forEach(el => el.classList.remove("battle-selected"));
}


// ===============================
// üîä PUZZLE BATTLE SOUND HELPERS
// ===============================
let battleNextAudio = null;
let battleWrongAudio = null;
let battleStartAudio = null;

function playBattleStartSound() {
  if (battleStartAudio) {
    battleStartAudio.pause();
    battleStartAudio.currentTime = 0;
  }

  battleStartAudio = new Audio("./sounds/puzzle-rush-start.mp3");
  battleStartAudio.volume = 0.9;
  battleStartAudio.play().catch(() => {});
}

function playBattleCorrectSound() {
  if (battleNextAudio) {
    battleNextAudio.pause();
    battleNextAudio.currentTime = 0;
  }

  battleNextAudio = new Audio("./sounds/next.mp3");
  battleNextAudio.volume = 0.8;
  battleNextAudio.play().catch(() => {});
}

function playBattleWrongSound() {
  if (battleWrongAudio) {
    battleWrongAudio.pause();
    battleWrongAudio.currentTime = 0;
  }

  battleWrongAudio = new Audio("./sounds/wrong.mp3");
  battleWrongAudio.volume = 0.8;
  battleWrongAudio.play().catch(() => {});
}


// ===============================
// ü™ü BATTLE MODAL CONTROLLER (ISOLATED FOR YOUR HTML)
// ===============================
const BattleModal = (() => {
  const overlay = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const btn = document.getElementById("modalOkBtn");

  if (!overlay || !title || !body || !btn) {
    console.warn("‚ö†Ô∏è BattleModal DOM not found");
    return { show: () => {} };
  }

  let locked = false; // prevents double-fire

  const show = (t, m) => {
    if (locked) return;
    locked = true;

    title.textContent = t;
    body.textContent = m;

    overlay.classList.remove("hidden");

    btn.onclick = () => {
      overlay.classList.add("hidden");
      locked = false;
    };
  };

  return { show };
})();


















    // ============================================
    // START APP
    // ============================================
    document.addEventListener('DOMContentLoaded', initApp);
  </script>

  <!-- Result Modal -->
<div id="resultModal" class="modal-overlay hidden">
  <div class="modal-card">
    <h2 id="modalTitle">‚úÖ Solution Submitted!</h2>

    <div id="modalContent" class="modal-content"></div>

    <button class="btn-success modal-btn" onclick="closeResultModal()">
      OK
    </button>
  </div>
</div>

<!-- Floating Modal -->
<div id="floatingModal" class="modal-overlay hidden">
  <div class="modal-card">
    <h3 id="modalTitle">Title</h3>
    <p id="modalBody">Message</p>
    <button id="modalOkBtn" class="btn-success">OK</button>
  </div>
</div>

<!-- Promotion Modal -->
<div id="promotionModal" class="promotion-modal hidden">
  <div class="promotion-box">
    <button onclick="completePromotion('q')">‚ôï</button>
    <button onclick="completePromotion('r')">‚ôñ</button>
    <button onclick="completePromotion('b')">‚ôó</button>
    <button onclick="completePromotion('n')">‚ôò</button>
  </div>
</div>

<!-- VS COMPUTER PROMOTION MODAL (ISOLATED) -->
<div id="vsPromotionModal" class="promotion-modal hidden">
  <div class="promotion-box">
    <button onclick="completeVsPromotion('q')">‚ôï</button>
    <button onclick="completeVsPromotion('r')">‚ôñ</button>
    <button onclick="completeVsPromotion('b')">‚ôó</button>
    <button onclick="completeVsPromotion('n')">‚ôò</button>
  </div>
</div>


<!-- Attempt Details Modal -->
<div id="attemptDetailsModal" class="modal-overlay hidden">
  <div class="modal-card" style="width:700px; max-width:95%; text-align:left;">
    <h3 id="attemptDetailsTitle">Attempt Details</h3>

    <div id="attemptDetailsBody" style="max-height:60vh; overflow:auto;">
      <!-- dynamic content -->
    </div>

    <div style="text-align:right; margin-top:16px;">
      <button class="btn-secondary" onclick="closeAttemptDetails()">Close</button>
    </div>
  </div>
</div>

<!-- Grade Confirmation Modal -->
<div id="gradeConfirmModal" class="modal-overlay hidden">
  <div class="modal-card" style="width:420px; max-width:90%; text-align:center;">
    <h3 id="gradeConfirmTitle">Confirm Action</h3>

    <div id="gradeConfirmBody" class="modal-content">
      Are you sure?
    </div>

    <div style="display:flex; gap:12px; justify-content:center; margin-top:16px;">
      <button class="btn-success" id="gradeConfirmYesBtn">Yes</button>
      <button class="btn-secondary" onclick="closeGradeConfirm()">Cancel</button>
    </div>
  </div>
</div>

<!-- DELETE CONFIRM MODAL -->
<div id="deleteModal" class="modal-overlay hidden">
  <div class="modal-box">
    <h3>‚ö†Ô∏è Delete Assignment</h3>
    <p>
      This will permanently delete the assignment.<br><br>
      <strong>‚Ä¢ All student attempts will be deleted</strong><br>
      <strong>‚Ä¢ This action cannot be undone</strong>
    </p>

    <div class="modal-actions">
      <button class="btn-secondary" id="cancelDeleteBtn">Cancel</button>
      <button class="btn-danger" id="confirmDeleteBtn">Delete</button>
    </div>
  </div>
</div>

<!-- ‚ö° PUZZLE RUSH RESULT MODAL -->
<div id="puzzleRushResultModal" class="modal-overlay hidden">
  <div class="modal-box" style="max-width:420px; text-align:center;">
    <h3>‚ö° Puzzle Rush Over</h3>

    <p id="prResultReason" style="margin:12px 0;"></p>

    <p style="font-weight:600; color:#ffd700;">
      üß© Solved: <span id="prResultScore">0</span>
    </p>

    <div class="modal-actions">
      <button class="btn-success" id="prResultBtn">OK</button>
    </div>
  </div>
</div>


<!-- PGN TITLE MODAL -->
<div id="pgnTitleModal" class="modal hidden">
  <div class="modal-box">
    <h3>üì¶ Save PGN to Library</h3>

    <input
      type="text"
      id="pgnTitleInput"
      placeholder="Enter PGN title..."
    />

    <div class="modal-actions">
      <button id="cancelPGNTitle" class="btn-secondary">Cancel</button>
      <button id="confirmPGNTitle" class="btn-primary">Save</button>
    </div>
  </div>
</div>


<!-- üéâ Celebration Overlay -->
  <div id="celebrationOverlay" class="celebration hidden"></div>

  <!-- üéµ Celebration Sound -->
  <audio id="celebrationSound" preload="auto">
    <source src="sounds/party.mp3" type="audio/mpeg">
  </audio>

  <!-- ‚ö° PUZZLE RUSH SOUNDS -->
<audio id="prCheckSound" src="sounds/check.mp3" preload="auto"></audio>
<audio id="prNextSound" src="sounds/next.mp3" preload="auto"></audio>
<audio id="prWrongSound" src="sounds/wrong.mp3" preload="auto"></audio>
<audio id="prCompleteSound" src="sounds/complete.mp3" preload="auto"></audio>



<!-- üë§ Student Details Modal -->
<div id="studentDetailsModal" class="modal-overlay hidden">
  <div class="modal-box" style="max-width:700px;">
    <h3 id="studentModalTitle">Student Details</h3>

    <!-- üéØ Rating Progress (Modal) -->
<div class="student-progress-box">
  <div class="progress-label">
    Progress to next rating
  </div>

  <div class="progress-bar">
    <div id="studentProgressFill" class="progress-fill"></div>
  </div>

  <div id="studentProgressText" class="progress-text">
    0% to next
  </div>
</div>


    <div id="studentModalBody">
      <p class="loading">Loading student data...</p>
    </div>

    <div class="modal-actions">
  <button
    id="printStudentBtn"
    class="btn-secondary"
    type="button"
  >
    üñ®Ô∏è Print PDF
  </button>

  <button onclick="generateStudentCertificatePDF()" class="btn-secondary">
  üìú Certificate
</button>


  <button
    class="btn-secondary"
    onclick="closeStudentModal()"
    type="button"
  >
    Close
  </button>
</div>

  </div>
</div>


<!-- ===============================
     üìò Study PGN Import Modal
     =============================== -->
<div id="studyImportModal" class="study-modal hidden">
  <div class="study-modal-content">
    <h3>Import PGN</h3>

    <textarea
      id="studyPgnInput"
      placeholder="Paste single or multiple PGNs here..."
    ></textarea>

    <div class="modal-actions">
      <button id="importStudyConfirm" class="btn-primary">
        Import
      </button>
      <button id="importStudyCancel" class="btn-secondary">
        Cancel
      </button>
    </div>
  </div>
</div>


<!-- üéØ QUIZ RESULT FLOATING MODAL -->
<div id="quizResultModal" class="quiz-result-modal hidden">
  <div class="quiz-result-box">
    <h2 id="quizResultTitle">Quiz Over</h2>
    <p id="quizResultText"></p>
    <button id="quizResultBtn">OK</button>
  </div>
</div>


<!-- =============================== -->
<!-- üî• KLF RESULT MODAL (ISOLATED) -->
<!-- =============================== -->
<div id="klfResultOverlay" class="klf-modal hidden">
  <div class="klf-modal-card">
    <h3 id="klfResultTitle">üî• Game Over</h3>
    <p id="klfResultText">Turns survived: 0</p>
    <button class="btn-success" onclick="closeKLFResult()">OK</button>
  </div>
</div>


<!-- ================================ -->
<!-- üëë KND FLOATING MODAL (ISOLATED) -->
<!-- ================================ -->
<div id="kndModal" class="knd-modal hidden">
  <div class="knd-modal-card">
    <h3 id="kndModalTitle">Game Over</h3>
    <p id="kndModalBody">Message</p>
    <button id="kndModalBtn" class="knd-btn">OK</button>
  </div>
</div>



<!-- üéµ Global Game Music Control -->
<div id="musicControl">
  <div id="musicMuteBtn" title="Mute / Unmute">üîä</div>

  <div id="musicMenu" class="hidden">
    <div data-src="./sounds/sound_track_1.mp3">üé∂ Sound_Track_1</div>
    <div data-src="./sounds/sound_track_2.mp3">üé∂ Sound_Track_2</div>
    <div data-src="./sounds/sound_track_3.mp3">üé∂ Sound_Track_3</div>
    <div data-src="./sounds/sound_track_4.mp3">üé∂ sound_track_4</div>
    <div data-src="./sounds/sound_track_5.mp3">üé∂ Sound_Track_5</div>
    <div data-src="./sounds/sound_track_6.mp3">üé∂ Sound_Track_6</div>
    <div data-src="./sounds/sound_track_7.mp3">üé∂ sound_track_7</div>
    <div data-src="./sounds/sound_track_8.mp3">üé∂ Sound_Track_8</div>
    <div data-src="./sounds/sound_track_9.mp3">üé∂ Sound_Track_9</div>
    <div data-src="./sounds/sound_track_10.mp3">üé∂ Sound_Track_10</div>
  </div>
</div>





<div class="leaderboard-overlay" id="leaderboardOverlay">
  <div class="leaderboard-popup" id="leaderboardPopup">

    <!-- HEADER -->
    <div class="leaderboard-header">
      üèÜ Olympus Leaderboard
      <span class="leaderboard-close" id="leaderboardClose">‚úñ</span>
    </div>

    <!-- TABS -->
    <div class="leaderboard-tabs">
      <button class="lb-tab active" data-tab="rating">üåü ELO Rating</button>
      <button class="lb-tab" data-tab="games">üéÆ Mini-Games</button>
    </div>

    <!-- BODY -->
    <div class="leaderboard-body">

      <!-- SCROLL WRAPPER -->
      <div class="lb-scroll">

        <!-- RATING PANEL -->
        <div class="lb-panel active" id="lb-rating">
          <div class="lb-list" id="ratingLeaderboard">
            <p class="lb-muted">Loading ratings...</p>
          </div>
        </div>

        <!-- GAMES PANEL -->
        <div class="lb-panel" id="lb-games">

          <!-- Game Selector (fixed, not scrolling) -->
          <select class="lb-game-select" id="lbGameSelect"></select>

          <div class="lb-list" id="gameLeaderboard">
            <p class="lb-muted">Select a game</p>
          </div>
        </div>

      </div>
      <!-- /SCROLL WRAPPER -->

    </div>
    <!-- /BODY -->

  </div>
</div>



<!-- LIVE MATCH PROMOTION MODAL (ISOLATED) -->
<div id="mpPromoModal" class="mp-promo-overlay hidden">
  <div class="mp-promo-box">
    <button onclick="mpCompletePromotion('q')">‚ôï</button>
    <button onclick="mpCompletePromotion('r')">‚ôñ</button>
    <button onclick="mpCompletePromotion('b')">‚ôó</button>
    <button onclick="mpCompletePromotion('n')">‚ôò</button>
  </div>
</div>


<div id="mpRematchModal" class="mp-modal hidden">
  <div class="mp-modal-box">
    <h3>‚ôªÔ∏è Rematch Request</h3>
    <p>Your opponent wants a rematch</p>
    <div class="mp-modal-actions">
      <button id="mpAcceptBtn">Accept</button>
      <button id="mpDeclineBtn">Decline</button>
    </div>
  </div>
</div>

<!-- DRAW OFFER MODAL -->
<div id="mpDrawModal" class="mp-modal hidden">
  <div class="mp-modal-box">
    <h3>ü§ù Draw Offer</h3>
    <p>Your opponent offers a draw</p>
    <div class="mp-modal-actions">
      <button id="mpDrawAcceptBtn">Accept</button>
      <button id="mpDrawDeclineBtn">Decline</button>
    </div>
  </div>
</div>







<!-- ===============================
 FLOATING CHAT SYSTEM
=============================== -->

<div id="chatBubble">
  üí¨
  <span id="chatBubbleBadge" class="chat-badge hidden">0</span>
</div>


<div id="chatWindow" class="chat-hidden">
  <div id="chatHeader">
    <span>üí¨ Olympus Chat</span>
    <button id="chatMinimize">‚Äì</button>
  </div>

  <div id="chatTabs">
    <button class="chat-tab active" data-tab="global">
  Broadcast <span id="broadcastBadge" class="chat-badge hidden">0</span>
</button>

<button class="chat-tab" data-tab="users">
  Users <span id="usersBadge" class="chat-badge hidden">0</span>
</button>

  </div>

  <div id="chatContent">
    <div id="chatMessages"></div>

    <div id="chatUsers" class="chat-hidden"></div>
  </div>

  <div id="chatInputBox">
    <input id="chatInput" placeholder="Type message‚Ä¶" />
    <button id="chatSend">Send</button>
  </div>
</div>


<!-- ============================= -->
<!-- GLOBAL FLOATING FEN EDITOR -->
<!-- ============================= -->

<div id="pdfFenOverlay"
  style="
    position: fixed;
    inset: 0;
    z-index: 2147483647;
    pointer-events: none;
  "
>
  <div id="pdfFenWindow"
    style="
      position: fixed;
      top: 120px;
      left: 120px;
      width: 400px;
      min-height: 480px;
      background: rgba(15,18,36,0.98);
      border-radius: 14px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.7);
      display: none;
      flex-direction: column;
      overflow: hidden;
      pointer-events: auto;
    "
  >

    <div id="pdfFenDrag"
      style="
        background: #1e223f;
        padding: 10px 14px;
        font-weight: 700;
        cursor: grab;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: #f1c40f;
      "
    >
      ‚ôü Floating Board Editor
      <button id="pdfFenClose"
        style="
          background: none;
          border: none;
          color: #e74c3c;
          font-size: 18px;
          cursor: pointer;
        "
      >‚úñ</button>
    </div>

    <canvas id="pdfFenCanvas"
      width="360"
      height="360"
      style="
        background: #111;
        margin: 12px auto;
        border-radius: 10px;
        display: block;
      "
    ></canvas>

    <div class="pdf-fen-controls"
  style="
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 14px 14px;
    gap: 10px;
    color: #fff;
  "
>
  <label>
    Side to move:
    <select id="pdfFenTurn"
      style="
        background: #151836;
        color: #fff;
        border: 1px solid #444;
        border-radius: 8px;
        padding: 6px;
      "
    >
      <option value="w">White</option>
      <option value="b">Black</option>
    </select>
  </label>

  <div style="display:flex; gap:8px;">
    <button id="pdfFenClear"
      style="
        background: #f39c12;
        border: none;
        padding: 8px 14px;
        border-radius: 8px;
        font-weight: 700;
        cursor: pointer;
      "
    >
      üßπ Clear
    </button>

    <button id="pdfFenCopy"
      style="
        background: #1abc9c;
        border: none;
        padding: 8px 14px;
        border-radius: 8px;
        font-weight: 700;
        cursor: pointer;
      "
    >
      üìã Copy FEN
    </button>
  </div>
</div>


  </div>
</div>





<script src="analysis-pdf/pdf-fen-editor.js"></script>


<script>
window.addEventListener("message", e => {
  if (e.data?.type === "OPEN_FEN_EDITOR") {
    if (window.PDF_FEN_EDITOR) {
      window.PDF_FEN_EDITOR.open()
    }
  }
})
</script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>




</body>
<img id="academyLogo" src="favicons.png" style="display:none;" />

</html>



























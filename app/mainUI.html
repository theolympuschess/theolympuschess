 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Olympus Chess Academy ‚Äî Dashboard</title>

  <!-- Chessboard.js CSS -->
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

  <style>
    /* ===== THEME & BASE ===== */
    :root {
      --bg-dark: #0b0d1a;
      --bg-darker: #0f1224;
      --bg-card: #171a32;
      --bg-input: #242748;
      --accent: #ffd700;
      --accent-hover: #e6c200;
      --text: #f5f5f7;
      --text-muted: #9da0b8;
      --danger: #ff4757;
      --success: #2ed573;
      --warning: #ffa502;
      --ring: rgba(255, 215, 0, 0.25);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
      background: radial-gradient(1200px 600px at 10% 0%, #0f1224 0%, #0b0d1a 60%), var(--bg-dark);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* ===== NAVBAR ===== */
    .navbar {
      background: linear-gradient(180deg, rgba(18, 20, 49, 0.9), rgba(13, 15, 36, 0.95));
      backdrop-filter: saturate(1.3) blur(8px);
      padding: 14px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      border-bottom: 1px solid rgba(255, 215, 0, 0.18);
      position: sticky;
      top: 0;
      z-index: 50;
    }
    .brand {
  display: flex;
  align-items: center;
  gap: 0px;
  margin-right: auto;
}





    
    .nav-btn {
      color: var(--text);
      background: none;
      border: none;
      padding: 10px 14px;
      cursor: pointer;
      border-radius: 9px;
      font-weight: 600;
      transition: all 160ms ease;
      outline: none;
    }
    .nav-btn:hover { background: rgba(255, 215, 0, 0.08); }
    .nav-btn.active { background: var(--accent); color: #121431; box-shadow: 0 0 0 2px var(--ring); }
    .user-info { color: var(--accent); font-weight: 500; margin: 0 8px; opacity: 0.9; }
    .btn-logout {
      background: var(--danger); color: white; border: none; padding: 10px 14px; border-radius: 9px;
      cursor: pointer; font-weight: 600; transition: transform 150ms ease, opacity 150ms ease;
    }
    .btn-logout:hover { opacity: 0.92; transform: translateY(-1px); }

   /* ===============================
   AUTO HIDE / HOVER NAVBAR
================================ */

#topNavbar {
  position: sticky;
  top: 0;
  z-index: 1000;

  /* COLLAPSED STATE */
  max-height: 50px;
  overflow: hidden;

  transition: max-height 0.35s ease, box-shadow 0.3s ease;
}

/* EXPAND ON HOVER */
#topNavbar:hover {
  max-height: 280px; /* enough for 2 rows */
  box-shadow: 0 10px 35px rgba(0, 0, 0, 0.7);
}

/* Optional hint text */
#topNavbar::after {
  content: "‚ñº Hover to expand menu";
  display: block;
  text-align: center;
  font-size: 11px;
  color: #aaa;
  padding-bottom: 6px;
  opacity: 0.6;
}

#topNavbar:hover::after {
  display: none;
}


    /* ===== MAIN CONTAINER ===== */
    .container { padding: 24px; max-width: 1300px; margin: 0 auto; }

    
    

    /* ===== SECTIONS ===== */
    .section {
      background: var(--bg-card);
      padding: 24px;
      border-radius: 14px;
      margin-bottom: 24px;
      display: none;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);
    }
    .section.active { display: block; animation: fadeIn 240ms ease; }
    @keyframes fadeIn { from {opacity:0; transform: translateY(8px);} to {opacity:1; transform: translateY(0);} }
    .section h2 {
      color: var(--accent);
      margin-bottom: 16px; font-size: 1.5rem;
      border-bottom: 2px solid rgba(255, 215, 0, 0.28); padding-bottom: 10px;
    }

    /* ===== BOARD + SIDE PANEL LAYOUT ===== */
    .board-layout {
      display: flex;
      gap: 20px;
      align-items: stretch;
      justify-content: center;
      flex-wrap: nowrap;
    }

    .board-wrapper {
  flex: 1 1 600px;   /* ‚¨Ö bigger board */
  min-width: 600px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
  border: 1px solid rgba(255,255,255,0.06);
  background: #101226;
  padding-bottom: 6px; /* üîë small breathing space */
}


    .side-panel {
  flex: 0 0 320px;
  max-width: 340px;
  min-width: 300px;
  display: flex;
  flex-direction: column;
  gap: 14px;
}


    #chessboard {
      width: 100%;
      height: 100%;
      position: relative;
      cursor: default;
    }

    #notationPanel {
      flex: 0 0 100px;
      min-width: 220px;
      max-width: 380px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-self: stretch;
      background: linear-gradient(180deg, #1f2240, #242748);
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
      overflow: hidden;
    }

    #notationPanel > h4 {
      margin: 0;
      padding: 8px 0;
      width: 100%;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 1rem;
      font-weight: 800;
      color: var(--accent);
      letter-spacing: 0.2px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
    }

    #notationList {
      flex: 1 1 auto;
      overflow-y: auto;
      padding-right: 6px;
      margin-top: 8px;
      font-family: ui-monospace, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 0.95rem;
      line-height: 1.35;
    }

    #notationList .move {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      color: var(--text);
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #notationList .move:hover {
      background: rgba(255,255,255,0.02);
    }
    #notationList .move.current {
      background: rgba(255,215,0,0.06);
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.04);
    }

    #notationList::-webkit-scrollbar { width: 8px; }
    #notationList::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.06);
      border-radius: 8px;
    }
    #notationList::-webkit-scrollbar-track { background: transparent; }

    @media (max-width: 900px) {
      .board-layout { flex-wrap: wrap; }
      #notationPanel { order: 3; width: 100%; max-width: none; flex: 1 1 100%; }
    }

    #notationList { padding: 6px 4px; }
    #notationList .move {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      color: var(--text);
    }
    #notationList .move:hover { background: rgba(255,255,255,0.02); }
    #notationList .move.current {
      background: rgba(255,215,0,0.06);
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.04);
    }
    #notationList .move .num { color: var(--text-muted); width: 36px; text-align: right; padding-right: 8px; }
    #notationList .move .san { flex: 1 1 auto; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    #notationList .move {
      display: grid;
      grid-template-columns: 40px 1fr 1fr;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
    }

    #notationList .move .num {
      color: var(--text-muted);
      text-align: right;
      padding-right: 8px;
      font-weight: 700;
      font-size: 0.95rem;
    }

    #notationList .move .white,
    #notationList .move .black {
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.98rem;
    }

    #notationList .move .black { opacity: 0.95; }

    #notationList .move:hover { background: rgba(255,255,255,0.02); }
    #notationList .move.current {
      background: rgba(255,215,0,0.06);
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.04);
    }

    #notationList { padding: 6px 4px; }

    @media (max-width: 600px) {
      #notationList .move { grid-template-columns: 32px 1fr 1fr; gap: 8px; padding: 8px 10px; }
      #notationList .move .num { font-size: 0.9rem; }
    }

    #notationList .move.current {
      background: rgba(255, 215, 0, 0.15) !important;
      border-left: none;
      font-weight: bold;
      color: var(--accent) !important;
    }

    #notationList .move.current .white,
    #notationList .move.current .black {
      color: var(--accent) !important;
    }

    .hidden { display: none !important; }
    .hidden-ui {
      opacity: 0;
      pointer-events: none;
      user-select: none;
    }
    .offscreen {
      position: absolute;
      left: -9999px;
      top: -9999px;
    }

    .board-b72b1 { border: 2px solid #353a5c; box-sizing: content-box; transition: border-color 200ms ease; }
    .board-b72b1:hover { border-color: #404676; }

    button { cursor: pointer; font-weight: 700; transition: all 160ms ease; }
    .btn-primary { background: var(--accent); color: #121431; border-radius: 9px; padding: 10px 14px; }
    .btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
    .btn-success { background: var(--success); color: #121431; border-radius: 9px; padding: 10px 14px; }
    .btn-success:hover { opacity: 0.94; transform: translateY(-1px); }
    .btn-danger { background: var(--danger); color: #fff; border-radius: 9px; padding: 10px 14px; }
    .btn-danger:hover { opacity: 0.94; transform: translateY(-1px); }
    .btn-secondary { background: var(--bg-input); color: var(--text); border-radius: 9px; padding: 10px 14px; }
    .btn-secondary:hover { background: #30345e; transform: translateY(-1px); }

    .control-grid {
      display: grid; grid-template-columns: repeat(2, 1fr);
      gap: 10px; width: 100%;
    }
    .keypad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; width: 100%; }

    input, select, textarea {
      padding: 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, #242748, #1f2240);
      color: var(--text); width: 100%; margin-bottom: 12px;
      outline: none; transition: border-color 140ms ease, box-shadow 140ms ease;
    }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 2px var(--ring); }
    input::placeholder, textarea::placeholder { color: var(--text-muted); }
    textarea { min-height: 100px; resize: vertical; }
    .form-row { display: flex; gap: 10px; flex-wrap: wrap; }
    .form-row > * { flex: 1 1 auto; }

    table {
      width: 100%; border-collapse: collapse; margin-top: 14px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 10px; overflow: hidden;
    }
    th { background: rgba(255, 215, 0, 0.12); color: var(--accent); padding: 14px; text-align: left; font-weight: 800; }
    td { padding: 14px; border-bottom: 1px solid rgba(255,255,255,0.05); }
    tr:hover { background: rgba(255,255,255,0.02); }

    .card { background: linear-gradient(180deg, #242748 0%, #1f2240 100%); padding: 18px; border-radius: 12px; margin-bottom: 14px; border-left: 4px solid var(--accent); }
    .card h4 { color: var(--accent); margin-bottom: 8px; font-weight: 800; }
    .card p { color: var(--text-muted); margin-bottom: 5px; }
    .access-denied { text-align: center; padding: 36px; color: var(--danger); }
    .loading { text-align: center; padding: 24px; color: var(--accent); }
    .pgn-viewer {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      padding: 12px; border-radius: 10px; margin-top: 6px;
      max-height: 220px; overflow-y: auto; font-family: ui-monospace, Menlo, Monaco, Consolas, "Courier New", monospace;
      line-height: 1.35;
    }
    .timer { background: linear-gradient(180deg, #242748 0%, #1f2240 100%); padding: 10px 12px; border-radius: 10px; font-family: ui-monospace, monospace; font-size: 1.05rem; color: var(--accent); }
    .status-indicator { padding: 6px 10px; border-radius: 7px; font-size: 0.92rem; margin-top: 4px; background: linear-gradient(180deg, #242748 0%, #1f2240 100%); border: 1px solid rgba(255,255,255,0.06); }

    @media (max-width: 768px) {
      .navbar { flex-direction: column; align-items: flex-start; gap: 10px; }
      .nav-btn { width: 100%; text-align: left; }
      .container { padding: 16px; }
      .section { padding: 18px; }
      .board-layout { flex-direction: column; }
      .side-panel { max-width: 100%; }
    }

    .assignments-search {
      width: 100%;
      max-width: 400px;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, #242748, #1f2240);
      color: var(--text);
      font-size: 1rem;
      margin-bottom: 20px;
    }

    .assignments-filters {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .assignments-dropdown {
      flex: 1 1 250px;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, #242748, #1f2240);
      color: var(--text);
      font-size: 1rem;
    }

    .assignment-details {
      background: var(--bg-card);
      padding: 18px;
      border-radius: 12px;
      border-left: 4px solid var(--accent);
      display: none;
    }

    .clear-filters-btn {
      background: var(--danger);
      color: #fff;
      border: none;
      padding: 10px 14px;
      border-radius: 9px;
      cursor: pointer;
      font-weight: 600;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    .clear-filters-btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .admin-layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 20px;
      align-items: start;
      width: 100%;
    }

    .admin-table {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.04);
      max-height: calc(100vh - 140px);
      overflow: auto;
    }

    .admin-table table { width: 100%; border-collapse: collapse; }
    .admin-table thead th { position: sticky; top: 0; background: rgba(255,215,0,0.08); z-index: 2; }

    .admin-form {
      min-width: 280px;
      max-width: 420px;
    }
    .admin-form > .card,
    .admin-form > div {
      position: sticky;
      top: 90px;
      align-self: start;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      padding: 18px;
      border-radius: 12px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border: 1px solid rgba(255,255,255,0.04);
    }

    @media (max-width: 980px) {
      .admin-layout { grid-template-columns: 1fr; }
      .admin-form > .card, .admin-form > div { position: relative; top: 0; max-height: none; }
    }

    :root {
      --admin-form-width: 520px;
    }

    .admin-layout {
      display: grid;
      grid-template-columns: 1fr var(--admin-form-width);
      gap: 20px;
      align-items: start;
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
    }

    .admin-table {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.04);
      max-height: calc(100vh - 140px);
      overflow: auto;
      min-width: 320px;
    }

    .admin-form {
      min-width: 320px;
      max-width: var(--admin-form-width);
    }
    .admin-form > .card,
    .admin-form > div {
      position: sticky;
      top: 90px;
      align-self: start;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      padding: 18px;
      border-radius: 12px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border: 1px solid rgba(255,255,255,0.04);
    }

    .admin-table table { width: 100%; border-collapse: collapse; }
    .admin-table thead th { position: sticky; top: 0; background: rgba(255,215,0,0.08); z-index: 2; }

    @media (max-width: 980px) {
      .admin-layout { grid-template-columns: 1fr; padding: 0 8px; }
      .admin-form > .card, .admin-form > div { position: relative; top: 0; max-height: none; }
    }

    :root { --assign-form-width: 520px; }

    .assignments-layout {
      display: grid;
      grid-template-columns: minmax(320px, 1fr) var(--assign-form-width);
      gap: 18px;
      align-items: start;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    .assignments-list {
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border-radius: 12px;
      padding: 14px;
      border: 1px solid rgba(255,255,255,0.04);
      max-height: calc(100vh - 220px);
      overflow-y: auto;
      min-width: 280px;
    }

    .assignments-form {
      min-width: 280px;
      max-width: var(--assign-form-width);
    }
    .assignments-form > .card,
    .assignments-form > div {
      position: sticky;
      top: 90px;
      align-self: start;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      padding: 18px;
      border-radius: 12px;
      background: linear-gradient(180deg, #242748 0%, #1f2240 100%);
      border: 1px solid rgba(255,255,255,0.04);
    }

    @media (max-width: 980px) {
      .assignments-layout { grid-template-columns: 1fr; padding: 0 8px; }
      .assignments-form > .card,
    .assignments-form > div { position: relative; top: 0; max-height: none; }
    }

    @media (min-width: 1400px) {
      .assignments-layout { max-width: 1400px; }
    }

    /* ===============================
   ‚ôüÔ∏è PUZZLE RUSH ‚Äì GRAB CURSOR
   =============================== */

/* Default hover on Puzzle Rush board */
#puzzleRushBoard {
  cursor: grab;
}

/* When hovering a piece */
#puzzleRushBoard .piece-417db {
  cursor: grab !important;
}

/* While dragging a piece */
#puzzleRushBoard .piece-417db:active {
  cursor: grabbing !important;
}

/* Optional: squares also feel interactive */
#puzzleRushBoard .square-55d63 {
  cursor: grab;
}


    /* ===== CHESSBOARD CURSOR STYLES ===== */
    #chessboard {
      cursor: default;
    }

    /* When hovering over draggable pieces */
    #chessboard .piece-417db {
      cursor: grab !important;
    }

    #chessboard .piece-417db:hover {
      cursor: grab !important;
    }

    /* When actively dragging a piece */
    #chessboard .piece-417db:active {
      cursor: grabbing !important;
    }

    /* Disable cursor when in navigation mode */
    .navigation-mode #chessboard .piece-417db {
      cursor: not-allowed !important;
    }

    /* Also style the board squares on hover when piece is present */
    #chessboard .square-55d63:hover {
      cursor: pointer;
    }

    /* Make sure the board container has proper cursor */
    .board-wrapper:hover #chessboard {
      cursor: default;
      
    }


    /* ===== DRAWING SYSTEM STYLES ===== */
    #boardOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    #boardOverlay line {
      stroke: #057505;
      stroke-width: 5;
      stroke-linecap: round;
      marker-end: url(#arrowhead);
      filter: drop-shadow(0 1px 2px rgba(0, 255, 0, 0.5));
    }

    #boardOverlay circle {
      fill: none;
      stroke: #057505;
      
      filter: drop-shadow(0 1px 2px rgba(0, 255, 0, 0.5));
    }

    #boardOverlay rect {
      fill: rgba(255, 255, 255, 0.05);
      stroke: rgba(255, 255, 255, 0.1);
      stroke-width: 1;
    }

    /* Arrow marker definition */
    .marker-arrow {
      fill: #057505;
    }

    /* Disable right-click context menu on chessboard */
    #chessboard {
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    /* Right-click drawing instruction */
    .drawing-instruction {
      position: absolute;
      bottom: 15px;
      left: 15px;
      background: rgba(0, 0, 0, 0.7);
      color: #057505;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.85rem;
      z-index: 5;
      border: 1px solid rgba(0, 255, 0, 0.3);
      pointer-events: none;
    }

    /* Drawing preview */
    .drawing-preview {
      stroke-dasharray: 5,5;
      opacity: 0.7;
    }

    .status-indicator {
  padding: 10px 14px;
  border-radius: 8px;
  margin-bottom: 10px;
  font-weight: 600;
  text-align: center;
  animation: fadeIn 0.3s ease;
}

.status-indicator.success {
  background: linear-gradient(180deg, #1fae66, #15803d);
  color: #fff;
}

.status-indicator.error {
  background: linear-gradient(180deg, #dc2626, #991b1b);
  color: #fff;
}

.status-indicator.info {
  background: linear-gradient(180deg, #334155, #1e293b);
  color: #f8fafc;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ===== MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-overlay.hidden {
  display: none;
}

.modal-card {
  background: linear-gradient(180deg, #1b2b4a, #121c2f);
  padding: 24px 28px;
  border-radius: 14px;
  width: 360px;
  max-width: 90%;
  box-shadow: 0 20px 50px rgba(0,0,0,0.5);
  text-align: center;
  animation: popIn 0.25s ease-out;
}

.modal-card h2 {
  margin-bottom: 14px;
  color: #3cff8f;
}

.modal-content {
  color: #e5e7eb;
  font-size: 0.95rem;
  line-height: 1.6;
  margin-bottom: 20px;
}

.modal-btn {
  width: 100%;
  font-size: 1rem;
}

/* small animation */
@keyframes popIn {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-overlay.hidden {
  display: none;
}

.modal-card {
  background: linear-gradient(145deg, #0f172a, #111827);
  color: #e5e7eb;
  padding: 24px;
  border-radius: 14px;
  width: 420px;
  max-width: 90%;
  box-shadow: 0 25px 60px rgba(0,0,0,0.6);
  text-align: center;
  animation: popIn 0.25s ease;
}

.modal-card h3 {
  color: #22c55e;
  margin-bottom: 12px;
}

.modal-card p {
  line-height: 1.6;
  margin-bottom: 18px;
}

@keyframes popIn {
  from { transform: scale(0.9); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

/* Assign select / clear buttons */
.assign-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 4px;   /* keeps it close to the student list */
}

.assign-actions .btn-small {
  padding: 4px 10px;
  font-size: 12px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  background: #2c2f55;
  color: #fff;
}

.assign-actions .btn-small:hover {
  background: #3a3e75;
}

.assign-actions .btn-small.danger {
  background: #5a2a2a;
}

.assign-actions .btn-small.danger:hover {
  background: #7a3434;
}

.promotion-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.promotion-modal.hidden {
  display: none;
}

.promotion-box {
  display: flex;
  gap: 12px;
  background: #0e1025;
  padding: 16px;
  border-radius: 12px;
  border: 1px solid #ffd700;
}

.promotion-box button {
  font-size: 32px;
  width: 64px;
  height: 64px;
  cursor: pointer;
  border-radius: 8px;
  background: #1c1f35;
  color: #fff;
  border: 1px solid #444;
}

.promotion-box button:hover {
  background: #ffd700;
  color: #000;
}

.player-bar {
  display: flex;
  justify-content: space-between;
  width: 100%;
  max-width: 100%;
  font-size: 1.10rem;
  color: #d0ff00;
  padding: 0 2px;
  margin-top: 2px;
}




#chessboard {
  margin-bottom: 4px;
}

.player {
  opacity: 0.85;
}

.player.white {
  align-self: flex-start;
}

.player.black {
  align-self: flex-end;
}

/* ===== LIVE CLASSROOM ===== */

.live-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display: inline-block;
  margin-right: 6px;
}

.live-dot.red {
  background: #ff4d4d;
  box-shadow: 0 0 6px rgba(255, 77, 77, 0.8);
}

.live-dot.green {
  background: #2ecc71;
  box-shadow: 0 0 6px rgba(46, 204, 113, 0.8);
}


.live-placeholder {
  margin-top: 16px;
  padding: 16px;
  border-radius: 10px;
  background: rgba(255,255,255,0.04);
  color: #ddd;
}

.hidden {
  display: none;
}


/* Live classroom student checklist */
.student-checklist {
  max-height: 260px;        /* üëà controls height */
  overflow-y: auto;         /* üëà scroll */
  padding: 8px 12px;
  border: 1px solid #2e355e;
  border-radius: 10px;
  background: rgba(0, 0, 0, 0.25);
}

/* Each student row */
.student-checklist label {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 14px;
  cursor: pointer;
}

/* Checkbox size fix */
.student-checklist input[type="checkbox"] {
  transform: scale(1.05);
}

/* ===== Dark themed SELECT dropdown ===== */
select {
  background-color: #1c1f35;
  color: #f0f0f0;
  border: 1px solid #333;
}

/* Dropdown options */
select option {
  background-color: #1c1f35;
  color: #f0f0f0;
}

/* Hovered option (works in most browsers) */
select option:hover {
  background-color: #2a2d4a;
  color: #ffd700;
}

/* Selected option */
select option:checked {
  background-color: #ffd700;
  color: #101225;
}


/* ===== MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal-box {
  background: #1c1f35;
  padding: 24px;
  border-radius: 14px;
  width: 100%;
  max-width: 420px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  animation: scaleIn 0.2s ease;
}

.modal-box h3 {
  color: #ffd700;
  margin-bottom: 12px;
}

.modal-box p {
  color: #ddd;
  font-size: 0.95rem;
  line-height: 1.5;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.hidden {
  display: none;
}

@keyframes scaleIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

/* ================= ASSIGNMENTS GRID ================= */
.assignments-layout {
  display: grid;
  grid-template-columns:
    minmax(300px, 1fr)
    minmax(420px, 520px)
    minmax(300px, 360px);
  gap: 20px;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;

  /* üîí IMPORTANT: limit vertical growth */
  height: calc(100vh - 160px);
}

/* ================= GENERAL CARD ================= */
.assignments-layout > .card {
  background: linear-gradient(180deg, #1a1f3c 0%, #12162d 100%);
  border-radius: 14px;
  padding: 16px 18px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.04),
    0 10px 30px rgba(0,0,0,0.35);

  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0;
  overflow: hidden;
}

/* ================= LEFT COLUMN SCROLL ================= */
.assignments-layout > .card:first-child {
  overflow-y: auto;
}

/* ================= MIDDLE COLUMN SCROLL ================= */
.assignments-layout > .card:nth-child(2) {
  overflow-y: auto;
}

/* ================= PGN LIBRARY ================= */
.assignments-layout > .card[aria-label="PGN Library"] {
  overflow: hidden;
}

/* PGN list scroll area */
#pgnLibraryList {
  margin-top: 12px;
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
}

body.student-view #pgnLibraryCard { display: none; }


/* ================= STUDENT PROGRESS SCROLL FIX ================= */

#studentProgressCard {
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0;          /* üî• critical */
  overflow: hidden;      /* prevent double scroll */
}

#studentProgressList {
  flex: 1;
  min-height: 0;         /* üî• critical */
  overflow-y: auto;      /* ‚úÖ enable scroll */
  overflow-x: hidden;
  padding-right: 6px;
}


.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  backdrop-filter: blur(6px);
  z-index: 9999;

  display: flex;
  align-items: center;
  justify-content: center;
}

/* üî• THIS LINE FIXES THE BUTTON */
.modal-box {
  pointer-events: auto;
  z-index: 10000;
}


/* üë§ Student Details Modal Scroll Fix */
#studentDetailsModal .modal-box {
  max-height: 80vh;              /* üëà keeps modal inside screen */
  display: flex;
  flex-direction: column;
}

#studentModalBody {
  overflow-y: auto;              /* üëà ENABLE SCROLL */
  max-height: 60vh;              /* üëà scroll area height */
  padding-right: 6px;
}




/* ===== PGN MODAL ===== */
.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.modal.hidden {
  display: none;
}

.modal-box {
  width: 340px;
  background: #11162b;
  border-radius: 12px;
  padding: 18px;
  box-shadow: 0 0 25px rgba(0,0,0,0.6);
}

.modal-box h3 {
  margin-bottom: 12px;
  color: #ffd700;
}

.modal-box input {
  width: 100%;
  padding: 10px;
  border-radius: 8px;
  border: none;
  margin-bottom: 14px;
  background: #1c2240;
  color: #fff;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

/* ================= PGN CONTROLS ALIGNMENT ================= */

.pgn-item {
  padding: 10px 0;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.pgn-controls {
  margin-top: 8px;
  display: grid;
  grid-template-columns: auto auto 1fr auto auto;
  align-items: center;
  gap: 12px;
}

/* Radio label alignment */
.pgn-controls label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: #ddd;
  cursor: pointer;
}

.pgn-controls input[type="radio"] {
  margin: 0;
}

/* Button normalization */
.pgn-controls .btn-small {
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 6px;
}

.pgn-controls .btn-small.danger {
  background: #f37070;
}

/* ================= STUDENT PROGRESS VISIBILITY ================= */

/* Hide student progress for admin & teacher */
body:not(.student-view) #studentProgressCard {
  display: none !important;
}


/* ================= STUDENT ASSIGNMENT HISTORY ================= */

#studentProgressCard {
  background: linear-gradient(180deg, #1a1f3c 0%, #12162d 100%);
  border-radius: 14px;
  padding: 16px 18px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.04),
    0 10px 30px rgba(0,0,0,0.35);
}

/* Scroll container */
#studentProgressList {
  margin-top: 10px;
  overflow-y: auto;
  padding-right: 6px;
}

/* Each assignment block */
.progress-item {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 12px;
  padding: 12px 14px;
  margin-bottom: 12px;
  border-left: 4px solid #312c49;
  box-shadow: 0 6px 14px rgba(0,0,0,0.35);
}

/* Title */
.progress-item strong {
  color: #ffd700;
  font-size: 1.05rem;
  display: block;
  margin-bottom: 6px;
}

/* Meta info */
.progress-meta {
  font-size: 0.9rem;
  color: #d1d5db;
  margin-bottom: 4px;
}

/* Date */
.progress-date {
  font-size: 0.8rem;
  color: #9da0b8;
  margin-bottom: 8px;
}

/* Buttons container */
.progress-actions {
  display: flex;
  gap: 8px;
  margin-top: 6px;
}

/* Small buttons */
.progress-actions .btn-small {
  padding: 6px 10px;
  font-size: 12px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s ease;
}

/* Re-attempt button */
.progress-actions .reattempt-btn {
  background: linear-gradient(180deg, #22c55e, #15803d);
  color: #052e16;
}
.progress-actions .reattempt-btn:hover {
  transform: translateY(-1px);
  filter: brightness(1.1);
}

/* View details button */
.progress-actions .view-details-btn {
  background: linear-gradient(180deg, #334155, #1e293b);
  color: #f8fafc;
}
.progress-actions .view-details-btn:hover {
  background: linear-gradient(180deg, #475569, #334155);
}

/* Divider remove */
.progress-item hr {
  display: none;
}

/* Scrollbar styling */
#studentProgressList::-webkit-scrollbar {
  width: 8px;
}
#studentProgressList::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}
#studentProgressList::-webkit-scrollbar-track {
  background: transparent;
}

/* ===== Center buttons in Assignment History cards ===== */

.progress-actions {
  display: flex;
  justify-content: center;   /* üî• THIS centers buttons */
  align-items: center;
  gap: 10px;
  margin-top: 8px;
}

/* Optional: make buttons same height & cleaner */
.progress-actions .btn-small {
  min-width: 92px;
  text-align: center;
}

/* ===== STICKY APP FOOTER ===== */
.app-footer {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;

  padding: 6px 8px;
  font-size: 0.75rem;
  text-align: center;

  color: #e6c86e;

  background: linear-gradient(
    180deg,
    rgba(15, 18, 36, 0.95),
    rgba(11, 13, 26, 0.98)
  );

  border-top: 1px solid rgba(255, 215, 0, 0.45);
  box-shadow: 0 -1px 12px rgba(255, 215, 0, 0.18);

  z-index: 100;
}

.app-footer .footer-brand {
  color: #ffd700;
  font-weight: 700;
}

.container {
  padding-bottom: 40px;
}



.bulk-bar {
  height: 42px;                 /* üîí fixed height */
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 14px;

  margin-top: 10px;
  padding: 6px 10px;

  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.08);

  font-weight: 700;
  color: #ffd700;

  /* üî• prevents layout jump */
  flex-shrink: 0;
}

#board-section h2 {
  font-size: 1.25rem;     /* üîΩ smaller than before */
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 12px;
}


.engine-panel {
  margin-top: 10px;
  border-radius: 8px;
  background: #10131c;
  border: 1px solid #2a2f45;
  grid-column: 1 / -1;
  width: 100%;
  box-sizing: border-box;
  overflow: hidden;
}

/* üî• THE KEY PART */
.engine-bar {
  display: flex;
  align-items: center;
  gap: 16px;              /* spacing between title, eval, depth */
  padding: 8px 10px;
  background: #0c0f18;
  border-bottom: 1px solid #2a2f45;
  font-size: 13px;
}


.engine-title {
  font-weight: bold;
  color: #f1c40f;
}


.engine-stat {
  color: #eaeaea;
  font-size: 12.5px;
}

/* BODY = FREE SPACE */
.engine-body {
  padding: 8px 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.engine-line {
  background: #0d1020;
  padding: 6px 8px;
  border-radius: 6px;
  border: 1px solid #2a2f45;
  font-size: 12.5px;
}


.engine-stat {
  color: #9da0b8;   /* Eval: Depth: */
  font-weight: 600;
}

#engineEval {
  color: #22c55e;
  font-weight: 700;
}

#engineDepth {
  color: #38bdf8;
  font-weight: 700;
}

/* Highlight ONLY WASM text */
.engine-title .wasm-badge {
  color: #38bdf8;           /* cyan-blue (matches depth vibe) */
  background: rgba(56, 189, 248, 0.15);
  padding: 2px 6px;
  border-radius: 6px;
  font-weight: 800;
  letter-spacing: 0.5px;
}

/* ===============================
   STUDENT BADGES ‚Äì STEP 2 (UI ONLY)
   =============================== */

#studentBadgePanel {
  display: flex;
  flex-direction: column;
  height: 100%;
}

#studentBadgeContent {
  margin-top: 12px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 12px;
  overflow-y: auto;
  padding-right: 6px;
}

/* Badge card */
.badge-card {
  background: linear-gradient(145deg, #1c1f35, #15182a);
  border-radius: 14px;
  padding: 12px;
  position: relative;
  text-align: center;
  opacity: 0.55; /* locked look */
}

/* Badge icon */
.badge-icon {
  font-size: 28px;
  margin-bottom: 6px;
}

/* Badge title */
.badge-title {
  font-size: 0.9rem;
  font-weight: 600;
  color: #ffd700;
}

/* Badge tagline */
.badge-tagline {
  font-size: 0.80rem;
  color: #aaa;
  margin-top: 4px;
}

/* Locked overlay */
.badge-lock {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  background: rgba(0, 0, 0, 0.45);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
}


/* ===============================
   üèÖ ACHIEVEMENTS ‚Äì CLEAN FIX
   =============================== */

#studentBadgeContent {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 14px;
}

/* CARD */
.badge-card {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 14px 10px 16px;
  min-height: 140px;
  text-align: center;
  position: relative;
  border: 1px solid rgba(255,255,255,0.05);
  box-shadow: 0 8px 20px rgba(0,0,0,0.35);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}


#studentBadgePanel > div {
  overflow: visible;
}


/* Hover */
.badge-card:hover {
  transform: translateY(-3px);
}

/* ICON */
.badge-icon {
  font-size: 34px;
  margin-bottom: 6px;
}

/* TITLE */
.badge-title {
  font-size: 0.95rem;
  font-weight: 700;
  color: #ffd700;
}

/* TAGLINE */
.badge-tagline {
  font-size: 0.80rem;
  color: #9da0b8;
  margin-top: 4px;
}

/* ================= LOCKED ================= */

.badge-card.locked {
  opacity: 0.35;
}

.badge-card.locked .badge-icon {
  filter: grayscale(100%);
}

/* Lock icon */
.badge-lock {
  position: absolute;
  top: 8px;
  right: 10px;
  font-size: 16px;
  opacity: 0.8;
}

/* ================= UNLOCKABLE ================= */

.badge-unlock-btn {
  margin-top: 10px;
  padding: 6px 14px;
  font-size: 12px;
  font-weight: 800;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  background: #ffd700;
  color: #101225;
  box-shadow: 0 0 12px rgba(255,215,0,0.6);
}

.badge-unlock-btn:hover {
  filter: brightness(1.1);
}

/* ================= UNLOCKED ================= */

.badge-card.unlocked {
  opacity: 1;
  box-shadow:
    0 0 0 2px rgba(255,215,0,0.45),
    0 0 22px rgba(255,215,0,0.35);
}

.badge-unlocked-mark {
  position: absolute;
  top: 8px;
  right: 10px;
  font-size: 18px;
}

/* üéâ unlock pop */
.badge-just-unlocked {
  animation: unlockPop 0.5s ease;
}

@keyframes unlockPop {
  0% { transform: scale(0.9); }
  60% { transform: scale(1.08); }
  100% { transform: scale(1); }
}


#studentBadgePanel h3 {
  text-align: center;
  font-size: 1.35rem;
  font-weight: 900;
  letter-spacing: 0.4px;
  margin-bottom: 12px;
  color: #ffd700;

  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

/* ===============================
   üîÅ UNIFIED SCROLLBAR (MATCH HISTORY)
   =============================== */

/* Firefox */
#assignmentsList,
#studentBadgeContent {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* WebKit (Chrome / Edge / Safari) */
#assignmentsList::-webkit-scrollbar,
#studentBadgeContent::-webkit-scrollbar {
  width: 8px;
}

#assignmentsList::-webkit-scrollbar-track,
#studentBadgeContent::-webkit-scrollbar-track {
  background: transparent;
}

#assignmentsList::-webkit-scrollbar-thumb,
#studentBadgeContent::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

#assignmentsList::-webkit-scrollbar-thumb:hover,
#studentBadgeContent::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}



/* ===============================
   üèÖ ACHIEVEMENTS ‚Äì FIX SCROLLBAR
   =============================== */

/* Firefox */
#studentBadgePanel {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* WebKit */
#studentBadgePanel::-webkit-scrollbar {
  width: 8px;
}

#studentBadgePanel::-webkit-scrollbar-track {
  background: transparent;
}

#studentBadgePanel::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

#studentBadgePanel::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}


/* ===============================
   üõ† ADMIN ‚Äì UNIFIED SCROLLBARS
   =============================== */

/* Firefox */
.assignments-form > div,
#pgnLibraryList {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* WebKit */
.assignments-form > div::-webkit-scrollbar,
#pgnLibraryList::-webkit-scrollbar {
  width: 8px;
}

.assignments-form > div::-webkit-scrollbar-track,
#pgnLibraryList::-webkit-scrollbar-track {
  background: transparent;
}

.assignments-form > div::-webkit-scrollbar-thumb,
#pgnLibraryList::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

.assignments-form > div::-webkit-scrollbar-thumb:hover,
#pgnLibraryList::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}


/* ===============================
   üë®‚Äçüéì ADMIN ‚Üí CURRENT STUDENTS SCROLLBAR
   =============================== */

/* make sure this element scrolls */
.admin-table {
  overflow-y: auto;
}

/* Firefox */
.admin-table {
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.08) transparent;
}

/* Chrome / Edge / Safari */
.admin-table::-webkit-scrollbar {
  width: 8px;
}

.admin-table::-webkit-scrollbar-track {
  background: transparent;
}

.admin-table::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
}

.admin-table::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.14);
}

/* ===============================
   üë®‚Äçüéì ADMIN ‚Äì STUDENT ROW TEXT SIZE
   =============================== */

/* Student usernames */
.admin-table tbody td:nth-child(2) {
  font-size: 1.30rem;   /* slightly bigger */
  font-weight: 600;
}

/* Status text (Active / Inactive) */
.admin-table tbody td:nth-child(3) {
  font-size: 1.10rem;
  font-weight: 600;
}

#attempts-section .section-title {
  position: sticky;
  top: 72px;
  z-index: 50;
  background: linear-gradient(135deg, #0e0f1f, #2a2d4a);
}

/* ===============================
   üìä STUDENT ATTEMPTS ‚Äì STICKY HEADER
   =============================== */

#attempts-section > h2 {
  position: sticky;
  top: 72px;              /* height of your navbar */
  z-index: 50;

  background: linear-gradient(135deg, #0e0f1f, #2a2d4a);
  padding: 12px 18px;

  border-radius: 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
}

/* ===============================
   üéâ CELEBRATION EFFECT
   =============================== */

.celebration {
  position: fixed;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
  z-index: 99999;
}

.celebration.hidden {
  display: none;
}

/* Glitter particle */
.glitter {
  position: absolute;
  top: -10px;
  width: 8px;
  height: 8px;
  background: radial-gradient(circle, #ffd700, #ffec8b);
  border-radius: 50%;
  opacity: 0.9;

  animation: fall linear forwards;
  animation-duration: 5s; /* üî• LONGER FALL */
}


@keyframes fall {
  to {
    transform: translateY(130vh) rotate(720deg); /* more spin + longer fall */
    opacity: 0;
  }
}


/* üöÄ BIG BADGE POP-OUT (2s total) */
.badge-pop-animate {
  animation: badgeBigPop 2s cubic-bezier(0.22, 1.61, 0.36, 1);
  z-index: 20;
}

@keyframes badgeBigPop {
  0% {
    transform: scale(1);
  }

  20% {
    transform: scale(1.6);
  }

  40% {
    transform: scale(1.85);
  }

  60% {
    transform: scale(1.4);
  }

  80% {
    transform: scale(1.15);
  }

  100% {
    transform: scale(1);
  }
}

#computerBoard {
  width: 420px;
  max-width: 100%;
}

#computer-section h3 {
  color: var(--accent);
  margin-top: 12px;
  margin-bottom: 6px;
}


#computer-section .analysis-layout {
  display: flex;
  gap: 24px;
  align-items: flex-start;
}

#computer-section .board-column {
  min-width: 420px;
}

#computer-section .side-panel {
  width: 320px;
}

/* ü§ñ Play vs Computer ‚Äì Layout */
#computer-section .analysis-layout {
  display: flex;
  gap: 28px;
  align-items: flex-start;
}

/* Board side takes more space */
#computer-section .board-column {
  flex: 1.4;
}

/* Right panel slightly smaller */
#computer-section .side-panel {
  flex: 1;
}

#computerBoard {
  width: 600px;       /* üî• increase from ~420 */
  max-width: 100%;
  margin: 0 auto;
}



/* ===============================
   ‚ôüÔ∏è Chessboard Cursor (GRAB)
   =============================== */

/* When hovering over a piece */
#chessboard .piece-417db,
#computerBoard .piece-417db {
  cursor: grab !important;
}



/* Board itself should not override */
#chessboard,
#computerBoard {
  cursor: default;
}

.vs-result {
  margin: 10px auto 16px;
  padding: 10px 18px;
  border-radius: 10px;
  text-align: center;
  font-size: 1.1rem;
  font-weight: 800;
  width: fit-content;
  animation: fadeIn 0.3s ease;
}

.vs-result.white {
  background: linear-gradient(180deg, #e5e7eb, #cbd5f5);
  color: #111827;
}

.vs-result.black {
  background: linear-gradient(180deg, #1f2933, #0f172a);
  color: #f8fafc;
}

.vs-result.draw {
  background: linear-gradient(180deg, #334155, #1e293b);
  color: #f8fafc;
}

.hidden {
  display: none;
}


/* ===============================
   ‚ôüÔ∏è PUZZLE RUSH ‚Äì BIGGER BOARD
   =============================== */

#puzzleRushBoard {
  width: 600px;
  height: 600px;
  margin: 0 auto;
  box-shadow: 0 12px 30px rgba(0,0,0,0.45);
  border-radius: 10px;
}

/* Responsive fallback */
@media (max-width: 900px) {
  #puzzleRushBoard {
    width: 420px;
    height: 420px;
  }
}

@media (max-width: 600px) {
  #puzzleRushBoard {
    width: 320px;
    height: 320px;
  }
}



/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì PREMIUM UI
   =============================== */

#puzzlerush-section h2 {
  font-size: 1.6rem;
  letter-spacing: 0.6px;
}

/* Main card */
#puzzleRushMenu {
  background: linear-gradient(145deg, #1a1f3c, #12162d);
  border-radius: 18px;
  padding: 26px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.05),
    0 18px 45px rgba(0,0,0,0.45);
  position: relative;
  overflow: hidden;
}

/* soft glow border */
#puzzleRushMenu::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 18px;
  pointer-events: none;
  box-shadow: 0 0 0 1px rgba(255,215,0,0.15);
}

/* Title */
#puzzleRushMenu h3 {
  text-align: center;
  font-size: 1.25rem;
  font-weight: 800;
  color: #ffd700;
  margin-bottom: 22px;
  letter-spacing: 0.4px;
}

/* Mode grid */
#puzzleRushMenu .control-grid {
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

/* Buttons ‚Äì base */
#puzzleRushMenu button {
  position: relative;
  font-size: 1.05rem;
  padding: 14px 16px;
  border-radius: 14px;
  font-weight: 800;
  letter-spacing: 0.3px;
  transition: all 0.2s ease;
  box-shadow:
    inset 0 -2px 0 rgba(0,0,0,0.25),
    0 8px 20px rgba(0,0,0,0.35);
}

/* Hover lift */
#puzzleRushMenu button:hover {
  transform: translateY(-2px) scale(1.02);
  filter: brightness(1.05);
}

/* Press */
#puzzleRushMenu button:active {
  transform: translateY(1px) scale(0.98);
}

/* 3 & 5 min ‚Äì GOLD */
#rush3,
#rush5 {
  background: linear-gradient(180deg, #ffd700, #e6c200);
  color: #101225;
  box-shadow:
    0 0 0 1px rgba(255,215,0,0.5),
    0 10px 26px rgba(255,215,0,0.45);
}

/* GOLD glow on hover */
#rush3:hover,
#rush5:hover {
  box-shadow:
    0 0 18px rgba(255,215,0,0.6),
    0 14px 32px rgba(255,215,0,0.55);
}

/* Survival ‚Äì DANGER */
#survival {
  grid-column: 1 / -1;
  background: linear-gradient(180deg, #ff4d4d, #c81e1e);
  color: #fff;
  box-shadow:
    0 0 0 1px rgba(255,77,77,0.5),
    0 10px 26px rgba(255,77,77,0.45);
}

/* Survival glow */
#survival:hover {
  box-shadow:
    0 0 18px rgba(255,77,77,0.6),
    0 14px 32px rgba(255,77,77,0.55);
}

/* Icon spacing polish */
#puzzleRushMenu button::first-letter {
  margin-right: 6px;
}

/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì HUD (PREMIUM)
   =============================== */

.puzzle-hud {
  display: flex;
  justify-content: center;
  gap: 16px;
  margin-top: 14px;
}

/* Shared HUD card */
.hud-item {
  min-width: 120px;
  padding: 10px 14px;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;

  font-weight: 900;
  font-size: 1.1rem;
  letter-spacing: 0.5px;

  background: linear-gradient(180deg, #242748, #1f2240);
  border: 1px solid rgba(255,255,255,0.08);

  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.03),
    0 8px 22px rgba(0,0,0,0.45);

  transition: transform 0.15s ease;
}

.hud-item:hover {
  transform: translateY(-2px);
}

/* Icon */
.hud-icon {
  font-size: 1.2rem;
}

/* TIMER */
.hud-timer {
  color: #38bdf8;
  box-shadow:
    0 0 0 1px rgba(56,189,248,0.35),
    0 0 18px rgba(56,189,248,0.25);
}

/* LIVES */
.hud-lives {
  color: #ff6b6b;
  box-shadow:
    0 0 0 1px rgba(255,107,107,0.35),
    0 0 18px rgba(255,107,107,0.25);
}

/* STREAK */
.hud-streak {
  color: #ffd700;
  box-shadow:
    0 0 0 1px rgba(255,215,0,0.45),
    0 0 22px rgba(255,215,0,0.35);
}

/* Small screens */
@media (max-width: 600px) {
  .puzzle-hud {
    gap: 10px;
  }

  .hud-item {
    min-width: 96px;
    font-size: 1rem;
    padding: 8px 10px;
  }
}

/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì EXIT (FINAL)
   =============================== */

/* Make layout the anchor */
#puzzleRushGame .analysis-layout {
  position: relative;
}

/* Exit button inside card */
#exitPuzzleRush {
  position: absolute;
  top: 14px;
  left: 14px;

  padding: 6px 10px;
  font-size: 13px;
  border-radius: 8px;

  background: #1f2240;
  color: #ffd700;
  border: 1px solid rgba(255,255,255,0.18);

  cursor: pointer;
  z-index: 20;
}

/* Hover effect */
#exitPuzzleRush:hover {
  background: #ffd700;
  color: #101225;
}

/* Hide side-panel visuals but keep DOM */
#puzzleRushGame .side-panel {
  width: 0;
  padding: 0;
  margin: 0;
  overflow: visible;
}

.bot-panel {
  width: 160px;
  min-width: 160px;
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 16px;

  padding: 20px 12px 12px;
  margin-right: 30px;   /* ‚¨ÖÔ∏è KEY FIX: pushes board away */

  box-shadow: 0 12px 30px rgba(0,0,0,0.45);

  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;

  gap: 10px;
  position: relative;
}

.bot-avatar {
  position: relative;
}

#botMouth {
  position: absolute;

  top: 115px;

  /* üëâ move mouth slightly RIGHT */
  left: 70%;
  transform: translateX(-50%) translateX(6px);

  width: 20px;
  height: 15px;

  background: #ff4d4d;
  border-radius: 50%;

  opacity: 0;
  z-index: 5;
  transition: height 0.08s ease, opacity 0.08s ease;
}

#botMouth.talk {
  height: 30px;
  opacity: 1;
}







.bot-avatar img {
  width: 145%;
  height: 145%;
  object-fit: contain;

  /* ‚¨ÜÔ∏è pull bot UP */
  transform: translateY(-30px);

  filter: drop-shadow(0 16px 20px rgba(0,0,0,0.55));
}


.game-left-panel {
  padding-right: 20px;
}




.bot-name {
  margin-top: -90px;   /* ‚¨ÜÔ∏è pulls name upward */
  margin-bottom: 6px;

  font-weight: 900;
  color: #ffd700;
  font-size: 1.5rem;
  text-align: center;

  text-shadow: 0 2px 6px rgba(0,0,0,0.6);
}




.bot-bubble {
  margin-top: 10px;              /* üëà puts it BELOW avatar */
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.75);
  color: #ffd966;
  border-radius: 12px;
  font-size: 22px;
  max-width: 160px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);

  /* animation */
  animation: popIn 0.25s ease-out;
}

.bot-bubble.hidden {
  display: none;
}

/* idle animation */
@keyframes botIdle {
  0% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
  100% { transform: translateY(0); }
}


.analysis-layout {
  display: flex;
  align-items: stretch; /* üî• IMPORTANT */
}


.takeback-btn {
  margin-top: auto;   /* üî• finally works */
  margin-bottom: 14px;
  width: 100%;
}

.bot-panel {
  display: flex;
  flex-direction: column;
  padding-bottom: 25px; /* try 24 ‚Üí 32 */
  height: 100%;
  min-height: 520px; /* üî• SAME or slightly less than board height */
}


/* ===============================
   ‚ö° PUZZLE RUSH ‚Äì TRUE CENTER FIX
   =============================== */

/* ‚úÖ Correct centering inside card (no drifting) */
#puzzleRushGame .analysis-layout {
  display: grid !important;
  grid-template-columns: 1fr auto 1fr !important;
  align-items: flex-start !important;
  position: relative !important;
}

/* Board always sits in true center column */
#puzzleRushGame .board-column {
  grid-column: 2 !important;
  position: static !important;   /* ‚ùå remove left:50% logic */
  transform: none !important;    /* ‚ùå remove translateX */
  margin: 0 !important;
}


/* Keep side-panel neutral */
#puzzleRushGame .side-panel {
  width: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
  overflow: visible !important;
}

/* Exit always visible */
#exitPuzzleRush {
  position: absolute !important;
  top: 16px !important;
  left: 16px !important;
  z-index: 9999 !important;
}


#editorBoard {
  width: 520px;
  min-height: 520px;
}


/* ===============================
   ‚ôüÔ∏è CHESSBOARD GRAB CURSOR
   =============================== */

/* Board containers */
#chessboard,
#editorBoard,
#computerBoard,
#puzzleRushBoard {
  cursor: default;
}

/* Hovering a draggable piece */
#chessboard .piece-417db,
#editorBoard .piece-417db,
#computerBoard .piece-417db,
#puzzleRushBoard .piece-417db {
  cursor: grab !important;
}

/* While dragging a piece */
#chessboard .piece-417db:active,
#editorBoard .piece-417db:active,
#computerBoard .piece-417db:active,
#puzzleRushBoard .piece-417db:active {
  cursor: grabbing !important;
}

/* Optional: squares feel interactive */
#chessboard .square-55d63,
#editorBoard .square-55d63,
#computerBoard .square-55d63,
#puzzleRushBoard .square-55d63 {
  cursor: grab;
}

/* üß© Board Editor ‚Äì spare pieces container */
#editorBoard .spare-pieces,
#editorBoard .spare-pieces-7492f {
  background: linear-gradient(180deg, #2a2f55, #1f2446);
  border-radius: 10px;
  padding: 8px 10px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.08),
    0 6px 18px rgba(0,0,0,0.35);
}

/* üìã Copy FEN button */
.btn-copy-fen {
  margin-top: 10px;
  background: linear-gradient(135deg, #2f3468, #1e2248);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px;
  padding: 8px 14px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-copy-fen:hover {
  background: linear-gradient(135deg, #3b4190, #262b66);
}

.fen-copy-status {
  display: inline-block;
  margin-left: 10px;
  font-size: 12px;
  color: #7CFF7C;
}

.hidden {
  display: none;
}


.castling-box {
  display: flex;
  gap: 20px;
  margin-top: 6px;
  font-size: 13px;
}

.castling-box label {
  cursor: pointer;
}



.castling-row {
  display: grid;
  grid-template-columns: 50px auto auto;
  align-items: center;
  column-gap: 16px;
  margin-top: 6px;
}

.castling-row .side {
  font-weight: 600;
  font-size: 13px;
}

.castle-opt {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;   /* üî¥ THIS IS THE KEY */
}

.castle-opt span {
  white-space: nowrap;   /* üî¥ PREVENTS O- / O WRAP */
}


.castling-row {
  display: grid;
  grid-template-columns: 50px 1fr 1fr; /* equal columns */
  align-items: center;
  margin-top: 6px;
}

.castle-opt {
  display: flex;
  align-items: center;      /* üî• vertical centering */
  gap: 6px;
  white-space: nowrap;
}

.castle-opt input {
  margin: 0;                /* üî• removes checkbox vertical offset */
}

.bot-panel {
  position: relative;
  width: 180px;
  text-align: center;
}

.bot-bubble {
  position: relative;
  margin-top: 14px;

  padding: 20px 24px;          /* ‚¨Ö bigger bubble */
  background: #222958;
  color: #ffffff;

  border-radius: 26px;         /* ‚¨Ö softer, bigger cloud */
  font-size: 22px;             /* ‚¨Ö BIGGER TEXT */
  font-weight: 700;            /* ‚¨Ö stronger readability */

  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.45);
  display: inline-block;

  max-width: 190px;            /* ‚¨Ö wider bubble */
  line-height: 1.35;           /* ‚¨Ö better spacing */
  text-align: center;

  animation: popIn 0.25s ease-out;
}


/* üî∫ Bubble tail */
/* üî∫ Extended bubble tail */
.bot-bubble::before {
  content: "";
  position: absolute;
  top: -14px;                 /* ‚¨Ö move tail upward */
  left: 50%;
  transform: translateX(-50%);

  border-width: 0 10px 14px 10px;   /* ‚¨Ö LONGER tail */
  border-style: solid;
  border-color: transparent transparent #1c1f35 transparent;
}


.bot-bubble.hidden {
  display: none;
}

/* ‚ú® Smooth pop animation */
@keyframes popIn {
  from {
    transform: scale(0.85);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}



/* ===============================
   üìò STUDY LAYOUT (PHASE 1)
   =============================== */

.study-layout {
  display: grid;
  grid-template-columns: 280px minmax(640px, 1.6fr) 320px;
  gap: 18px;
  height: calc(100vh - 220px);
}


/* LEFT PANEL */
.study-left {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 12px;
  display: flex;
  flex-direction: column;
}

.study-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  color: #ffd700;
}

.study-list {
  flex: 1;
  max-height: calc(100vh - 260px); /* üëà limits height */
  overflow-y: auto;
  padding-right: 6px;
}

.study-list::-webkit-scrollbar {
  width: 6px;
}

.study-list::-webkit-scrollbar-thumb {
  background: rgba(255, 215, 0, 0.35);
  border-radius: 6px;
}

.study-list::-webkit-scrollbar-track {
  background: transparent;
}



.study-item {
  padding: 10px;
  font-weight: 700;
  color: #ffd700;
}

.study-chapter {
  padding: 8px 10px;
  cursor: pointer;
  border-radius: 8px;
}

.study-chapter:hover {
  background: rgba(255,255,255,0.05);
}

/* CENTER BOARD */
.study-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.study-board-placeholder {
  width: min(78vh, 78vw);
  max-width: 680px;
  aspect-ratio: 1 / 1;

  background: #101226;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);

  display: flex;
  align-items: center;
  justify-content: center;

  color: #9da0b8;
  font-size: 1.1rem;
}


/* RIGHT PANEL */
.study-right {
  display: flex;
  flex-direction: column;
  gap: 14px;
  height: 100%;
}

/* üîΩ Smaller engine */
.study-engine {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 12px;
  flex: 0 0 20%; /* engine height */
}

/* üîº Bigger notation */
.study-notation {
  background: linear-gradient(180deg, #242748, #1f2240);
  border-radius: 14px;
  padding: 12px;
  flex: 1; /* takes remaining space */
}


/* ===== Study interactions ===== */

.study-item {
  cursor: pointer;
  user-select: none;
}

.study-item.active {
  color: #ffd700;
}

.study-chapter {
  margin-left: 14px;
  font-size: 0.95rem;
  color: #d0d2ff;
}

.study-chapter.active {
  background: rgba(255, 215, 0, 0.12);
  color: #ffd700;
  font-weight: 600;
}


/* ===== Study Import Modal ===== */

.study-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.study-modal.hidden {
  display: none;
}

.study-modal-content {
  width: 520px;
  background: #1b1e3a;
  border-radius: 14px;
  padding: 18px;
}

.study-modal textarea {
  width: 100%;
  height: 220px;
  background: #0e1026;
  border: none;
  border-radius: 10px;
  padding: 12px;
  color: #fff;
  resize: none;
  margin-top: 10px;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 12px;
}




.notation-placeholder {
  overflow-y: auto;
  font-family: "Segoe UI", monospace;
  font-size: 0.95rem;
}

.notation-row {
  display: flex;
  gap: 8px;
  padding: 4px 0;
}

.move-num {
  color: #aaa;
  width: 28px;
}

.move.white {
  color: #fff;
  min-width: 48px;
}

.move.black {
  color: #bbb;
}


/* üìò Study notation ‚Äì grab cursor */
.study-notation .move {
  cursor: grab;
}

.study-notation .move:active {
  cursor: grabbing;
}


/* ‚ôüÔ∏è Study board ‚Äì grab cursor */
#studyBoard .piece-417db {
  cursor: grab;
}

#studyBoard .piece-417db:active {
  cursor: grabbing;
}


/* üìú Study notation panel (Lichess-like) */
.study-notation {
  max-height: 520px;        /* match board height */
  overflow-y: auto;         /* vertical scroll */
  overflow-x: hidden;       /* no horizontal scroll */
  padding-right: 6px;
}

/* Each move row */
.notation-row {
  display: block;
  white-space: normal;      /* allow wrapping */
  line-height: 1.6;
}

/* üåø Inline variations ( (Rxg6+) style ) */
.move.variation {
  margin-left: 6px;
  color: #aaa;
  font-style: italic;
  cursor: grab;
  white-space: normal;
  display: inline;
}

.move.variation:hover {
  color: #ffd700;
}

/* üñ± Scrollbar polish */
.study-notation::-webkit-scrollbar {
  width: 6px;
}

.study-notation::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 4px;
}

/* üîí Engine container ‚Äî FIXED SIZE */
.study-engine-box {
  background: #0f172a;
  border-radius: 12px;
  padding: 12px;
  color: #e5e7eb;
  font-size: 14px;

  height: 180px;              /* ‚úÖ FIXED HEIGHT */
  display: flex;
  flex-direction: column;
  overflow: hidden;           /* ‚ùå prevent resizing */
}

/* ===== Header ===== */
.engine-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;             /* üîí never shrink */
}

.engine-title {
  font-weight: 600;
}

.wasm-badge {
  background: #2563eb;
  color: #fff;
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 6px;
  margin-left: 6px;
}

/* ===== Toggle ===== */
.engine-toggle {
  border: none;
  border-radius: 6px;
  padding: 4px 10px;
  font-weight: 600;
  cursor: pointer;
}

.engine-toggle.off {
  background: #374151;
  color: #fff;
}

.engine-toggle.on {
  background: #16a34a;
  color: #fff;
}

/* ===== Stats ===== */
.engine-stats {
  margin-top: 6px;
  color: #93c5fd;
  flex-shrink: 0;             /* üîí fixed */
}

/* ===== PV Lines (ONLY THIS SCROLLS) ===== */
.engine-line {
  background: #020617;
  border-radius: 8px;
  padding: 6px 10px;
  margin-bottom: 6px;

  font-family: "JetBrains Mono", monospace; /* optional but üî• */
  font-size: 13.5px;
  font-weight: 600;          /* ‚úÖ makes moves bold */
  letter-spacing: 0.3px;     /* improves readability */
  color: #e5e7eb;

  line-height: 1.5;
}


/* Optional scrollbar polish */
.engine-lines::-webkit-scrollbar {
  width: 6px;
}
.engine-lines::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 6px;
}

/* ===== Individual PV Line ===== */
.engine-line {
  background: #020617;
  border-radius: 8px;
  padding: 6px 8px;
  margin-bottom: 6px;
  font-family: monospace;
  font-size: 13px;
  line-height: 1.4;
}

#enginePanel {
  height: 180px;              /* üîí FIXED HEIGHT */
  display: flex;
  flex-direction: column;
  overflow: hidden;           /* prevent resize */
}




/* üîí Study Engine fixed height (already done, re-confirm) */
.study-engine-box {
  height: 180px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* ‚úÖ SCROLLABLE PV AREA */
.engine-lines {
  flex: 1;                    /* take remaining space */
  overflow-y: auto;           /* ‚úÖ enable vertical scroll */
  margin-top: 8px;
  padding-right: 6px;
}

/* üé® Scrollbar styling (optional but nice) */
.engine-lines::-webkit-scrollbar {
  width: 6px;
}

.engine-lines::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 6px;
}

.engine-lines::-webkit-scrollbar-track {
  background: transparent;
}


/* üîí FIXED HEIGHT ANALYSIS ENGINE */
#enginePanel {
  height: 170px;              /* fixed height */
  display: flex;
  flex-direction: column;
  overflow: hidden;           /* prevent jumping */
}

/* Header must stay fixed */
.engine-bar {
  flex-shrink: 0;
}

/* ‚úÖ SCROLLABLE PV LINES */
.engine-body {
  flex: 1;                    /* take remaining space */
  overflow-y: auto;           /* ENABLE SCROLL */
  padding-right: 6px;
}

/* üé® Scrollbar styling (optional, matches Study) */
.engine-body::-webkit-scrollbar {
  width: 6px;
}

.engine-body::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 6px;
}

.engine-body::-webkit-scrollbar-track {
  background: transparent;
}


#quiz-section {
  min-height: calc(100vh - 140px);
}

#quizBoard {
  width: 420px;
}


.quiz-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
}

.quiz-timer,
.quiz-score {
  background: linear-gradient(180deg, #0f172a, #020617);
  border: 2px solid #facc15;          /* gold border */
  padding: 14px 22px;
  border-radius: 16px;

  font-weight: 800;
  font-size: 22px;                    /* BIG */
  letter-spacing: 0.5px;
  color: #facc15;                     /* gold text */

  display: flex;
  align-items: center;
  gap: 8px;

  box-shadow:
    0 0 0 3px rgba(250, 204, 21, 0.15),
    0 12px 30px rgba(0, 0, 0, 0.6);
}

#quizTimer,
#quizScore {
  font-size: 28px;
  font-weight: 900;
}

.quiz-timer.warning {
  border-color: #ef4444;
  color: #ef4444;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%   { box-shadow: 0 0 0 0 rgba(239,68,68,0.6); }
  70%  { box-shadow: 0 0 0 10px rgba(239,68,68,0); }
  100% { box-shadow: 0 0 0 0 rgba(239,68,68,0); }
}




.quiz-title {
  text-align: center;
  font-size: 18px;
  font-weight: 600;
  color: #e5e7eb;
  margin-bottom: 14px;
}


#quizBoardWrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 16px 0 18px;
}

#quizBoard {
  width: 500px;
  max-width: 100%;
  border-radius: 14px;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6);
}

.quiz-options {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 10px;
}

.quiz-option {
  background: linear-gradient(180deg, #1e293b, #111827);
  border: 1px solid #334155;
  border-radius: 14px;
  padding: 14px 10px;
  font-size: 15px;
  font-weight: 600;
  color: #e5e7eb;
  cursor: pointer;
  transition: all 0.15s ease;
}

.quiz-option:hover {
  background: linear-gradient(180deg, #2563eb, #1d4ed8);
  border-color: #3b82f6;
  transform: translateY(-1px);
}

.quiz-option:active {
  transform: scale(0.98);
}

@media (max-width: 480px) {
  #quizBoard {
    width: 100%;
  }

  .quiz-option {
    font-size: 14px;
    padding: 12px 8px;
  }
}



.mini-game {
  width: 450px;
  margin: 0 auto;
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 18px;
  padding: 14px;
  box-shadow: 0 12px 30px rgba(0,0,0,0.45);
  color: #fff;
  text-align: center;
}

.mini-header {
  display: flex;
  justify-content: space-between;
  font-weight: bold;
  margin-bottom: 20px;
}

.mini-title {
  color: gold;
}

.mini-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr); /* üîí force equal ranks */
  aspect-ratio: 1 / 1;               /* üîí perfect square */
  width: 100%;
}

.mini-square {
  width: 64px;
  height: 64px;
  background: #f0d9b5;            /* ‚ôüÔ∏è light square */
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}


.mini-square.dark {
  background: #b58863;            /* ‚ôüÔ∏è dark square */
}

.mini-square.correct {
  background: #4ade80 !important;
}

.mini-square.wrong {
  background: #ef4444 !important;
}

.mini-footer {
  margin-top: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#startMiniGame {
  padding: 6px 14px;
  border-radius: 10px;
  border: none;
  background: gold;
  font-weight: bold;
  cursor: pointer;
}





.mini-games-row {
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* üî• 2 columns */
  grid-template-rows: repeat(2, 1fr);    /* üî• 2 rows */
  gap: 28px;
  align-items: stretch;
}


@media (max-width: 1200px) {
  .mini-games-row {
    grid-template-columns: repeat(2, 260px);
  }
}

@media (max-width: 620px) {
  .mini-games-row {
    grid-template-columns: 1fr;
  }
}


.mini-game {
  width: 260px;
}


.mini-piece {
  width: 40px;          /* ‚¨ÜÔ∏è was 28px */
  height: 40px;
  object-fit: contain;
  pointer-events: none;
}





.mini-square {
  width: 38px;
  height: 38px;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;   /* VERY IMPORTANT */
}


.mini-square {
  cursor: grab;
}

.mini-square:active {
  cursor: grabbing;
}



/* =========================
   FOOTER
========================= */

.mini-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 40px;
  margin-top: 6px;
}

.mini-footer .stars {
  font-size: 20px;
  font-weight: 700;
  color: #ffd700;
  background: rgba(255,215,0,0.15);
  padding: 6px 12px;
  border-radius: 999px;
  box-shadow: inset 0 0 0 1px rgba(255,215,0,0.35);
}


/* =========================
   ‚ú® BEAUTIFUL START BUTTON
========================= */

.mini-footer button {
  padding: 10px 26px;
  font-size: 16px;
  font-weight: 800;
  border-radius: 999px;
  border: none;
  cursor: pointer;

  background: linear-gradient(180deg, #ffd700, #e6b800);
  color: #111;

  box-shadow:
    0 6px 18px rgba(255,215,0,0.45),
    inset 0 2px 0 rgba(255,255,255,0.35);

  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.mini-footer button:hover {
  transform: translateY(-1px);
  box-shadow:
    0 10px 28px rgba(255,215,0,0.6),
    inset 0 2px 0 rgba(255,255,255,0.45);
}


/* Hover */
.mini-footer button:hover {
  transform: translateY(-2px) scale(1.05);
  box-shadow:
    0 10px 22px rgba(255,215,0,0.65),
    inset 0 -2px 0 rgba(0,0,0,0.3);
}

/* Click */
.mini-footer button:active {
  transform: scale(0.95);
  box-shadow:
    0 4px 10px rgba(255,215,0,0.4),
    inset 0 2px 4px rgba(0,0,0,0.35);
}

/* =========================
   MOBILE TUNING
========================= */

@media (max-width: 520px) {
  .mini-title {
    font-size: 14px;
  }

  .mini-footer button {
    padding: 7px 16px;
    font-size: 12px;
  }
}

/* ===============================
   üéØ QUIZ RESULT MODAL (ISOLATED)
================================ */

.quiz-result-modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.55);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999; /* higher than quiz, lower than system modals */
}

.quiz-result-modal.hidden {
  display: none;
}

.quiz-result-box {
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 16px;
  padding: 24px 28px;
  width: 320px;
  text-align: center;
  box-shadow: 0 20px 50px rgba(0,0,0,0.6);
  animation: quizPop 0.25s ease-out;
}

.quiz-result-box h2 {
  color: #ffd700;
  margin-bottom: 10px;
}

.quiz-result-box p {
  color: #e5e7eb;
  font-size: 15px;
  margin-bottom: 18px;
}

.quiz-result-box button {
  background: #ffd700;
  color: #12162d;
  border: none;
  padding: 10px 18px;
  border-radius: 10px;
  font-weight: bold;
  cursor: pointer;
}

.quiz-result-box button:hover {
  background: #f5c400;
}

@keyframes quizPop {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}






.mini-square {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden; /* safety */
}



.practice-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);   /* üîí FORCE rows */

  width: 530px;
  height: 530px;                        /* üîí ABSOLUTE LOCK */

  
  border-radius: 0px;
  overflow: hidden;
}






.mini-piece {
  width: 90%;
  height: 90%;
  object-fit: contain;
  pointer-events: none;
  display: block;
}


.mini-square {
  position: relative;
}


.mini-game {
  background: radial-gradient(circle at top, #1e2448, #0d1022);
  border-radius: 18px;
  padding: 16px 16px 18px;
  box-shadow:
    0 20px 50px rgba(0,0,0,0.55),
    0 0 0 1px rgba(255,215,0,0.12);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  
}


.mini-game {
  display: flex;
  flex-direction: column;
  align-items: center;   /* üî• THIS is the key */
  gap: 12px;
}


/* ONLY piece practice boards */
.practice-board .mini-square[data-x="0"]::before {
  content: attr(data-rank);
  position: absolute;
  left: 4px;
  top: 4px;
  font-size: 20px;
  font-weight: 700;
  color: rgba(54, 6, 117, 0.851);
  pointer-events: none;
}


.practice-board .mini-square[data-y="7"]::after {
  content: attr(data-file);
  position: absolute;
  right: 4px;
  bottom: 4px;
  font-size: 20px;
  font-weight: 700;
  color: rgba(54, 6, 117, 0.851);
  pointer-events: none;
}



.mini-footer {
  display: flex;
  align-items: center;
  gap: 18px;
}

/* ‚≠ê & ‚ùå pill */
.mini-footer .stars,
.mini-footer .misses {
  display: flex;
  align-items: center;
  gap: 8px;

  padding: 10px 18px;        /* ‚¨ÜÔ∏è BIGGER */
  border-radius: 999px;

  font-weight: 800;
  font-size: 18px;           /* ‚¨ÜÔ∏è BIGGER TEXT */

  min-width: 70px;           /* ‚¨ÖÔ∏è keeps pill size consistent */
  justify-content: center;

  background: rgba(0, 0, 0, 0.55);
  box-shadow:
    inset 0 0 0 2px rgba(255, 215, 0, 0.35),
    0 6px 14px rgba(0,0,0,0.4);
}

/* ‚≠ê */
.mini-footer .stars {
  color: #ffd700;
}

/* ‚ùå */
.mini-footer .misses {
  color: #ff4d4d;
  box-shadow:
    inset 0 0 0 2px rgba(255, 77, 77, 0.45),
    0 6px 14px rgba(0,0,0,0.4);
}


/* üî• Mini-game header title (ALL pieces) */
.mini-title {
  display: inline-flex;
  align-items: center;
  gap: 8px;

  font-size: 18px;        /* ‚¨ÜÔ∏è was small ‚Üí now readable */
  font-weight: 800;       /* bold */
  letter-spacing: 0.4px;

  color: #ffd700;         /* Olympus gold */
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
}



.target-object {
  position: absolute;
  width: 75%;
  height: 75%;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;

  /* glow */
  filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.8))
          drop-shadow(0 0 14px rgba(255, 180, 0, 0.6));

  animation: glowFloat 1.6s ease-in-out infinite;
}

/* ‚ú® glowing + floating */
@keyframes glowFloat {
  0% {
    transform: translate(-50%, -52%) scale(1);
    filter: drop-shadow(0 0 6px rgba(0, 4, 255, 0.7))
            drop-shadow(0 0 14px rgba(255, 0, 200, 0.5));
  }
  50% {
    transform: translate(-50%, -58%) scale(1.08);
    filter: drop-shadow(0 0 12px rgb(24, 2, 75))
            drop-shadow(0 0 26px rgba(228, 0, 141, 0.9));
  }
  100% {
    transform: translate(-50%, -52%) scale(1);
    filter: drop-shadow(0 0 6px rgba(255, 0, 0, 0.7))
            drop-shadow(0 0 14px rgba(255, 180, 0, 0.5));
  }
}


.target-object {
  width: 80%;
  height: 80%;
}

#botMouth {
  z-index: 5;
}

.bot-avatar img {
  position: relative;
  z-index: 1;
}



#studyDrawLayer {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none; /* prevents crashes */
}


.memory-top {
  display: flex;
  justify-content: space-between;
  font-size: 18px;
  margin-bottom: 10px;
}

.memory-square {
  width: 100%;
  aspect-ratio: 1;
  background: #e5e7eb;
  cursor: pointer;
}

/* =========================
   ‚ôü MEMORY BOARD COORDINATES
   (UNIFORM DEEP BLUE)
========================= */

.memory-square {
  position: relative;
}

.memory-coord {
  position: absolute;
  top: 4px;
  left: 4px;

  font-size: 11px;
  font-weight: 700;
  line-height: 1;

  /* üîµ Uniform deep blue */
  color: #60038b;

  opacity: 1;
  pointer-events: none;
  user-select: none;

  /* subtle glow for readability */
  text-shadow: 0 0 3px rgba(30, 111, 217, 0.45);
}


.memory-square.dark {
  background: #9ca3af;
}

.memory-square.flash {
  background: #22c55e !important;
}

.memory-square.correct {
  background: #16a34a !important;
}

.memory-square.wrong {
  background: #dc2626 !important;
}


/* ============================= */
/* üß† Memory Squares Board Size  */
/* ============================= */

#memory-section .mini-board {
  width: 560px;        /* üëà control size here */
  max-width: 90vw;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  aspect-ratio: 1;
}



/* ============================= */
/* üß† Memory Squares ‚Äì Top Bar   */
/* ============================= */

#memory-section .memory-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 360px;
  margin: 0 auto 14px auto;
  padding: 8px 14px;
  background: rgba(0, 0, 0, 0.35);
  border-radius: 14px;
  font-size: 20px;
  font-weight: 600;
  color: #f8fafc;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
}

#memory-section .memory-top span {
  margin-left: 6px;
}

#memory-section .memory-top .timer {
  color: #38bdf8; /* blue */
}

#memory-section .memory-top .lives {
  color: #f87171; /* red */
}

#memory-section .memory-top .score {
  color: #facc15; /* gold */
}




/* ============================= */
/* üß† Memory Squares ‚Äì Board     */
/* ============================= */

#memory-section .memory-square {
  width: 100%;
  aspect-ratio: 1;
  cursor: pointer;
  transition: background 0.15s ease, box-shadow 0.15s ease;
}

#memory-section .memory-square:not(.dark) {
  background: #f0d9b5; /* light brown */
}

#memory-section .memory-square.dark {
  background: #b58863; /* dark brown */
}



#memory-section .memory-square.flash {
  background: #222dc5 !important;
  box-shadow: 0 0 12px rgba(34,197,94,0.8);
}

#memory-section .memory-square.correct {
  background: #16a34a !important;
}

#memory-section .memory-square.wrong {
  background: #dc2626 !important;
}


/* ============================= */
/* üß† Memory Squares ‚Äì Mode Cards */
/* ============================= */

#memory-section #memoryMenu {
  max-width: 900px;
  margin: 0 auto;
}

#memory-section #memoryMenu h3 {
  font-size: 22px;
  margin-bottom: 18px;
  color: #facc15;
}

/* Grid for big buttons */
#memory-section .control-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
}

/* Big buttons */
#memory-section .control-grid button {
  height: 64px;
  font-size: 20px;
  font-weight: 700;
  border-radius: 14px;
  letter-spacing: 0.5px;
  box-shadow: 0 10px 20px rgba(0,0,0,0.35);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

/* Hover effect */
#memory-section .control-grid button:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 26px rgba(0,0,0,0.45);
}

/* Survival full width */
#memory-section .control-grid button#memSurvival {
  grid-column: 1 / -1;
  height: 58px;
  font-size: 19px;
}

#memory-section .control-grid button {
  border: 2px solid rgba(255,255,255,0.15);
}


/* ===============================
   üëë QUEEN MEMORY PATH
================================ */

#pathfinder-section .card {
  max-width: 600px;
  margin: auto;
}

#pfBoard {
  display: grid;
  grid-template-columns: repeat(8, 1fr);

  /* ‚¨ÜÔ∏è Bigger board */
  width: 570px;
  height: 570px;

  margin: 24px auto;
}



.pf-square.light { background: #f0d9b5; }
.pf-square.dark  { background: #b58863; }

/* flash colors */
.pf-green { background: #3fb950 !important; }
.pf-red   { background: #ff4d4f !important; }
.pf-grey  { background: #6b7280 !important; }

.pf-queen {
  width: 100%;
  height: 100%;
  background: url("assets/pieces/wQ.png") center / 70% no-repeat;
}

.pf-home {
  width: 100%;
  height: 100%;
  background: url("assets/icons/home.png") center / 70% no-repeat;
}

.pf-square {
  position: relative;
}

.pf-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}


/* cursor when hovering board */
#pfBoard {
  cursor: grab;
}

/* cursor while clicking */
#pfBoard:active {
  cursor: grabbing;
}

/* individual squares also show grab */
#pfBoard .pf-square {
  cursor: grab;
}

#pfBoard .pf-square:active {
  cursor: grabbing;
}



.qp-home {
  font-size: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;

  background: rgba(0, 255, 0, 0.15);
  border: none solid #00ff66;
  border-radius: 0px;
}


.pf-home-icon {
  font-size: 40px;
  pointer-events: none; /* üëà very important */
}

/* ================================
   üéØ PATHFINDER MODE SELECTION
================================ */

#pfMenu.card {
  max-width: 720px;
  margin: 0 auto;
  padding: 32px 36px;
  background: linear-gradient(180deg, #1c2240, #12162d);
  border-radius: 20px;
  box-shadow: 0 20px 50px rgba(0,0,0,0.55);
  border-left: 5px solid #facc15;
}

#pfMenu h3 {
  font-size: 30px;
  margin-bottom: 28px;
  color: #facc15;
  text-align: center;
  letter-spacing: 0.5px;
}

/* grid layout */
#pfMenu .control-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
}

/* buttons */
#pfMenu button {
  height: 70px;
  font-size: 19px;
  font-weight: 700;
  border-radius: 14px;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

/* hover effect */
#pfMenu button:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 10px 25px rgba(0,0,0,0.4);
}

/* EASY */
#pfEasy {
  background: linear-gradient(135deg, #22c55e, #16a34a);
  color: #022c22;
}

/* MEDIUM */
#pfMedium {
  background: linear-gradient(135deg, #facc15, #eab308);
  color: #3a2f00;
}

/* SURVIVAL */
#pfSurvival {
  grid-column: span 2;
  background: linear-gradient(135deg, #ff4d4d, #dc2626);
  color: white;
  font-size: 20px;
}


/* ================================
   üéØ PATH FINDER HUD (TIMER / LIFE / STAR)
================================ */

.pf-hud {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
}

/* common HUD item */
.pf-hud .hud-item {
  background: linear-gradient(180deg, #1f2547, #141a33);
  border-radius: 14px;
  padding: 10px 14px;
  font-size: 20px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.06),
    0 6px 20px rgba(0,0,0,0.4);
}

/* timer */
.pf-hud .timer {
  color: #38bdf8;
}

/* lives */
.pf-hud .lives {
  color: #ff4d4d;
}

/* stars */
.pf-hud .score {
  color: #facc15;
}

/* numbers */
.pf-hud span {
  font-size: 20px;
}

/* small pulse when values change (optional but nice) */
.pf-hud span {
  transition: transform 0.15s ease;
}


.pf-queen-emoji {
  font-size: 42px;
  line-height: 1;
  cursor: grab;
  user-select: none;

  display: flex;
  align-items: center;
  justify-content: center;
  

  animation: queenIdle 1.6s ease-in-out infinite;
}

@keyframes queenIdle {
  0%   { transform: translateY(0); }
  50%  { transform: translateY(-3px); }
  100% { transform: translateY(0); }
}


.pf-queen-emoji:active {
  cursor: grabbing;
}


.pf-piece {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 34px;
  line-height: 1;
}

.mini-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  width: 550px;          /* ‚úÖ FIXED SIZE */
  height: 550px;         /* ‚úÖ PERFECT SQUARE */
  margin: 20px auto;
  border-radius: 10px;
  overflow: hidden;
}


.pf-square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;      /* emoji size */
  cursor: pointer;
  user-select: none;
}



/* All flash-queen pieces */
.pf-piece {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 38px;          /* üî• increase emoji size */
  line-height: 1;
  cursor: pointer;
}

/* Queen slightly bigger + highlight */
.pf-piece.queen {
  font-size: 34px;
  filter: drop-shadow(0 0 6px gold);
}


/* üî• BIG MODE SELECTION CARD */
#flashQueenMenu {
  max-width: 900px;                 /* bigger card */
  margin: 40px auto;
  padding: 32px 36px;

  background: linear-gradient(
    180deg,
    #1b2142 0%,
    #141a36 100%
  );

  border-radius: 22px;
  border: 2px solid rgba(255, 215, 0, 0.35);

  box-shadow:
    0 0 25px rgba(255, 215, 0, 0.25),
    0 0 60px rgba(255, 215, 0, 0.15),
    inset 0 0 20px rgba(255, 255, 255, 0.04);

  animation: fqGlow 3s ease-in-out infinite;
}

/* ‚ú® subtle breathing glow */
@keyframes fqGlow {
  0% {
    box-shadow:
      0 0 18px rgba(255, 215, 0, 0.18),
      0 0 45px rgba(255, 215, 0, 0.12);
  }
  50% {
    box-shadow:
      0 0 32px rgba(255, 215, 0, 0.35),
      0 0 80px rgba(255, 215, 0, 0.25);
  }
  100% {
    box-shadow:
      0 0 18px rgba(255, 215, 0, 0.18),
      0 0 45px rgba(255, 215, 0, 0.12);
  }
}


#flashQueenMenu .control-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
  margin-top: 24px;
}

#flashQueenMenu button {
  font-size: 20px;
  padding: 18px 22px;
  border-radius: 14px;
  font-weight: 700;
  letter-spacing: 0.5px;
}

/* Survival stands out */
#fqSurvival {
  grid-column: span 2;
  font-size: 21px;
}


/* ============================= */
/* üéÆ COMPACT HUD (FIXED HEIGHT) */
/* ============================= */

.flash-queen-hud,
.memory-top {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin: 10px 0 14px;   /* ‚¨ÖÔ∏è reduced vertical margin */
}

#flashQueenBoard {
  margin-top: -1px;
}


.flash-queen-hud .timer,
#fqTimer {
  background: linear-gradient(180deg, #1e2a5c, #131c3f);
  border-radius: 14px;
  padding: 14px 18px;
  margin-top: -40px;


  font-size: 20px;
  font-weight: 700;
  color: #4fd1ff;

  display: flex;
  align-items: center;
  justify-content: center;

  box-shadow:
    inset 0 0 12px rgba(79, 209, 255, 0.25),
    0 0 18px rgba(79, 209, 255, 0.18);
}

.flash-queen-hud .lives,
#fqLives {
  background: linear-gradient(180deg, #4a0f1f, #2a0610);
  border-radius: 14px;
  padding: 14px 18px;
  margin-top: -40px;

  font-size: 20px;
  font-weight: 800;
  color: #ff4d6d;

  display: flex;
  align-items: center;
  justify-content: center;

  box-shadow:
    inset 0 0 12px rgba(255, 77, 109, 0.3),
    0 0 18px rgba(255, 77, 109, 0.25);
}

.flash-queen-hud .score,
#fqScore {
  background: linear-gradient(180deg, #5a4600, #2f2500);
  border-radius: 14px;
  padding: 14px 18px;
  margin-top: -40px;

  font-size: 20px;
  font-weight: 800;
  color: #ffd700;

  display: flex;
  align-items: center;
  justify-content: center;

  box-shadow:
    inset 0 0 14px rgba(255, 215, 0, 0.35),
    0 0 22px rgba(255, 215, 0, 0.35);
}

.flash-queen-question,
.question {
  margin: 6px 0 14px;
  margin-top: -30px;



  font-size: 22px;
  font-weight: 800;
  text-align: center;

  color: #ffffff;
  letter-spacing: 0.5px;

  text-shadow:
    0 0 8px rgba(255, 215, 0, 0.45),
    0 0 18px rgba(255, 215, 0, 0.25);
}

.flash-queen-hud > div {
  animation: hudPop 0.35s ease-out;
}

@keyframes hudPop {
  from {
    transform: scale(0.9);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

/* normal emoji */
.pf-piece {
  font-size: 35px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* üë∏ QUEEN SPECIAL */
.pf-queen {
  font-size: 36px;                 /* bigger */
  text-shadow:
    0 0 6px gold,
    0 0 12px gold,
    0 0 18px rgba(255,215,0,0.8);
  animation: queenGlow 1.5s infinite alternate;
}

/* glow animation */
@keyframes queenGlow {
  from {
    transform: scale(1);
    filter: drop-shadow(0 0 4px gold);
  }
  to {
    transform: scale(1.08);
    filter: drop-shadow(0 0 10px gold);
  }
}


/* HOW TO PLAY ‚Äì Puzzle Rush */
.how-to-play {
  margin-top: 18px;
  padding: 16px 18px;
  border-radius: 14px;
  background: linear-gradient(180deg, #1b203f, #141833);
  border: 1px solid rgba(255, 215, 0, 0.25);
  box-shadow: inset 0 0 18px rgba(255, 215, 0, 0.08);
}

.how-to-play h4 {
  margin-bottom: 10px;
  color: #ffd700;
  font-size: 1.05rem;
  text-align: center;
}

.how-to-play ul {
  list-style: none;
  padding: 0;
  margin: 0 0 10px;
}

.how-to-play li {
  font-size: 0.95rem;
  color: #eaeaf0;
  padding: 4px 0;
  line-height: 1.4;
}

.how-to-play .mode-info {
  font-size: 0.85rem;
  color: #b9c0ff;
  border-top: 1px dashed rgba(255, 215, 0, 0.3);
  padding-top: 8px;
}

.how-to-play .mode-info span {
  color: #ffd700;
  font-weight: 600;
}


/* HOW TO PLAY ‚Äì Shared Style */
.how-to-play {
  margin-top: 18px;
  padding: 16px 18px;
  border-radius: 14px;
  background: linear-gradient(180deg, #1b203f, #141833);
  border: 1px solid rgba(255, 215, 0, 0.25);
  box-shadow: inset 0 0 18px rgba(255, 215, 0, 0.08);
}

.how-to-play h4 {
  margin-bottom: 10px;
  color: #ffd700;
  font-size: 1.05rem;
  text-align: center;
}

.how-to-play ul {
  list-style: none;
  padding: 0;
  margin: 0 0 10px;
}

.how-to-play li {
  font-size: 0.95rem;
  color: #eaeaf0;
  padding: 4px 0;
  line-height: 1.4;
}

.how-to-play .mode-info {
  font-size: 0.85rem;
  color: #b9c0ff;
  border-top: 1px dashed rgba(255, 215, 0, 0.3);
  padding-top: 8px;
}

.how-to-play .mode-info span {
  color: #ffd700;
  font-weight: 600;
}

.kp-square {
  position: relative;
}

.ksr-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* üîµ deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}



.kp-square.flash {
  background: #ffd700 !important;
  box-shadow: inset 0 0 0 4px #ff9800;
}

.kp-square.knight {
  font-size: 28px;
}

.kp-square {
  position: relative;
}

.kem-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}






/* ===== Knight Flash Path Board ===== */
/* ===== Knight Flash Path Board (REAL CHESS BOARD) ===== */
#kpBoard {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  width: 580px;
  height: 580px;
   margin: -25px auto 30px;
  border-radius: 12px;
  overflow: hidden;
  border: 3px solid #3b2a1a;
}

.kp-square {
  position: relative;
}

.kp-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;       /* üíú Deep Blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}



/* Square base */
.kp-square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
  cursor: pointer;
  user-select: none;
}

/* REAL chessboard coloring */
.kp-square.light {
  background: #f0d9b5; /* light brown */
}

.kp-square.dark {
  background: #b58863; /* dark brown */
}

/* Flash highlight */
.kp-square.flash {
  background: #ffd700 !important;
  box-shadow: inset 0 0 0 3px #ff9800;
}

/* Knight piece */
.kp-square.knight {
  font-size: 28px;
}



.kp-square.knight {
  font-size: 35px;
  line-height: 1;
}

#kpBoard.locked {
  pointer-events: none;
}


/* ===== Knight Flash Path Card ===== */
.kp-card {
  background: linear-gradient(180deg, #1a2040, #141a33);
  border-radius: 18px;
  padding: 22px;
  box-shadow:
    0 15px 40px rgba(0,0,0,0.55),
    inset 0 0 0 1px rgba(255,255,255,0.05);
}

/* Title */
.kp-card h3 {
  margin-bottom: 14px;
  color: #ffd700;
  font-weight: 700;
}

/* ===== Mode Buttons ===== */
.kp-modes {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 14px;
  margin-bottom: 18px;
}

.kp-mode-btn {
  padding: 14px 18px;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.25s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

/* Easy */
.kp-mode-easy {
  background: linear-gradient(135deg, #28c76f, #1ea85a);
  color: #081b12;
}

/* Medium */
.kp-mode-medium {
  background: linear-gradient(135deg, #ffd44d, #ffb703);
  color: #2b1d00;
}

/* Hard */
.kp-mode-hard {
  grid-column: span 2;
  background: linear-gradient(135deg, #ff4d4f, #d62828);
  color: #fff;
}

/* Hover effect */
.kp-mode-btn:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 8px 25px rgba(0,0,0,0.4);
}

/* ===== How To Play ===== */
.kp-how {
  margin-top: 16px;
  padding: 16px;
  border-radius: 14px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,215,0,0.2);
}

.kp-how h4 {
  margin-bottom: 10px;
  color: #ffd700;
  display: flex;
  align-items: center;
  gap: 8px;
}

.kp-how ul {
  padding-left: 18px;
  margin: 0;
}

.kp-how li {
  margin-bottom: 8px;
  color: #d6dbff;
  line-height: 1.5;
  font-size: 20px;
}



/* ===== Knight Flash Path HUD ===== */
.memory-top {
  display: flex;
  gap: 24px;
  margin-bottom: 18px;
}

/* Each stat box */
.memory-top > div {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  border-radius: 14px;
  font-size: 15px;
  font-weight: 600;
  background: linear-gradient(180deg, #1f254a, #161c38);
  box-shadow:
    0 6px 18px rgba(0,0,0,0.4),
    inset 0 0 0 1px rgba(255,255,255,0.05);
}

/* Level specific */
.memory-top > div:first-child {
  color: #ffd700;
  border: 1px solid rgba(255,215,0,0.25);
}

/* Lives specific */
.memory-top > div:last-child {
  color: #ff6b6b;
  border: 1px solid rgba(255,107,107,0.25);
}

/* Numbers */
.memory-top span {
  font-size: 18px;
  font-weight: 800;
  margin-left: 2px;
  transition: transform 0.2s ease;
}

/* Optional pop animation */
.memory-top span.pop {
  transform: scale(1.2);
}

/* =============================== */
/* üß™ LAB MIXER ‚Äì ISOLATED STYLES */
/* =============================== */

.lm-square {
  position: relative;
}

.lm-overlay {
  position: absolute;
  inset: 0;
  border-radius: 0px;
  opacity: 0;
  transition: opacity 0.15s ease;
  pointer-events: none;
}

.lm-overlay.show {
  opacity: 0.9;
}

.lm-square {
  position: relative;
}

.lm-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;     /* üîµ deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}


/* color variants */
.lm-red    { background: #ff4d4d; }
.lm-green  { background: #3cff7a; }
.lm-blue   { background: #4da6ff; }
.lm-yellow { background: #ffd93d; }
.lm-orange { background: #ff9f43; }
.lm-violet { background: #b980ff; }


/* =============================== */
/* üß™ LAB MIXER ‚Äì FIND BANNER */
/* =============================== */

#color-section .lm-find-banner {
  text-align: center;
  margin: -70px auto 8px; /* üëà pulls UP */
  padding: 10px 18px;
  width: fit-content;

  background: linear-gradient(135deg, #1e223d, #2a2f55);
  border: 1px solid rgba(255, 215, 0, 0.35);
  border-radius: 14px;

  font-size: 18px;
  font-weight: 800;
  letter-spacing: 1px;
  color: #ffd700;

  box-shadow: 0 0 12px rgba(255, 215, 0, 0.25);
}

#color-section .lm-find-banner span {
  padding-left: 6px;
  text-transform: uppercase;
}


/* =============================== */
/* üß™ LAB MIXER ‚Äì FIND COLOR THEMES */
/* =============================== */

#color-section .find-red    { color: #ff4d4d; box-shadow: 0 0 14px rgba(255, 77, 77, 0.4); }
#color-section .find-green  { color: #3cff7a; box-shadow: 0 0 14px rgba(60, 255, 122, 0.4); }
#color-section .find-blue   { color: #4da6ff; box-shadow: 0 0 14px rgba(77, 166, 255, 0.4); }
#color-section .find-yellow { color: #ffd700; box-shadow: 0 0 14px rgba(255, 215, 0, 0.4); }
#color-section .find-orange { color: #ff9f43; box-shadow: 0 0 14px rgba(255, 159, 67, 0.4); }
#color-section .find-violet { color: #b980ff; box-shadow: 0 0 14px rgba(185, 128, 255, 0.4); }





/* =============================== */
/* üß™ LAB MIXER ‚Äì ROUND BADGE (ALWAYS GOLD) */
/* =============================== */

#color-section .lm-round {
  background: linear-gradient(
    135deg,
    #3a2c00,
    #8a6a00,
    #ffd700,
    #8a6a00
  );

  color: #1a1300;
  font-weight: 900;
  letter-spacing: 1px;

  padding: 6px 14px;
  border-radius: 10px;

  border: 1px solid rgba(255, 215, 0, 0.6);

  box-shadow:
    0 0 12px rgba(255, 215, 0, 0.6),
    inset 0 0 6px rgba(255, 255, 255, 0.35);

  text-shadow:
    0 1px 1px rgba(255, 255, 255, 0.6),
    0 -1px 1px rgba(0, 0, 0, 0.4);

  transition: all 0.25s ease;
}



#color-section .lm-round {
  animation: lmGoldPulse 2.8s ease-in-out infinite;
}

@keyframes lmGoldPulse {
  0%   { box-shadow: 0 0 10px rgba(255,215,0,0.4); }
  50%  { box-shadow: 0 0 20px rgba(255,215,0,0.9); }
  100% { box-shadow: 0 0 10px rgba(255,215,0,0.4); }
}




/* ============================= */
/* Knight vs Monster - Mode UI  */
/* ============================= */

.kvm-modes {
  display: grid;
  grid-template-columns: repeat(3, minmax(160px, 1fr));
  gap: 16px;
  margin: 20px 0;
}

.kvm-coord {
  position: absolute;
  bottom: 3px;
  right: 4px;
  font-size: 11px;
  color: #1e40af;   /* üîµ deep blue */
  opacity: 1;
  pointer-events: none;
  font-weight: 500;
}

.kvm-mode {
  background: linear-gradient(180deg, #1b1f3b, #12142a);
  border: 2px solid #2f335c;
  border-radius: 14px;
  padding: 18px 10px;
  color: #fff;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.25s ease;
  box-shadow: 0 6px 16px rgba(0,0,0,0.4);
}

.kvm-mode span {
  display: block;
  margin-top: 6px;
  font-size: 13px;
  font-weight: 500;
  opacity: 0.8;
}

/* Hover effect */
.kvm-mode:hover {
  transform: translateY(-4px) scale(1.03);
  box-shadow: 0 10px 26px rgba(0,0,0,0.6);
}

/* Difficulty colors */
.kvm-mode.easy {
  border-color: #2ecc71;
}
.kvm-mode.medium {
  border-color: #f1c40f;
}
.kvm-mode.hard {
  border-color: #e74c3c;
}

/* Click feedback */
.kvm-mode:active {
  transform: scale(0.97);
}




/* ============================= */
/* Knight vs Monster - Emoji UI */
/* ============================= */

#kvmBoard .kp-square {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40px;          /* üëà MAIN SIZE CONTROL */
  cursor: pointer;
  user-select: none;
}

/* Slight emphasis */
#kvmBoard .kp-square span {
  transform: scale(1.1);
}



/* ================================================= */
/* üî• KNIGHT LAVA FLOOR ‚Äì CLEAN & NORMAL CHESS BOARD */
/* ================================================= */

#klfBoard {
  display: grid;
  grid-template-columns: repeat(10, 1fr); /* ‚¨ÖÔ∏è 10 files */
  grid-template-rows: repeat(10, 1fr);    /* ‚¨ÖÔ∏è 10 ranks */

  width: 620px;   /* slightly bigger for 10√ó10 */
  height: 620px;

  margin: 20px auto;
  border-radius: 12px;
  overflow: hidden;
  border: 3px solid #3b2a1a;
}


/* ================= */
/* BOARD SQUARE BASE */
/* ================= */
#klfBoard .klf-square {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 34px;
  line-height: 1; /* üî• FIX EMOJI DISTORTION */

  cursor: pointer;
  user-select: none;

  border: none !important;
  outline: none !important;
  box-shadow: none !important;
}

/* ================= */
/* NORMAL BROWN BOARD */
/* ================= */
#klfBoard .klf-light {
  background-color: #f0d9b5;
}

#klfBoard .klf-dark {
  background-color: #b58863;
}

/* ====== */
/* KNIGHT */
/* ====== */
#klfBoard .klf-knight {
  font-size: 36px;
  filter: drop-shadow(0 3px 6px rgba(0,0,0,0.5));
}

/* ===== */
/* LAVA */
/* ===== */
#klfBoard .klf-lava {
  background-color: #e65100;
  box-shadow:
    inset 0 0 10px rgba(255,180,0,0.7),
    inset 0 0 18px rgba(255,80,0,0.9);
  animation: klfLavaPulse 1.2s infinite ease-in-out;
}

@keyframes klfLavaPulse {
  0%   { filter: brightness(1); }
  50%  { filter: brightness(1.25); }
  100% { filter: brightness(1); }
}





/* ================================= */
/* üî• KLF FLOATING RESULT MODAL */
/* ================================= */

#klfResultOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999; /* above game only */
}

#klfResultOverlay.hidden {
  display: none;
}

#klfResultOverlay .klf-modal-card {
  background: linear-gradient(180deg, #1e2238, #14182b);
  padding: 24px 28px;
  border-radius: 14px;
  min-width: 280px;
  text-align: center;

  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
  border: 1px solid rgba(255, 215, 0, 0.35);
}

#klfResultOverlay h3 {
  margin-bottom: 10px;
  color: #ffcc33;
}

#klfResultOverlay p {
  margin-bottom: 18px;
  color: #e6e6e6;
  font-size: 15px;
}





/* ================================================= */
/* üî• KLF INTRO CARD ‚Äì FULLY ISOLATED STYLING */
/* ================================================= */

/* ================================================= */
/* üî• KLF INTRO CARD ‚Äì LARGE & PROMINENT */
/* ================================================= */

#knightlava-section .klf-intro-card {
  background: linear-gradient(180deg, #1f2340, #161a33);
  border-radius: 18px;

  /* üî• SIZE FIX */
  padding: 28px 34px;
  max-width: 900px;          /* ‚¨ÖÔ∏è bigger */
  min-height: 220px;         /* ‚¨ÖÔ∏è gives weight */

  border-left: 6px solid #ffcc33;

  box-shadow:
    inset 0 0 0 1px rgba(255,215,0,0.18),
    0 16px 40px rgba(0,0,0,0.45);
}


/* Title */
#knightlava-section .klf-intro-card h3 {
  margin-bottom: 10px;
  color: #ffcc33;
  font-size: 22px;
}

/* Rules list */
#knightlava-section .klf-rules {
  list-style: none;
  padding: 0;
  margin: 0 0 16px 0;
}

#knightlava-section .klf-rules li {
  margin-bottom: 6px;
  color: #d6d9ff;
  font-size: 15x;
  line-height: 1.5;
}

/* Highlight important text */
#knightlava-section .klf-rules b {
  color: #ffffff;
}

/* Start button */
#knightlava-section .klf-start-btn {
  margin-top: 14px;
  padding: 12px 22px;
  font-size: 15px;
}




/* ========================================= */
/* üå´Ô∏èüçé KNIGHT FOG QUEST ‚Äì ISOLATED BOARD */
/* ========================================= */

#kfqBoard {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  grid-template-rows: repeat(10, 1fr);

  width: 620px;     /* same as your example */
  height: 620px;

  margin: 20px auto;
  padding: 10px;

  background: #e7cfa8;     /* wooden frame */
  border-radius: 12px;
  overflow: hidden;

  border: 3px solid #b3a1a3;
  box-shadow:
    inset 0 0 0 2px #b08968,
    0 10px 30px rgba(0,0,0,0.4);
}

/* ===================== */
/* BOARD SQUARES         */
/* ===================== */

#kfqBoard .kfq-square {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 24px;
  cursor: pointer;
  user-select: none;
}

/* light / dark squares */
#kfqBoard .kfq-light {
  background: #f3ddb8;
}

#kfqBoard .kfq-dark {
  background: #b88a60;
}

/* fog effect */
#kfqBoard .kfq-fog {
  filter: brightness(0.45);
}

/* knight */
#kfqBoard .kfq-knight {
  font-size: 30px;
  transform: scale(1.1);
}




/* ======================================= */
/* üå´Ô∏èüçé KNIGHT FOG QUEST ‚Äì MENU UI (ISOLATED)
/* ======================================= */

#knightfog-section {
  max-width: 1100px;
  margin: 30px auto;
}

/* Title */
#knightfog-section > h2 {
  font-size: 22px;
  font-weight: 700;
  padding-left: 12px;
  margin-bottom: 14px;
  color: #ffd84d;
}

/* Main menu card */
#knightfog-section #kfqMenu {
  background: linear-gradient(180deg, #1f2342, #1a1e38);
  border-radius: 14px;
  padding: 26px 28px;
  box-shadow: 0 15px 40px rgba(0,0,0,0.45);
  position: relative;
}

/* Yellow side accent */
#knightfog-section #kfqMenu::before {
  content: "";
  position: absolute;
  left: 0;
  top: 18px;
  bottom: 18px;
  width: 5px;
  border-radius: 6px;
  background: #ffd400;
}

/* Heading */
#knightfog-section #kfqMenu h3 {
  margin: 0 0 6px 0;
  font-size: 20px;
  color: #ffffff;
}

/* Description text */
#knightfog-section #kfqMenu p {
  margin: 0 0 18px 0;
  line-height: 1.55;
  color: #c9cbe3;
  font-size: 14.5px;
}

/* Speed challenge box */
#knightfog-section .kfq-modes {
  display: flex;
  gap: 12px;
  margin: 10px 0 18px 0;
}

/* Difficulty buttons */
#knightfog-section .kfq-mode {
  flex: 0 0 auto;
  padding: 8px 12px;
  border-radius: 10px;
  font-size: 13px;
  font-weight: 600;
  background: #12152b;
  color: #fff;
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.25s ease;
  text-align: center;
}

#knightfog-section .kfq-mode span {
  display: block;
  font-size: 12px;
  font-weight: 500;
  opacity: 0.9;
}

/* Easy */
#knightfog-section .kfq-mode.easy {
  border-color: #26d96f;
}
#knightfog-section .kfq-mode.easy:hover {
  background: rgba(38,217,111,0.15);
}

/* Medium */
#knightfog-section .kfq-mode.medium {
  border-color: #ffd84d;
}
#knightfog-section .kfq-mode.medium:hover {
  background: rgba(255,216,77,0.15);
}

/* Hard */
#knightfog-section .kfq-mode.hard {
  border-color: #ff6a3d;
}
#knightfog-section .kfq-mode.hard:hover {
  background: rgba(255,106,61,0.15);
}

/* Start normal mode button */
#knightfog-section .btn-primary {
  margin-top: 6px;
  padding: 10px 18px;
  font-size: 14px;
  font-weight: 700;
  border-radius: 10px;
  background: linear-gradient(180deg, #ffd84d, #f0c400);
  color: #121212;
  border: none;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

#knightfog-section .btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 18px rgba(255,216,77,0.45);
}

/* ======================================= */
/* üå´Ô∏èüçé Knight Fog Quest ‚Äì Bigger Buttons */
/* ======================================= */

#knightfog-section .kfq-modes {
  gap: 18px; /* more spacing */
}

#knightfog-section .kfq-mode {
  min-width: 140px;
  padding: 30px 110px;
  border-radius: 14px;

  font-size: 20px;
  line-height: 1.2;
}

#knightfog-section .kfq-mode span {
  font-size: 13px;
  margin-top: 4px;
}

/* Optional: subtle press effect */
#knightfog-section .kfq-mode:active {
  transform: scale(0.97);
}


/* ================================= */
/* üëë KNIGHT DEFENSE ‚Äì 10x10 BOARD */
/* ================================= */

#kndBoard {
  display: grid;

  grid-template-columns: repeat(10, 60px);
  grid-template-rows: repeat(10, 60px);

  width: calc(10 * 60px + 20px);
  height: calc(10 * 60px + 20px);

  margin: 20px auto;
  padding: 10px;

  background: #e7cfa8;
  border-radius: 18px;
  overflow: hidden;

  border: 4px solid #b08968;
  box-shadow:
    inset 0 0 0 2px #b08968,
    0 14px 40px rgba(0,0,0,0.45);

  box-sizing: border-box;
}

#kndBoard .knd-square {
  width: 60px;
  height: 60px;

  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 32px;
  cursor: pointer;
  user-select: none;
}

#kndBoard .light { background: #f3ddb8; }
#kndBoard .dark  { background: #b88a60; }

#kndBoard .king   { font-size: 36px; }
#kndBoard .knight { font-size: 34px; }
#kndBoard .monster{ font-size: 32px; }







/* ===================================== */
/* üëë KNIGHT DEFENSE ‚Äì JOURNEY STYLE MENU */
/* ===================================== */

#knight-defense-section {
  max-width: 1200px;
  margin: 40px auto;
}

/* Main menu card */
#kndMenu {
  background: linear-gradient(180deg, #1c2142, #14172d);
  border-radius: 18px;
  padding: 30px 34px;
  box-shadow: 0 25px 70px rgba(0,0,0,0.55);
  position: relative;
}

/* Left yellow accent */
#kndMenu::before {
  content: "";
  position: absolute;
  left: 0;
  top: 22px;
  bottom: 22px;
  width: 6px;
  border-radius: 6px;
  background: linear-gradient(#ffd84d, #ffb700);
}

/* ===================== */
/* TITLE + TEXT */
/* ===================== */

#kndMenu h3 {
  font-size: 24px;
  font-weight: 900;
  color: #ffffff;
  margin-bottom: 14px;
}

#kndMenu ul {
  list-style: none;
  padding: 0;
  margin: 0 0 20px;
}

#kndMenu ul li {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #d7dcff;
  font-size: 15px;
  margin-bottom: 6px;
}

/* ===================== */
/* MODE BARS (KEY PART) */
/* ===================== */

.knd-modes {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
  margin: 18px 0 22px;
}

/* Full-width row for Hard */
.knd-modes .hard {
  grid-column: 1 / -1;
}

/* Mode bar */
.knd-mode {
  border-radius: 14px;
  padding: 16px 18px;
  font-size: 16px;
  font-weight: 900;
  text-align: center;
  cursor: pointer;
  color: #111;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 26px rgba(0,0,0,0.35);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.knd-mode span {
  font-size: 13px;
  font-weight: 700;
  margin-top: 4px;
}

/* Easy */
.knd-mode.easy {
  background: linear-gradient(180deg, #2ecc71, #27ae60);
}
.knd-mode.easy:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 36px rgba(46,204,113,0.45);
}

/* Medium */
.knd-mode.medium {
  background: linear-gradient(180deg, #f1c40f, #f39c12);
}
.knd-mode.medium:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 36px rgba(241,196,15,0.45);
}

/* Hard */
.knd-mode.hard {
  background: linear-gradient(180deg, #ff4d4d, #e53935);
  color: #fff;
}
.knd-mode.hard:hover {
  transform: translateY(-2px);
  box-shadow: 0 14px 36px rgba(231,76,60,0.45);
}

/* ===================== */
/* HOW TO PLAY BOX */
/* ===================== */

.knd-how {
  background: linear-gradient(180deg, #23285a, #1b1f46);
  border-radius: 14px;
  padding: 18px 20px;
  border: 1px solid rgba(255,255,255,0.08);
}

.knd-how h4 {
  color: #ffd84d;
  font-size: 16px;
  margin-bottom: 10px;
}

.knd-how ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.knd-how li {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #e1e4ff;
  font-size: 14px;
  margin-bottom: 6px;
}




/* ================================ */
/* üëë KND MODAL ‚Äì FULLY ISOLATED */
/* ================================ */

.knd-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.knd-modal.hidden {
  display: none;
}

.knd-modal-card {
  background: linear-gradient(180deg, #1c2142, #14182f);
  padding: 26px 30px;
  border-radius: 16px;
  width: 320px;
  text-align: center;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.08);
  animation: kndPop 0.25s ease-out;
}

@keyframes kndPop {
  from { transform: scale(0.85); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

.knd-modal-card h3 {
  color: #ffd84d;
  font-size: 20px;
  margin-bottom: 10px;
}

.knd-modal-card p {
  color: #e6e8ff;
  font-size: 15px;
  margin-bottom: 18px;
}

.knd-btn {
  background: linear-gradient(180deg, #ffd84d, #ffb700);
  color: #1b1b1b;
  border: none;
  padding: 10px 22px;
  font-size: 14px;
  font-weight: 800;
  border-radius: 12px;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(255,200,0,0.4);
}

.knd-btn:hover {
  transform: translateY(-1px);
}


/* ================================ */
/* üîä GLOBAL MUSIC MUTE ICON        */
/* ================================ */
#musicMuteBtn {
  position: fixed;
  bottom: 18px;
  left: 18px;
  z-index: 99999;

  background: #0f1226;
  color: #ffd84d;

  font-size: 22px;
  padding: 10px 12px;
  border-radius: 12px;

  cursor: pointer;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  user-select: none;
}




/* ===================================== */
/* üëë MATH JOURNEY ‚Äì ISOLATED UI */
/* ===================================== */

#kingmath-section {
  max-width: 1100px;
  margin: 40px auto;
}

/* Main card */
#kingmath-section .math-card {
  background: linear-gradient(180deg, #1b1f3a, #14172d);
  border-radius: 18px;
  padding: 26px 30px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.45);
  border: 1px solid rgba(255,255,255,0.06);
}

/* Title */
#kingmath-section h2 {
  color: #ffd84d;
  font-weight: 900;
  margin-bottom: 14px;
}

/* Inner panel */
#kingmath-section .math-panel {
  position: relative;
  background: linear-gradient(180deg, #232850, #1a1e3c);
  border-radius: 16px;
  padding: 24px 26px;
}

/* Yellow accent line */
#kingmath-section .math-panel::before {
  content: "";
  position: absolute;
  left: 0;
  top: 16px;
  bottom: 16px;
  width: 5px;
  border-radius: 6px;
  background: linear-gradient(#ffd84d, #ffb700);
}

/* Section title */
#kingmath-section .math-panel h3 {
  color: #ffffff;
  font-size: 18px;
  font-weight: 800;
  margin-bottom: 16px;
}

/* ======================= */
/* MODE BUTTONS */
/* ======================= */

#kingmath-section .math-modes {
  display: flex;
  flex-direction: column;
  gap: 14px;
  margin-bottom: 22px;
}

#kingmath-section .math-mode {
  height: 54px;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 900;
  color: #1b1b1b;
  border: none;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

#kingmath-section .math-mode:hover {
  transform: translateY(-1px);
  box-shadow: 0 10px 24px rgba(0,0,0,0.35);
}

/* Easy */
#kingmath-section .math-mode.easy {
  background: #2ecc71;
}

/* Medium */
#kingmath-section .math-mode.medium {
  background: #ffd84d;
}

/* Hard */
#kingmath-section .math-mode.hard {
  background: #ff4d4d;
  color: #fff;
}

/* ======================= */
/* HOW TO PLAY */
/* ======================= */

#kingmath-section .math-how {
  background: rgba(0,0,0,0.25);
  border-radius: 14px;
  padding: 16px 18px;
  border: 1px solid rgba(255,255,255,0.08);
}

#kingmath-section .math-how h4 {
  color: #ffd84d;
  font-size: 15px;
  margin-bottom: 10px;
}

#kingmath-section .math-how ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

#kingmath-section .math-how li {
  color: #cfd3ff;
  font-size: 14px;
  margin-bottom: 6px;
  display: flex;
  gap: 8px;
}



/* ================================
   üëë MATH JOURNEY BOARD (10x10)
================================ */

#kmBoard {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  grid-template-rows: repeat(10, 1fr);

  width: 600px;
  height: 600px;

  margin: 20px auto;

  background: #c9a26a;
  border-radius: 14px;
  padding: 8px;

  box-shadow:
    inset 0 0 0 4px #b08b5a,
    0 12px 40px rgba(0,0,0,0.45);
}

/* ================================
   BOARD SQUARES
================================ */

#kmBoard .square {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: 22px;
  font-weight: 700;

  cursor: pointer;
  user-select: none;
}

/* light / dark */
#kmBoard .light {
  background: #f3deb3;
}

#kmBoard .dark {
  background: #b88a5b;
}

/* ================================
   PIECES / ELEMENTS
================================ */

#kmBoard .king {
  font-size: 29px;
}



/* ================================
   üü® Base answer styling (NO color)
================================ */

#kmBoard .square.answer {
  font-weight: 900;
  border-radius: 6px;
  cursor: pointer;
  box-shadow: 0 0 2px rgba(0,0,0,0.25) inset;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

#kmBoard .square.answer:hover {
  transform: scale(1.08);
  box-shadow: 0 0 12px rgba(255,255,255,0.4);
}

/* ================================
   üé® Answer colors (REAL COLORS)
================================ */

.answer-green {
  background: #2ecc71 !important;
  color: #0b2e13;
}

.answer-yellow {
  background: #f1c40f !important;
  color: #3a2d00;
}

.answer-blue {
  background: #3498db !important;
  color: #08243a;
}

.answer-purple {
  background: #9b59b6 !important;
  color: #2d133b;
}





.km-timer {
  margin: -60px auto 10px auto;   /* space above board */
  width: fit-content;

  background: #1a1f3a;
  border: 1px solid #ff5555;
  color: #ff7777;

  padding: 8px 18px;
  border-radius: 12px;

  font-weight: 700;
  font-size: 20px;

  box-shadow: 0 0 12px rgba(255, 85, 85, 0.35);
  text-align: center;
}



.km-timer.danger {
  border-color: #ff0000;
  color: #ff0000;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { box-shadow: 0 0 8px rgba(255,0,0,0.4); }
  50% { box-shadow: 0 0 16px rgba(255,0,0,0.9); }
  100% { box-shadow: 0 0 8px rgba(255,0,0,0.4); }
}



/* ================================
   üé® COLOR FLIP CHAOS ‚Äì UI POLISH
================================ */

/* Center everything cleanly */
#cfcGame {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Board alignment + spacing */
#cfcBoard {
  display: grid !important;
  grid-template-columns: repeat(8, 1fr) !important;
  gap: 2px;
  margin: 24px auto;
  margin-top: -17px;   /* üîº adjust if needed */
}

/* Square styling */
#cfcBoard .cfc-square {
  aspect-ratio: 1;
  border-radius: 2px;
  font-size: 26px;
  display: flex;
  align-items: center;
  justify-content: center;

  /* üñê grab cursor */
  cursor: grab;

  transition:
    background-color 0.6s ease,
    transform 0.15s ease;
}

/* Grab effect on click */
#cfcBoard .cfc-square:active {
  cursor: grabbing;
  transform: scale(0.96);
}

/* üê¥ Knight emphasis */
#cfcBoard .cfc-square:has(span),
#cfcBoard .cfc-square {
  line-height: 1;
}

/* Bigger knight (JS adds emoji directly) */
#cfcBoard .cfc-square {
  font-size: 28px;
}

/* Extra boost only when knight is present */
#cfcBoard .cfc-square:has(:contains("üê¥")) {
  font-size: 34px;
}

#cfcBoard .cfc-knight {
  font-size: 36px;
}



/* ================================
   üé® COLOR FLIP CHAOS ‚Äì BIGGER MODE CARD
   (ISOLATED)
================================ */

/* ================================
   üé® COLOR FLIP CHAOS ‚Äì LARGE MODE CARD
   (FINAL, ISOLATED)
================================ */

.cfc-card {
  width: 100%;
  max-width: 760px;          /* üî• MUCH wider */
  min-height: 300px;         /* üî• gives vertical presence */

  padding: 40px 48px;        /* üî• big breathing space */
  margin: 0 auto;

  text-align: center;

  background: linear-gradient(
    180deg,
    rgba(32, 36, 70, 0.96),
    rgba(20, 24, 52, 0.96)
  );

  border-radius: 22px;
  box-shadow:
    0 30px 80px rgba(0, 0, 0, 0.55),
    inset 0 0 0 1px rgba(255, 255, 255, 0.05);

  transform: scale(1.05);   /* üî• makes it feel BIG */
}



.cfc-card h3 {
  font-size: 22px;
  margin-bottom: 24px;
}

.cfc-modes {
  margin: 24px 0;
  gap: 18px;
}

.cfc-mode-btn {
  padding: 14px 22px;
  font-size: 16px;
  border-radius: 10px;
}

.cfc-how {
  margin-top: 26px;
  font-size: 16px;
  line-height: 1.7;
}


.cfc-mode-easy { background: #2ecc71; color: #000; }
.cfc-mode-medium { background: #f1c40f; color: #000; }
.cfc-mode-hard { background: #e74c3c; color: #fff; }

/* Game area alignment */
#cfcGame {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Force board layout (8√ó8) */
#cfcBoard {
  display: grid !important;
  grid-template-columns: repeat(8, 1fr) !important;
  max-width: 360px;
  width: 100%;
  margin: 12px auto;
  gap: 6px;
}

/* Board squares */
#cfcBoard .cfc-square {
  aspect-ratio: 1;
  border-radius: 1px;
  font-size: 28px;
  cursor: grab;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.8s ease, transform 0.15s ease;
}

#cfcBoard .cfc-square:active {
  cursor: grabbing;
  transform: scale(0.95);
}

/* Knight emphasis */
#cfcBoard .cfc-knight {
  font-size: 36px;
  line-height: 1;
}


/* ================================
   üé® COLOR FLIP CHAOS ‚Äì BOARD FIX
   (SQUARE, NON-STRETCHING)
================================ */

/* Lock board aspect */
#cfcBoard {
  width: 550px;
  height: 550px;           /* üî• THIS IS THE KEY */
  max-width: 90vw;
  max-height: 90vw;

  display: grid !important;
  grid-template-columns: repeat(8, 1fr) !important;
  grid-template-rows: repeat(8, 1fr);   /* üî• force equal rows */

  gap: 1px;
  margin: -16px auto;

  align-self: center;
}

/* Square safety */
#cfcBoard .cfc-square {
  width: 100%;
  height: 100%;
}


/* ================================
   üé® COLOR FLIP CHAOS ‚Äì EXIT BUTTON OFFSET
   (ISOLATED)
================================ */

#colorchaos-section .btn-secondary {
  margin-top: 24px;   /* üîΩ pushes Exit button down */
}




/* ================================
   üé® COLOR FLIP CHAOS ‚Äì COORDINATES
   (ISOLATED)
================================ */

.cfc-board-wrapper {
  display: grid;
  grid-template-columns: 28px auto;
  grid-template-rows: auto 28px;
  justify-content: center;
  align-items: center;
  margin: 12px auto 4px;
}

/* RANKS (1‚Äì8) */
.cfc-ranks {
  display: grid;
  grid-template-rows: repeat(8, 1fr);
  gap: 48px;
  font-size: 16px;
  color: #ccc;
  text-align: center;
}

/* FILES (a‚Äìh) */
.cfc-files {
  grid-column: 2;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 6px;
  font-size: 16px;
  color: #ccc;
  text-align: center;
  margin-top: 20px;
}

/* Board alignment fix */
.cfc-board-wrapper #cfcBoard {
  grid-column: 2;
}


#musicControl {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 9999;
}

#musicMuteBtn {
  font-size: 24px;
  cursor: pointer;
  user-select: none;
}

#musicMenu {
  position: absolute;
  bottom: 36px;
  left: 0;
  background: #1c1f35;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 6px;
  min-width: 160px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.4);
}

#musicMenu div {
  padding: 6px 10px;
  cursor: pointer;
  font-size: 14px;
  border-radius: 6px;
}

#musicMenu div:hover {
  background: #2a2d4a;
}

.hidden {
  display: none;
}



/* ================================
üìç Board Coordinate Training ‚Äì Board Skin
(ISOLATED)
================================ */

#coordtrain-section .mini-board {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  aspect-ratio: 1 / 1;
  border-radius: 1px;
  overflow: hidden;
  background: #3b2a1a;
  margin-top: -15px;
  
}

#coordtrain-section .square {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: box-shadow 0.15s ease, transform 0.1s ease;
}

/* ‚ôü CLASSIC BROWN BOARD */
#coordtrain-section .square.light {
  background: #f0d9b5;
}

#coordtrain-section .square.dark {
  background: #b58863;
}

/* Hover feedback */
#coordtrain-section .square:hover {
  transform: scale(1.02);
}

/* Files (a‚Äìh) closer to board */
#coordtrain-section .cfc-files {
  grid-column: 2;
  margin-top: 4px;   /* üî• reduce this */
  padding-top: 0;
}

/* Board itself ‚Äì remove bottom spacing */
#coordtrain-section .mini-board {
  margin-bottom: 0;  /* üî• important */
}




/* ======================================
üß† BOARD FREEZE ‚Äì COORDINATES FIX
====================================== */

#boardfreeze-section .bf-board-wrapper {
  display: grid;
  grid-template-columns: auto auto;
  grid-template-rows: auto auto;
  gap: 6px;
  justify-content: center;
  margin: 20px auto;
}

/* RANKS */
#boardfreeze-section .bf-ranks {
  display: grid;
  grid-template-rows: repeat(8, 1fr);
  font-size: 13px;
  color: #ddd;
  text-align: right;
  padding-right: 2px;
}

/* FILES */
#boardfreeze-section .bf-files {
  grid-column: 2;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  font-size: 13px;
  color: #ddd;
  text-align: center;
  padding-top: 2px;
}

/* BOARD */
#boardfreeze-section #bfBoard {
  width: 560px;
  height: 560px;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  border-radius: 14px;
  overflow: hidden;
}

/* SQUARES */
#boardfreeze-section #bfBoard .square {
  display: flex;
  align-items: center;
  justify-content: center;
}

/* COLORS (REAL CHESS ORIENTATION) */
#boardfreeze-section #bfBoard .light {
  background: #f0d9b5;
}
#boardfreeze-section #bfBoard .dark {
  background: #b58863;
}

/* PIECES */
#boardfreeze-section #bfBoard img {
  width: 80%;
  height: 80%;
  pointer-events: none;
}



/* ============================= */
/* üß≠ KNIGHT GPS BOARD LAYOUT */
/* ============================= */

.kg-center {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 14px;
}

/* ranks + board */
.kg-board-grid {
  display: grid;
  grid-template-columns: 32px auto;
  align-items: center;
}

/* BOARD */
#kgBoard {
  display: grid;
  grid-template-columns: repeat(8, 80px);
  grid-template-rows: repeat(8, 80px);
  border: 2px solid #ffd700;
  box-shadow: 0 0 28px rgba(255, 215, 0, 0.4);
  margin-top: -70px;
}

/* RANKS */
.kg-ranks {
  display: grid;
  grid-template-rows: repeat(8, 80px);
  font-size: 13px;
  color: #aaa;
  text-align: center;
  margin-right: 6px;

  /* üëá key fixes */
  align-items: flex-start;
  padding-top: 6px;
}


/* FILES */
.kg-files {
  display: grid;
  grid-template-columns: repeat(8, 80px);
  font-size: 13px;
  color: #aaa;
  text-align: center;
  margin-top: -30px;
}

/* SQUARES */
.kg-square {
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}

/* COLORS */
.kg-light { background: #f0d9b5; }
.kg-dark  { background: #b58863; }

/* üéØ Target ‚Äî emoji only, no square color */
.kg-target {
  background: transparent !important;
  position: relative;
}

/* üéØ Target overlay ‚Äî NO square color */
.kg-target {
  position: relative;
}

.kg-target span {
  position: absolute;
  font-size: 34px;
  z-index: 5;
  filter: drop-shadow(0 0 6px rgba(0,255,204,0.8));
}

.kg-target::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 50%;
  background: radial-gradient(
    circle,
    rgba(0, 255, 204, 0.7) 18%,
    rgba(0, 255, 204, 0.35) 28%,
    transparent 45%
  );
  z-index: 1;
  pointer-events: none;
}



/* ‚ôû Knight */
.kg-square img {
  width: 68px;
  height: 68px;
  pointer-events: none;
  transform: translateY(-2px);
  filter: drop-shadow(0 3px 6px rgba(0,0,0,0.45));
}



/* Fixed container should stretch */
.mini-score-fixed {
  position: fixed;
  left: 12px;
  top: 110px;
  bottom: 20px;          /* üî• THIS is the key */
  z-index: 50;
  display: flex;
}

/* Panel fills full height */
.mini-score-panel {
  width: 260px;
  height: 100%;
  display: flex;
  flex-direction: column;
  background: linear-gradient(180deg, #161a33, #0f1328);
  border-radius: 16px;
  padding: 16px;
  box-shadow:
    inset 0 0 0 1px rgba(255,215,0,0.15),
    0 10px 30px rgba(0,0,0,0.4);
}



#miniScoreList {
  flex: 1;                /* fills remaining space */
  overflow-y: auto;
  padding-right: 4px;
}

/* smooth scrollbar (optional but sexy) */
#miniScoreList::-webkit-scrollbar {
  width: 6px;
}
#miniScoreList::-webkit-scrollbar-thumb {
  background: rgba(255,215,0,0.35);
  border-radius: 6px;
}



/* ================================
   üèÜ MINI SCORE ‚Äì FIXED & SHORT
================================ */

/* Fixed position, but NOT full height */
.mini-score-fixed {
  position: fixed;
  left: 12px;
  top: 110px;        /* below navbar */
  z-index: 50;
}

/* Compact panel height (matches main card visually) */
.mini-score-panel {
  width: 260px;
  max-height: 650px;     /* üî• THIS controls red-line height */
  display: flex;
  flex-direction: column;

  background: linear-gradient(180deg, #161a33, #0f1328);
  border-radius: 16px;
  padding: 16px;

  box-shadow:
    inset 0 0 0 1px rgba(255,215,0,0.15),
    0 10px 30px rgba(0,0,0,0.4);
}

/* Title stays fixed */
.mini-score-panel h3 {
  color: #ffd700;
  margin-bottom: 10px;
  font-size: 1.05rem;
  text-align: center;
  flex-shrink: 0;
}

/* Scroll only scores, not whole panel */
#miniScoreList {
  flex: 1;
  overflow-y: auto;
  padding-right: 6px;
}

/* Score row */
.score-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 10px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  margin-bottom: 6px;
  font-size: 0.9rem;
}

.score-row span:first-child {
  color: #a9b7ff;
}

.score-row span:last-child {
  color: #00ffcc;
  font-weight: 700;
}

/* Muted text */
.muted {
  color: #777;
  text-align: center;
  font-size: 0.85rem;
}

/* Smooth scrollbar */
#miniScoreList::-webkit-scrollbar {
  width: 6px;
}
#miniScoreList::-webkit-scrollbar-thumb {
  background: rgba(255,215,0,0.35);
  border-radius: 6px;
}


.mini-score-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 4px;
  font-size: 1rem;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.game-name {
  opacity: 0.9;
}

.game-score {
  color: #ffd700;
  font-weight: 700;
}


@media (max-width: 1366px) {

  .mini-score-panel {
    width: 220px;
    max-height: 650px;
  }

  .analysis-board,
  .main-content,
  .section,
  .container {
    margin-left: 90px !important;
  }
}






@media (max-width: 1440px) {
  .analysis-board,
  .main-content,
  .section {
    transform: scale(0.80);
    transform-origin: top center;
  }
}

@media (max-width: 1366px) {
  .analysis-board,
  .main-content,
  .section {
    transform: scale(0.72);   /* ‚âà 75% feel */
    transform-origin: top center;
  }
}




























  </style>
</head>

<body>


<!-- üèÜ FIXED MINI GAME SCORES (LEFT) -->
<div class="mini-score-fixed">
  <div class="mini-score-panel">
    <h3>üèÜ My Best Scores</h3>
    <div id="miniScoreList">
      <p class="muted">Loading scores...</p>
    </div>
  </div>
</div>




  <!-- NAVBAR -->
  <div id="topNavbar" class="navbar">

    <div class="brand">
  <img src="favicons.png" alt="Olympus Chess Academy Logo" class="brand-logo">
  
</div>


     <button class="nav-btn" data-tab="coordtrain">üìç Board Coordinates</button>
     

    <button class="nav-btn" data-tab="piecePractice">
  ü¶ñ Toy Hunt
 

<button class="nav-btn" data-tab="memory">üß† IQ Hunt</button>
<button class="nav-btn" data-tab="boardfreeze">‚ùì Guess Materials</button>
<button class="nav-btn" data-tab="color">üß™ Lab Hunt</button>
<button class="nav-btn" data-tab="knightfog">
  üçé Knight Fog Quest
</button>
<button class="nav-btn" data-tab="knightdefense">
  üëë Defend The King
</button>
<button class="nav-btn" data-tab="knightpath">üê¥ Knight Hunt</button>
<button class="nav-btn" data-tab="knightmonster">üê¥ vs üëπ</button>
<button class="nav-btn" data-tab="knightescape">üè∞ Escape</button>
<button class="nav-btn" data-tab="knightspeed">üê¥ Speed Run</button>
<button class="nav-btn" data-tab="knightlava">üî• Lava Knight</button>
<button class="nav-btn" data-tab="knightgps">üß≠ Knight GPS</button>

<button class="nav-btn" data-tab="kingmath">
  üëë Chess Math Journey
</button>
<button class="nav-btn" data-tab="colorchaos">üé® Rainbow Mania</button>



<button class="nav-btn" data-tab="flashqueen">
   Find The üë∏
</button>
<button class="nav-btn" data-tab="pathfinder">üë∏ Reach Home</button>
<button class="nav-btn" data-tab="puzzlerush">‚ö° Puzzle </button>
<button class="nav-btn" data-tab="quiz">‚öΩÔ∏è Quiz</button>
<button class="nav-btn" data-tab="computer">
  üéØ Play
</button>
<button class="nav-btn" data-tab="study">üìò Study</button>
 <button class="nav-btn" data-tab="board">üî¨ Analysis</button>
    <button class="nav-btn" data-tab="editor">üß© Editor</button>
    <button class="nav-btn" data-tab="assignments">üìö Assignments</button>
    <button class="nav-btn" data-tab="attempts" id="attemptsTab" style="display: none;">üìä Attempts</button>
    <button class="nav-btn" data-tab="students" id="adminTab" style="display: none;">üë®‚Äçüéì Admin</button>
    <span class="user-info" id="userInfo"></span>
    <button class="btn-logout" id="logoutBtn">Logout</button>
  </div>

  

  <!-- MAIN CONTENT -->
  <div class="container">

    <div class="section" id="live-section">
  <h2>üé• Live Classroom</h2>

  <div class="live-placeholder">
    <p><strong>Status:</strong>
      <span id="liveStatusText">No live class running</span>
    </p>
    <p>This area will host live puzzles, student presence and results.</p>
    <p style="opacity:0.6;">(Live logic coming next)</p>
  </div>

  <!-- Student join live class -->
<button
  id="joinLiveBtn"
  class="btn-success"
  style="display:none; margin-top:12px;"
>
  ‚ñ∂ Join Live Class
</button>
<!-- Student waiting panel -->
<div id="liveWaitingPanel" class="card" style="display:none; margin-top:12px;">
  <p>‚è≥ You have joined the live class.</p>
  <p style="opacity:0.8;">Waiting for the teacher to start activities‚Ä¶</p>
</div>


<!-- Live classroom admin student selector -->
<div id="liveStudentSelector" class="card" style="display:none; margin-top:16px;">
  <h3>üë• Select students for live class</h3>

  <div id="liveStudentsList" class="student-checklist">
    <!-- students will be injected here -->
     
  </div>

  <button id="confirmLiveStudentsBtn" class="btn-success" style="margin-top:12px;">
    Confirm & Start Live Class
  </button>
  <!-- Live joined students list (admin) -->
<div id="liveJoinedBox" style="display:none; margin-top:16px;">
  <h4>üü¢ Joined students</h4>
  <ul id="liveJoinedList"></ul>
</div>

</div>

<!-- Admin controls -->
<div id="liveAdminControls" style="display:none; margin-top:12px;">
  <button id="startLiveBtn" class="btn-success" style="display:none;">
  ‚ñ∂ Start Live Class
</button>

  <button id="endLiveBtn" class="btn-danger" style="display:none;">‚ñ† End Live Class</button>
</div>
</div>


<div class="section" id="study-section">
  <h2>üìò Study</h2>

  <div class="study-layout">

    <!-- LEFT: Study Panel -->
    <div class="study-left">
      <div class="study-header">
  

  <div style="display:flex; gap:8px;">
    <button class="btn-secondary" id="importStudyBtn">
      + Import PGN
    </button>
    <select id="studySelect">
  <option value="">Study</option>
</select>

    

    <button class="btn-secondary" id="uploadStudyBtn">
      üìÇ Upload
    </button>
    
  </div>
  
</div>


      <div class="study-list" id="studyList">
        <div class="study-item active">
          ‚ñ∂ Sample Study
        </div>
        <div class="study-chapter">
          1. Introduction
        </div>
        <div class="study-chapter">
          2. Main Line
        </div>
      </div>
    </div>

    <!-- CENTER: Board -->
<div class="study-center">
  <div id="studyBoardWrapper" style="position: relative; width: 650px; height: 650px; margin: auto;">
    
    <div
      id="studyBoard"
      style="width: 650px; height: 650px;"
    ></div>

    <!-- DRAW LAYER -->
    <canvas id="studyDrawLayer"></canvas>

  
</div>


</div>


    <!-- RIGHT: Engine + Notation -->
    <div class="study-right">

      <div class="study-engine-box">

  <div class="engine-header">
    <span class="engine-title">
      Stockfish <span class="wasm-badge">WASM</span>
    </span>

    <button id="studyEngineToggle" class="engine-toggle off">
      OFF
    </button>
  </div>

  <div class="engine-stats">
    Eval: <span id="studyEval">--</span>
    &nbsp; | &nbsp;
    Depth: <span id="studyDepth">--</span>
  </div>

  <div id="studyPVLines" class="engine-lines"></div>

</div>



      <div class="study-notation">
        <strong>Notation</strong>
        <div class="notation-placeholder" id="studyNotation">
    Select a chapter to view moves
        </div>
      </div>

    </div>

  </div>
</div>





<div class="section" id="editor-section">
  <h2>üß© Board Editor</h2>

  <div class="board-layout">
    <!-- Board -->
    <div class="board-wrapper">
      <div id="editorBoard"></div>
    </div>

    <!-- Controls -->
    <div class="side-panel">
      <h3>Editor Controls</h3>

      <button class="btn-secondary" id="editorStartPos">
        ‚ôü Starting Position
      </button>

      <button class="btn-secondary" id="editorClear">
        üóë Clear Board
      </button>

      <button class="btn-primary" id="editorApply">
        ‚ñ∂ Use in Analysis Board
      </button>

      <div class="editor-field">
  <label for="editorTurn">Side to move</label>
  <select id="editorTurn">
    <option value="w">White to move</option>
    <option value="b">Black to move</option>
  </select>
</div>


      <textarea
        id="editorFEN"
        rows="3"
        readonly
        placeholder="FEN will appear here"
      ></textarea>
      <button id="copyFenBtn" class="btn-copy-fen">
  üìã Copy FEN
</button>

<span id="fenCopyStatus" class="fen-copy-status hidden">
  ‚úî Copied
</span>
<div class="editor-field">
  <div class="editor-label">Castling rights</div>

  <div class="castling-row">
    <div class="side">White</div>
    <label class="castle-opt">
      <input type="checkbox" id="castleWK"> <span>O-O</span>
    </label>
    <label class="castle-opt">
      <input type="checkbox" id="castleWQ"> <span>O-O-O</span>
    </label>
  </div>

  <div class="castling-row">
    <div class="side">Black</div>
    <label class="castle-opt">
      <input type="checkbox" id="castleBK"> <span>O-O</span>
    </label>
    <label class="castle-opt">
      <input type="checkbox" id="castleBQ"> <span>O-O-O</span>
    </label>
  </div>
</div>




    </div>
  </div>
</div>




<!-- ü§ñ PLAY VS COMPUTER SECTION -->
<div class="section" id="computer-section">
  <h2>ü§ñ Play vs Olympus AI</h2>
  <div id="vsGameResult" class="vs-result hidden"></div>


  <!-- board + clock + controls will go here -->
<div class="card" style="margin-top:16px;">
  <div class="analysis-layout">

    <!-- ü§ñ BOT CHARACTER PANEL -->
<div class="bot-panel">
  <div class="bot-avatar">
    <img id="botImage" src="bots/max.png" alt="Olympus Bot" />

    <!-- üî¥ Fake mouth -->
    <div id="botMouth"></div>
  </div>

  <div class="bot-name" id="botName">Ares Blaster</div>

  <div class="bot-bubble hidden" id="botBubble">
    brr‚Ä¶ zzt‚Ä¶ ‚ôüÔ∏è
  </div>


  
<button id="resignBtn" class="btn-danger takeback-btn">
  üè≥Ô∏è Resign
</button>

  <!-- üîô TAKE BACK (INSIDE BOT PANEL) -->
  <button
    id="takeBackBtn"
    class="btn-secondary takeback-btn"
  >
    ‚¨Ö Take Back
  </button>
</div>





    <!-- ‚ôü BOARD -->
    <div class="board-column">
      <div id="computerBoard" class="chessboard"></div>

      <!-- CLOCKS -->
      <div class="player-bar clock-bar">
  <div class="player white active">
    ‚ôî You ‚Äî <span id="whiteClock">60:00</span>
  </div>
  <div class="player black">
    ü§ñ BOT ‚Äî <span id="blackClock">60:00</span>
  </div>
</div>

    </div>

    
    
    

    <!-- üéõ CONTROLS -->
    <div class="side-panel">

      <h3>üé® Choose Color</h3>
<select id="playerColor">
  <option value="white">White</option>
  <option value="black">Black</option>
  <option value="random">Random</option>
</select>


      <h3>ü§ñ Select your BOT</h3>
      <select id="engineSelect">
  
  <option value="ares">Ares Blaster</option>
  <option value="athena">OlyBot</option>
  
</select>


      <h3>üéØ Difficulty</h3>
<select id="engineLevel">
  <option value="600">üê£ Tiny Tot</option>
  <option value="900">üê• Beginner</option>
  <option value="1200">üê§ Rookie</option>
  <option value="1500">ü¶Å Champion</option>
  <option value="2000">üëë Master</option>
</select>




      <h3>‚åö Format</h3>
      <select id="timeControl">
  <option value="3600">Standard</option>
  
</select>


      <button class="btn-success" id="startVsComputer" style="margin-top:12px;">
        ‚ñ∂ Start Game
      </button>

      <button class="btn-secondary" id="resetVsComputer">
        üîÑ Reset
      </button>

    </div>
    

  </div>
</div>





</div>

<div class="section" id="puzzlerush-section">
  <h2>‚ö° Olympus Tactical Rush ‚ö°</h2>

  <!-- MODE SELECTION -->
  <div class="card" id="puzzleRushMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="rush3">‚è± 3 Min Rush</button>
      <button class="btn-primary" id="rush5">‚è± 5 Min Rush</button>
      <button class="btn-danger" id="survival">üî• Survival</button>
    </div>

    <!-- HOW TO PLAY -->
<div class="how-to-play">
  <h4>üß† How to Play</h4>

  <ul>
    <li>‚ôüÔ∏è Solve as many chess puzzles as you can</li>
    <li>‚è±Ô∏è Each correct move gives you a new puzzle instantly</li>
    <li>‚ùå Wrong move may cost a life or end the run</li>
    <li>üî• Build streaks by solving puzzles continuously</li>
    <li>üèÜ Challenge yourself to beat your best score</li>
  </ul>

  <div class="mode-info">
    <span>‚è± 3 Min / 5 Min:</span> Solve max puzzles before time runs out  
    <br>
    <span>üî• Survival:</span> One mistake can end everything
  </div>
</div>


 
</div>


  


  <!-- GAME AREA -->
  <div class="card hidden" id="puzzleRushGame">
    <div class="analysis-layout">

      <!-- BOARD -->
      <div class="board-column">
        <div id="puzzleRushBoard"></div>

        <!-- STATUS BAR -->
        <div class="puzzle-hud">
  <div class="hud-item hud-timer">
    <span class="hud-icon">‚è±</span>
    <span id="prTimer">02:57</span>
  </div>

  <div class="hud-item hud-lives">
    <span class="hud-icon">‚ù§Ô∏è</span>
    <span id="prLives">3</span>
  </div>

  <div class="hud-item hud-streak">
    <span class="hud-icon">üî•</span>
    <span id="prScore">0</span>
  </div>
</div>


      </div>

      <!-- RIGHT PANEL -->
      <div class="side-panel">
        

        <button class="btn-secondary" id="exitPuzzleRush">
          ‚¨Ö Exit
        </button>
      </div>

    </div>
  </div>
</div>

<section id="memory-section" class="section hidden">
  <h2>üß† Memorise the squares</h2>

  <!-- MODE SELECTION -->
  <div class="card" id="memoryMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="mem3">‚è± 3 Min Rush</button>
      <button class="btn-primary" id="mem5">‚è± 5 Min Rush</button>
      <button class="btn-danger" id="memSurvival">üî• Survival</button>
    </div>
    <div class="how-to-play">
  <h4>üß† How to Play</h4>

  <ul>
    <li>üëÄ Watch carefully which squares light up</li>
    <li>üß† Memorise their positions quickly</li>
    <li>üëâ Click the correct squares after they disappear</li>
    <li>‚ùå Wrong square costs a life</li>
    <li>‚≠ê Correct answers increase your score</li>
  </ul>

  <div class="mode-info">
    <span>‚è± 3 / 5 Min Rush:</span> Solve as many patterns as possible  
    <br>
    <span>üî• Survival:</span> One mistake can end the game
  </div>
</div>
  </div>
  <!-- HOW TO PLAY -->



  <!-- GAME AREA -->
  <div id="memoryGame" class="hidden">
    <div class="memory-top">
  <div class="timer">‚è± <span id="memoryTimer">0</span>s</div>
  <div class="lives">‚ù§Ô∏è <span id="memoryLives">3</span></div>
  <div class="score">‚≠ê <span id="memoryScore">0</span></div>
</div>


    <div id="memoryBoard" class="mini-board"></div>

    <button class="btn-secondary" id="memoryExit">‚èπ Exit</button>
  </div>
</section>


<section id="pathfinder-section" class="section hidden">
  <h2>üë∏ Help The Queen! </h2>

  <!-- ===== MODE MENU ===== -->
  <div class="card" id="pfMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="pfEasy">üü¢ Easy</button>
      <button class="btn-primary" id="pfMedium">üü° Medium</button>
      <button class="btn-danger" id="pfSurvival">üî• Hard</button>
    </div>
    <div class="how-to-play">
  <h4>üë∏ How to Play</h4>

  <ul>
    <li>üëë The Queen must reach the target square</li>
    <li>üß≠ Click the correct path squares</li>
    <li>‚ö†Ô∏è Avoid blocked or dangerous squares</li>
    <li>‚è±Ô∏è Solve before the timer runs out</li>
    <li>‚≠ê Each correct path increases difficulty</li>
  </ul>

  <div class="mode-info">
    <span>üü¢ Easy:</span> More time, fewer obstacles  
    <br>
    <span>üü° Medium:</span> Faster & trickier paths  
    <br>
    <span>üî• Hard:</span> One mistake = game over
  </div>
</div>
  </div>

  <!-- HOW TO PLAY -->




  <!-- ===== GAME AREA ===== -->
  <div id="pfGame" class="hidden">
    <div class="memory-top pf-hud">
  <div class="hud-item timer">‚è± <span id="pfTimer">8</span>s</div>
  <div class="hud-item lives">‚ù§Ô∏è <span id="pfLives">3</span></div>
  <div class="hud-item score">‚≠ê <span id="pfScore">2</span></div>
</div>


    <div id="pfBoard" class="mini-board"></div>

    <button class="btn-secondary" id="pfExit">‚¨Ö Exit</button>
  </div>
</section>

<section id="flashqueen-section" class="section hidden">

  <!-- TITLE -->
  <h2>üë∏ Find the Queen!</h2>

  <!-- MODE MENU -->
  <div class="card" id="flashQueenMenu">
    <h3>Select Mode</h3>

    <div class="control-grid">
      <button class="btn-primary" id="fqEasy">Easy</button>
      <button class="btn-primary" id="fqMedium">Medium</button>
      <button class="btn-danger" id="fqSurvival">üî• Survival</button>
    </div>
    <div class="how-to-play">
  <h4>üë∏ How to Play</h4>

  <ul>
    <li>üëÄ Watch carefully where the Queen appears</li>
    <li>üß† Memorise her square before she disappears</li>
    <li>üëâ Click the square where the Queen was</li>
    <li>‚ùå Wrong square costs a life</li>
    <li>‚≠ê Correct answers increase your score</li>
  </ul>

  <div class="mode-info">
    <span>üü¢ Easy:</span> Slower speed, fewer squares  
    <br>
    <span>üü° Medium:</span> Faster & more confusing  
    <br>
    <span>üî• Survival:</span> One mistake can end the game
  </div>
</div>
  </div>
  <!-- HOW TO PLAY -->



  <!-- GAME AREA -->
  <div id="flashQueenGame" class="hidden">

    <div class="memory-top">
      <div>‚è± <span id="fqTimer">0</span>s</div>
      <div>‚ù§Ô∏è <span id="fqLives">3</span></div>
      <div>‚≠ê <span id="fqScore">0</span></div>
    </div>

    <h3 class="question">üë∏ Where is the Queen?</h3>

    <div id="flashQueenBoard" class="mini-board"></div>

    <button class="btn-secondary" id="fqExit">‚Üê Exit</button>
  </div>

</section>
<section id="knightpath-section" class="section hidden">
  <h2>üê¥ Knight Journey</h2>

  <!-- MODE MENU -->
  <div class="card kp-card" id="kpMenu">
  <h3>Select Mode</h3>

  <div class="kp-modes">
    <button class="kp-mode-btn kp-mode-easy" onclick="startKP('easy')">
      üü¢ Easy
    </button>

    <button class="kp-mode-btn kp-mode-medium" onclick="startKP('medium')">
      üü° Medium
    </button>

    <button class="kp-mode-btn kp-mode-hard" onclick="startKP('hard')">
      üî• Hard
    </button>
  </div>

  <div class="kp-how">
    <h4>üìò How to Play</h4>
    <ul>
      <li>üê¥ A knight appears on the board</li>
      <li>‚ú® Squares flash one by one</li>
      <li>üß† Remember the flashing path</li>
      <li>üëÜ Click the squares in correct order</li>
      <li>‚≠ê Each level adds one more move</li>
    </ul>
  </div>
</div>


  <!-- GAME AREA -->
  <div id="kpGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Level: <span id="kpLevel">1</span></div>
      <div>‚ù§Ô∏è Lives: <span id="kpLives">3</span></div>
    </div>

    <div id="kpBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKP()">‚¨Ö Exit</button>
  </div>
</section>
</section>

<!-- =============================== -->
<!-- üß™ LAB MIXER (COLOR MEMORY GAME) -->
<!-- =============================== -->
<section id="color-section" class="section hidden">
  <h2>üß™ Lab Mixer</h2>

  <!-- MODE MENU -->
  <div class="card kp-card" id="lmMenu">
    <h3>Select Mode</h3>

    <div class="kp-modes">
      <button class="kp-mode-btn kp-mode-easy" onclick="startLabMixer('easy')">
        üü¢ Easy
      </button>

      <button class="kp-mode-btn kp-mode-medium" onclick="startLabMixer('medium')">
        üü° Medium
      </button>

      <button class="kp-mode-btn kp-mode-hard" onclick="startLabMixer('hard')">
        üî• Hard
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üé® Colored squares will flash</li>
        <li>üß† Remember the colors</li>
        <li>‚ùì A color will be asked</li>
        <li>üëÜ Click the correct square</li>
        <li>‚≠ê Each round adds difficulty</li>
      </ul>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="lmGame" class="hidden">
    <div class="memory-top">
  <div class="lm-round">üß™ Round: <span id="lmRound">1</span></div>

</div>

<div class="lm-find-banner">
  üéØ FIND: <span id="lmTarget">BLUE</span>
</div>

<div id="lmBoard" class="mini-board"></div>


    <button class="btn-secondary" onclick="exitLabMixer()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightmonster-section" class="section hidden">
  <h2>üê¥üëπ Knight vs Monster</h2>

  <!-- MODE MENU -->
  <div class="card" id="kvmMenu">
    <h3>Select Mode</h3>

    <div class="kvm-modes">
  <button class="kvm-mode easy" onclick="startKVM('easy')">
    üü¢ Easy<br><span>1 Monster</span>
  </button>

  <button class="kvm-mode medium" onclick="startKVM('medium')">
    üü° Medium<br><span>2 Monsters</span>
  </button>

  <button class="kvm-mode hard" onclick="startKVM('hard')">
    üî• Hard<br><span>3 Monsters</span>
  </button>
</div>


    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ You control the knight</li>
        <li>üëπ Monsters chase you like a king</li>
        <li>üéØ Survive as many turns as possible</li>
        <li>üíÄ If a monster catches you ‚Äî game over</li>
      </ul>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="kvmGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Turns: <span id="kvmTurns">0</span></div>
      <div>üëπ Monsters: <span id="kvmMonsterCount">1</span></div>
    </div>

    <div id="kvmBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKVM()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightescape-section" class="section hidden">
  <h2>üè∞ Knight Escape Maze</h2>

  <!-- MENU -->
  <div class="card" id="kemMenu">
    <h3>Select Mode</h3>

    <div class="kvm-modes">
      <button class="kvm-mode easy" onclick="startKEM('easy')">
        üü¢ Easy<br><span>Few Walls</span>
      </button>

      <button class="kvm-mode medium" onclick="startKEM('medium')">
        üü° Medium<br><span>More Walls</span>
      </button>

      <button class="kvm-mode hard" onclick="startKEM('hard')">
        üî• Hard<br><span>Maze Mode</span>
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ Move the knight legally</li>
        <li>üß± Walls block your path</li>
        <li>üëπ Watch out! they are coming for you!</li>
        <li>üèÅ Reach the exit to win</li>
      </ul>
    </div>
  </div>

  <!-- GAME -->
  <div id="kemGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Moves: <span id="kemTurns">0</span></div>
      <div>üèÜ Level: <span id="kemLevel">1</span></div>
    </div>

    <div id="kemBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKEM()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightspeed-section" class="section hidden">
  <h2>üê¥ Knight Speed Run</h2>

  <!-- MENU -->
  <div class="card" id="ksrMenu">
    <h3>Speed Challenge</h3>
    <p>Collect as many ‚≠ê as possible before time runs out!</p>

    <div class="kvm-modes">
      <button class="kvm-mode easy" onclick="startKSR('easy')">
        üü¢ Easy<br><span>40 Seconds</span>
      </button>

      <button class="kvm-mode medium" onclick="startKSR('medium')">
        üü° Medium<br><span>30 Seconds</span>
      </button>

      <button class="kvm-mode hard" onclick="startKSR('hard')">
        üî• Hard<br><span>20 Seconds</span>
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ Move the knight legally</li>
        <li>‚≠ê Collect stars as fast as possible</li>
        <li>üí£ Watch Out for Bombs! </li>
        <li>‚è± Beat the timer</li>
        <li>üèÜ Higher score = better speed</li>
      </ul>
    </div>
  </div>

  <!-- GAME -->
  <div id="ksrGame" class="hidden">
    <div class="memory-top">
      <div>‚≠ê Score: <span id="ksrScore">0</span></div>
      <div>‚è± Time: <span id="ksrTime">30</span>s</div>
    </div>

    <div id="ksrBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKSR()">‚¨Ö Exit</button>
  </div>
</section>

<!-- ================================ -->
<!-- üî• KNIGHT LAVA FLOOR (ISOLATED) -->
<!-- ================================ -->
<section id="knightlava-section" class="section hidden">

  <h2>üî• Knight Lava Floor</h2>

  <!-- MENU -->
<div class="card klf-intro-card" id="klfMenu">

  <div class="klf-intro-left">
    <h3>üî• Survive the Lava</h3>

    <ul class="klf-rules">
      <li>üê¥ Move the knight using <b>legal moves</b></li>
      <li>üî• Lava spreads <b>after every move</b></li>
      <li>‚ò†Ô∏è Step on lava = <b>Game Over</b></li>
      <li>üèÜ Survive as long as you can</li>
    </ul>

    <button class="btn-primary klf-start-btn" onclick="startKLF()">
      ‚ñ∂ Start Game
    </button>
  </div>

</div>


  <!-- GAME -->
  <div id="klfGame" class="hidden">

    <div class="memory-top">
      <div>‚è± Turns: <span id="klfTurns">0</span></div>
      <div>üî• Lava: <span id="klfLavaCount">0</span></div>
    </div>

    <div id="klfBoard" class="klf-board"></div>

    <button class="btn-secondary" onclick="exitKLF()">‚¨Ö Exit</button>
  </div>

</section>


<section id="knightfog-section" class="section hidden">
  <h2>üçé Knight Fog Quest</h2>

  <!-- ===================== -->
  <!-- MENU -->
  <!-- ===================== -->
  <div class="card" id="kfqMenu">
    <h3>Find the Hidden Apple!</h3>
    <p>
      Move the knight üê¥ on a 10√ó10 board.<br>
      The board is hidden by fog.<br>
      Find all üçé apples before time runs out!
    </p>

    <!-- SPEED CHALLENGE -->
    <div class="card" style="margin-top:14px;">
      <h3>‚è±Ô∏è Speed Challenge</h3>
      <p>Finish finding apples before the timer ends.</p>

      <div class="kfq-modes">
        <button class="kfq-mode easy" onclick="startKFQTimed(40)">
          üü¢ Easy<br><span>40 Seconds</span>
        </button>

        <button class="kfq-mode medium" onclick="startKFQTimed(30)">
          üü° Medium<br><span>30 Seconds</span>
        </button>

        <button class="kfq-mode hard" onclick="startKFQTimed(20)">
          üî• Hard<br><span>20 Seconds</span>
        </button>
      </div>
    </div>

    <!-- NORMAL MODE -->
    <button class="btn-primary" style="margin-top:12px;" onclick="startKFQ()">
      ‚ñ∂ Free Mode
    </button>
  </div>

  <!-- ===================== -->
  <!-- GAME -->
  <!-- ===================== -->
  <div id="kfqGame" class="hidden">
    <div class="memory-top">
      <div>üéØ Task: <span id="kfqTask">Find üçé</span></div>
      <div>‚≠ê Moves: <span id="kfqMoves">0</span></div>
      <div>üçé Found: <span id="kfqFound">0 / 8</span></div>

      <div>‚è± Time: <span id="kfqTime">0</span>s</div>
    </div>

    <div id="kfqBoard"></div>

    <button class="btn-secondary" onclick="exitKFQ()">‚¨Ö Exit</button>
  </div>
</section>




<section id="knightdefense-section" class="section hidden">
  <h2>üëëüõ°Ô∏è Defend the King </h2>

  <!-- MENU -->
  <div class="card" id="kndMenu">
    <h3>Protect the King!</h3>
    <p>
      üëë King is on <b>e1</b><br>
      
      üê¥ You control the knight<br>
      üëπ Monsters fall from the top!<br>
      Kill them before they reach the King.
    </p>

    <div class="knd-modes">
      <button class="knd-mode easy" onclick="startKND('easy')">
        üü¢ Easy<br><span>3 Monsters</span>
      </button>
      <button class="knd-mode medium" onclick="startKND('medium')">
        üü° Medium<br><span>4 Monsters</span>
      </button>
      <button class="knd-mode hard" onclick="startKND('hard')">
        üî• Hard<br><span>5 Monsters</span>
      </button>
    </div>
  </div>

  <!-- GAME -->
  <div id="kndGame" class="hidden">
    <div class="memory-top">
      <div>üëπ Left: <span id="kndLeft">0</span></div>
      <div>‚è± Time: <span id="kndTime">0</span>s</div>
    </div>

    <div id="kndBoard"></div>

    <button class="btn-secondary" onclick="exitKND()">‚¨Ö Exit</button>
  </div>
</section>



<!-- ================================ -->
<!-- üëë MATH JOURNEY (ISOLATED GAME) -->
<!-- ================================ -->

<section id="kingmath-section" class="section hidden">

  <h2>üëë Chess Math Journey</h2>

  <!-- MENU -->
  <div class="card" id="kmMenu">
    <h3>Select Level</h3>

    <div class="kvm-modes">
      <button class="kvm-mode easy" onclick="startKM('easy')">
        üü¢ Easy
      </button>

      <button class="kvm-mode medium" onclick="startKM('medium')">
        üü° Medium
      </button>

      <button class="kvm-mode hard" onclick="startKM('hard')">
        üî• Hard
      </button>
    </div>

    <div class="kp-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üëë King starts from last rank</li>
        <li> üü¢ Easy = 40 Sec/ üü° Medium = 60 Sec/ üî• Hard = 90 Sec/</li>
        <li>‚ûï Solve the math shown above</li>
        <li>‚¨Ü Choose one of the next 3 squares</li>
        <li>üö© Complete the all the questions within time</li>
        <li>‚ùå Wrong answer = Game Over</li>
      </ul>
    </div>
  </div>

  <!-- GAME -->
  <div id="kmGame" class="hidden">

    <div class="memory-top">
      <div>üß† Solve: <span id="kmQuestion">?</span></div>
      <div>‚¨Ü Steps: <span id="kmStep">0</span></div>
    </div>
    <div id="kmTimer" class="km-timer">
  ‚è± Time: <span id="kmTime">90</span>s
</div>



    <div id="kmBoard" class="mini-board"></div>

    <button class="btn-secondary" onclick="exitKM()">‚¨Ö Exit</button>
  </div>

</section>


<section id="colorchaos-section" class="section hidden">
  <h2>üé®‚ö° Rainbow Showdwon</h2>

  <!-- MODE MENU -->
  <div class="card cfc-card" id="cfcMenu">
    <h3>Select Mode</h3>

    <div class="cfc-modes">
      <button class="cfc-mode-btn cfc-mode-easy" onclick="startCFC('easy')">
        üü¢ Easy
      </button>

      <button class="cfc-mode-btn cfc-mode-medium" onclick="startCFC('medium')">
        üü° Medium
      </button>

      <button class="cfc-mode-btn cfc-mode-hard" onclick="startCFC('hard')">
        üî• Hard
      </button>
    </div>

    <div class="cfc-how">
      <h4>üìò How to Play</h4>
      <ul>
        <li>üê¥ Control the knight using legal moves</li>
        <li>üé® Board colors change automatically</li>
        <li>‚ö™ Land on WHITE squares</li>
        <li>‚è± Finish before time runs out</li>
        <li>‚≠ê Difficulty only changes available time</li>
      </ul>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="cfcGame" class="hidden">
    <div class="memory-top">
      <div>‚ö™ Score: <span id="cfcScore">0</span></div>
      <div>üéØ Target: <span id="cfcTarget">5</span></div>
      <div>‚è± Time: <span id="cfcTime">20</span>s</div>
    </div>

    <!-- BOARD -->
    <div class="cfc-board-wrapper">
  <!-- RANK LABELS -->
  <div class="cfc-ranks">
    <span>8</span>
    <span>7</span>
    <span>6</span>
    <span>5</span>
    <span>4</span>
    <span>3</span>
    <span>2</span>
    <span>1</span>
  </div>

  <!-- BOARD -->
  <div id="cfcBoard" class="mini-board board-8"></div>

  <!-- FILE LABELS -->
  <div class="cfc-files">
    <span>a</span>
    <span>b</span>
    <span>c</span>
    <span>d</span>
    <span>e</span>
    <span>f</span>
    <span>g</span>
    <span>h</span>
  </div>
</div>


    <button class="btn-secondary" onclick="exitCFC()">‚¨Ö Exit</button>
  </div>
</section>

<section id="coordtrain-section" class="section hidden">
  <h2>üìç Board Coordinate Training</h2>

  <!-- MENU -->
  <div class="card" id="ctMenu">
    <h3>Find the Square!</h3>
    <p>
      A square name will flash briefly.<br />
      Click the correct square on the board.
    </p>

    <button class="btn-primary" onclick="startCT()">‚ñ∂ Start</button>
  </div>

  <!-- GAME -->
  <div id="ctGame" class="hidden">
    <div class="memory-top">
      <div>üéØ Target: <span id="ctTarget">e4</span></div>
      <div>‚≠ê Score: <span id="ctScore">0</span></div>
      <div>‚ùå Miss: <span id="ctMiss">0</span></div>
    </div>
    <div style="margin-bottom: 10px; text-align: center;">
  <button class="btn-secondary" id="ctToggleCoords" onclick="toggleCTCoords()">
    üëÅ Hide Files & Ranks
  </button>
</div>


    <div class="cfc-board-wrapper">
      
      <!-- RANKS -->
      <div class="cfc-ranks">
        <span>8</span><span>7</span><span>6</span><span>5</span>
        <span>4</span><span>3</span><span>2</span><span>1</span>
      </div>

      <!-- BOARD -->
      <div id="ctBoard" class="mini-board board-8"></div>

      <!-- FILES -->
      <div class="cfc-files">
        <span>a</span><span>b</span><span>c</span><span>d</span>
        <span>e</span><span>f</span><span>g</span><span>h</span>
      </div>
    </div>

    <button class="btn-secondary" onclick="exitCT()">‚¨Ö Exit</button>
  </div>
</section>

<section id="boardfreeze-section" class="section hidden">
  <h2>üéØ Guess Materials</h2>

  <!-- MENU -->
  <div class="card" id="bfMenu">
    <h3>Snapshot Challenge</h3>
    <p>
      Board flashes for 5 seconds.<br>
      Remember & answer the question.
    </p>

    <button class="btn-primary" onclick="startBF()">‚ñ∂ Start</button>
  </div>

  <!-- GAME -->
  <div id="bfGame" class="hidden">

    <div class="memory-top">
      <div>‚ùì Question: <span id="bfQuestion">‚Äì</span></div>
      <div>‚≠ê Score: <span id="bfScore">0</span></div>
    </div>

    <div class="bf-board-wrapper">

  <!-- RANKS -->
  <div class="bf-ranks">
    <span>8</span><span>7</span><span>6</span><span>5</span>
    <span>4</span><span>3</span><span>2</span><span>1</span>
  </div>

  <!-- BOARD -->
  <div id="bfBoard"></div>

  <!-- FILES -->
  <div class="bf-files">
    <span>a</span><span>b</span><span>c</span><span>d</span>
    <span>e</span><span>f</span><span>g</span><span>h</span>
  </div>

</div>


    <div style="margin-top:16px; text-align:center;">
      <button class="btn-secondary" onclick="bfMinus()">‚àí</button>
      <span id="bfAnswer" style="font-size:24px; margin:0 16px;">0</span>
      <button class="btn-secondary" onclick="bfPlus()">+</button>
    </div>

    <div style="margin-top:12px; text-align:center;">
      <button class="btn-primary" onclick="bfSubmit()">Submit</button>
    </div>

    <button class="btn-secondary" style="margin-top:14px;" onclick="exitBF()">‚¨Ö Exit</button>
  </div>
</section>

<section id="knightgps-section" class="section hidden">
  <h2>üß≠ Knight GPS</h2>

  <!-- MENU -->
  <div class="card" id="kgMenu">
    <h3>Reach the Target</h3>
    <p>
      Move the knight using legal moves.<br>
      Barriers block your path.<br>
      Reach üéØ using minimum fuel ‚õΩ
    </p>

    <button class="btn-primary" onclick="startKG()">‚ñ∂ Start</button>
  </div>

  <!-- GAME -->
  <div id="kgGame" class="hidden">

    <div class="memory-top">
      <div>‚õΩ Fuel: <span id="kgFuel">10</span></div>
      <div>üéØ Target: <span id="kgTarget">‚Äì</span></div>
    </div>

    <div class="kg-center">
  <div class="kg-board-grid">

    <!-- RANKS -->
    <div class="kg-ranks">
      <span>8</span><span>7</span><span>6</span><span>5</span>
      <span>4</span><span>3</span><span>2</span><span>1</span>
    </div>

    <!-- BOARD -->
    <div id="kgBoard"></div>

  </div>

  <!-- FILES -->
  <div class="kg-files">
    <span>a</span><span>b</span><span>c</span><span>d</span>
    <span>e</span><span>f</span><span>g</span><span>h</span>
  </div>
</div>


    <button class="btn-secondary" style="margin-top:14px;" onclick="exitKG()">‚¨Ö Exit</button>
  </div>
</section>

















<!-- ========================= -->
<!-- ‚ôüÔ∏è PIECE PRACTICE TAB -->
<!-- ========================= -->
<div class="section hidden" id="piecePractice-section">

  <h2>ü¶ñ Hunt Doddles</h2>

  <div class="card">
    <div class="mini-games-row">

      <!-- ‚ö° Knight -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôò Knight Hunter</span>
        </div>
        <div id="miniBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="stars">0</span></div>
          <div class="misses">‚ùå <span id="knightMisses">0</span></div>
          <button id="startMiniGame">New</button>
        </div>
      </div>

      <!-- ‚ôó Bishop -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôó Bishop Hunter</span>
        </div>
        <div id="bishopBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="bishopStars">0</span></div>
          <div class="misses">‚ùå <span id="bishopMisses">0</span></div>
          <button id="bishopStart">New</button>
        </div>
      </div>

      <!-- ‚ôñ Rook -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôñ Rook Hunter</span>
        </div>
        <div id="rookBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="rookStars">0</span></div>
          <div class="misses">‚ùå <span id="rookMisses">0</span></div>
          <button id="rookStart">New</button>
        </div>
      </div>

      <!-- üëë Queen -->
      <div class="mini-game">
        <div class="mini-header">
          <span class="mini-title">‚ôõ Queen Hunter</span>
        </div>
        <div id="queenBoard" class="practice-board"></div>

        <div class="mini-footer">
          <div class="stars">‚≠ê <span id="queenStars">0</span></div>
          <div class="misses">‚ùå <span id="queenMisses">0</span></div>
          <button id="queenStart">New</button>
        </div>
      </div>
      <!-- ‚ôô Pawn -->
<div class="mini-game">
  <div class="mini-header">
    <span class="mini-title">‚ôô Pawn Hunter</span>
  </div>

  <div id="pawnBoard" class="practice-board"></div>


  <div class="mini-footer">
    <div class="stars">‚≠ê <span id="pawnStars">0</span></div>
    <div class="misses">‚ùå <span id="pawnMisses">0</span></div>
    <button id="pawnStart">New</button>
  </div>
</div>
<!-- üëë King -->
<div class="mini-game">
  <div class="mini-header">
    <span class="mini-title">‚ôö King Hunter</span>
  </div>

  <div id="kingBoard" class="practice-board"></div>


  <div class="mini-footer">
    <div class="stars">‚≠ê <span id="kingStars">0</span></div>
    <div class="misses">‚ùå <span id="kingMisses">0</span></div>
    <button id="kingStart">New</button>
  </div>
</div>



    </div>
  </div>

</div>





<section id="quiz-section" class="section">
    <div id="quizRushScreen" class="quiz-rush">

      <div class="quiz-top">
        <div class="quiz-timer">‚è± <span id="quizTimer">60</span>s</div>
        <div class="quiz-score">Score: <span id="quizScore">0</span></div>
      </div>

      <div class="quiz-title">‚ôüÔ∏è Find the best move</div>

      <div id="quizBoardWrapper">
        <div id="quizBoard"></div>
      </div>

      <div class="quiz-options">
        <button class="quiz-option" data-index="0">Option A</button>
        <button class="quiz-option" data-index="1">Option B</button>
        <button class="quiz-option" data-index="2">Option C</button>
        <button class="quiz-option" data-index="3">Option D</button>
      </div>

    </div>
  </section>




    <!-- CHESS BOARD SECTION -->
    <div class="section active" id="board-section">
      <h2>üî¨ Analysis board</h2>

      <div id="gameStatus" class="status-indicator" style="display: none;"></div>
      <div id="timerDisplay" class="timer" style="display: none;">
        ‚è±Ô∏è Time: <span id="timer">00:00</span>
      </div>

      <div class="board-layout">
        
        <!-- Board (left) -->
        <div class="board-wrapper">
          <div id="chessboard"></div>
          
          <!-- Player names under board -->
<div class="player-bar">
    <div id="whitePlayer" class="player white">
      ‚ôö White: <span></span>
    </div>
    <div id="blackPlayer" class="player black">
      ‚ôî Black: <span></span>
    </div>
  </div>
  <div id="bulkNav" class="bulk-bar">
  <button onclick="goToPrevBulkPuzzle()">‚¨Ö Prev</button>
  <span id="bulkIndicator">Puzzle 1 / 1</span>
  <button onclick="goToNextBulkPuzzle()">Next ‚û°</button>
</div>




          <!-- Fixed SVG overlay -->
          <svg id="boardOverlay"></svg>
          
        </div>
        <div id="notationPanel" class="card" aria-live="polite">
          <h4>Notation</h4>
          <div id="notationList" style="max-height:420px; overflow:auto; font-family:ui-monospace;"></div>
        </div>

        <!-- Side panel (right) -->
        <div id="sidePanel" class="side-panel">
          

          <!-- Controls -->
          <div class="control-grid">
            <button class="btn-primary" onclick="resetBoard()">Reset board (R)</button>
            <button class="btn-secondary" onclick="copyPGN()">Copy PGN (P)</button>
            

            <button class="btn-secondary" onclick="flipBoard()">Flip board (F)</button>
            
            <button class="btn-success" onclick="savePosition()">Save Database (S)</button>
            
            
<div id="enginePanel" class="engine-panel">

  <!-- üî• ONE SINGLE HEADER BAR -->
  <div class="engine-bar">
    <span class="engine-title">
   Stockfish <span class="wasm-badge">WASM</span>
</span>


    <span class="engine-stat">
      Eval: <span id="engineEval">‚Äì</span>
    </span>

    <span class="engine-stat">
      Depth: <span id="engineDepth">‚Äì</span>
    </span>
  </div>

  <!-- üîΩ FREE SPACE FOR MULTI ENGINE LINES -->
  <div class="engine-body" id="engineLines">
  <div class="engine-line" id="engineLine1">üî∑</div>
  <div class="engine-line" id="engineLine2">üî∑</div>
  <div class="engine-line" id="engineLine3">üî∑</div>
</div>


    <!-- future -->
    <!-- <div class="engine-line">PV1: ‚Ä¶</div> -->
    <!-- <div class="engine-line">PV2: ‚Ä¶</div> -->
  

</div>








          </div>
          

          <!-- Add this in the side panel after the control-grid div -->

          
          

          <!-- Move input + keypad -->
          

          

          
          
          <!-- PGN viewer + navigation -->
          <div id="pgnContainer" class="hidden" aria-hidden="true">
            <h3>Game PGN</h3>
            <div class="pgn-viewer" id="pgnViewer">No moves yet</div>
            <div style="margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap;">
              <button class="btn-secondary" onclick="copyPGN()">Copy PGN (P)</button>
              <button class="btn-success" onclick="submitSolution()" id="submitBtn" style="display: none;">Submit solution</button>
            </div>
            <div id="assignmentModeContainer" style="display:none;">
    <h3>Assignment Loaded successfully</h3>
    <p>Play the correct move in the given position.</p>
</div>

          </div>
          <button
  id="analyzeBtn"
  class="btn-secondary"
  style="margin-top:8px;"
>
  üü¢ Start Analysis
</button>

          <!-- Admin-only PGN / FEN load -->
          <div id="pgnUploadSection" style="display: none;">
            
            <textarea id="pgnInput" placeholder="Paste PGN (e.g., 1. e4 e5 2. Nf3 Nc6)"></textarea>
            <div class="form-row">
              <button class="btn-success" onclick="loadPGN()">Load PGN</button>
            </div>
            
            <input id="fenInput" type="text" placeholder="Paste FEN (optional)" />
            <div class="form-row">
              <button class="btn-secondary" onclick="loadFEN()">Load FEN</button>
            </div>
            

            <div id="pgnNavButtons" style="margin-top:12px; display:flex; gap:8px; flex-wrap:nowrap;">
              <button id="btnFirst" class="btn-secondary" onclick="pgnFirstMove()">‚èÆÔ∏è First (Home)</button>
              <button id="btnPrev" class="btn-secondary" onclick="pgnPrevMove()">‚óÄÔ∏è Prev (‚Üê)</button>
              <button id="btnNext" class="btn-secondary" onclick="pgnNextMove()">Next ‚ñ∂Ô∏è (‚Üí)</button>
              <button id="btnLast" class="btn-secondary" onclick="pgnLastMove()">Last ‚è≠Ô∏è (End)</button>
              
              
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ASSIGNMENTS -->
    <div class="section" id="assignments-section">
      <h2>üìö Assignments</h2>
      <div class="assignments-layout" aria-live="polite">
        <div id="assignmentsList" class="assignments-list loading" role="region" aria-label="Assignments list">
          Loading assignments...
        </div>
        <div class="assignments-form" aria-label="Create assignment form">
          <div id="createAssignmentForm" style="display: none;">
            <!-- Assign to specific students (Admin only) -->
<div class="form-row" id="assignStudentsRow" style="display:none;">
  

  <div id="assignStudentsBox"
       style="
         border:1px solid #444;
         border-radius:8px;
         padding:10px;
         max-height:160px;
         overflow-y:auto;
         background:#0f1224;
       ">
    <!-- student checkboxes will be injected here -->
  </div>

  
</div>

<div class="assign-actions" style="
  display:flex;
  gap:8px;
  justify-content:flex-end;
  margin-top:8px;   /* üî• reduced */
">

  <button type="button" class="btn-small" onclick="selectAllStudents()">Select all</button>
  <button type="button" class="btn-small danger" onclick="clearAllStudents()">Clear all</button>
</div>



            <h3>‚ûï Create new assignment</h3>
            <div class="form-row">
              <input type="text" id="assignTitle" placeholder="Assignment title">
              <select id="assignType">
                <option value="tactics">Tactics puzzle</option>
                <option value="endgame">Endgame study</option>
                <option value="opening">Opening practice</option>
                <option value="analysis">Position analysis</option>
                
              </select>
            </div>
            <textarea id="assignDesc" placeholder="Description and instructions..."></textarea>
            <div class="form-row">
              <input type="datetime-local" id="assignDue">
              <input type="text" id="assignFEN" placeholder="Starting FEN (optional)">
            </div>
            <div class="form-row">
              

<textarea
  id="assignPGN"
  placeholder="Paste PGN here or import from file"
  rows="6"
></textarea>

<!-- PGN Import -->
<input
  type="file"
  id="pgnFileInput"
  accept=".pgn"
  style="display:none;"
>

<button
  type="button"
  id="importPgnBtn"
  class="btn-secondary"
  style="margin-top:8px;"
>
  üìÇ Import PGN from computer
</button>

            </div>
            <div class="create-actions">
              <button class="btn-success" onclick="createAssignment()">Create assignment</button>
              <button class="clear-filters-btn" id="clearAssignmentFormBtn" type="button">Clear</button>
            </div>
            
          </div>
          <!-- ================= STUDENT BADGES (STEP 1: EMPTY) ================= -->
<div class="card" id="studentBadgePanel" aria-label="Student Badges">
  <h3>üèÖ Achievements</h3>

  <div id="studentBadgeContent">
    



  </div>
</div>

        </div>
        
        <!-- ================= STUDENT PROGRESS (STUDENT ONLY) ================= -->
<div class="card" id="studentProgressCard">
  <h3>üìä My Assignment History</h3>

  <div id="studentProgressList">
    <p class="muted">
      Your assignment history will appear here.
    </p>
  </div>
</div>

         <!-- ================= RIGHT COLUMN : PGN LIBRARY ================= -->
<div class="card" id="pgnLibraryCard" aria-label="PGN Library">


  <h3>üì¶ PGN Database</h3>

  <!-- Hidden file input -->
  <input
    type="file"
    id="pgnLibraryFileInput"
    accept=".pgn"
    style="display:none"
  />

  <!-- Import button -->
  <button
    class="btn-secondary"
    style="margin-top:10px;"
    onclick="document.getElementById('pgnLibraryFileInput').click()"
  >
    üìÇ Import PGN to Database
  </button>

  <!-- üî• THIS WAS MISSING -->
  <div id="pgnLibraryList">

    <!-- PGNs will render here -->
  </div>

</div>



  </div>

      </div>
    </div>
    

    <!-- ADMIN PANEL -->
    <div class="section" id="students-section">
      <div id="adminContent">
        <h2>üîê Admin panel</h2>
        
        <div class="admin-layout">
          <div class="admin-table" aria-label="Current students">
            <h3>üìã Current students</h3>
            <table>
              <thead>
                <tr>
                  <th style="width:40px;"><input type="checkbox" id="selectAllStudents"></th>
                  <th>Username</th>
                  <th>Status</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="studentsTable">
                <tr><td colspan="4" class="loading">Loading students...</td></tr>
              </tbody>
            </table>
          </div>
          <div class="admin-form" aria-label="Manage students and settings">
            <div>
              <h3>‚ûï Add new student</h3>
              <div class="form-row">
                <input type="text" id="newStudentUser" placeholder="Username">
                <div style="position: relative; width: 100%;">
  <input
    type="password"
    id="newStudentPass"
    placeholder="Password"
    style="padding-right: 44px;"
  />

  <button
    type="button"
    id="togglePassBtn"
    onclick="toggleStudentPassword()"
    style="
      position: absolute;
      right: 10px;
      top: 30%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #ffd700;
      cursor: pointer;
      font-size: 32px;
    "
    title="Show / Hide password"
  >
    üëÅÔ∏è‚Äçüó®Ô∏è
  </button>
</div>


              </div>
              <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                <button class="btn-success" onclick="addStudent()">Add student</button>
                <button class="btn-secondary" id="clearAddStudentBtn" type="button">Clear</button>
              </div>
              <h3 style="margin-top:18px;">‚öôÔ∏è Manage system settings</h3>
              <div style="margin-top:8px;">
                <div class="form-row">
                  <label style="width:100%; color:var(--text-muted); font-weight:700; margin-bottom:6px;">Default student status</label>
                  <select id="defaultStudentStatus">
                    <option value="active">Active</option>
                    <option value="inactive">Inactive</option>
                  </select>
                </div>
                <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
                  <button class="btn-secondary" onclick="refreshStudentList()">Refresh list</button>

                </div>
                <p
  id="studentSortHint"
  style="margin-top:8px; font-size:13px; color:#9da0b8;"
></p>

              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="adminAccessDenied" style="display: none;" class="access-denied">
        <h2>‚õî Access denied</h2>
        <p>This section is restricted to administrators only.</p>
      </div>
    </div>

    <!-- ATTEMPTS -->
    <div class="section" id="attempts-section">
      <h2>üìä Student attempts</h2>
      <div id="attemptsList" class="loading">Loading attempts...</div>
    </div>
  </div>

<input
  type="file"
  id="studyFileInput"
  accept=".pgn"
  style="display:none"
/>

  <!-- Libraries -->
  <!-- Libraries -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<!-- üî• ADD THESE TWO LINES -->
<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
<link
  rel="stylesheet"
  href="https://code.jquery.com/ui/1.13.2/themes/smoothness/jquery-ui.css"
/>

<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.11.0/chess.min.js"></script>


  <script type="module">
    // ============================================
    // IMPORTS & GLOBALS
    // ============================================
    import { supabase } from './supabase-client.js';

    let currentUser = null;
    let currentProfile = null;
    let quizChess = new Chess();
let currentQuizSolution = null;
let currentOptions = [];



async function saveMiniGameScore(gameKey, newScore) {
  if (!currentProfile) return;

  const { data: existing } = await supabase
    .from("minigame_high_scores")
    .select("score")
    .eq("student_id", currentProfile.id)
    .eq("game_key", gameKey)
    .maybeSingle();

  if (!existing || newScore > existing.score) {
    const { error } = await supabase
      .from("minigame_high_scores")
      .upsert(
        {
          student_id: currentProfile.id,
          game_key: gameKey,
          score: newScore
        },
        {
          onConflict: "student_id,game_key"
        }
      );

    if (error) {
      console.error("‚ùå Upsert failed:", error);
    } else {
      console.log("‚úÖ High score updated:", gameKey, newScore);
      // üèÜ UPDATE LEFT PANEL IMMEDIATELY
      loadMyBestScores();
    }
  }
}


async function loadMyBestScores() {
  const list = document.getElementById("miniScoreList");
  if (!list || !currentProfile) return;

  list.innerHTML = `<p class="muted">Loading scores...</p>`;

  const { data, error } = await supabase
    .from("minigame_high_scores")
    .select("game_key, score")
    .eq("student_id", currentProfile.id)
    .order("game_key");

  if (error) {
    console.error("‚ùå Score load error", error);
    list.innerHTML = `<p class="muted">Failed to load</p>`;
    return;
  }

  if (!data || data.length === 0) {
    list.innerHTML = `<p class="muted">No scores yet</p>`;
    return;
  }

  list.innerHTML = "";

  data.forEach(row => {
    const div = document.createElement("div");
    div.className = "mini-score-row";
    div.innerHTML = `
      <span class="game-name">${formatGameName(row.game_key)}</span>
      <span class="game-score">${row.score}</span>
    `;
    list.appendChild(div);
  });
}

function formatGameName(key) {
  const map = {
    memory: "üß† IQ Hunt",
    boardfreeze: "‚ùì Guess Materials",
    color: "üß™ Lab Hunt",
    knightfog: "üçé Knight Fog Quest",
    knightdefense: "üëë Defend The King",
    knightpath: "üê¥ Knight Hunt",
    knightmonster: "üê¥ vs üëπ",
    knightescape: "üè∞ Escape",
    knightspeed: "‚ö° Speed Run",
    knightlava: "üî• Lava Knight",
    knightgps: "üß≠ Knight GPS",
    kingmath: "üëë Chess Math",
    colorchaos: "üé® Rainbow Mania",
    flashqueen: "üë∏ Find The Queen",
    pathfinder: "üë∏ Reach Home",
    puzzlerush: "‚ö° Puzzle Rush",
    quiz: "‚öΩ Quiz",
    coordtrain: "üìç Board Coordinates"
  };

  return map[key] || key;
}


















    // ===============================
// ‚ôü STOCKFISH ENGINE (CLASSIC JS)
// ===============================
let stockfish = null;
const ENGINE_BULLETS = ["üî∑", "üî∑", "üî∑"];
let engineReady = false;
let engineAnalyzing = false;
let currentPV = [];
const pvMap = {};
let engineRunning = false;   // üî• NEW

let studyEngine = null;
let studyEngineReady = false;

let studyEngineEnabled = false;
let studyPV = {};

document.getElementById("studyEngineToggle").onclick = () => {
  studyEngineEnabled = !studyEngineEnabled;

  const btn = document.getElementById("studyEngineToggle");
  btn.textContent = studyEngineEnabled ? "ON" : "OFF";
  btn.className = "engine-toggle " + (studyEngineEnabled ? "on" : "off");

  if (studyEngineEnabled) {
    initStudyEngine();
    analyzeStudyPosition();
  } else {
    studyEngine.postMessage("stop");
    document.getElementById("studyPVLines").innerHTML = "";
    document.getElementById("studyEval").textContent = "--";
    document.getElementById("studyDepth").textContent = "--";
  }
};





function initEditorBoard() {
  if (editorBoard) return;

  editorChess = new Chess(); // empty logic holder

  editorBoard = Chessboard("editorBoard", {
    position: "start",
    draggable: true,
    sparePieces: true,   // üî• IMPORTANT (lichess-style)
    dropOffBoard: "trash", // allow deleting pieces
    pieceTheme:
      "https://lichess1.org/assets/piece/merida/{piece}.svg",

    onDrop: onEditorDrop

  });

  syncEditorFEN();
}
function onEditorDrop(source, target, piece) {
  // remove piece from source square
  editorChess.remove(source);

  // detect color and type from piece string (wP, bQ, etc.)
  const color = piece[0] === "w" ? "w" : "b";
  const type = piece[1].toLowerCase();

  // place piece on target square
  editorChess.put({ type, color }, target);

  // üî• force FEN update immediately
  syncEditorFEN();
}



function syncEditorFEN() {
  if (!editorBoard) return;

  // üî• WAIT for Chessboard.js to finish updating
  setTimeout(() => {
    const boardFen = editorBoard.fen();
    const turn = document.getElementById("editorTurn").value;

    let castling = "";

    if (document.getElementById("castleWK").checked) castling += "K";
    if (document.getElementById("castleWQ").checked) castling += "Q";
    if (document.getElementById("castleBK").checked) castling += "k";
    if (document.getElementById("castleBQ").checked) castling += "q";

    if (castling === "") castling = "-";

    const fullFen = `${boardFen} ${turn} ${castling} - 0 1`;
    document.getElementById("editorFEN").value = fullFen;
  }, 0);
}



function normalizeEditorFEN(fen) {
  const parts = fen.trim().split(" ");

  // chessboard.js editor gives only board layout
  if (parts.length === 1) {
    return `${parts[0]} w - - 0 1`;
  }

  // fill missing fields safely
  while (parts.length < 6) {
    if (parts.length === 1) parts.push("w");
    else if (parts.length === 2) parts.push("-");
    else if (parts.length === 3) parts.push("-");
    else if (parts.length === 4) parts.push("0");
    else if (parts.length === 5) parts.push("1");
  }

  return parts.join(" ");
}

document.getElementById("editorTurn").addEventListener("change", () => {
  syncEditorFEN();
});


document
  .getElementById("editorStartPos")
  .addEventListener("click", () => {
    if (!editorBoard) return;

    editorBoard.position("start", true);
    syncEditorFEN();
  });

document
  .getElementById("editorClear")
  .addEventListener("click", () => {
    if (!editorBoard) return;

    editorBoard.clear(true);
    syncEditorFEN();
  });

  document.getElementById("editorApply").addEventListener("click", () => {
  if (!editorBoard) return;

  const fen = document.getElementById("editorFEN").value;

  // ‚úÖ switch to Analysis Board tab (correct key)
  const analysisBtn = document.querySelector('[data-tab="board"]');
  if (analysisBtn) analysisBtn.click();

  // ‚úÖ load FEN safely after board is visible
  setTimeout(() => {
    if (board && chess) {
      chess.load(fen);
      board.position(fen, false);

      // üî• sync engine / UI
      moveHistory = [];
      renderMoveList?.();
      stopEngine();
    }
  }, 120);
});

document.getElementById("copyFenBtn").addEventListener("click", () => {
  const fenBox = document.querySelector(
    '#editorControls textarea'
  ) || document.querySelector('textarea');

  if (!fenBox) return;

  navigator.clipboard.writeText(fenBox.value).then(() => {
    const status = document.getElementById("fenCopyStatus");
    status.classList.remove("hidden");

    setTimeout(() => {
      status.classList.add("hidden");
    }, 1500);
  });
});





function initStockfish() {
  if (stockfish) return;

  console.log("‚ôü Initializing Stockfish engine‚Ä¶");

  stockfish = new Worker("./stockfish/stockfish.js");

  stockfish.onmessage = (e) => {
    const line = e.data;
    if (typeof line !== "string") return;

    // ======================
    // ENGINE READY
    // ======================
    if (line === "uciok") {
      stockfish.postMessage("setoption name MultiPV value 3");
      engineReady = true;
      return;
    }

    if (line === "readyok") return;

    // ======================
    // INFO (DEPTH / EVAL / MULTI PV)
    // ======================
    if (line.startsWith("info")) {
      const depthMatch = line.match(/depth (\d+)/);
      const cpMatch = line.match(/score cp (-?\d+)/);
      const mateMatch = line.match(/score mate (-?\d+)/);

      if (depthMatch) {
        document.getElementById("engineDepth").textContent = depthMatch[1];
      }

      // üîç detect MultiPV index ONCE
      const multipvMatch = line.match(/multipv (\d+)/);

      // ======================
      // HEADER EVAL (PV1 ONLY)
      // ======================
      if (cpMatch && multipvMatch && multipvMatch[1] === "1") {
        const cp = parseInt(cpMatch[1], 10);

        // üî• normalize eval to WHITE POV
        const turn = chess.turn(); // 'w' or 'b'
        const evalCp = turn === 'w' ? cp : -cp;

        document.getElementById("engineEval").textContent =
          (evalCp > 0 ? "+" : "") + (evalCp / 100).toFixed(2);
      }

      // ======================
      // MATE HANDLING (PV1 ONLY)
      // ======================
      if (mateMatch && multipvMatch && multipvMatch[1] === "1") {
        const mate = parseInt(mateMatch[1], 10);
        const turn = chess.turn();
        const mateForWhite = turn === 'w' ? mate : -mate;

        document.getElementById("engineEval").textContent =
          "Mate " + mateForWhite;
      }

      // ======================
      // MULTI PV HANDLING
      // ======================
      const pvMatch = line.match(/ pv (.+)$/);

      if (multipvMatch && pvMatch) {
        const index = Number(multipvMatch[1]); // 1,2,3
        pvMap[index] = pvMatch[1].split(" ").slice(0, 10);
        renderMultiPV();
      }
    }

    // ======================
    // ANALYSIS END
    // ======================
    if (line.startsWith("bestmove")) {
      engineAnalyzing = false;
    }
  };

  // üîë START UCI HANDSHAKE
  stockfish.postMessage("uci");
  stockfish.postMessage("isready");
}

function startEngine() {
  if (!engineReady || engineRunning) return;

  engineRunning = true;
  engineAnalyzing = true;

  // Clear old lines
  Object.keys(pvMap).forEach(k => delete pvMap[k]);
  for (let i = 1; i <= 3; i++) {
    const el = document.getElementById(`engineLine${i}`);
    if (el) el.textContent = `${i}. ‚Äì`;
  }

  const fen = chess.fen();

  stockfish.postMessage("ucinewgame");
  stockfish.postMessage(`position fen ${fen}`);
  stockfish.postMessage("go infinite");

  document.getElementById("analyzeBtn").textContent = "üî¥ Stop Analysis";
}

function stopEngine() {
  if (!engineRunning) return;

  engineRunning = false;
  engineAnalyzing = false;

  stockfish.postMessage("stop");

  document.getElementById("analyzeBtn").textContent = "üü¢ Start Analysis";
  document.getElementById("engineEval").textContent = "‚Äì";
document.getElementById("engineDepth").textContent = "‚Äì";

}

document.querySelectorAll(".nav-btn").forEach(btn => {
  if (btn.dataset.tab === "flashqueen") {
    btn.onclick = () => {
      document.querySelectorAll(".section").forEach(s => s.classList.add("hidden"));
      document.getElementById("flashqueen-section").classList.remove("hidden");

      document.getElementById("flashQueenMenu").classList.remove("hidden");
      document.getElementById("flashQueenGame").classList.add("hidden");
    };
  }
});



document.querySelectorAll(".nav-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const tab = btn.dataset.tab;
    switchTab(tab);
  });
});

let piecePracticeInitialized = false;

function switchTab(tab) {
  // hide all sections
  document.querySelectorAll(".section").forEach(sec => {
    sec.classList.remove("active");
    sec.classList.add("hidden");
  });

  // show target section
  const section = document.getElementById(`${tab}-section`);
  if (section) {
    section.classList.add("active");
    section.classList.remove("hidden");
  } else {
    console.error("‚ùå Section not found:", `${tab}-section`);
  }

  // quiz logic untouched
  if (tab === "quiz") {
    initQuizBoard();
    loadQuizPuzzle();
  }

  // auto-start piece practice ONCE
  if (tab === "piecePractice" && !piecePracticeInitialized) {
    autoStartPiecePractice();
    piecePracticeInitialized = true;
  }
}

function autoStartPiecePractice() {
  requestAnimationFrame(() => {
    startGame();          // Knight
    startBishopGame();    // Bishop
    startRookGame();      // Rook
    startQueenGame();     // Queen
    startPawnGame();      // Pawn
    startKingGame();      // King
  });
}







/* üî• PUT IT HERE */
function updateEnginePosition() {
  if (!engineRunning) return;

  Object.keys(pvMap).forEach(k => delete pvMap[k]);

  for (let i = 1; i <= 3; i++) {
    document.getElementById(`engineLine${i}`).textContent =
      `${ENGINE_BULLETS[i - 1]} ‚Äì`;
  }

  
  stockfish.postMessage(`position fen ${chess.fen()}`);
  stockfish.postMessage("go infinite");
}


document.getElementById("startVsComputer").addEventListener("click", () => {
  clearVsResult(); // üî• clear old "White wins / Black wins"
  initVsEngine();
  initVsComputerBoard();

  // üîÅ RESET GAME STATE
  engineThinking = false;
  vsGameActive = true;

  const baseTime = parseInt(
    document.getElementById("timeControl").value,
    10
  );

  whiteTime = baseTime;
  blackTime = baseTime;
  updateClockUI();

  // üõë CLEAR ANY OLD CLOCK
  if (clockInterval) clearInterval(clockInterval);

  vsEngineConfig = getVsEngineConfig();

  // ‚ôü COLOR SELECTION
  const colorChoice = document.getElementById("playerColor").value;

  let playerColor = colorChoice;
  if (colorChoice === "random") {
    playerColor = Math.random() < 0.5 ? "white" : "black";
  }

  // üî• PUT IT RIGHT HERE
  vsPlayerColor = playerColor;

  // reset game
  vsChess.reset();

  // set board orientation
  vsBoard.orientation(playerColor);

  vsEngine.postMessage(`setoption name Skill Level value ${vsEngineConfig.skill}`);
  vsEngine.postMessage("ucinewgame");

  // ‚è± CLOCK + FIRST MOVE
  if (playerColor === "white") {
    startWhiteClock(); // player moves first
  } else {
    startBlackClock(); // engine moves first

    // ü§ñ engine first move
    setTimeout(() => {
      vsEngine.postMessage(`position fen ${vsChess.fen()}`);
      vsEngine.postMessage(
        `go depth ${vsEngineConfig.depth} movetime ${vsEngineConfig.time}`
      );
    }, 300);
  }

  console.log("üéÆ VS Computer game started", baseTime, playerColor);
});







document
  .getElementById("resetVsComputer")
  .addEventListener("click", resetVsComputerGame);


  








    // Chessboard.js + chess.js
    let board = null;
    let chess = null;
    let boardOrientation = 'white';
    let currentAssignment = null;
    let isAssignmentMode = false; // üîí engine allowed by default




    window.START_FEN =
  "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

  let quizBoard = null;

function initQuizBoard() {
  if (quizBoard) return;

  quizBoard = Chessboard("quizBoard", {
    position: "start",
    draggable: false,
    pieceTheme:
      "https://lichess1.org/assets/piece/merida/{piece}.svg"
  });

  console.log("üß© Quiz board initialized (with pieces)");
}




  // Board Editor //

  let editorBoard = null;
let editorChess = null;
let quizTimer = null;
let timeLeft = 20;
let quizScore = 0;
let quizActive = false;



  // ===============================
// ü§ñ PLAY VS COMPUTER (BOARD ONLY)
// ===============================
let vsChess = null;
let vsBoard = null;
let vsGameActive = false;
let whiteTime = 0;
let blackTime = 0;
let clockInterval = null;
let engineThinking = false;
let vsPlayerColor = "white"; // default
let botVoiceAudio = null;


const BOT_PERSONALITIES = {
 

  ares: {
    name: "Ares Blaster",
    image: "bots/max.png",
    gibberish: [
  "üòÄ Hello! there",
  "üòÅ Hi! my buddy!",
  "üòÑ Hey! mate!",
  "üòä Hi there!",
  "üëã Hello! there",
  "üòÉ Hey buddy!",
  "üôÇ Hi friend!",
  "ü§ó Hello there!",
  "üòé Hey! my boy",
  "üòé Hi! friend"
],
voice: "bot/voices/ares.mp3"


  },

  athena: {
    name: "Olybot",
    image: "bots/ultra.png",
    gibberish: [
  "üòÄ Hello! there",
  "üòÅ Hi! my buddy!",
  "üòÑ Hey! mate!",
  "üòä Hi there!",
  "üëã Hello! there",
  "üòÉ Hey buddy!",
  "üôÇ Hi friend!",
  "ü§ó Hello there!",
  "üòé Hey! my boy",
  "üòé Hi! friend"
],
voice: "bot/voices/olybot.mp3"


  },

  

 
  
};


// =============================
// ü§ñ BOT SPEECH (SAFE FUNCTION)
// =============================
let botBubbleTimer = null;
let botCaptureAudio = null;


function botSpeak(key) {
  const bubble = document.getElementById("botBubble");
  if (!bubble) return;

  const bot = BOT_PERSONALITIES[key];
  if (!bot) return;

  // üí¨ text
  const lines = bot.gibberish;
  bubble.textContent = lines[Math.floor(Math.random() * lines.length)];
  bubble.classList.remove("hidden");

  // üîä stop previous voice
  if (botVoiceAudio) {
    botVoiceAudio.pause();
    botVoiceAudio.currentTime = 0;
  }

  // üîä play new bot voice
  if (bot.voice) {
    botVoiceAudio = new Audio(bot.voice);
botVoiceAudio.volume = 0.8;
botVoiceAudio.play().catch(() => {});

// üëÑ START MOUTH SYNC (THIS IS THE KEY LINE)
syncMouthWithAudio(botVoiceAudio);

  }

  // ‚è± hide bubble after 2 sec
  if (botBubbleTimer) clearTimeout(botBubbleTimer);
  botBubbleTimer = setTimeout(() => {
    bubble.classList.add("hidden");
  }, 3000);
}



let mouthCtx = null;
let mouthAnalyser = null;
let mouthData = null;
let mouthRAF = null;

function syncMouthWithAudio(audioEl) {
  const mouth = document.getElementById("botMouth");
  if (!mouth || !audioEl) return;

  if (!mouthCtx) {
    mouthCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  // ‚ö†Ô∏è Important: only ONE source per audio element
  if (!audioEl._mouthSource) {
    audioEl._mouthSource = mouthCtx.createMediaElementSource(audioEl);
    mouthAnalyser = mouthCtx.createAnalyser();
    mouthAnalyser.fftSize = 256;

    audioEl._mouthSource.connect(mouthAnalyser);
    mouthAnalyser.connect(mouthCtx.destination);

    mouthData = new Uint8Array(mouthAnalyser.frequencyBinCount);
  }

  function animate() {
    if (audioEl.paused || audioEl.ended) {
      mouth.classList.remove("talk");
      cancelAnimationFrame(mouthRAF);
      return;
    }

    mouthAnalyser.getByteFrequencyData(mouthData);

    let sum = 0;
    for (let i = 0; i < mouthData.length; i++) sum += mouthData[i];
    const avg = sum / mouthData.length;

    if (avg > 15) {
      mouth.classList.add("talk");
    } else {
      mouth.classList.remove("talk");
    }

    mouthRAF = requestAnimationFrame(animate);
  }

  animate();
}








function botReact(eventType) {
  const botKey = document.getElementById("engineSelect").value;
  const bot = BOT_PERSONALITIES[botKey];
  if (!bot) return;

  const bubble = document.getElementById("botBubble");
  if (!bubble) return;

  let lines = [];

  if (eventType === "check") {
  lines = [
    "üò≥ Check!", "ü´£ Uh oh!", "‚ö†Ô∏è OMG!", "üò¨ That's check!",
    "üò≥ Check!", "ü´£ Uh oh!", "‚ö†Ô∏è OMG!", "üò¨ That's check!",
    "üòÆ Whoa!", "üö® Danger!", "üò± Yikes!", "üëÄ Bro!",
    "üòØ Oh no!", "‚ö° Zap! Check!", "üõë Hold on!",
    "üòµ In trouble!", "üî• Pressure!", "üôÄ Watch out!",
    "üòÖ Close call!", "‚ö†Ô∏è Alert!", "üò≤ Ghosss!",
    "üß† Think fast!", "üò¨ Not good!", "üöß Red alert!",
    "üò≥ Check again!", "‚ö†Ô∏è Careful now!", "üò¨ That hurts!",
    "üòÆ Uh-oh!", "üö® King alert!", "üòµ Pressure!",
    "üëÄ Eyes open!", "üò± Yikes!", "üõë Stop!",
    "üî• Danger zone!", "üòì Not good!", "üò≤ Sneaky!",
    "‚ö° Fast check!", "üôÄ Scary!", "üòÖ Close one!",
    "üöß Watch it!", "üò¨ Risky!", "üß† Think!",
    "üòÆ Surprise check!", "‚ö†Ô∏è Trouble!", "üòµ‚Äçüí´ Dizzy!",
    "üö® Red flag!", "üòê Again?", "üò§ Annoying!",
    "üëë King in danger!", "üò≥ Didn‚Äôt see that!",
    "‚ö° Sharp!", "üôà Oops!", "üò¨ Careful king!",
    "üö® Emergency!"
  ];

  // üîä ADD THIS LINE
  playBotCheckSounds()
}

  if (eventType === "capture") {
  lines = [
    "üí• Oof!", "üòµ Taken!", "üò§ Hey!", "‚ö° Bruh!",
    "üí• Oof!", "üòµ Taken!", "üò§ Hey!", "‚ö° Bruh!",
    "üò¨ Whoops!", "üòÆ Gone!", "üí£ Boom!", "üôÉ Lost it!",
    "üò± Nooo!", "ü´† Slipped!", "üòì Uh-oh!", "üî• Smash!",
    "ü§ï Ouch!", "ü´¢ Yoink!", "üòÖ My piece!", "üö´ Blocked!",
    "üéØ Got me!", "üòê Really?", "üíî Pain!", "üòÆ‚Äçüí® Sigh!",
    "üí• Boom!", "üòµ Gone!", "üò§ Not fair!", "‚ö° Snatched!",
    "üò¨ Oops!", "üôÉ Lost one!", "üò± Oh no!", "ü´¢ Taken!",
    "ü§ï That hurt!", "üî• Crushed!", "üòì Slipped away!",
    "üéØ Nice hit!", "üòÆ Vanished!", "ü´† Misstep!",
    "üòÖ My bad!", "üö´ Blocked!", "üí£ Kaboom!",
    "üòê Seriously?", "üò§ Hey now!",
    "üß† Should‚Äôve seen that!", "üò¨ Big mistake!",
    "üôÄ Gone wrong!", "üòÆ‚Äçüí® Painful!",
    "üíî Lost it!", "ü§¶ Oopsie!", "üòµ That‚Äôs rough!",
    "‚ö° Quick grab!", "üò≥ Didn‚Äôt expect that!",
    "üé≠ Tricked!"
  ];

  // üîä ADD THIS LINE
  playBotCaptureSounds();
}

  bubble.textContent = lines[Math.floor(Math.random() * lines.length)];
  bubble.classList.remove("hidden");

  if (botBubbleTimer) clearTimeout(botBubbleTimer);
  botBubbleTimer = setTimeout(() => {
    bubble.classList.add("hidden");
  }, 3000);
}

function playBotCheckSounds() {
  setTimeout(() => {
    try {
      if (!window.botCheckAudio) {
        window.botCheckAudio = null;
      }

      if (window.botCheckAudio) {
        window.botCheckAudio.pause();
        window.botCheckAudio.currentTime = 0;
      }

      const index = Math.floor(Math.random() * 17) + 1;
      const audio = new Audio(
        `bot_reaction_sound/check${index}.mp3`
      );

      audio.volume = 0.5;
      window.botCheckAudio = audio;

      audio.play().catch(() => {});
    } catch (err) {
      console.warn("Check sound error (ignored):", err);
    }
  }, 350);
}


function playBotCaptureSounds() {
  // üî• Defer sound completely out of move stack
  setTimeout(() => {
    try {
      if (!window.botCaptureAudio) {
        window.botCaptureAudio = null;
      }

      if (window.botCaptureAudio) {
        window.botCaptureAudio.pause();
        window.botCaptureAudio.currentTime = 0;
      }

      const index = Math.floor(Math.random() * 14) + 1;
      const audio = new Audio(
        `bot_reaction_sound/capture${index}.mp3`
      );

      audio.volume = 0.5;
      window.botCaptureAudio = audio;

      audio.play().catch(() => {});
    } catch (err) {
      console.warn("Capture sound error (ignored):", err);
    }
  }, 350);
}


const loserSounds = [
  "sounds/loser1.mp3",
  "sounds/loser2.mp3",
  "sounds/loser3.mp3",
  "sounds/loser4.mp3",
  "sounds/loser5.mp3"
];

function playRandomLoserSound() {
  const src = loserSounds[Math.floor(Math.random() * loserSounds.length)];
  const audio = new Audio(src);
  audio.volume = 0.9;
  audio.play().catch(() => {});
}





// =============================
// ü§ñ BOT UI HOOK (SAFE ZONE)
// =============================

const botImage = document.getElementById("botImage");
const botName = document.getElementById("botName");

document.getElementById("engineSelect").addEventListener("change", (e) => {
  const key = e.target.value;

  const bot = BOT_PERSONALITIES[key];
  if (!bot) return;

  botImage.src = bot.image;
  botName.textContent = bot.name;

  botSpeak(key);
});






// ===============================
// ‚è± VS COMPUTER CLOCK HELPERS
// ===============================
function startWhiteClock() {
  clearInterval(clockInterval);
  clockInterval = setInterval(() => {
    if (!vsGameActive) return;
    if (whiteTime > 0) {
      whiteTime--;
      updateClockUI();
    }
  }, 1000);
}

function startBlackClock() {
  clearInterval(clockInterval);
  clockInterval = setInterval(() => {
    if (!vsGameActive) return;
    if (blackTime > 0) {
      blackTime--;
      updateClockUI();
    }
  }, 1000);
}

document.getElementById("takeBackBtn").addEventListener("click", () => {
  if (!vsGameActive) return;

  // üõë stop engine & clock
  clearInterval(clockInterval);
  engineThinking = false;

  // üîô undo engine move (if exists)
  const lastMove = vsChess.history().length;
  if (lastMove >= 1) vsChess.undo(); // engine move
  if (lastMove >= 2) vsChess.undo(); // player move

  // ‚ôü sync board
  vsBoard.position(vsChess.fen());

  // ‚ñ∂Ô∏è restart correct clock
  if (vsPlayerColor === "white") {
    startWhiteClock();
  } else {
    startBlackClock();
  }
});


document.addEventListener("click", () => {
  if (!window._audioUnlocked) {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    ctx.resume();
    window._audioUnlocked = true;
    console.log("üîì Audio unlocked");
  }
});



// ===============================
// ü§ñ VS COMPUTER ENGINE
// ===============================
let vsEngine = null;
let vsEngineConfig = null;
// ‚è± BOT MOVE DELAY (3 seconds)
const BOT_MOVE_DELAY = 2000;
let gameOver = false;







function getVsEngineConfig() {
  const level = document.getElementById("engineLevel").value;

  const map = {
  "600":  { skill: 3,  depth: 6,  time: 120 },  // üçº Tiny Tot
  "900":  { skill: 6,  depth: 8,  time: 200 },  // üå± Beginner
  "1200": { skill: 10, depth: 11, time: 350 },  // ‚öî Rookie
  "1500": { skill: 14, depth: 14, time: 600 },  // üß† Champion
  "2000": { skill: 20, depth: 18, time: 1200 }  // üëë Master
};


  return map[level];
}





function showVsResult(text, type) {
  const el = document.getElementById("vsGameResult");
  if (!el) return;

  el.textContent = text;
  el.classList.remove("hidden"); // üî• THIS WAS MISSING
  el.className = `vs-result ${type}`;
}

function endGameWhiteWins(reason = "resign") {
  gameOver = true;

  // Stop further moves
  if (computerBoard) {
    computerBoard.draggable = false;
  }

  // Show result banner
  const resultBox = document.createElement("div");
  resultBox.className = "vs-result white";
  resultBox.textContent = "üèÜ You played well!";
  document.querySelector("#computer-section").prepend(resultBox);

  // üîä play random loser sound
  playRandomLoserSound();

  console.log("GAME OVER:", reason);
}


function clearVsResult() {
  const el = document.getElementById("vsGameResult");
  if (!el) return;

  el.textContent = "";
  el.classList.add("hidden");
}

function checkVsGameEnd() {
  if (!vsChess.game_over()) return;

  vsGameActive = false;
  clearInterval(clockInterval);

  if (vsChess.in_checkmate()) {
    const winner =
      vsChess.turn() === "w" ? "Black wins!" : "White wins!";

    showVsResult(
      winner,
      winner.startsWith("White") ? "white" : "black"
    );
  } else {
    showVsResult("Draw!", "draw");
  }
}

document.getElementById("resignBtn")?.addEventListener("click", () => {
  if (gameOver) return;

  

  endGameWhiteWins("resign");
});


document.getElementById("studentDetailsModal").addEventListener("click", (e) => {
  if (e.target.id === "studentDetailsModal") {
    closeStudentModal();
  }
});

document.getElementById("rush3").onclick = () => startPuzzleRush("3");
document.getElementById("rush5").onclick = () => startPuzzleRush("5");
document.getElementById("survival").onclick = () => startPuzzleRush("survival");

document.getElementById("exitPuzzleRush").onclick = () => {
  document.getElementById("puzzleRushGame").classList.add("hidden");
  document.getElementById("puzzleRushMenu").classList.remove("hidden");

  puzzleRushMode = null;
};

let puzzleRushMode = null;

async function startPuzzleRush(mode) {
  // üîä Puzzle Rush start sound
puzzleRushStartSound.currentTime = 0;
puzzleRushStartSound.play().catch(() => {});

  puzzleRushMode = mode;

  document.getElementById("puzzleRushMenu").classList.add("hidden");
  document.getElementById("puzzleRushGame").classList.remove("hidden");

  // üîí RESET STATE
  puzzleQueue = [];
  puzzleIndex = 0;
  puzzleSolved = false;

  // ‚è± SET TIME & LIVES
  if (mode === "3") {
    prTimeLeft = 180;
    prLivesLeft = 3;
  } else if (mode === "5") {
    prTimeLeft = 300;
    prLivesLeft = 3;
  } else {
    prTimeLeft = null; // survival
    prLivesLeft = 1;
  }

  updatePuzzleRushUI();

  // ===============================
  // ‚ö° LOAD MATE IN 1 PUZZLES ONLY
  // ===============================
  const puzzles = await loadMateIn1Puzzles();

  puzzleQueue = puzzles.map(p => ({
    fen: p.fen,
    solution: p.solution.replace(/[+#?!]/g, ""), // normalize
    side: p.side_to_move
  }));

  console.log("üß© Puzzle Rush loaded puzzles:", puzzleQueue.length);

  if (!puzzleQueue.length) {
    alert("No Mate in 1 puzzles found.");
    return;
  }

  // üîÄ RANDOMIZE ONCE
  puzzleQueue.sort(() => Math.random() - 0.5);

  // ‚ôü INIT BOARD + LOAD FIRST PUZZLE
  setTimeout(() => {
    initPuzzleRushBoard();
    loadTestPuzzle();
  }, 0);

  // ‚ñ∂Ô∏è START TIMER
  if (prTimerInterval) clearInterval(prTimerInterval);

  if (prTimeLeft !== null) {
    prTimerInterval = setInterval(() => {
      prTimeLeft--;
      updatePuzzleRushUI();

      if (prTimeLeft <= 0) {
        clearInterval(prTimerInterval);
        alert("‚è∞ Time's up!");
      }
    }, 1000);
  }
}






// ===============================
// ‚ö° PUZZLE RUSH BOARD
// ===============================
let prChess = null;
let prBoard = null;
let prTimerInterval = null;
let prTimeLeft = null;
let prLivesLeft = null;
let prScore = 0;
let currentPuzzle = null;
let puzzleSideToMove = "w"; // default
let puzzleSolved = false;



function initPuzzleRushBoard() {
  if (prBoard) return;

  prChess = new Chess();

  prBoard = Chessboard("puzzleRushBoard", {
    position: "start",
    draggable: true,
    pieceTheme:
      "https://lichess1.org/assets/piece/merida/{piece}.svg",

    // üîí LOCK FREE PLAY
    onDragStart: (source, piece) => {
      if (!currentPuzzle) return false;
      if (puzzleSolved) return false;

      // allow only puzzle side to move
      if (
        (puzzleSideToMove === "w" && piece.startsWith("b")) ||
        (puzzleSideToMove === "b" && piece.startsWith("w"))
      ) {
        return false;
      }

      return true;
    },

    onDrop: (source, target) => {
  if (!currentPuzzle || puzzleSolved) return "snapback";

  const move = prChess.move({
    from: source,
    to: target,
    promotion: "q"
  });

  if (!move) return "snapback";

  // üîä every move = check sound (mate attempt)
  playPRSound("prCheckSound", 0.5);

  const played = move.san.replace(/[+#?!]/g, "");
  const expected = currentPuzzle.solution.replace(/[+#?!]/g, "");

  // ‚úÖ CORRECT (CHECKMATE)
  if (played === expected) {
    puzzleSolved = true;
    prScore++;

    // üîä correct puzzle solved
    playPRSound("prNextSound", 0.9);

    updatePuzzleRushUI();
    setTimeout(loadTestPuzzle, 500);
    return;
  }

  // ‚ùå WRONG MOVE
  prChess.undo();
  prBoard.position(prChess.fen());

  prLivesLeft--;

  // üîä wrong move
  playPRSound("prWrongSound", 0.8);

  updatePuzzleRushUI();

  if (prLivesLeft <= 0) {
    endPuzzleRush("üíÄ No lives left!");
  }

  return "snapback";
}


  });
}

let puzzleRushStartSound = new Audio("sounds/puzzle-rush-start.mp3");
puzzleRushStartSound.volume = 0.9;



// ===============================
// ‚ö° PUZZLE RUSH ‚Äì TEMP QUEUE
// ===============================
let puzzleQueue = [];
let puzzleIndex = 0;

function loadTestPuzzle() {
  if (!puzzleQueue.length) return;

  if (puzzleIndex >= puzzleQueue.length) {
    puzzleIndex = 0;
  }

  currentPuzzle = puzzleQueue[puzzleIndex++];
  puzzleSolved = false;

  prChess.reset();
  prChess.load(currentPuzzle.fen);

  puzzleSideToMove = prChess.turn(); // 'w' or 'b'

  // üî• FIX: SET BOARD ORIENTATION CORRECTLY
  prBoard.orientation(puzzleSideToMove === "w" ? "white" : "black");

  prBoard.position(currentPuzzle.fen);

  console.log("üß© Puzzle loaded:", currentPuzzle);
}






// ===============================
// ‚ö° PGN ‚Üí PUZZLE CONVERTER (STEP 1)
// ===============================




// ===============================
// üìö PUZZLE RUSH ‚Äì LOAD BULK PGNs
// ===============================
async function loadBulkPGNsForPuzzleRush() {
  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("id, pgn, title")
    .eq("is_active", true);

  if (error) {
    console.error("‚ùå Failed to load bulk PGNs", error);
    return [];
  }

  // üîç ADD THIS
  console.log("üì¶ RAW PGN ROWS FROM DB:", data);

  return data;
}


// ===============================
// ‚ôüÔ∏è PUZZLE RUSH ‚Äì PGN ‚Üí PUZZLES
// ===============================
// ===============================
// ‚ôüÔ∏è PUZZLE RUSH ‚Äì PGN ‚Üí PUZZLES
// (compatible with chess.js 0.13.x)
// ===============================
// ===============================
// ‚ôüÔ∏è PUZZLE RUSH ‚Äì SAFE PGN PARSER
// supports FULL + MOVE-ONLY PGNs
// ===============================
function buildPuzzleFromFullPGN(pgn) {
  if (!pgn || typeof pgn !== "string") return null;

  const clean = pgn
    .replace(/\{[^}]*\}/g, "")
    .replace(/\[[^\]]*\]/g, "")
    .replace(/\d+\.(\.\.)?/g, "")
    .replace(/\r?\n/g, " ")
    .trim();

  const tokens = clean.split(/\s+/).filter(Boolean);
  if (tokens.length < 2) return null;

  const game = new Chess();
  let lastMove = null;

  for (const san of tokens) {
  // ‚õî skip game results
  if (
    san === "1-0" ||
    san === "0-1" ||
    san === "1/2-1/2" ||
    san === "*"
  ) {
    continue;
  }

  const move = game.move(san, { sloppy: true });

if (!move) {
  console.warn("‚ùå Invalid SAN skipped:", san);
  continue; // ‚úÖ just ignore and move on
}

lastMove = move;

}


  if (!lastMove) {
  console.warn("‚ö†Ô∏è No valid moves found in PGN");
  return null;
}


  game.undo(); // üëà go back ONE move

  console.log("‚úÖ PUZZLE CREATED", {
  fen: game.fen(),
  solution: lastMove.san
});


  return {
    fen: game.fen(),
    solution: lastMove.san.replace(/[?!+#]/g, "")
  };
}









// ===============================
// ü§ñ PUZZLE RUSH ‚Äì AUTO REPLY MOVE
// ===============================
function playAutoMoveIfNeeded() {
  if (!currentPuzzle || !currentPuzzle.solution) return;
  if (currentPuzzle.index >= currentPuzzle.solution.length) return;


  const san = currentPuzzle.solution[currentPuzzle.index];
  const move = prChess.move(san, { sloppy: true });

  if (!move) return;

  currentPuzzle.index++;
  prBoard.position(prChess.fen());

  // üî• THIS IS THE FIX
  puzzleSideToMove = prChess.turn();
}










    // üî¥ PROMOTION STATE (ADD THIS)
    let pendingPromotion = null;

    // Timer
    let timerInterval = null;
    let startTime = null;
    let elapsedTime = 0;

    // State
    let moveHistory = [];
    let pgnCursor = 0;
    let fullPGNHistory = []; // Store the complete game history for navigation
    let isNavigationMode = false;
    let isPGNLoaded = false;

    // Drawing system variables
    let drawings = new Map(); // Store drawings per FEN
    let isDrawing = false;
    let drawStartSquare = null;
    let currentDrawings = [];
    let isRightMouseDown = false;
    let mousePosition = { x: 0, y: 0 };
    let svgOverlay = null;

    // Assignment system variables
    let expectedMoves = [];
    let assignmentCursor = 0;
    let assignmentColor = "w";
    let attemptCount = 0;
    let bulkPuzzles = [];
    let bulkIndex = 0;
    let pendingDeleteAssignmentId = null;

    let soundUnlocked = false;
    // ================================
// STUDENT BADGE PROGRESS (STEP 4A)
// ================================
let studentSolvedCount = 0;
// ================================
// STUDENT BADGES ‚Äî UNLOCK STATE
// STEP 4D
// ================================
let BADGE_STORAGE_KEY = null;

let unlockedBadges = new Set();



    // ================================
// STUDENT BADGES ‚Äî DEFINITIONS
// ================================
const STUDENT_BADGES = [
  {
    id: "fast_furious",
    icon: "‚ö°",
    title: "Fast & Furious",
    tagline: "3 assignments completed",
    tier: "bronze",
    required: 3
  },
  {
    id: "sharp_shooter",
    icon: "üéØ",
    title: "Sharp Shooter",
    tagline: "Solve with precision",
    tier: "bronze",
    required: 6
  },
  {
    id: "consistency",
    icon: "üî•",
    title: "Consistency",
    tagline: "9 puzzles solved",
    tier: "silver",
    required: 9
  },
  {
    id: "tactician",
    icon: "‚öîÔ∏è",
    title: "Tactician",
    tagline: "Think before you strike",
    tier: "silver",
    required: 12
  },
  {
    id: "deep_thinker",
    icon: "üß†",
    title: "Deep Thinker",
    tagline: "Solved without rushing",
    tier: "silver",
    required: 15
  },
  {
    id: "speed_runner",
    icon: "‚è±Ô∏è",
    title: "Speed Runner",
    tagline: "Solved under time pressure",
    tier: "gold",
    required: 18
  },
  {
  id: "clear_head",
  icon: "üß†",
  title: "Clear Head",
  tagline: "Chose clarity over chaos",
  tier: "silver",
  required: 21
},
{
  id: "bulls_eye",
  icon: "ü¶Ö",
  title: "Bulls Eye",
  tagline: "Spotted the tactic",
  tier: "gold",
  required: 24
},
{
  id: "momentum",
  icon: "üöÄ",
  title: "Momentum",
  tagline: "Multiple solves in a row",
  tier: "gold",
  required: 27
},
{
  id: "olympian",
  icon: "üëë",
  title: "Olympian",
  tagline: "50 assignments completed",
  tier: "platinum",
  required: 30
},
{
  id: "ball_head",
  icon: "üß†",
  title: "ball Head",
  tagline: "Chose clarity over fight",
  tier: "silver",
  required: 33
},
{
  id: "eagle_eye",
  icon: "ü¶Ö",
  title: "Eagle Eye",
  tagline: "Spotted the key tactic",
  tier: "silver",
  required: 36
},
{
  id: "mega",
  icon: "üöÄ",
  title: "Mega",
  tagline: "Multiple solves in a row",
  tier: "gold",
  required: 39
},
{
  id: "iron_wall",
  icon: "üß±",
  title: "Iron Wall",
  tagline: "Nothing got through",
  tier: "gold",
  required: 42
},
{
  id: "calculation_mode",
  icon: "üßÆ",
  title: "Calculation Mode",
  tagline: "Saw it till the end",
  tier: "gold",
  required: 45
},
{
  id: "breakthrough",
  icon: "üåÑ",
  title: "Breakthrough",
  tagline: "Found the winning idea",
  tier: "platinum",
  required: 48
},
{
  id: "champion_spirit",
  icon: "üèÜ",
  title: "Champion Spirit",
  tagline: "Never gave up",
  tier: "platinum",
  required: 51
},
{
  id: "focused_mind",
  icon: "üß†",
  title: "Focused Mind",
  tagline: "Stayed sharp till the end",
  tier: "platinum",
  required: 54
},
{
  id: "recovery",
  icon: "üîÑ",
  title: "Recovery",
  tagline: "Bounced back after a mistake",
  tier: "platinum",
  required: 57
},
{
  id: "break_the_wall",
  icon: "üß®",
  title: "Break the Wall",
  tagline: "Found the breakthrough move",
  tier: "platinum",
  required: 60
},
{
  id: "light_touch",
  icon: "ü™∂",
  title: "Light Touch",
  tagline: "Handled the position smoothly",
  tier: "diamond",
  required: 63
},
{
  id: "mental_fortress",
  icon: "üß†",
  title: "Mental Fortress",
  tagline: "Held strong under pressure",
  tier: "diamond",
  required: 66
},
{
  id: "perfect_harmony",
  icon: "üéº",
  title: "Perfect Harmony",
  tagline: "All pieces worked together",
  tier: "diamond",
  required: 69
},
{
  id: "decisive_cut",
  icon: "ü™ì",
  title: "Decisive Cut",
  tagline: "Ended the position cleanly",
  tier: "diamond",
  required: 72
},
{
  id: "turning_point",
  icon: "üåó",
  title: "Turning Point",
  tagline: "Changed the course of the game",
  tier: "diamond",
  required: 75
},
{
  id: "pattern_spotter",
  icon: "üß©",
  title: "Pattern Spotter",
  tagline: "Recognized the familiar idea",
  tier: "diamond",
  required: 78
},
{
  id: "clinical_finish",
  icon: "üéØ",
  title: "Clinical Finish",
  tagline: "Converted advantage precisely",
  tier: "diamond",
  required: 81
},
{
  id: "positional_dna",
  icon: "üß¨",
  title: "Positional DNA",
  tagline: "Understood the position deeply",
  tier: "diamond",
  required: 84
},
{
  id: "roadblock",
  icon: "üöß",
  title: "Roadblock",
  tagline: "Stopped the opponents plan",
  tier: "diamond",
  required: 87
},
{
  id: "mental_clarity",
  icon: "üß†",
  title: "Mental Clarity",
  tagline: "Found order in complexity",
  tier: "diamond",
  required: 90
},
{
  id: "steady_hand",
  icon: "‚öì",
  title: "Steady Hand",
  tagline: "Never lost control",
  tier: "diamond",
  required: 93
},
{
  id: "clutch_climber",
  icon: "üßó",
  title: "Clutch Climber",
  tagline: "Solved when it mattered most",
  tier: "diamond",
  required: 96
},
{
  id: "discipline",
  icon: "üéñÔ∏è",
  title: "Discipline",
  tagline: "Played by principles",
  tier: "diamond",
  required: 99
},
{
  id: "sense_of_direction",
  icon: "üß≠",
  title: "Sense of Direction",
  tagline: "Always knew where to go",
  tier: "diamond",
  required: 102
},
{
  id: "battle_ready",
  icon: "ü™ñ",
  title: "Battle Ready",
  tagline: "Handled tough positions confidently",
  tier: "diamond",
  required: 105
},
{
  id: "cold_calclation",
  icon: "üß†",
  title: "Cold Calclation",
  tagline: "Calculated without emotion",
  tier: "diamond",
  required: 108
},
{
  id: "finish_line",
  icon: "üèÅ",
  title: "Finish Line",
  tagline: "Completed the task cleanly",
  tier: "diamond",
  required: 111
},
{
  id: "strategic_calm",
  icon: "üß†",
  title: "Strategic Calm",
  tagline: "Kept control in complex play",
  tier: "diamond",
  required: 114
},
{
  id: "key_breaker",
  icon: "üóùÔ∏è",
  title: "Key Breaker",
  tagline: "Unlocked the position",
  tier: "diamond",
  required: 117
},
{
  id: "shield_wall",
  icon: "üõ°Ô∏è",
  title: "Shield Wall",
  tagline: "Defended with precision",
  tier: "diamond",
  required: 120
},
{
  id: "moment_of_brilliance",
  icon: "üå†",
  title: "Moment of Brilliance",
  tagline: "Found the standout move",
  tier: "diamond",
  required: 123
},
{
  id: "composed_thinker",
  icon: "üß†",
  title: "Composed Thinker",
  tagline: "Stayed calm and accurate",
  tier: "diamond",
  required: 126
},
{
  id: "rock_solid",
  icon: "ü™®",
  title: "Rock Solid",
  tagline: "No weaknesses left behind",
  tier: "diamond",
  required: 129
},
{
  id: "calculatio_engine",
  icon: "üßÆ",
  title: "Calculatio Engine",
  tagline: "Counted every variation",
  tier: "diamond",
  required: 132
},
{
  id: "standout_performance",
  icon: "üåü",
  title: "Standout Performance",
  tagline: "Solved with confidence",
  tier: "diamond",
  required: 135
},
{
  id: "balanced_mind",
  icon: "üß†",
  title: "Balanced Mind",
  tagline: "Attack and defense in harmony",
  tier: "diamond",
  required: 138
},
{
  id: "creative_spark",
  icon: "ü™Ñ",
  title: "Creative Spark",
  tagline: "Found an unexpected idea",
  tier: "diamond",
  required: 141
},
{
  id: "pin_master",
  icon: "üß∑",
  title: "Pin Master",
  tagline: "Used restriction to win",
  tier: "diamond",
  required: 144
},
{
  id: "flow_state",
  icon: "üåä",
  title: "Flow State",
  tagline: "Everything felt natural",
  tier: "diamond",
  required: 147
},
{
  id: "silent_killer",
  icon: "üß†",
  title: "Silent Killer",
  tagline: "Won without unnecessary risk",
  tier: "diamond",
  required: 150
},
{
  id: "trap_setter",
  icon: "ü™§",
  title: "Trap Setter",
  tagline: "Lured the opponent in",
  tier: "diamond",
  required: 153
},
{
  id: "firefighter",
  icon: "üßØ",
  title: "Firefighter",
  tagline: "Extinguished the threat",
  tier: "diamond",
  required: 156
},
{
  id: "clarity_moment",
  icon: "üåü",
  title: "Clarity Moment",
  tagline: "Everything made sense",
  tier: "diamond",
  required: 159
},
{
  id: "master_focus",
  icon: "üß†",
  title: "Master Focus",
  tagline: "Locked in from start to finish",
  tier: "diamond",
  required: 162
},
{
  id: "hook_and_win",
  icon: "ü™ù",
  title: "Hook & Win",
  tagline: "Forced the opponent‚Äôs hand",
  tier: "diamond",
  required: 165
},
{
  id: "iron_wall_elite",
  icon: "üß±",
  title: "Iron Wall Elite",
  tagline: "Nothing broke through",
  tier: "diamond",
  required: 168
},
{
  id: "peak_moment",
  icon: "üåü",
  title: "Peak Moment",
  tagline: "Played at your absolute best",
  tier: "diamond",
  required: 171
},
{
  id: "balanced_pressure",
  icon: "‚öñÔ∏è",
  title: "Balanced Under Pressure",
  tagline: "Stayed accurate in tense moments",
  tier: "diamond",
  required: 174
},
{
  id: "endgame_grip",
  icon: "‚ôú",
  title: "Endgame Grip",
  tagline: "Converted with technique",
  tier: "diamond",
  required: 177
},
{
  id: "tactical_instinct",
  icon: "‚ö°",
  title: "Tactical Instinct",
  tagline: "Spotted danger instantly",
  tier: "diamond",
  required: 180
},
{
  id: "positional_anchor",
  icon: "‚öì",
  title: "Positional Anchor",
  tagline: "Held the structure firm",
  tier: "diamond",
  required: 183
},
{
  id: "critical_decision",
  icon: "üß†",
  title: "Critical Decision",
  tagline: "Chose the right moment",
  tier: "diamond",
  required: 186
},
{
  id: "counterplay_master",
  icon: "üîÑ",
  title: "Counterplay Master",
  tagline: "Turned defense into attack",
  tier: "diamond",
  required: 189
},
{
  id: "unstoppable",
  icon: "üöÄ",
  title: "Unstoppable",
  tagline: "Momentum could not be broken",
  tier: "diamond",
  required: 192
},
{
  id: "elite_composure",
  icon: "üßä",
  title: "Elite Composure",
  tagline: "Ice-cold accuracy throughout",
  tier: "diamond",
  required: 195
},
{
  id: "precision_path",
  icon: "üìê",
  title: "Precision Path",
  tagline: "Every move had a purpose",
  tier: "diamond",
  required: 198
},
{
  id: "initiative_holder",
  icon: "üéØ",
  title: "Initiative Holder",
  tagline: "Kept control of the pace",
  tier: "diamond",
  required: 201
},
{
  id: "calm_converter",
  icon: "üß†",
  title: "Calm Converter",
  tagline: "Turned advantage into a win",
  tier: "diamond",
  required: 204
},
{
  id: "resource_finder",
  icon: "üîç",
  title: "Resource Finder",
  tagline: "Found the hidden saving idea",
  tier: "diamond",
  required: 207
},
{
  id: "structural_mastery",
  icon: "üß±",
  title: "Structural Mastery",
  tagline: "Pawn structure under control",
  tier: "diamond",
  required: 210
},
{
  id: "timing_expert",
  icon: "‚è±Ô∏è",
  title: "Timing Expert",
  tagline: "Struck at the perfect moment",
  tier: "diamond",
  required: 213
},
{
  id: "positional_squeeze",
  icon: "üß≤",
  title: "Positional Squeeze",
  tagline: "Slow pressure paid off",
  tier: "diamond",
  required: 216
},
{
  id: "grand_composure",
  icon: "üëë",
  title: "Grand Composure",
  tagline: "Elite calm, elite control",
  tier: "diamond",
  required: 219
},
{
  id: "ultimate_precision",
  icon: "üéØ",
  title: "Ultimate Precision",
  tagline: "Accuracy reached another level",
  tier: "diamond",
  required: 222
},
{
  id: "calculatio_master",
  icon: "üßÆ",
  title: "Calculatio Master",
  tagline: "Nothing left uncalculated",
  tier: "diamond",
  required: 225
},
{
  id: "positional_dominator",
  icon: "üß±",
  title: "Positional Dominator",
  tagline: "Controlled every square",
  tier: "diamond",
  required: 228
},
{
  id: "tactical_supremacy",
  icon: "‚öîÔ∏è",
  title: "Tactical Supremacy",
  tagline: "Tactics decided everything",
  tier: "diamond",
  required: 231
},
{
  id: "grandmaster_mindset",
  icon: "üß†",
  title: "Grandmaster Mindset",
  tagline: "Thinking like an elite player",
  tier: "diamond",
  required: 234
},
{
  id: "unstoppable_force",
  icon: "üöÄ",
  title: "Unstoppable Force",
  tagline: "Nothing could slow you down",
  tier: "diamond",
  required: 237
},
{
  id: "olympus_legend",
  icon: "üèîÔ∏è",
  title: "Olympus Legend",
  tagline: "A true master of Olympus",
  tier: "diamond",
  required: 240
},
{
  id: "mythic_control",
  icon: "üî±",
  title: "Mythic Control",
  tagline: "Ruled the board like a god",
  tier: "mythic",
  required: 243
},
{
  id: "absolute_calculatio",
  icon: "üì°",
  title: "Absolute Calculatio",
  tagline: "Saw beyond all variations",
  tier: "mythic",
  required: 246
},
{
  id: "immovable_empire",
  icon: "üèõÔ∏è",
  title: "Immovable Empire",
  tagline: "Position stood unbreakable",
  tier: "mythic",
  required: 249
},
{
  id: "divine_precision",
  icon: "‚ú®",
  title: "Divine Precision",
  tagline: "Every move felt inevitable",
  tier: "mythic",
  required: 252
},
{
  id: "olympus_ascended",
  icon: "‚ö°",
  title: "Olympus Ascended",
  tagline: "You surpassed legend status",
  tier: "mythic",
  required: 255
},
{
  id: "eternal_focus",
  icon: "üïØÔ∏è",
  title: "Eternal Focus",
  tagline: "Concentration never wavered",
  tier: "mythic",
  required: 258
},
{
  id: "sovereign_pressure",
  icon: "üëë",
  title: "Sovereign Pressure",
  tagline: "Dominated without forcing",
  tier: "mythic",
  required: 261
},
{
  id: "unbreakable_will",
  icon: "üßø",
  title: "Unbreakable Will",
  tagline: "Held firm in impossible positions",
  tier: "mythic",
  required: 264
},
{
  id: "checkmate_instinct",
  icon: "‚ôüÔ∏è",
  title: "Checkmate Instinct",
  tagline: "You sensed the end before it came",
  tier: "mythic",
  required: 267
},
{
  id: "heir_of_olympus",
  icon: "üè∫",
  title: "Heir of Olympus",
  tagline: "Legacy worthy of the gods",
  tier: "mythic",
  required: 270
},
{
  id: "timeless_patience",
  icon: "‚è≥",
  title: "Timeless Patience",
  tagline: "Waited for the perfect moment",
  tier: "mythic",
  required: 273
},
{
  id: "absolute_dominion",
  icon: "üåç",
  title: "Absolute Dominion",
  tagline: "Every square answered to you",
  tier: "mythic",
  required: 276
},
{
  id: "flawless_judgment",
  icon: "‚öñÔ∏è",
  title: "Flawless Judgment",
  tagline: "Never chose the wrong path",
  tier: "mythic",
  required: 279
},
{
  id: "endless_clarity",
  icon: "üí†",
  title: "Endless Clarity",
  tagline: "Complexity became simple",
  tier: "mythic",
  required: 282
},
{
  id: "chosen_of_olympus",
  icon: "üî•",
  title: "Chosen of Olympus",
  tagline: "The gods took notice",
  tier: "mythic",
  required: 285
},
{
  id: "eternal_mastery",
  icon: "‚ôæÔ∏è",
  title: "Eternal Mastery",
  tagline: "Skill that transcends time",
  tier: "mythic",
  required: 288
},
{
  id: "divine_equilibrium",
  icon: "‚òØÔ∏è",
  title: "Divine Equilibrium",
  tagline: "Perfect balance of attack and defense",
  tier: "mythic",
  required: 291
},
{
  id: "omniscient_vision",
  icon: "üëÅÔ∏è",
  title: "Omniscient Vision",
  tagline: "Nothing on the board was hidden",
  tier: "mythic",
  required: 294
},
{
  id: "hand_of_fate",
  icon: "‚úã",
  title: "Hand of Fate",
  tagline: "Games bent to your will",
  tier: "mythic",
  required: 297
},
{
  id: "olympus_immortal",
  icon: "üèõÔ∏è",
  title: "Olympus Immortal",
  tagline: "Your name is carved forever",
  tier: "mythic",
  required: 300
},
{
  id: "beyond_olympus",
  icon: "üúè",
  title: "Beyond Olympus",
  tagline: "Even the gods were left behind",
  tier: "transcendent",
  required: 303
},
{
  id: "silent_ascent",
  icon: "üå´Ô∏è",
  title: "Silent Ascent",
  tagline: "No applause was needed",
  tier: "transcendent",
  required: 306
},
{
  id: "timeless_player",
  icon: "‚åõ",
  title: "Timeless Player",
  tagline: "Time stopped measuring progress",
  tier: "transcendent",
  required: 309
},
{
  id: "board_without_edges",
  icon: "üß≠",
  title: "Board Without Edges",
  tagline: "There were no limits left",
  tier: "transcendent",
  required: 312
},
{
  id: "inevitable_truth",
  icon: "üîÆ",
  title: "Inevitable Truth",
  tagline: "The correct move always appeared",
  tier: "transcendent",
  required: 315
},
{
  id: "calm_before_eternity",
  icon: "üåä",
  title: "Calm Before Eternity",
  tagline: "Nothing rushed, nothing forced",
  tier: "transcendent",
  required: 318
},
{
  id: "observer_of_outcomes",
  icon: "üëÅÔ∏è",
  title: "Observer of Outcomes",
  tagline: "Wins and losses lost meaning",
  tier: "transcendent",
  required: 321
},
{
  id: "the_unending_game",
  icon: "‚ôæÔ∏è",
  title: "The Unending Game",
  tagline: "There was never a finish line",
  tier: "transcendent",
  required: 324
},
{
  id: "motionless_control",
  icon: "ü™∂",
  title: "Motionless Control",
  tagline: "Everything moved without force",
  tier: "transcendent",
  required: 327
},
{
  id: "pattern_dissolved",
  icon: "üí†",
  title: "Pattern Dissolved",
  tagline: "Recognition gave way to intuition",
  tier: "transcendent",
  required: 330
},
{
  id: "ineffable_move",
  icon: "‚ú®",
  title: "Ineffable Move",
  tagline: "It could not be explained",
  tier: "transcendent",
  required: 333
},
{
  id: "beyond_calculatio",
  icon: "üìø",
  title: "Beyond Calculatio",
  tagline: "Numbers stopped helping",
  tier: "transcendent",
  required: 338
},
{
  id: "quiet_dominion",
  icon: "üèîÔ∏è",
  title: "Quiet Dominion",
  tagline: "Control without resistance",
  tier: "transcendent",
  required: 341
},
{
  id: "inevitable_victory",
  icon: "üïäÔ∏è",
  title: "Inevitable Victory",
  tagline: "The end was known long ago",
  tier: "transcendent",
  required: 344
},
{
  id: "clarity_without_thought",
  icon: "üí≠",
  title: "Clarity Without Thought",
  tagline: "Decisions arrived fully formed",
  tier: "transcendent",
  required: 347
},
{
  id: "board_as_language",
  icon: "üìú",
  title: "Board as Language",
  tagline: "Positions spoke for themselves",
  tier: "transcendent",
  required: 350
},
{
  id: "formless_mastery",
  icon: "ü´•",
  title: "Formless Mastery",
  tagline: "No style could define you",
  tier: "transcendent",
  required: 353
},
{
  id: "beyond_opposition",
  icon: "‚ö™",
  title: "Beyond Opposition",
  tagline: "There was no enemy left",
  tier: "transcendent",
  required: 356
},
{
  id: "echo_of_eternity",
  icon: "üîî",
  title: "Echo of Eternity",
  tagline: "Every game still resonates",
  tier: "transcendent",
  required: 359
},
{
  id: "the_final_silence",
  icon: "üåå",
  title: "The Final Silence",
  tagline: "Nothing remained to be proven",
  tier: "transcendent",
  required: 362
}
















  
];

function loadUnlockedBadges() {
  const saved = localStorage.getItem(BADGE_STORAGE_KEY);
  if (saved) {
    try {
      unlockedBadges = new Set(JSON.parse(saved));
    } catch {
      unlockedBadges = new Set();
    }
  }
}



function renderStudentBadges() {
  const container = document.getElementById("studentBadgeContent");
  if (!container) return;

  container.innerHTML = "";

  STUDENT_BADGES.forEach(badge => {
    const isUnlockable = studentSolvedCount >= badge.required;
    const isUnlocked = unlockedBadges.has(badge.id);

    const card = document.createElement("div");
    card.className = "badge-card";
    card.dataset.badgeId = badge.id;

    if (isUnlocked) card.classList.add("unlocked");
    else if (!isUnlockable) card.classList.add("locked");

    let actionHTML = "";

    if (isUnlocked) {
      actionHTML = `<div class="badge-unlocked-mark">üèÜ</div>`;
    } else if (isUnlockable) {
      actionHTML = `<button class="badge-unlock-btn">Unlock</button>`;
    } else {
      actionHTML = `<div class="badge-lock">üîí</div>`;
    }

    card.innerHTML = `
      <div class="badge-icon">${badge.icon}</div>
      <div class="badge-title">${badge.title}</div>
      <div class="badge-tagline">${badge.tagline}</div>
      ${actionHTML}
    `;

    container.appendChild(card);
  });

  attachBadgeUnlockHandlers();
}




// ================================
// STUDENT BADGES ‚Äî UNLOCK HANDLER
// STEP 4D
// ================================
function attachBadgeUnlockHandlers() {
  const buttons = document.querySelectorAll(".badge-unlock-btn");

  buttons.forEach(btn => {
    btn.addEventListener("click", e => {
      const card = e.target.closest(".badge-card");
      const badgeId = card?.dataset.badgeId;
      if (!badgeId) return;

      // üîì mark unlocked
      unlockedBadges.add(badgeId);

      // üíæ persist
      localStorage.setItem(
        BADGE_STORAGE_KEY,
        JSON.stringify([...unlockedBadges])
      );

      // üéâ celebration (glitter + sound)
      triggerCelebration();

      // üèÜ POP OUT ‚Üí POP BACK (2s)
      card.classList.add("badge-pop-animate");

      // üîÑ re-render AFTER animation
      setTimeout(() => {
        renderStudentBadges();
      }, 2000);
    });
  });
}






// ================================
// STUDENT BADGES ‚Äî UNLOCK CHECK
// STEP 4B (NO UI)
// ================================
function getUnlockableBadges() {
  if (!Array.isArray(STUDENT_BADGES)) return [];

  return STUDENT_BADGES.filter(
    badge => studentSolvedCount >= badge.required
  );
}


// ================================
// üéâ CELEBRATION SYSTEM
// ================================
function triggerCelebration() {
  const overlay = document.getElementById("celebrationOverlay");
  const sound = document.getElementById("celebrationSound");

  if (!overlay) return;

  overlay.innerHTML = "";
  overlay.classList.remove("hidden");

  // üîä Play sound (safe for browsers)
  if (sound) {
    sound.currentTime = 0;
    sound.volume = 0.6;
    sound.play().catch(() => {});
  }

  // ‚ú® Create glitter particles
  const COUNT = 300;

const COLORS = [
  "#ffd700",
  "#ff6ec7",
  "#38bdf8",
  "#a855f7",
  "#22c55e",
  "#f97316"
];

for (let i = 0; i < COUNT; i++) {
  const g = document.createElement("div");
  g.className = "glitter";

  const color = COLORS[Math.floor(Math.random() * COLORS.length)];

  g.style.left = Math.random() * 100 + "vw";
  g.style.animationDuration = 3 + Math.random() * 4 + "s";
  g.style.animationDelay = Math.random() * 0.6 + "s";
  g.style.transform = `scale(${0.4 + Math.random() * 1.2})`;

  g.style.background = `radial-gradient(circle, ${color}, white)`;

  overlay.appendChild(g);
}


  // üßπ Cleanup
  setTimeout(() => {
    overlay.classList.add("hidden");
    overlay.innerHTML = "";
  }, 6000);
}




    





    async function joinLiveClass() {
      console.log('‚ñ∂ Join Live Class clicked'); // üëà ADD THIS LINE
  if (!currentProfile) return;

  // get active live session
  const { data: session, error: sessionError } = await supabase
    .from('live_sessions')
    .select('id')
    .eq('status', 'active')
    .single();

  if (sessionError || !session) {
  showModal(
    "üö´ Live Class Unavailable",
    "<p>The live class is not available right now.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}







  // check already joined
  const { data: existing } = await supabase
    .from('live_participants')
    .select('id')
    .eq('session_id', session.id)
    .eq('student_id', currentProfile.id)
    .single();

  if (!existing) {
    await supabase.from('live_participants').insert({
      session_id: session.id,
      student_id: currentProfile.id
    });
  }

  document.getElementById('joinLiveBtn').textContent = '‚úÖ Joined Live Class';
  document.getElementById('joinLiveBtn').disabled = true;
  document.getElementById('joinLiveBtn').style.display = 'none';
document.getElementById('liveWaitingPanel').style.display = 'block';

}

document.getElementById("clearAddStudentBtn")?.addEventListener("click", () => {
  const userInput = document.getElementById("newStudentUser");
  const passInput = document.getElementById("newStudentPass");

  if (userInput) userInput.value = "";
  if (passInput) passInput.value = "";

  // optional: put cursor back on username
  userInput?.focus();
});


// ‚úÖ Load joined students for admin (live view)
async function loadLiveJoinedStudents(sessionId) {
  const list = document.getElementById('liveJoinedList');
  const box = document.getElementById('liveJoinedBox');

  if (!list || !box) return;

  const { data, error } = await supabase
    .from('live_participants')
    .select('student_id, profiles(username)')
    .eq('session_id', sessionId);

  if (error) {
    console.error('Failed to load joined students:', error);
    return;
  }

  list.innerHTML = '';

  if (!data || data.length === 0) {
    list.innerHTML = '<li>No students joined yet</li>';
  } else {
    data.forEach(row => {
      const li = document.createElement('li');
      li.textContent = row.profiles?.username || 'Student';
      list.appendChild(li);
    });
  }

  box.style.display = 'block';
}

// ==============================
// PGN FILE IMPORT (Assignments)
// ==============================
document.getElementById('importPgnBtn')?.addEventListener('click', () => {
  document.getElementById('pgnFileInput').click();
});

document.getElementById('pgnFileInput')?.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  if (!file.name.endsWith('.pgn')) {
  showModal(
    "‚ö†Ô∏è Invalid File",
    "<p>Please select a valid <strong>.pgn</strong> file.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


  const reader = new FileReader();
  reader.onload = () => {
    document.getElementById('assignPGN').value = reader.result.trim();
  };
  reader.readAsText(file);
});

// ================================
// PGN LIBRARY IMPORT (RIGHT PANEL)
// ================================

document.addEventListener("DOMContentLoaded", () => {
  const input = document.getElementById("pgnLibraryFileInput");
  if (!input) return;

  input.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();

    openPGNTitleModal(async (title) => {

  const { error } = await supabase
    .from("bulk_pgn_library")
    .insert({
      title,
      pgn: text,
      is_active: true
    });

  if (error) {
    console.error(error);
    alert("Failed to import PGN");
    return;
  }

  showModal(
  "üìö PGN Imported",
  "<p>PGN imported into the library successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

loadPGNLibrary();

});


    const { error } = await supabase
      .from("bulk_pgn_library")
      .insert({
        title,
        pgn: text,
        is_active: true
      });

    if (error) {
      console.error(error);
      alert("Failed to import PGN");
      return;
    }

    showModal(
  "üìö PGN Imported",
  "<p>PGN imported into the library successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

loadPGNLibrary();

  });
});

const analyzeBtn = document.getElementById("analyzeBtn");
if (analyzeBtn) {
  analyzeBtn.addEventListener("click", () => {
    if (!engineReady) {
      console.warn("‚è≥ Engine not ready");
      return;
    }

    if (isAssignmentMode && currentProfile.role === "student") {
  console.warn("‚õî Student engine blocked during assignment");
  return;
}


    // üîÅ TOGGLE MODE
    if (engineRunning) {
      stopEngine();
    } else {
      startEngine();
    }
  });
}


document.addEventListener("click", (e) => {
  const name = e.target.closest(".student-name");
  if (!name) return;

  const studentId = name.dataset.studentId;
  const username = name.textContent.trim();

  openStudentModal(studentId, username);
});






    // ============================================
    // INIT
    // ============================================
    async function initApp() {
      console.log('üöÄ Initializing application...');

      try {
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
          console.log('No user found, redirecting to login...');
          window.location.href = 'login.html';
          return;
        }
        currentUser = user;

       



        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', user.id)
          .single();

        if (profileError || !profile) {
  showModal(
    "‚ö†Ô∏è Account Issue",
    "<p>Your account is not properly set up.<br>Please contact the administrator.</p>"
  );

  await supabase.auth.signOut();

  setTimeout(() => {
    window.location.href = 'login.html';
  }, 2000);

  return;
}

        if (!profile.active) {
  showModal(
    "üö´ Account Deactivated",
    "<p>Your account has been deactivated.<br>Please contact the administrator.</p>"
  );

  await supabase.auth.signOut();

  setTimeout(() => {
    window.location.href = 'login.html';
  }, 2000);

  return;
}


        currentProfile = profile;

        // üèÜ Load Best Scores (AFTER profile is ready)
loadMyBestScores();

        // üîê PER-STUDENT BADGE STORAGE
BADGE_STORAGE_KEY = `unlocked_badges_${currentProfile.id}`;
loadUnlockedBadges();


        

        const joinBtn = document.getElementById('joinLiveBtn');
    if (joinBtn) {
      joinBtn.addEventListener('click', joinLiveClass);
    }
        document.getElementById('userInfo').textContent =
          `${profile.role} ‚Ä¢ ${profile.username || user.email.split('@')[0]}`;

          // üîí ROLE FLAGS (GUARANTEED TO RUN)
document.body.classList.remove("student-view", "teacher-view", "admin-view");

if (profile.role === "admin") {
  document.body.classList.add("admin-view");
} else {
  // EVERYTHING that is not admin = student UI
  document.body.classList.add("student-view");
}

// ‚úÖ STUDENT: load progress once profile is ready
if (profile.role === "student") {
  loadStudentProgress();
}



console.log("ROLE APPLIED:", profile.role, document.body.className);

// ================================
// STUDENT BADGE PANEL VISIBILITY
// ================================
const badgePanel = document.getElementById("studentBadgePanel");

if (badgePanel) {
  if (currentProfile?.role !== "student") {
    badgePanel.remove(); // completely remove for teacher/admin
  }
}





        if (profile.role === 'admin') {
          document.getElementById('adminTab').style.display = 'inline-block';
          document.getElementById('attemptsTab').style.display = 'inline-block';
          document.getElementById('createAssignmentForm').style.display = 'block';
          document.getElementById('adminContent').style.display = 'block';
          document.getElementById('adminAccessDenied').style.display = 'none';
          document.getElementById('pgnUploadSection').style.display = 'block';
          document.getElementById('assignStudentsRow').style.display = 'block';
          // Live classroom admin controls
const liveAdmin = document.getElementById('liveAdminControls');
if (liveAdmin && profile.role === 'admin') {
  liveAdmin.style.display = 'block';
}
// live classroom student selector (checkbox list)
const liveSelector = document.getElementById('liveStudentSelector');
if (liveSelector && profile.role === 'admin') {
  liveSelector.style.display = 'block';
}

if (currentProfile.role !== "admin") {
  document.body.classList.add("student-view");
}


if (currentProfile.role === "student") {
  document.body.classList.add("student-view");
  loadStudentProgress();
}






          loadStudents();
          loadStudentsForAssignment();
          loadStudentsForAssignment2();
          loadAttempts();
        } else {
          document.getElementById('adminTab').style.display = 'none';
          document.getElementById('attemptsTab').style.display = 'none';
          document.getElementById('createAssignmentForm').style.display = 'none';
          document.getElementById('adminContent').style.display = 'none';
          document.getElementById('adminAccessDenied').style.display = 'block';
          const pgnSection = document.getElementById('pgnUploadSection');

// Admin & Student ‚Üí BOTH can load PGN
pgnSection.style.display = 'block';

// Admin-only extras (if you add later)
if (profile.role !== 'admin') {
  // students should NOT see PGN library delete / admin tools
  document.querySelectorAll('.admin-only').forEach(el => {
    el.style.display = 'none';
  });
}


        }

        setupEventListeners();
        loadAssignments();
        loadPGNLibrary();
        loadQuizPuzzle();
        


        initChessboard();
        wireMoveInput();
        setupKeyboardNavigation();
        initStockfish();

        // üî¥üü¢ Live classroom status
        updateLiveClassStatus();
        wireLiveClassButtons();
        setInterval(updateLiveClassStatus, 10000); // optional but recommended
        loadStudentsForLiveClass();
        checkStudentLiveAccess();


        showCreateFormIfAdmin();


        startLiveBtn.addEventListener('click', async () => {
  if (currentProfile.role !== 'admin') return;

  // Check if already running
  const { data } = await supabase
    .from('live_sessions')
    .select('id')
    .eq('status', 'active')
    .limit(1);

  if (data && data.length > 0) {
  showModal(
    "üé• Live Class Started",
    "<p>The live class has started successfully!</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1500);

  return;
}


  const { error } = await supabase
    .from('live_sessions')
    .insert([{
      title: 'Live Class',
      created_by: currentProfile.id,
      status: 'active'
    }]);

  if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to start the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


  updateLiveClassStatus();
});

endLiveBtn.addEventListener('click', async () => {
  if (currentProfile.role !== 'admin') return;

  const { error } = await supabase
    .from('live_sessions')
    .update({ status: 'ended' })
    .eq('status', 'active');

    

  if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to end the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


  updateLiveClassStatus();
});

const confirmLiveBtn = document.getElementById('confirmLiveStudentsBtn');

if (confirmLiveBtn) {
  confirmLiveBtn.addEventListener('click', async () => {
    if (currentProfile.role !== 'admin') return;

    // 1Ô∏è‚É£ Collect selected students
    const checked = document.querySelectorAll(
      '#liveStudentsList input[type="checkbox"]:checked'
    );

    if (checked.length === 0) {
  showModal(
    "‚ö†Ô∏è No Student Selected",
    "<p>Please select at least one student.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}


    // 2Ô∏è‚É£ Create live session (ONE only)
    const { data: session, error: sessionError } = await supabase
      .from('live_sessions')
      .insert([{
        title: 'Live Class',
        created_by: currentProfile.id,
        status: 'active'
      }])
      .select()
      .single();

    if (sessionError) {
  console.error(sessionError);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to start the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


    // 3Ô∏è‚É£ Insert selected students into live_participants
    const participants = [...checked].map(cb => ({
      session_id: session.id,
      student_id: cb.value
    }));

    const { error: partError } = await supabase
      .from('live_participants')
      .insert(participants);

    if (partError) {
  console.error(partError);

  showModal(
    "‚ùå Error",
    "<p>Failed to add students.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


    // 4Ô∏è‚É£ Update UI
    updateLiveClassStatus();

showModal(
  "üé• Live Class Started",
  "<p>Live class started successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);
});
}




        


        document.getElementById('clearAssignmentFormBtn')?.addEventListener('click', () => {
          ['assignTitle','assignType','assignDesc','assignDue','assignFEN','assignPGN'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            if (el.tagName === 'SELECT') el.selectedIndex = 0;
            else el.value = '';
          });
        });

      } catch (error) {
        console.error('Initialization error:', error);
        alert('Error initializing application. Please refresh.');
        window.location.href = 'login.html';
      }
    }

    document.addEventListener("click", async function (event) {
  const action = event.target.dataset.action;
  const id = event.target.dataset.id;

  if (!action) return;

  if (action === "test" || action === "start") {
    console.log("Starting assignment:", id);
    startAssignmentMode(id);
  }

  if (action === "view") {
    openAssignmentDetails(id);
  }
});




    // Add this to your existing event setup
document.getElementById('assignmentsList').addEventListener('click', (e) => {
  const button = e.target.closest('button');
  if (!button) return;
  
  const action = button.dataset.action;
  const assignmentId = button.dataset.id;
  
  if (!action || !assignmentId) return;
  
  if (action === 'start') {
    startAssignmentMode(assignmentId);
  } else if (action === 'test') {
    testAssignment(assignmentId);
  } else if (action === 'view') {
    viewAssignment(assignmentId);
  }
});

function wireLiveClassButtons() {
  const startLiveBtn = document.getElementById('startLiveBtn');
  const endLiveBtn = document.getElementById('endLiveBtn');

  if (startLiveBtn) {
    startLiveBtn.onclick = async () => {
      if (currentProfile.role !== 'admin') return;

      const { error } = await supabase
        .from('live_sessions')
        .insert([{
          title: 'Live Class',
          created_by: currentProfile.id,
          status: 'active'
        }]);

      if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to start the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


      updateLiveClassStatus();
    };
  }

  if (endLiveBtn) {
    endLiveBtn.onclick = async () => {
      const { error } = await supabase
        .from('live_sessions')
        .update({ status: 'ended' })
        .eq('status', 'active');

      if (error) {
  console.error(error);

  showModal(
    "‚ùå Live Class Error",
    "<p>Failed to end the live class.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);

  return;
}


      updateLiveClassStatus();
    };
  }
}

const pgnInput = document.getElementById("pgnLibraryFileInput");

if (pgnInput) {
  pgnInput.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();

    

    const { error } = await supabase
      .from("bulk_pgn_library")
      .insert({
        title,
        pgn: text,
        is_active: true
      });

    if (error) {
      console.error(error);
      alert("Failed to import PGN");
      return;
    }

    showModal(
  "üìö PGN Imported",
  "<p>PGN imported into the library successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

loadPGNLibrary();

  });
}

document.addEventListener("click", async (e) => {
  const btn = e.target.closest(".reattempt-btn");
  if (!btn) return;

  const assignmentId = Number(btn.dataset.assignmentId);
  if (!assignmentId) return;

  await reattemptAssignment(assignmentId);
});

document.addEventListener("click", async (e) => {
  const btn = e.target.closest(".view-details-btn");
  if (!btn) return;

  const assignmentId = Number(btn.dataset.assignmentId);
  if (!assignmentId) return;

  await viewAssignmentDetailsForStudent(assignmentId);
});





    // ============================================
    // UI EVENTS
    // ============================================

    function stopQuizTimer() {
  if (quizTimer) {
    clearInterval(quizTimer);
    quizTimer = null;
  }
  quizActive = false;
  console.log("üõë Quiz timer stopped");
}
    function setupEventListeners() {
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          const tab = btn.dataset.tab;
          document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
          document.getElementById(`${tab}-section`).classList.add('active');
          // üß© Board Editor ‚Äì init AFTER section becomes visible
if (tab === 'editor') {
  setTimeout(() => {
    initEditorBoard();

    if (editorBoard) {
      editorBoard.resize(); // üî• required
    }
  }, 50);
}


          // üî¥üü¢ IMPORTANT: when Live tab opens, wire buttons
if (tab === 'live') {
  wireLiveClassButtons();
}

// ü§ñ Play vs Computer ‚Äî init board
if (tab === 'computer') {
  setTimeout(initVsComputerBoard, 0);
}

if (tab === "study") {
  loadStudyDropdown();
}

if (tab === "study") {
  initStudyEngine();
  analyzeStudyPosition();
}

if (tab !== "study" && studyEngine) {
  studyEngine.postMessage("stop");
}

          if (tab === 'students' && currentProfile.role !== 'admin') {
            alert('Access denied. Admin only.');
            document.querySelector('[data-tab="board"]').click();
          }
          if (tab === 'attempts' && currentProfile.role !== 'admin') {
            alert('Access denied. Admin only.');
            document.querySelector('[data-tab="board"]').click();
          }
        });
      });

      document.getElementById('logoutBtn').addEventListener('click', () => {
  openGradeConfirm(
    "üö™ Confirm Logout",
    "<p>Are you sure you want to logout?</p>",
    async () => {
      await supabase.auth.signOut();
      sessionStorage.clear();
      window.location.href = 'login.html';
    }
  );
});

document.getElementById("quizResultBtn")?.addEventListener("click", () => {
  document.getElementById("quizResultModal").classList.add("hidden");
});


    }

    function wireMoveInput() {
      const moveInput = document.getElementById('moveInput');
      document.getElementById('applyMoveBtn')?.addEventListener('click', applyMoveFromInput);
      moveInput?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') applyMoveFromInput();
      });
    }

    


    function setupKeyboardNavigation() {
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch(e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            pgnPrevMove();
            break;
          case 'ArrowRight':
            e.preventDefault();
            pgnNextMove();
            break;
          case 'Home':
            e.preventDefault();
            pgnFirstMove();
            break;
          case 'End':
            e.preventDefault();
            pgnLastMove();
            break;
          case 'r':
          case 'R':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              resetBoard();
            }
            break;
          case 'u':
          case 'U':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              undoMove();
              // üî• keep engine in sync
    if (engineRunning) updateEnginePosition();
            }
            break;
          case 'f':
          case 'F':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              flipBoard();
            }
            break;
          case 'p':
          case 'P':
            if (!e.ctrlKey && !e.metaKey) {
              e.preventDefault();
              copyPGN();
            }
            break;
          case 'Escape':
            e.preventDefault();
            if (isPGNLoaded) {
              pgnLastMove();
            }
            clearAllDrawings();
            break;
        }
      });
    }

    function sanitizePGN(raw) {
  if (!raw) return "";

  return raw
    .split("\n")
    .filter(line => !line.startsWith("["))
    .join(" ")
    .replace(/\s+/g, " ")
    .trim();
}




    function showCreateFormIfAdmin() {
      try {
        const form = document.getElementById('createAssignmentForm');
        if (!form) return;
        if (currentProfile && currentProfile.role === 'admin') {
          form.style.display = 'block';
        } else {
          form.style.display = 'none';
        }
      } catch (e) {
        console.warn('showCreateFormIfAdmin error', e);
      }
    }

    // Quiz set up //

    // üîä Quiz Sounds
const quizSounds = {
  next: new Audio("sounds/next.mp3"),
  wrong: new Audio("sounds/wrong.mp3"),
  party: new Audio("sounds/party.mp3")
};

function playQuizSound(type) {
  const s = quizSounds[type];
  if (!s) return;
  s.currentTime = 0;
  s.volume = 0.8;
  s.play().catch(() => {});
}

// üîì unlock audio on first user interaction (IMPORTANT)
document.addEventListener("click", unlockQuizAudio, { once: true });
document.addEventListener("keydown", unlockQuizAudio, { once: true });

function unlockQuizAudio() {
  Object.values(quizSounds).forEach(a => {
    a.volume = 0;
    a.play().then(() => {
      a.pause();
      a.currentTime = 0;
      a.volume = 0.9;
    }).catch(() => {});
  });
}

    

   async function loadQuizPuzzle() {
  console.log("üß© Loading quiz puzzle...");

  // 1Ô∏è‚É£ Get total count
  const { count, error: countError } = await supabase
    .from("puzzle_rush_mate1")
    .select("*", { count: "exact", head: true });

  if (countError || !count) {
    console.error("‚ùå Failed to get puzzle count", countError);
    return;
  }

  // 2Ô∏è‚É£ Pick random index
  const randomIndex = Math.floor(Math.random() * count);

  // 3Ô∏è‚É£ Fetch that one row
  const { data, error } = await supabase
    .from("puzzle_rush_mate1")
    .select("fen, solution, side_to_move")
    .eq("is_active", true)
    .range(randomIndex, randomIndex)
    .single();

  if (error || !data) {
    console.error("‚ùå Failed to load puzzle", error);
    return;
  }

  console.log("‚úÖ Puzzle loaded:", data);
  setupQuizPosition(data);
  playQuizSound("next");

}


function setupQuizPosition(puzzle) {
  quizChess.reset();
  quizChess.load(puzzle.fen);

  // Set board orientation
  quizBoard.orientation(
    puzzle.side_to_move === "b" ? "black" : "white"
  );

  quizBoard.position(puzzle.fen);

  // Normalize solution (remove + or # if present)
  currentQuizSolution = puzzle.solution.replace(/[+#]/g, "");

  generateQuizOptions();
  startQuizTimer(); // üî•

  console.log("üéØ Correct solution:", currentQuizSolution);
}

function generateQuizOptions() {
  const legalMoves = quizChess.moves({ verbose: true });

  // Find correct move object
  const correctMove = legalMoves.find(m =>
    m.san.replace(/[+#]/g, "") === currentQuizSolution
  );

  if (!correctMove) {
    console.error("‚ùå Correct move not found in legal moves");
    return;
  }

  // Collect wrong moves
  const wrongMoves = legalMoves
    .filter(m => m !== correctMove)
    .sort(() => Math.random() - 0.5)
    .slice(0, 3);

  // Combine + shuffle
  currentOptions = [correctMove, ...wrongMoves]
    .sort(() => Math.random() - 0.5);

  // Render buttons
  document.querySelectorAll(".quiz-option").forEach((btn, i) => {
    btn.textContent = currentOptions[i].san;
    btn.dataset.correct =
      currentOptions[i] === correctMove ? "1" : "0";
  });

  console.log("üß† Options generated:", currentOptions.map(m => m.san));
}

document.querySelectorAll(".quiz-option").forEach(btn => {
  btn.onclick = () => {
    if (!quizActive) return;

    clearInterval(quizTimer);
    quizActive = false;

    if (btn.dataset.correct === "1") {
      // ‚úÖ CORRECT
      quizScore++;
      updateScoreUI();

      // small delay for UX
      setTimeout(() => {
        loadQuizPuzzle(); // ‚û°Ô∏è NEXT PUZZLE
      }, 300);

    } else {
      // ‚ùå WRONG = GAME OVER
      endQuiz("‚ùå Wrong move!");
      playQuizSound("wrong");

    }
  };
});




function updateTimerUI() {
  document.getElementById("quizTimer").textContent = timeLeft;
}

function updateScoreUI() {
  document.getElementById("quizScore").textContent = quizScore;
}

function startQuizTimer() {
  clearInterval(quizTimer);
  timeLeft = 20;
  updateTimerUI();
  quizActive = true;

  quizTimer = setInterval(() => {
    timeLeft--;
    updateTimerUI();

    // ‚ö†Ô∏è low time warning (optional)
    if (timeLeft <= 10) {
      document
        .querySelector(".quiz-timer")
        .classList.add("warning");
    }

    // ‚è± TIME UP = GAME OVER
    if (timeLeft <= 0) {
      clearInterval(quizTimer);
      quizActive = false;
      endQuiz("‚è± Time's up!");
    }
  }, 1000);
}

function endQuiz(reason) {
  stopQuizTimer();
  quizActive = false;

  // üèÜ SAVE BEST SCORE (Quiz)
  saveMiniGameScore("quiz", quizScore);

  // üéØ modal content
  document.getElementById("quizResultTitle").textContent = "Quiz Finished";
  document.getElementById("quizResultText").textContent =
    `${reason}\nFinal Score: ${quizScore}`;

  document.getElementById("quizResultModal").classList.remove("hidden");

  playQuizSound("party");

  // üîÅ reset score AFTER saving
  quizScore = 0;
  updateScoreUI();
}





    // ============================================
    // CHESSBOARD.JS SETUP
    // ============================================
    function initChessboard() {
      if (typeof Chess === 'undefined') {
        document.getElementById('chessboard').innerHTML =
          '<div style="color:white;text-align:center;padding:40px;">Chess engine failed to load.</div>';
        return;
      }

      chess = new Chess();

      const cfg = {
        draggable: true,
        position: 'start',
        orientation: boardOrientation,
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: "https://lichess1.org/assets/piece/merida/{piece}.svg",
      };

      board = Chessboard('chessboard', cfg);
      
      // Initialize notation
      initNotation();
      
      // Initialize drawing system
      initDrawingSystem();
      
      window.addEventListener('resize', () => {
        if (board && typeof board.resize === 'function') board.resize();
        // Redraw drawings on resize
        if (chess) {
          loadDrawingsForPosition(chess.fen());
        }
      });
    }

    function onDragStart(source, piece, position, orientation) {
  // ‚ùå Block right-click drag
  if (window.event && window.event.button === 2) {
    return false;
  }

  // ‚ùå Do not allow dragging if game is over
  if (chess.game_over()) return false;

  // ‚ùå Enforce turn
  if (
    (chess.turn() === "w" && piece.search(/^b/) !== -1) ||
    (chess.turn() === "b" && piece.search(/^w/) !== -1)
  ) {
    return false;
  }

  return true;
}

async function updateLiveClassStatus() {
  const { data, error } = await supabase
    .from('live_sessions')
    .select('id, status')
    .eq('status', 'active')
    .limit(1);

  if (error) {
    console.error(error);
    return;
  }

  const isLive = data && data.length > 0;

  // UI elements
  const dot = document.getElementById('liveStatusDot');
  const text = document.getElementById('liveStatusText');
  const startBtn = document.getElementById('startLiveBtn');
  const endBtn = document.getElementById('endLiveBtn');

  if (isLive) {
  const activeSessionId = data[0].id;

  dot?.classList.remove('red');
  dot?.classList.add('green');
  if (text) text.textContent = 'Live class is running';

  if (currentProfile.role === 'admin') {
    startBtn.style.display = 'none';
    endBtn.style.display = 'inline-block';

    // ‚úÖ SHOW JOINED STUDENTS (ADMIN ONLY)
    loadLiveJoinedStudents(activeSessionId);
  }
  } else {
    dot?.classList.remove('green');
    dot?.classList.add('red');
    if (text) text.textContent = 'No live class running';

    if (currentProfile.role === 'admin') {
      startBtn.style.display = 'inline-block';
      endBtn.style.display = 'none';
    }
  }
}

async function checkStudentLiveAccess() {
  if (!currentProfile || currentProfile.role !== 'student') return;

  // get active session
  const { data: session } = await supabase
    .from('live_sessions')
    .select('id')
    .eq('status', 'active')
    .single();

  if (!session) return;

  // check if student is allowed
  const { data: allowed } = await supabase
    .from('live_participants')
    .select('id')
    .eq('session_id', session.id)
    .eq('student_id', currentProfile.id)
    .single();

  const joinBtn = document.getElementById('joinLiveBtn');

  if (allowed && joinBtn) {
    joinBtn.style.display = 'inline-block';
  }
}




    function onDrop(source, target) {
  // Assignment mode handling
  if (currentAssignment && expectedMoves.length > 0 && assignmentCursor < expectedMoves.length) {
    const expected = expectedMoves[assignmentCursor];
    
    // Check if it's student's turn
    const studentColor = assignmentColor || "w";
    if (studentColor !== chess.turn()) {
      alert("Not your turn!");
      return "snapback";
    }

    // Student plays move
let move;

// üîÅ Promotion handling (BEFORE chess.move)
if (isPromotionMove(source, target)) {
  showPromotionDialog(source, target);
  return "snapback"; // stop drag, wait for user choice
}

// ‚ñ∂ Normal move (no forced queen)
move = chess.move({
  from: source,
  to: target
});

// ‚ùó correct check
if (!move) return "snapback";

// Check if move matches expected move
if (move.san !== expected.san) {
  attemptCount++;

  playSound('wrong');

  // ‚ùå No alerts
  // ‚ùå No expectedMove.san leakage

  if (currentProfile.role === "admin") {
    showStatus(
      `Wrong move. Attempts: ${attemptCount}`,
      "error"
    );
  } else {
    


    showStatus(
  `Wrong move. Try again. <span style="float:right;">Retry: ${attemptCount}</span>`,
  "error"
);


  }

  chess.undo();
  
  return "snapback";
}
// üîä MOVE / CAPTURE SOUND
if (move.flags.includes('k') || move.flags.includes('q')) {
  // üëë Castling
  playSound('castle');

} else if (move.san.includes('+')) {
  // üîî Check
  playSound('check');

} else if (move.captured) {
  // ‚öîÔ∏è Capture
  playSound('capture');

} else {
  // ‚ôü Normal move
  playSound('move');
}





    // Correct move
    moveHistory.push({
      from: move.from,
      to: move.to,
      san: move.san,
      fen: chess.fen(),
      timestamp: new Date()
    });
    
    fullPGNHistory.push(move);
    pgnCursor++;
    assignmentCursor++;

    

// ========================================
// üîÅ BULK PUZZLE COMPLETION CHECK (ADD HERE)
// ========================================
if (currentAssignment?.is_bulk && assignmentCursor >= expectedMoves.length) {
  // üéØ PUZZLE COMPLETED
  bulkIndex++;

  if (bulkIndex < bulkPuzzles.length) {
    setTimeout(() => {
      playSound('next');
      loadCurrentBulkPuzzle();
    }, 800);
  } else {
    playSound('complete');
    // üéâ ALL PUZZLES DONE
    showStatus(
      "üéâ All puzzles completed! Submit your assignment.",
      "success"
    );
    document.getElementById("submitBtn").style.display = "block";
  }

  return; // ‚õî VERY IMPORTANT: stop further execution
}


    // Auto-play opponent's reply if exists
    if (assignmentCursor < expectedMoves.length) {
      const reply = expectedMoves[assignmentCursor];
      setTimeout(() => {
        const autoMove = chess.move(reply.san);
        if (autoMove) {
          // üîä AUTO MOVE SOUND (soft)
  if (autoMove.captured) {
    playSound('capture');
  } else {
    playSound('move');
  }
          fullPGNHistory.push(autoMove);
          pgnCursor++;
          assignmentCursor++;
          board.move(autoMove.from + '-' + autoMove.to);

          updateEnginePosition();
          
          updatePGNViewer();
          renderNotation();
          updateNavigationButtons();
          checkGameEnd();
          

        }
      }, 500);
    }

    
    // üî• UPDATE ENGINE AFTER PLAYER MOVE
updateEnginePosition();

    // Update board + UI
    
    updatePGNViewer();
    renderNotation();
    updateNavigationButtons();
    checkGameEnd();

    // Check if assignment is completed
    if (assignmentCursor >= expectedMoves.length) {
      showStatus("üéâ Assignment completed! Click 'Submit solution' to submit.", "success", false);

      document.getElementById("submitBtn").style.display = "block";
    }

    return true;
  }

  // Normal free-play mode (rest of the existing code...)
  // ... existing normal mode code ...



      // Normal free-play mode
let move;

// ‚ôüÔ∏è Promotion check FIRST
if (isPromotionMove(source, target)) {
  showPromotionDialog(source, target);
  return "snapback"; // stop here, wait for user choice
}

// ‚ñ∂ Normal move (no forced queen)
move = chess.move({ from: source, to: target });

// ‚ùå Illegal move
if (!move) {
  return "snapback";
}

// üîä MOVE / CAPTURE SOUND
if (move.flags.includes('k') || move.flags.includes('q')) {
  // üëë Castling
  playSound('castle');

} else if (move.san.includes('+')) {
  // üîî Check
  playSound('check');

} else if (move.captured) {
  // ‚öîÔ∏è Capture
  playSound('capture');

} else {
  // ‚ôü Normal move
  playSound('move');
}




      
      // Update history for normal moves
      moveHistory.push({
        from: move.from,
        to: move.to,
        san: move.san,
        fen: chess.fen(),
        timestamp: new Date()
      });
      
      if (pgnCursor < fullPGNHistory.length) {
        fullPGNHistory = fullPGNHistory.slice(0, pgnCursor);
      }
      fullPGNHistory.push(move);
      pgnCursor++;
      
      updatePGNViewer();
      renderNotation();
      updateNavigationButtons();
      checkGameEnd();
    }

    function onSnapEnd() {
  board.position(chess.fen());

  // ‚úÖ Hide drawings visually when position changes
  clearSVGOnly();

  // Restore grab cursor after snap
  const boardElement = document.getElementById('chessboard');
  if (boardElement) {
    const pieces = boardElement.querySelectorAll('.piece-417db');
    pieces.forEach(p => p.style.cursor = 'grab');
    if (engineRunning) updateEnginePosition();

  }
}


    window.selectAllStudents = function () {
  const checkboxes = document.querySelectorAll(
    "#assignStudentsBox input[type='checkbox']"
  );
  checkboxes.forEach(cb => cb.checked = true);
};

window.clearAllStudents = function () {
  const checkboxes = document.querySelectorAll(
    "#assignStudentsBox input[type='checkbox']"
  );
  checkboxes.forEach(cb => cb.checked = false);
};


    function resetAssignmentPosition() {
  const fen = currentAssignment.fen || "start";
  chess = new Chess(fen);

  assignmentCursor = 0;
  attemptCount = 0;

  fullPGNHistory = [];
  moveHistory = [];
  pgnCursor = 0;

  board.position(chess.fen());

  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();
}


    function checkGameEnd() {
      if (!chess.game_over()) return;

      let message = '';
      if (chess.in_checkmate()) message = 'Checkmate!';
      else if (chess.in_draw()) message = 'Draw!';
      else if (chess.in_stalemate()) message = 'Stalemate!';
      else if (chess.in_threefold_repetition()) message = 'Threefold repetition!';
      else if (chess.insufficient_material()) message = 'Insufficient material!';
      else message = 'Game over!';
      
      document.getElementById('gameStatus').textContent = message;
      document.getElementById('gameStatus').style.display = 'block';
    }

    // ============================================
    // BOARD CONTROLS
    // ============================================
    window.resetBoard = function() {
      stopEngine();

  if (!chess || !board) return;
  chess.reset();
  board.start();
  moveHistory = [];
  fullPGNHistory = [];
  pgnCursor = 0;
  isNavigationMode = false;
  isPGNLoaded = false;
  
  // Reset assignment state
  currentAssignment = null;
  expectedMoves = [];
  assignmentCursor = 0;
  attemptCount = 0;
  assignmentColor = "w";
  
  // Clear all drawings
  clearAllDrawings();
  drawings.clear();
  
  updateBoardCursor();
  updatePGNViewer();
  updateNavigationButtons();
  safeDisable("moveInput", false);
safeDisable("applyMoveBtn", false);

  document.getElementById('gameStatus').style.display = 'none';
  document.getElementById('submitBtn').style.display = 'none';
  document.getElementById('pgnContainer').style.display = 'none';
  renderNotation();
  
  // Stop timer
  stopTimer();
  document.getElementById('timerDisplay').style.display = 'none';
};

function clearSVGOnly() {
  // ‚ùó removes drawings from screen ONLY
  const els = svgOverlay.querySelectorAll('.drawing-arrow, .drawing-circle');
  els.forEach(el => el.remove());
}


    window.flipBoard = function() {
      if (!board) return;
      board.flip();
      boardOrientation = (boardOrientation === 'white') ? 'black' : 'white';
      
      // Redraw drawings with new orientation
      if (chess) {
        loadDrawingsForPosition(chess.fen());
      }
    };

    window.undoMove = function() {
      if (!chess || !board) return;
      const undone = chess.undo();
      if (undone) {
        moveHistory.pop();
        if (fullPGNHistory.length > 0) {
          fullPGNHistory.pop();
          pgnCursor--;
        }
        board.position(chess.fen());
        updatePGNViewer();
        updateNavigationButtons();
        renderNotation();
      }
    };

    window.savePosition = async function () {
  if (!chess || !currentProfile) return;

  if (currentProfile.role !== "admin") {
    showModal("‚õî Access denied", "<p>Only admins can save PGNs.</p>");
    return;
  }

  const rawPGN = chess.pgn();

  if (!rawPGN || rawPGN.trim() === "") {
    showModal(
      "‚ö†Ô∏è No moves found",
      "<p>Please play the full game on the board first.</p>"
    );
    return;
  }

  const title = prompt("Enter PGN title for Database")
  if (!title) return;

  const { error } = await supabase
    .from("bulk_pgn_library")
    .insert({
      title: title.trim(),
      pgn: rawPGN,          // ‚úÖ FULL GAME
      is_active: true,
      created_by: currentProfile.id
    });

  if (error) {
    console.error(error);
    showModal("‚ùå Error", "<p>Failed to save PGN.</p>");
    return;
  }

  showModal(
    "‚úÖ PGN Saved",
    "<p>Full game saved to PGN Library.</p>"
  );

  await loadPGNLibrary();
};

function uciToSAN(uci) {
  try {
    const temp = new Chess(chess.fen());

    const move = temp.move({
      from: uci.slice(0, 2),
      to: uci.slice(2, 4),
      promotion: uci[4] // handles promotion
    });

    if (!move) return uci;

    const moveNumber = Math.ceil(temp.history().length / 2);
    const prefix = move.color === "w"
      ? `${moveNumber}. `
      : `${moveNumber}... `;

    return prefix + move.san;
  } catch {
    return uci;
  }
}
function renderPVLine() {
  if (!currentPV.length) return;

  const temp = new Chess(chess.fen());
  let sanLine = [];
  let moveNumber = temp.history().length / 2 + 1;

  currentPV.forEach((uci, index) => {
    const move = temp.move({
      from: uci.slice(0, 2),
      to: uci.slice(2, 4),
      promotion: uci[4]
    });

    if (!move) return;

    if (move.color === "w") {
      sanLine.push(`${Math.ceil(moveNumber)}.${move.san}`);
    } else {
      sanLine.push(move.san);
      moveNumber++;
    }
  });

  document.getElementById("engineBestMove").textContent =
    sanLine.join(" ");
}

function renderMultiPV() {
  const fen = chess.fen();
  const fenParts = fen.split(" ");

  const sideToMove = fenParts[1];          // "w" or "b"
  let fullMoveNumber = parseInt(fenParts[5], 10); // correct move number

  for (let i = 1; i <= 3; i++) {
    const el = document.getElementById(`engineLine${i}`);
    if (!el || !pvMap[i]) continue;

    const temp = new Chess(fen);
    let san = [];
    let moveNum = fullMoveNumber;

    pvMap[i].forEach(uci => {
      const move = temp.move({
        from: uci.slice(0, 2),
        to: uci.slice(2, 4),
        promotion: uci[4]
      });
      if (!move) return;

      // ‚úÖ Correct numbering
      if (move.color === "w") {
  san.push(`${moveNum}.${move.san}`);
} else {
  san.push(move.san);
  moveNum++;
}

    });

    el.textContent = `${ENGINE_BULLETS[i - 1]} ${san.join(" ")}`;
  }
}


function safeDisable(id, value = true) {
  const el = document.getElementById(id);
  if (!el) return;
  el.disabled = value;
}






    window.copyPGN = function () {
  if (!chess) return;

  const pgn = chess.pgn();

  navigator.clipboard.writeText(pgn).then(() => {
    showModal(
      "üìã Copied",
      "<p>PGN copied to clipboard successfully.</p>"
    );

    setTimeout(() => {
      closeModal();
    }, 1200);
  }).catch(err => {
    console.error(err);

    showModal(
      "‚ùå Copy Failed",
      "<p>Failed to copy PGN to clipboard.</p>"
    );

    setTimeout(() => {
      closeModal();
    }, 2000);
  });
};


    function playNavigationSound(move) {
  if (!move) return;

  // üëë Castling
  if (move.flags?.includes('k') || move.flags?.includes('q')) {
    playSound('castle');
    return;
  }

  // üîî Check
  if (move.san?.includes('+')) {
    playSound('check');
    return;
  }

  // ‚öîÔ∏è Capture
  if (move.captured) {
    playSound('capture');
    return;
  }

  // ‚ôü Normal move
  playSound('move');
}


    // ============================================
    // MOVE INPUT
    // ============================================
    function applyMoveFromInput() {
      if (!chess || !board) return;
      
      if (isNavigationMode && pgnCursor < fullPGNHistory.length) {
        pgnLastMove();
        isNavigationMode = false;
        document.getElementById('moveInput').disabled = false;
        document.getElementById('applyMoveBtn').disabled = false;
      }
      
      const val = document.getElementById('moveInput').value.trim();
      if (!val) return;

      let move = chess.move(val, { sloppy: true });

if (
  !move &&
  /^[a-h][1-8][a-h][1-8][qrbn]?$/i.test(val)
) {
  const from = val.slice(0, 2).toLowerCase();
  const to = val.slice(2, 4).toLowerCase();
  const promo = val.slice(4).toLowerCase();

  // ‚ôüÔ∏è Promotion handling
  if (!promo && isPromotionMove(from, to)) {
    showPromotionDialog(from, to);
    return;
  }

  move = chess.move({
    from,
    to,
    promotion: promo // ‚ùó NO default 'q'
  });
}


      if (move) {
        board.position(chess.fen());
        moveHistory.push({
          from: move.from,
          to: move.to,
          san: move.san,
          fen: chess.fen(),
          timestamp: new Date()
        });
        
        // Update fullPGNHistory
        if (pgnCursor < fullPGNHistory.length) {
          fullPGNHistory = fullPGNHistory.slice(0, pgnCursor);
        }
        fullPGNHistory.push(move);
        pgnCursor++;
        
        updatePGNViewer();
        document.getElementById('moveInput').value = '';
        checkGameEnd();
        updateNavigationButtons();
        renderNotation();
      } else {
        board.position(chess.fen());
        alert('Invalid move!');
      }
    }

    //SOUND SFX START//
    const sounds = {
  move: new Audio('sounds/move.mp3'),
  capture: new Audio('sounds/capture.mp3'),
  castle: new Audio('sounds/castle.mp3'),
  check: new Audio('sounds/check.mp3'),
  wrong: new Audio('sounds/wrong.mp3'),
  next: new Audio('sounds/next.mp3'),
  complete: new Audio('sounds/complete.mp3'),
};

Object.values(sounds).forEach(s => s.volume = 0.4);

function playSound(name) {
  const sound = sounds[name];
  if (!sound) return;
  sound.currentTime = 0;
  sound.play().catch(() => {});
}




// Play with Computer Functions Start //

function updateClockUI() {
  const wMin = Math.floor(whiteTime / 60);
  const wSec = whiteTime % 60;

  document.getElementById("whiteClock").textContent =
    `${String(wMin).padStart(2, "0")}:${String(wSec).padStart(2, "0")}`;

  const bMin = Math.floor(blackTime / 60);
  const bSec = blackTime % 60;

  document.getElementById("blackClock").textContent =
    `${String(bMin).padStart(2, "0")}:${String(bSec).padStart(2, "0")}`;
}




function initVsComputerBoard() {
  if (vsBoard) return; // prevent re-init

  vsChess = new Chess();

  vsBoard = Chessboard("computerBoard", {
    position: "start",
    draggable: true,
    pieceTheme: "https://lichess1.org/assets/piece/merida/{piece}.svg",

    onDragStart: (source, piece) => {
  // block if game over
  if (!vsGameActive) return false;

  // only allow dragging player's color
  if (
    (vsPlayerColor === "white" && piece.startsWith("b")) ||
    (vsPlayerColor === "black" && piece.startsWith("w"))
  ) {
    return false;
  }

  // only allow when it's player's turn
  if (vsChess.turn() !== (vsPlayerColor === "white" ? "w" : "b")) {
    return false;
  }

  return true;
},


    onDrop: (source, target) => {
      const move = vsChess.move({
        from: source,
        to: target,
        promotion: "q"
        
      });
      

      if (!move) return "snapback";
      // ‚úÖ CHECK GAME END IMMEDIATELY
      
  checkVsGameEnd();
      
      
      // üîä PLAYER MOVE SOUND
if (move.flags.includes('k') || move.flags.includes('q')) {
  playSound('castle');
} else if (move.san.includes('+')) {
  playSound('check');
} else if (move.captured) {
  playSound('capture');
} else {
  playSound('move');
}
// ü§ñ BOT REACTION (TEXT ONLY, NO SOUND)
const studentMoved =
  (vsPlayerColor === "white" && move.color === "w") ||
  (vsPlayerColor === "black" && move.color === "b");
  if (studentMoved) {
  // üîä PRIORITY: CHECK > CAPTURE
  if (vsChess.in_check()) {
    botReact("check");        // existing gibberish
    playBotCheckSounds();     // ‚úÖ ADD THIS
  } else if (move.captured) {
    botReact("capture");     // existing gibberish
    playBotCaptureSounds();   // ‚úÖ ADD THIS
  }
}




      // engine move will come later (STEP 4)

      // ü§ñ engine turn
if (vsEngine && vsEngineConfig) {
  vsEngine.postMessage(`position fen ${vsChess.fen()}`);
  vsEngine.postMessage(
    `go depth ${vsEngineConfig.depth} movetime ${vsEngineConfig.time}`
  );
  // üß† ENGINE TURN ‚Üí START BLACK CLOCK (GUARANTEED)
engineThinking = true;

clearInterval(clockInterval);
clockInterval = setInterval(() => {
  if (!vsGameActive) return;

  if (blackTime > 0) {
    blackTime--;
    updateClockUI();
  }
}, 1000);


  // ‚è± START BLACK CLOCK (ENGINE THINKING)
  clearInterval(clockInterval);
  engineThinking = true;

  clockInterval = setInterval(() => {
    if (!vsGameActive) return;

    if (blackTime > 0) {
      blackTime--;
      updateClockUI();
    }
  }, 1000);
}



    }
  });
}

function initVsEngine() {
  if (vsEngine) return;

  vsEngine = new Worker("./stockfish/stockfish.js");
  vsEngine.onmessage = handleVsEngineMessage;

  vsEngine.postMessage("uci");
  vsEngine.postMessage("isready");

  console.log("ü§ñ VS Engine initialized");
}

function handleVsEngineMessage(e) {
  const line = e.data;
if (typeof line !== "string") return;

// üß† ENGINE STARTED THINKING ‚Üí START BLACK CLOCK
if (line.startsWith("info") && !engineThinking) {
  engineThinking = true;

  clearInterval(clockInterval);

  clockInterval = setInterval(() => {
    if (!vsGameActive) return;

    if (blackTime > 0) {
      blackTime--;
      updateClockUI();
    }
  }, 1000);
}

// ‚õî ignore everything except bestmove after this
if (!line.startsWith("bestmove")) return;

// üõë ENGINE FINISHED THINKING
engineThinking = false;
const moveUci = line.split(" ")[1];
if (!moveUci || moveUci === "(none)") return;



  // ‚è± DELAY ENGINE MOVE BY 3 SECONDS
setTimeout(() => {
  if (!vsGameActive) return;

  // ‚ôü APPLY ENGINE MOVE
  const engineMove = vsChess.move({
    from: moveUci.slice(0, 2),
    to: moveUci.slice(2, 4),
    promotion: moveUci[4]
  });

  if (!engineMove) return;
  

  // üîä ENGINE MOVE SOUND
  // üîä BOT MOVE SOUND (SAFE ORDER)

// 1Ô∏è‚É£ Capture has TOP priority
if (engineMove.captured) {
  playBotCaptureSound();
}

// 2Ô∏è‚É£ Check (only if NOT capture)
else if (vsChess.in_check()) {
  playBotCheckSound();
}
if (engineMove.flags.includes("k") || engineMove.flags.includes("q")) {
  playSound("castle");
}
else {
  playSound("move");
}


// 3Ô∏è‚É£ Optional normal move sound (later)
// else {
//   playSound("move");
// }


  // ‚úÖ SYNC BOARD
  vsBoard.position(vsChess.fen());
  checkVsGameEnd();

  // ‚è± ENGINE DONE ‚Üí START WHITE CLOCK
  clearInterval(clockInterval);
  clockInterval = setInterval(() => {
    if (!vsGameActive) return;

    if (whiteTime > 0) {
      whiteTime--;
      updateClockUI();
    }
  }, 1000);

}, BOT_MOVE_DELAY);

}

const BOT_SOUND_VOLUME = 0.20; // üîä tweak: 0.25‚Äì0.45
function playBotCheckSound() {
  const i = Math.floor(Math.random() * 8) + 1;
  const audio = new Audio(`bot_happy_sound/botcheck${i}.mp3`);
  audio.volume = BOT_SOUND_VOLUME;
  audio.play().catch(() => {});
}

function playBotCaptureSound() {
  const i = Math.floor(Math.random() * 7) + 1;
  const audio = new Audio(`bot_happy_sound/botcapture${i}.mp3`);
  audio.volume = BOT_SOUND_VOLUME;
  audio.play().catch(() => {});
}






function resetVsComputerGame() {
  clearVsResult();
  console.log("üîÑ Hard reset VS Computer");

  // 1. Stop engine safely
  if (vsEngine) {
    try {
      vsEngine.postMessage("stop");
      vsEngine.postMessage("ucinewgame");
    } catch (e) {
      console.warn("Engine already stopped");
    }
  }

  // 2. Disable game
  vsGameActive = false;

  // 3. Reset chess logic
  if (vsChess) {
    vsChess.reset();
  }

  // 4. Reset board UI
  if (vsBoard) {
    vsBoard.position("start", false);
  }

  // 5. Reset clocks
  document.getElementById("whiteClock").textContent = "05:00";
  document.getElementById("blackClock").textContent = "05:00";

  // 6. Optional: visual feedback
  console.log("‚úÖ VS Computer fully reset");
}


function updatePuzzleRushUI() {
  document.getElementById("prScore").textContent = prScore;
  document.getElementById("prLives").textContent = prLivesLeft;

  if (prTimeLeft === null) {
    document.getElementById("prTimer").textContent = "‚àû";
  } else {
    const m = Math.floor(prTimeLeft / 60);
    const s = prTimeLeft % 60;
    document.getElementById("prTimer").textContent =
      `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  }
}



function endPuzzleRush(reason) {
  clearInterval(prTimerInterval);
  prTimerInterval = null;

  // üèÜ SAVE BEST SCORE (Puzzle Rush)
  saveMiniGameScore("puzzlerush", prScore);

  // üîä Puzzle Rush complete sound
  playPRSound("prCompleteSound", 1.0);

  showPuzzleRushResult(reason, prScore);


  document.getElementById("puzzleRushGame").classList.add("hidden");
  document.getElementById("puzzleRushMenu").classList.remove("hidden");

  puzzleRushMode = null;
}



function playPRSound(id, volume = 0.75) {
  const s = document.getElementById(id);
  if (!s) return;
  s.currentTime = 0;
  s.volume = volume;
  s.play().catch(() => {});
}


// Play with Computer Functions End //

    //SOUND SFX END//

    // ============================================
    // NOTATION SYSTEM - FIXED VERSION
    // ============================================
    function renderNotation() {
      const container = document.getElementById('notationList');
      container.innerHTML = '';

      // Always use fullPGNHistory if it has moves, otherwise use current chess history
      let moves = [];
      if (fullPGNHistory.length > 0) {
        // Show all moves from the complete history
        moves = fullPGNHistory;
      } else {
        // No history yet, use current chess moves
        moves = chess.history({ verbose: true });
      }

      // Create notation rows
      for (let i = 0; i < moves.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        const white = moves[i] ? moves[i].san : '';
        const black = moves[i + 1] ? moves[i + 1].san : '';

        const row = document.createElement('div');
        row.className = 'move';
        row.dataset.plyIndex = i; // Store the ply index for clicking
        
        // Mark which plies this row contains
        row.dataset.containsPlies = `${i},${i + 1}`;

        const num = document.createElement('div');
        num.className = 'num';
        num.textContent = moveNum + '.';

        const whiteCell = document.createElement('div');
        whiteCell.className = 'white';
        whiteCell.textContent = white;

        const blackCell = document.createElement('div');
        blackCell.className = 'black';
        blackCell.textContent = black;

        row.appendChild(num);
        row.appendChild(whiteCell);
        row.appendChild(blackCell);
        container.appendChild(row);
      }

      if (moves.length === 0) {
        container.innerHTML = '<div style="padding:12px;color:var(--text-muted); text-align:center;">No moves yet</div>';
      }

      highlightCurrentNotation();
      
      // Scroll to show current move
      setTimeout(() => {
        const currentRows = container.querySelectorAll('.move.current');
        if (currentRows.length > 0) {
          const lastCurrent = currentRows[currentRows.length - 1];
          lastCurrent.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      }, 10);
    }

    function highlightCurrentNotation() {
      const container = document.getElementById('notationList');
      const rows = container.querySelectorAll('.move');
      rows.forEach(r => r.classList.remove('current'));

      if (pgnCursor === 0) return;

      // Find the row that contains the current ply
      const rowIndex = Math.floor((pgnCursor - 1) / 2);
      const target = rows[rowIndex];
      if (target) {
        target.classList.add('current');
      }
    }

    function attachNotationClickHandler() {
      const container = document.getElementById('notationList');
      container.addEventListener('click', (e) => {
        let target = e.target;
        
        // Find the move element
        if (!target.classList.contains('move')) {
          target = target.closest('.move');
        }
        if (!target) return;
        
        // Get ply index from data attribute
        const plyIndex = parseInt(target.dataset.plyIndex);
        if (!isNaN(plyIndex)) {
          // Navigate to the position AFTER the white move in this row
          navigateToMove(plyIndex + 1);
        }
      });
    }

    function initNotation() {
      attachNotationClickHandler();
      renderNotation();
    }

    // ============================================
    // PGN NAVIGATION - FIXED VERSION
    // ============================================
    function navigateToMove(targetIndex) {
      if (!chess || !board) return;
      
      // Don't navigate if no moves
      if (fullPGNHistory.length === 0 && targetIndex > 0) return;
      
      // Clamp target index
      targetIndex = Math.max(0, Math.min(targetIndex, fullPGNHistory.length));
      
      // Rebuild game up to target index
      chess.reset();
      
      for (let i = 0; i < targetIndex; i++) {
        const move = fullPGNHistory[i];
        chess.move({
          from: move.from,
          to: move.to,
          promotion: move.promotion

        });
      }
      
      board.position(chess.fen());
      // üî• Keep engine synced during PGN navigation
if (engineRunning) updateEnginePosition();

      // üîä Play sound for PGN navigation move
if (targetIndex > 0) {
  const navMove = fullPGNHistory[targetIndex - 1];
  playNavigationSound(navMove);
}

      pgnCursor = targetIndex;
      isNavigationMode = (targetIndex < fullPGNHistory.length);
      
      // Load drawings for this position
      loadDrawingsForPosition(chess.fen());
      
      updateBoardCursor();
      updatePGNViewer();
      updateNavigationButtons();
      renderNotation();
      highlightCurrentNotation();
      
      // Enable/disable move input based on navigation state
      document.getElementById('moveInput').disabled = isNavigationMode;
      document.getElementById('applyMoveBtn').disabled = isNavigationMode;
      
      // Show game status if at end and game is over
      if (targetIndex === fullPGNHistory.length) {
        checkGameEnd();
      } else {
        document.getElementById('gameStatus').style.display = 'none';
      }
    }

    window.pgnFirstMove = function() {
      navigateToMove(0);
    };

    window.pgnPrevMove = function() {
      if (pgnCursor > 0) {
        navigateToMove(pgnCursor - 1);
      }
    };

    window.pgnNextMove = function() {
      if (pgnCursor < fullPGNHistory.length) {
        navigateToMove(pgnCursor + 1);
      }
    };

    window.pgnLastMove = function() {
      navigateToMove(fullPGNHistory.length);
    };

    function updateNavigationButtons() {
      const btnPrev = document.getElementById('btnPrev');
      const btnNext = document.getElementById('btnNext');
      const btnFirst = document.getElementById('btnFirst');
      const btnLast = document.getElementById('btnLast');
      
      if (btnPrev) btnPrev.disabled = pgnCursor <= 0;
      if (btnNext) btnNext.disabled = pgnCursor >= fullPGNHistory.length;
      if (btnFirst) btnFirst.disabled = pgnCursor <= 0;
      if (btnLast) btnLast.disabled = pgnCursor >= fullPGNHistory.length;
      
      
    }



    // ============================================
    // CURSOR MANAGEMENT FUNCTIONS
    // ============================================
    function updateBoardCursor() {
      const boardElement = document.getElementById('chessboard');
      if (!boardElement) return;
      
      if (isNavigationMode) {
        boardElement.parentElement.classList.add('navigation-mode');
      } else {
        boardElement.parentElement.classList.remove('navigation-mode');
      }
    }

    // ============================================
    // PGN / FEN LOAD
    // ============================================
    window.loadPGN = function() {
      if (!chess || !board) return;
      const pgnInput = document.getElementById('pgnInput').value.trim();
      if (!pgnInput) {
  showModal(
    "‚ö†Ô∏è Missing PGN",
    "<p>Please enter a PGN.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}

      try {
        const tempChess = new Chess();
        const success = tempChess.load_pgn(pgnInput);
        

        
        if (!success) {
          throw new Error('Failed to parse PGN');
        }
        
        const moves = tempChess.history({verbose: true});
        fullPGNHistory = moves;
        
        // Load into main chess instance
        chess.load_pgn(pgnInput);
        board.position(chess.fen());
        extractPlayersFromPGN(pgnInput);

        
        pgnCursor = moves.length;
        moveHistory = moves.map((move, index) => ({
          from: move.from,
          to: move.to,
          san: move.san,
          fen: getFenAtMove(index + 1, moves),
          timestamp: new Date()
        }));
        
        isPGNLoaded = true;
        isNavigationMode = false;
        navigateToMove(pgnCursor);

        
        updatePGNViewer();

showModal(
  "‚ôü PGN Loaded",
  "<p>PGN loaded successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

        
        document.getElementById('moveInput').disabled = false;
        document.getElementById('applyMoveBtn').disabled = false;
        updateNavigationButtons();
        renderNotation();
        

        
      } catch (error) {
  console.error("PGN load error:", error);

  showModal(
    "‚ùå PGN Error",
    "<p>‚úÖ PGN loaded successfully!</p>"
  );

  setTimeout(closeModal, 2000);
}

    };



    function getFenAtMove(targetMoveIndex, moves) {
      const tempChess = new Chess();
      for (let i = 0; i < targetMoveIndex && i < moves.length; i++) {
        tempChess.move(moves[i]);
      }
      return tempChess.fen();
    }

    window.loadFEN = function() {
      if (!chess || !board) return;
      const fen = document.getElementById('fenInput').value.trim();
      if (!fen) {
        alert('Please enter FEN');
        return;
      }
      try {
        chess.load(fen);
        board.position(fen);
        moveHistory = [];
        fullPGNHistory = [];
        pgnCursor = 0;
        isNavigationMode = false;
        isPGNLoaded = false;
        updatePGNViewer();
        updateNavigationButtons();
        renderNotation();
       showModal(
  "‚ôü FEN Loaded",
  "<p>FEN loaded successfully.</p>"
);

setTimeout(() => {
  closeModal();
}, 1200);

      } catch (e) {
        console.error('FEN load error:', e);
        alert('Invalid FEN format');
      }
    };

    function updatePGNViewer() {
  const viewer = document.getElementById("pgnViewer");
  viewer.textContent = chess.pgn() || "No moves yet";
  viewer.scrollTop = viewer.scrollHeight;
}


    // ============================================
    // TIMER
    // ============================================
    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      startTime = Date.now();
      elapsedTime = 0;
      timerInterval = setInterval(() => {
        elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        updateTimerDisplay();
      }, 1000);
      document.getElementById('timerDisplay').style.display = 'block';
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function updateTimerDisplay() {
      const minutes = Math.floor(elapsedTime / 60);
      const seconds = elapsedTime % 60;
      document.getElementById('timer').textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${minutes}m ${secs}s`;
    }

    let mouseDownPos = { x: 0, y: 0 };
const DRAG_THRESHOLD = 6; // pixels (lichess-like)


    // ============================================
    // FIXED DRAWING SYSTEM
    // ============================================
    function initDrawingSystem() {
      // Get or create SVG overlay
      const boardWrapper = document.querySelector('.board-wrapper');
      svgOverlay = document.getElementById('boardOverlay');
      
      // Clear existing content
      svgOverlay.innerHTML = '';
      
      // Add arrow marker definition (SMALLER & CLEAN)
const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
const arrowMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');

arrowMarker.setAttribute('id', 'arrowhead');
arrowMarker.setAttribute('markerWidth', '6');
arrowMarker.setAttribute('markerHeight', '6');
arrowMarker.setAttribute('refX', '5');
arrowMarker.setAttribute('refY', '3');
arrowMarker.setAttribute('orient', 'auto');
arrowMarker.setAttribute('markerUnits', 'strokeWidth'); // ‚≠ê important

const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
polygon.setAttribute('points', '0 0, 6 3, 0 6');
polygon.setAttribute('fill', '#057505'); // deep green

arrowMarker.appendChild(polygon);
defs.appendChild(arrowMarker);
svgOverlay.appendChild(defs);

      
      // Add event listeners to the chessboard element
      const chessboardEl = document.getElementById('chessboard');
      if (chessboardEl) {
        // Prevent default context menu on right-click
        chessboardEl.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          // ‚úÖ Left click clears drawings ONLY if not clicking a piece
chessboardEl.addEventListener('mousedown', (e) => {
  // LEFT click only
  if (e.button !== 0) return;

  // If right-click drawing is active, ignore
  if (isRightMouseDown) return;

  // üõë If clicking on a chess piece, do NOT clear
  if (e.target.closest('.piece-417db')) return;

  // ‚úÖ Safe to clear drawings
  clearAllDrawings();
});

          return false;
        });
        
        // Mouse events for drawing
        chessboardEl.addEventListener('mousedown', handleMouseDown);
        chessboardEl.addEventListener('mousemove', handleMouseMove);
        chessboardEl.addEventListener('mouseup', handleMouseUp);
        chessboardEl.addEventListener('mouseleave', handleMouseLeave);
      }
    }

    function showModal(title, message, onOk) {
  const modal = document.getElementById("floatingModal");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  titleEl.textContent = title;
  bodyEl.innerHTML = message.replace(/\n/g, "<br>");

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    if (typeof onOk === "function") onOk();
  };
}





    function handleMouseDown(e) {
  if (e.button !== 2) return;

  e.preventDefault();
  e.stopPropagation();

  isRightMouseDown = true;

  mouseDownPos.x = e.clientX;
  mouseDownPos.y = e.clientY;

  const square = getSquareFromCoordinates(e.clientX, e.clientY);
  if (!square) return;

  drawStartSquare = square;
  isDrawing = true;
}




    function handleMouseMove(e) {
      // Update mouse position
      mousePosition.x = e.clientX;
      mousePosition.y = e.clientY;
      
      if (isDrawing && isRightMouseDown) {
        updateDrawingPreview(e);
      }
    }

    function handleMouseUp(e) {
  if (e.button !== 2) return;

  e.preventDefault();
  e.stopPropagation();

  const dx = e.clientX - mouseDownPos.x;
  const dy = e.clientY - mouseDownPos.y;
  const distance = Math.sqrt(dx * dx + dy * dy);

  const endSquare = getSquareFromCoordinates(e.clientX, e.clientY);

  // üëâ Case 1: NO DRAG ‚Üí draw circle
  if (distance < DRAG_THRESHOLD) {
    if (endSquare) {
      drawCircle(endSquare);
    }
  }
  // üëâ Case 2: DRAG ‚Üí draw arrow
  else if (drawStartSquare && endSquare && drawStartSquare !== endSquare) {
    drawArrow(drawStartSquare, endSquare);
  }

  // Reset state
  isRightMouseDown = false;
  isDrawing = false;
  drawStartSquare = null;
  clearDrawingPreview();
}


    function handleMouseLeave() {
      // Cancel drawing if mouse leaves while drawing
      if (isDrawing) {
        isDrawing = false;
        drawStartSquare = null;
        clearDrawingPreview();
      }
      isRightMouseDown = false;
    }

    function getSquareFromCoordinates(clientX, clientY) {
      if (!board || !chess) return null;
      
      const boardEl = document.getElementById('chessboard');
      const boardRect = boardEl.getBoundingClientRect();
      
      // Calculate relative position within the board element
      const x = clientX - boardRect.left;
      const y = clientY - boardRect.top;
      
      // Calculate square size based on board dimensions
      const squareSize = boardRect.width / 8;
      
      // Calculate file and rank
      let file, rank;
      
      if (boardOrientation === 'white') {
        file = Math.floor(x / squareSize);
        rank = 7 - Math.floor(y / squareSize);
      } else {
        file = 7 - Math.floor(x / squareSize);
        rank = Math.floor(y / squareSize);
      }
      
      // Convert to algebraic notation
      if (file >= 0 && file < 8 && rank >= 0 && rank < 8) {
        const fileChar = String.fromCharCode(97 + file);
        return fileChar + (rank + 1);
      }
      
      return null;
    }

    function getSquareCoordinates(square) {
      if (!board || !chess) return { x: 0, y: 0 };
      
      const boardEl = document.getElementById('chessboard');
      const boardRect = boardEl.getBoundingClientRect();
      const squareSize = boardRect.width / 8;
      
      const file = square.charCodeAt(0) - 97;
      const rank = parseInt(square[1]) - 1;
      
      let x, y;
      
      if (boardOrientation === 'white') {
        x = (file * squareSize) + (squareSize / 2);
        y = ((7 - rank) * squareSize) + (squareSize / 2);
      } else {
        x = ((7 - file) * squareSize) + (squareSize / 2);
        y = (rank * squareSize) + (squareSize / 2);
      }
      
      // Convert to SVG coordinates (relative to SVG)
      return { x, y };
    }

    function updateDrawingPreview(e) {
      if (!drawStartSquare || !isDrawing) return;
      
      clearDrawingPreview();
      
      const startCoords = getSquareCoordinates(drawStartSquare);
      const currentCoords = { 
        x: e.clientX - svgOverlay.getBoundingClientRect().left,
        y: e.clientY - svgOverlay.getBoundingClientRect().top
      };
      
      // Draw preview line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', startCoords.x);
      line.setAttribute('y1', startCoords.y);
      line.setAttribute('x2', currentCoords.x);
      line.setAttribute('y2', currentCoords.y);
      line.setAttribute('stroke', '#00ff00');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-dasharray', '5,5');
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('class', 'drawing-preview');
      line.setAttribute('opacity', '0.7');
      
      svgOverlay.appendChild(line);
    }

    function clearDrawingPreview() {
      const previews = svgOverlay.querySelectorAll('.drawing-preview');
      previews.forEach(el => el.remove());
    }

    function drawArrow(fromSquare, toSquare) {
      const fromCoords = getSquareCoordinates(fromSquare);
      const toCoords = getSquareCoordinates(toSquare);
      
      // Create arrow
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', fromCoords.x);
      line.setAttribute('y1', fromCoords.y);
      line.setAttribute('x2', toCoords.x);
      line.setAttribute('y2', toCoords.y);
      line.setAttribute('stroke', '#00ff00');
      line.setAttribute('stroke-width', '2.8');
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('marker-end', 'url(#arrowhead)');
      line.setAttribute('class', 'drawing-arrow');
      line.setAttribute('data-from', fromSquare);
      line.setAttribute('data-to', toSquare);
      
      svgOverlay.appendChild(line);
      
      // Store drawing
      saveDrawing('arrow', { from: fromSquare, to: toSquare });
    }

    function drawCircle(square) {
  const coords = getSquareCoordinates(square);
  const boardEl = document.getElementById('chessboard');
  const boardRect = boardEl.getBoundingClientRect();
  const squareSize = boardRect.width / 8;

  // üü¢ LICHESS-BOLD VALUES
  const radius = squareSize * 0.41;          // almost touching square
  const strokeWidth = squareSize * 0.070;     // VERY bold (this was missing)

  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circle.setAttribute('cx', coords.x);
  circle.setAttribute('cy', coords.y);
  circle.setAttribute('r', radius);
  circle.setAttribute('fill', 'none');
  circle.setAttribute('stroke', '#057505');
  circle.setAttribute('stroke-width', strokeWidth);
  circle.setAttribute('opacity', '0.70');
  circle.setAttribute('class', 'drawing-circle');
  circle.setAttribute('data-square', square);

  svgOverlay.appendChild(circle);

  saveDrawing('circle', { square });
}




    function saveDrawing(type, data) {
      const currentFen = chess.fen();
      
      if (!drawings.has(currentFen)) {
        drawings.set(currentFen, []);
      }
      
      drawings.get(currentFen).push({ type, data, timestamp: Date.now() });
      
      // Update current drawings
      currentDrawings = drawings.get(currentFen);
    }

    window.clearAllDrawings = function() {
      // Remove all drawings from SVG
      const arrows = svgOverlay.querySelectorAll('.drawing-arrow, .drawing-circle');
      arrows.forEach(el => el.remove());
      
      // Clear drawings for current position
      const currentFen = chess.fen();
      if (drawings.has(currentFen)) {
        drawings.delete(currentFen);
      }
      
      currentDrawings = [];
    };

    function loadDrawingsForPosition(fen) {
      // Clear existing drawings
      const arrows = svgOverlay.querySelectorAll('.drawing-arrow, .drawing-circle');
      arrows.forEach(el => el.remove());
      
      // Load drawings for this position
      if (drawings.has(fen)) {
        const positionDrawings = drawings.get(fen);
        positionDrawings.forEach(drawing => {
          if (drawing.type === 'arrow') {
            drawArrow(drawing.data.from, drawing.data.to);
          } else if (drawing.type === 'circle') {
            drawCircle(drawing.data.square);
          }
        });
      }
    }

    function updateEngineVisibility() {
  const enginePanel = document.getElementById("enginePanel");
  const analyzeBtn = document.getElementById("analyzeBtn");

  if (!enginePanel || !analyzeBtn) return;

  // üö´ Student + assignment ‚Üí hide
  if (currentProfile.role === "student" && isAssignmentMode) {
    enginePanel.style.display = "none";
    analyzeBtn.style.display = "none";
  } 
  // ‚úÖ Teacher / Admin OR free mode ‚Üí show
  else {
    enginePanel.style.display = "block";
    analyzeBtn.style.display = "block";
  }
}


    function showPuzzleRushResult(reason, score) {
  document.getElementById("prResultReason").textContent = reason;
  document.getElementById("prResultScore").textContent = score;

  document
    .getElementById("puzzleRushResultModal")
    .classList.remove("hidden");
}

function hidePuzzleRushResult() {
  document
    .getElementById("puzzleRushResultModal")
    .classList.add("hidden");

  document.getElementById("puzzleRushGame").classList.add("hidden");
  document.getElementById("puzzleRushMenu").classList.remove("hidden");
}



    // ============================================
    // ASSIGNMENTS
    // ============================================

    

    async function loadAssignments() {
    
  const listEl = document.getElementById('assignmentsList');
  listEl.innerHTML = '<div class="loading">Loading assignments...</div>';

  try {
    let assignments = [];

    if (currentProfile.role === 'admin') {
      const { data, error } = await supabase
        .from('assignments')
        .select('*')
        .order('created_at', { ascending: false });
      if (error) throw error;
      assignments = data || [];
    } else {
      console.log("STUDENT UUID:", currentProfile.id);
      const { data, error } = await supabase
  .from('assignments')
  .select('*')
  .eq('status', 'active')
  .or(
    `is_public.eq.true,assigned_to.cs.["${currentProfile.id}"]`
  )
  .order('created_at', { ascending: false });
      if (error) throw error;
      console.log("STUDENT assignments data:", data);
      assignments = data || [];
    }

    if (assignments.length === 0) {
      listEl.innerHTML = '<div class="card"><p>No assignments available yet.</p></div>';
      return;
    }

    listEl.innerHTML = assignments.map(assign => `
      <div class="card" data-assignment-id="${assign.id}">
        <h4>${assign.title || 'Untitled Assignment'}</h4>
        <p>${assign.description || 'No description provided.'}</p>
        <p><strong>Type:</strong> ${assign.task_type || 'General'} | <strong>Status:</strong> ${assign.status || 'active'}</p>
        ${assign.due_at ? `<p><strong>Due:</strong> ${new Date(assign.due_at).toLocaleDateString()}</p>` : ''}
        <div class="assignment-actions">

  ${currentProfile.role === 'admin'
    ? `
      <button class="btn-secondary" data-action="view" data-id="${assign.id}">
        View Details
      </button>

      <button class="btn-primary" data-action="test" data-id="${assign.id}">
        Test Assignment
      </button>

      <button class="btn-danger" data-action="delete" data-id="${assign.id}">
        üóë Delete
      </button>
    `
    : `
      <button class="btn-primary" data-action="start" data-id="${assign.id}">
        Start Assignment
      </button>
    `
  }
</div>
      </div>
    `).join('');

  } catch (error) {
    console.error('Error loading assignments:', error);
    listEl.innerHTML = '<div class="card"><p style="color: #ff4757;">Error loading assignments. Please try again later.</p></div>';
  }
}

document.getElementById('assignmentsList').addEventListener('click', (e) => {
  const btn = e.target.closest('button');
  if (!btn) return;

  const action = btn.dataset.action;
  const assignmentId = btn.dataset.id;

  if (action === 'delete') {
    confirmDeleteAssignment(assignmentId);
  }
});

function confirmDeleteAssignment(assignmentId) {
  if (currentProfile.role !== "admin") return;

  pendingDeleteAssignmentId = assignmentId;
  document.getElementById("deleteModal").classList.remove("hidden");

}


const prResultBtn = document.getElementById("prResultBtn");
if (prResultBtn) {
  prResultBtn.addEventListener("click", hidePuzzleRushResult);
}








async function deleteAssignmentFromDB(assignmentId) {
  try {
    const { error } = await supabase
      .from("assignments")
      .delete()
      .eq("id", assignmentId);

    if (error) throw error;

    showStatus("üóë Assignment deleted successfully", "success");
    loadAssignments();

  } catch (err) {
    console.error(err);
    showStatus("‚ùå Failed to delete assignment", "error");
  }
}

document.getElementById("cancelDeleteBtn").onclick = () => {
  pendingDeleteAssignmentId = null;
  document.getElementById("deleteModal").classList.add("hidden");
};

document.getElementById("confirmDeleteBtn").onclick = async () => {
  if (!pendingDeleteAssignmentId) return;

  await deleteAssignmentFromDB(pendingDeleteAssignmentId);

  pendingDeleteAssignmentId = null;
  document.getElementById("deleteModal").classList.add("hidden");
};







window.startAssignmentMode = async function (assignmentId) {
  console.log("Fetching assignment:", assignmentId);

  const { data: assignment, error } = await supabase
    .from("assignments")
    .select("*")
    .eq("id", assignmentId)
    .single();

  if (error || !assignment) {
    console.error("Assignment load error:", error);
    alert("Assignment not found.");
    return;
  }

  // Hide only PGN upload tools & admin stuff ‚Äî NOT the whole panel
document.getElementById("pgnUploadSection").style.display = "none";



  // FIXED ‚Äî Auto open Chess Board tab
  document.querySelector('[data-tab="board"]').click();

  // Launch interactive mode
  startInteractiveAssignment(assignment);
};

async function loadStudyDropdown() {
  const select = document.getElementById("studySelect");
  if (!select) return;

  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("id, title")
    .order("created_at", { ascending: false });

  if (error) {
    console.error("‚ùå PGN load error:", error);
    return;
  }

  select.innerHTML = `<option value="">Study</option>`;

  data.forEach(pgn => {
    const opt = document.createElement("option");
    opt.value = pgn.id;
    opt.textContent = pgn.title;
    select.appendChild(opt);
  });
}

function loadStudyFromPGN(pgnText, studyTitle) {
  const list = document.getElementById("studyList");
  list.innerHTML = "";

  const games = pgnText
    .split(/\n\n(?=\[Event)/g) // split multiple games safely
    .filter(Boolean);

  // Study title
  const header = document.createElement("div");
  header.className = "study-item active";
  header.textContent = `‚ñ∂ ${studyTitle}`;
  list.appendChild(header);

  games.forEach((gamePgn, index) => {
    const chapter = document.createElement("div");
    chapter.className = "study-chapter";
    chapter.textContent = `${index + 1}. Chapter ${index + 1}`;

    chapter.addEventListener("click", () => {
      loadStudyChapter(gamePgn);
    });

    list.appendChild(chapter);
  });
}

function loadStudyChapter(pgn) {
  studyChess.reset();
  studyChess.load_pgn(pgn);
  studyBoard.position(studyChess.fen());
  renderStudyNotation(studyChess.history({ verbose: true }));
}


document.addEventListener("change", async (e) => {
  if (e.target.id !== "studySelect") return;

  const pgnId = e.target.value;
  if (!pgnId) return;

  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("pgn, title")
    .eq("id", pgnId)
    .single();

  if (error) return;

  loadStudyFromPGN(data.pgn, data.title);
});

function resetStudyState() {
  studyChess = new Chess();
  studyMoves.length = 0;
  currentMoveIndex = -1;
  document.getElementById("studyNotation").innerHTML = "";
}




async function loadStudentsForAssignment() {
  const select = document.getElementById("assignStudentsSelect");
  if (!select) return;

  select.innerHTML = "";

  const { data, error } = await supabase
    .from("profiles")
    .select("id, username")
    .eq("role", "student")
    .eq("active", true)
    .order("username");

  if (error) {
    console.error("Failed to load students", error);
    return;
  }

  data.forEach(student => {
    const option = document.createElement("option");
    option.value = student.id;
    option.textContent = student.username;
    select.appendChild(option);
  });
}

async function loadStudentsForAssignment2() {
  const box = document.getElementById("assignStudentsBox");
  if (!box) return;

  box.innerHTML = "<div style='opacity:.7'>Loading students‚Ä¶</div>";

  try {
    const { data, error } = await supabase
      .from("profiles")
      .select("id, username")
      .eq("role", "student")
      .eq("active", true)
      .order("username");

    if (error) throw error;

    box.innerHTML = "";

    if (!data || data.length === 0) {
      box.innerHTML = "<div style='opacity:.7'>No students found</div>";
      return;
    }

    data.forEach(student => {
  const row = document.createElement("label");

  row.style.display = "flex";
  row.style.alignItems = "center";
  row.style.justifyContent = "space-between";
  row.style.padding = "6px 10px";
  row.style.cursor = "pointer";
  row.style.borderBottom = "1px solid rgba(255,255,255,0.05)";

  row.innerHTML = `
  <span style="flex:1; text-align:left;">${student.username}</span>
  <span style="width:60px; text-align:right;">
    <input type="checkbox" value="${student.id}">
  </span>
`;


  box.appendChild(row);
});


  } catch (err) {
    console.error("loadStudentsForAssignment error:", err);
    box.innerHTML = "<div style='color:red'>Failed to load students</div>";
  }
}


function getSelectedStudentIds() {
  const box = document.getElementById("assignStudentsBox");
  if (!box) return [];

  return Array.from(
    box.querySelectorAll("input[type='checkbox']:checked")
  ).map(cb => cb.value);
}


function updatePlayerNames(white, black) {
  const whiteContainer = document.getElementById("whitePlayer");
  const blackContainer = document.getElementById("blackPlayer");

  if (whiteContainer) {
    const span = whiteContainer.querySelector("span");
    if (span) span.textContent = white || "White player";
  }

  if (blackContainer) {
    const span = blackContainer.querySelector("span");
    if (span) span.textContent = black || "Black player";
  }
}

function extractPlayersFromPGN(pgn) {
  if (!pgn) {
    updatePlayerNames();
    return;
  }

  const whiteMatch = pgn.match(/\[White\s+"([^"]+)"\]/i);
  const blackMatch = pgn.match(/\[Black\s+"([^"]+)"\]/i);

  const whiteName = whiteMatch ? whiteMatch[1] : null;
  const blackName = blackMatch ? blackMatch[1] : null;

  updatePlayerNames(whiteName, blackName);
}


async function loadStudentsForLiveClass() {
  if (!currentProfile || currentProfile.role !== 'admin') return;

  const list = document.getElementById('liveStudentsList');
  if (!list) return;

  list.innerHTML = 'Loading students...';

  const { data, error } = await supabase
    .from('profiles')
    .select('id, username')
    .eq('role', 'student')
    .eq('active', true)
    .order('username', { ascending: true });

  if (error) {
    console.error(error);
    list.innerHTML = '<p style="color:red">Failed to load students</p>';
    return;
  }

  if (!data || data.length === 0) {
    list.innerHTML = '<p>No active students</p>';
    return;
  }

  list.innerHTML = '';

  data.forEach(student => {
    const row = document.createElement('label');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '8px';
    row.style.marginBottom = '6px';

    row.innerHTML = `
      <input type="checkbox" value="${student.id}">
      <span>${student.username}</span>
    `;

    list.appendChild(row);
  });
}

// PGN DATABASE START //



async function savePGNToLibrary() {
  const titleInput = document.getElementById("assignTitle");
  const pgnInput = document.getElementById("assignPGN");

  if (!titleInput || !pgnInput) {
    alert("Assignment fields not found");
    return;
  }

  const title = titleInput.value.trim();
  const pgn = pgnInput.value.trim();

  if (!title) {
    alert("Please enter a title (this will be used as PGN name)");
    return;
  }

  if (!pgn) {
    alert("Please paste a PGN first");
    return;
  }

  const { error } = await supabase
    .from("bulk_pgn_library")
    .insert({
      title,
      pgn,
      is_active: true
    });

  if (error) {
    console.error("Save PGN failed:", error.message);
    alert("Failed to save PGN (check admin access)");
    return;
  }

  alert("PGN saved to library ‚úÖ");

  // Refresh library panel
  loadPGNLibrary();
}


async function loadPGNLibrary() {
  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("id, title, puzzle_count, created_at, pgn")
    .eq("is_active", true)
    .order("created_at", { ascending: false });

  if (error) {
    console.error("Failed to load PGN library:", error.message);
    return;
  }

  renderPGNLibrary(data || []);
}


function renderPGNLibrary(pgNs) {
  const container = document.getElementById("pgnLibraryList");
  if (!container) return;

  container.innerHTML = "";

  if (!pgNs.length) {
    container.innerHTML = `<p style="opacity:.6;">No PGNs saved yet</p>`;
    return;
  }

  pgNs.forEach(pgn => {
    container.innerHTML += `
  <div class="pgn-item" style="position:relative; margin-bottom:10px;">
    <strong>${pgn.title}</strong>

    <div class="pgn-controls">
  <label>
    <input type="radio" name="pgnMode_${pgn.id}" value="single" checked>
    <span>Single</span>
  </label>

  <label>
    <input type="radio" name="pgnMode_${pgn.id}" value="bulk">
    <span>Bulk</span>
  </label>

  <button class="btn-small" onclick="usePGNFromLibrary(${pgn.id})">
    Use PGN
  </button>

  <button
    class="btn-small danger"
    onclick="deletePGNFromLibrary(${pgn.id})"
  >
    üóë Delete
  </button>
</div>

  </div>
`;

  });
}







// üî• MUST be global
window.usePGNFromLibrary = async function (pgnId) {
  try {
    // 1Ô∏è‚É£ Read mode safely
    let mode = "single";
    const modeInput = document.querySelector(
      `input[name="pgnMode_${pgnId}"]:checked`
    );
    if (modeInput) {
      mode = modeInput.value;
    }

    // 2Ô∏è‚É£ Fetch PGN from Supabase
    const { data, error } = await supabase
      .from("bulk_pgn_library")
      .select("title, pgn")
      .eq("id", pgnId)
      .single();

    if (error || !data) {
      console.error(error);
      alert("Failed to load PGN");
      return;
    }

    // 3Ô∏è‚É£ Fill assignment title if empty
    const titleInput = document.getElementById("assignTitle");
    if (titleInput && !titleInput.value) {
      titleInput.value = data.title;
    }

    // 4Ô∏è‚É£ Fill PGN textarea
    const pgnTextarea = document.getElementById("assignPGN");
    if (!pgnTextarea) {
      alert("Assignment PGN field not found");
      return;
    }

    pgnTextarea.value = data.pgn.trim();

    // 5Ô∏è‚É£ Show form
    const form = document.getElementById("createAssignmentForm");
    if (form) {
      form.style.display = "block";
    }

    pgnTextarea.scrollIntoView({ behavior: "smooth", block: "center" });

    showModal(
  "‚ôü PGN Loaded",
  `<p>PGN loaded as <strong>${mode.toUpperCase()}</strong> successfully.</p>`
);

setTimeout(() => {
  closeModal();
}, 1500);

} catch (err) {
  console.error("usePGNFromLibrary error:", err);

  showModal(
    "‚ùå PGN Load Error",
    "<p>Unexpected error while loading the PGN.<br>Please try again.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2000);
}
};



window.deletePGNFromLibrary = function (pgnId) {
  openGradeConfirm(
    "üóëÔ∏è Delete PGN",
    "<p>Are you sure you want to delete this PGN?<br>This action cannot be undone.</p>",
    async () => {
      try {
        const { error } = await supabase
          .from("bulk_pgn_library")
          .update({ is_active: false })
          .eq("id", pgnId);

        if (error) throw error;

        showModal(
          "‚úÖ PGN Deleted",
          "<p>The PGN has been deleted successfully.</p>"
        );

        setTimeout(() => {
          closeModal();
        }, 1500);

        await loadPGNLibrary(); // üî• force refresh

      } catch (err) {
        console.error(err);

        showModal(
          "‚ùå Error",
          "<p>Failed to delete PGN.<br>Please try again.</p>"
        );

        setTimeout(() => {
          closeModal();
        }, 2000);
      }
    }
  );
};




function openPGNTitleModal(onConfirm) {
  const modal = document.getElementById("pgnTitleModal");
  const input = document.getElementById("pgnTitleInput");
  const confirmBtn = document.getElementById("confirmPGNTitle");
  const cancelBtn = document.getElementById("cancelPGNTitle");

  input.value = "";
  modal.classList.remove("hidden");
  input.focus();

  const cleanup = () => {
    modal.classList.add("hidden");
    confirmBtn.onclick = null;
    cancelBtn.onclick = null;
  };

  cancelBtn.onclick = cleanup;

  confirmBtn.onclick = () => {
    const title = input.value.trim();
    if (!title) {
      alert("Title required");
      return;
    }
    cleanup();
    onConfirm(title);
  };
}


function formatSecondsToTime(value) {
  const seconds = Number(value);
  if (!seconds || isNaN(seconds)) return "0s";

  const m = Math.floor(seconds / 60);
  const s = seconds % 60;

  return m > 0 ? `${m}m ${s}s` : `${s}s`;
}




// PGN DATABASE END //

// Puzzle Rush mate in 1 start //
// ===============================
// ‚ö° PUZZLE RUSH ‚Äì LOAD MATE IN 1
// ===============================
async function loadMateIn1Puzzles() {
  const { data, error } = await supabase
    .from("puzzle_rush_mate1")
    .select("id, fen, solution, side_to_move")
    .eq("is_active", true);

  if (error) {
    console.error("‚ùå Failed to load Mate in 1 puzzles", error);
    return [];
  }

  console.log("‚ö° Mate in 1 puzzles loaded:", data.length);
  return data;
}


// puzzle rush mate in 1 end //


// STUDENT PROGRESS FUNCTIONS START //
async function loadStudentProgress() {
  const list = document.getElementById("studentProgressList");
  if (!list) return;

  list.innerHTML = "<p class='muted'>Loading progress...</p>";

  const { data, error } = await supabase
    .from("attempts")
    .select(`
      assignment_id,
      time_spent,
      is_correct,
      submitted_at,
      assignments ( title )
    `)
    .eq("student_id", currentUser.id)
    .order("submitted_at", { ascending: false });

  if (error) {
    console.error("Progress load error:", error);
    list.innerHTML = "<p class='muted'>Failed to load progress.</p>";
    return;
  }

  if (!data || data.length === 0) {
    list.innerHTML = "<p class='muted'>No attempts yet.</p>";
    return;
  }

  // Group by assignment
  const progressMap = {};

  for (const row of data) {
    const id = row.assignment_id;

    if (!progressMap[id]) {
      progressMap[id] = {
  assignmentId: id,
  title: row.assignments?.title || "Unknown assignment",
  attempts: 0,
  status: "Attempted",
  time: row.time_spent,
  lastPlayed: row.submitted_at
};

    }

    progressMap[id].attempts += 1;

    if (row.is_correct) {
      progressMap[id].status = "Solved";
    }
  }

  // ‚úÖ STEP 4A: count EVERY successful submission (not grouped)
const solvedCount = data.filter(row => row.is_correct === true).length;

studentSolvedCount = solvedCount;
console.log("üèÖ Student solved submissions:", studentSolvedCount);

const unlockable = getUnlockableBadges();
console.log(
  "üîì Unlockable badges:",
  unlockable.map(b => `${b.title} (req ${b.required})`)
);

// REQUIRED
loadUnlockedBadges();
renderStudentBadges();



  // Render
  list.innerHTML = "";

  const orderedProgress = Object.values(progressMap).sort(
  (a, b) => new Date(b.lastPlayed) - new Date(a.lastPlayed)
);

orderedProgress.forEach(p => {
  list.innerHTML += `
    <div class="progress-item">
      <strong>${p.title}</strong>
      <div class="progress-meta">
        Attempts: ${p.attempts} |
        Status: ${p.status} |
        Time: ${formatSecondsToTime(p.time)}
      </div>
      <div class="progress-date">
        Last played: ${new Date(p.lastPlayed).toLocaleDateString()}
      </div>
      <div class="progress-actions">
        <button
  class="btn-small reattempt-btn"
  data-assignment-id="${p.assignmentId}"
>
  Re-attempt
</button>



        <button
  class="btn-small view-details-btn"
  data-assignment-id="${p.assignmentId}"
>
  View details
</button>

      </div>
      <hr />
    </div>
  `;
});

}

async function reattemptAssignment(assignmentId) {
  try {
    console.log("Re-attempting assignment:", assignmentId);

    const { data: assignment, error } = await supabase
      .from("assignments")
      .select("*")
      .eq("id", assignmentId)
      .single();

    if (error || !assignment) {
      showStatus("Assignment not found", "error");
      return;
    }

    // üîÅ FULL RESET (important)
    currentAssignment = null;
    expectedMoves = [];
    assignmentCursor = 0;
    attemptCount = 0;
    bulkIndex = 0;
    bulkPuzzles = [];

    // Switch to board
    document.querySelector('[data-tab="board"]').click();

    // Start fresh attempt
    startInteractiveAssignment(assignment);

    showStatus("üîÅ Re-attempt started", "info");

  } catch (err) {
    console.error("Re-attempt failed:", err);
    showStatus("Failed to re-attempt assignment", "error");
  }
}

async function viewAssignmentDetailsForStudent(assignmentId) {
  try {
    const { data: assignment, error } = await supabase
      .from("assignments")
      .select(`
        title,
        description,
        task_type,
        due_at,
        created_at
      `)
      .eq("id", assignmentId)
      .single();

    if (error || !assignment) {
      showModal("‚ùå Error", "<p>Assignment details not found.</p>");
      return;
    }

    const html = `
      <p><strong>Title:</strong> ${assignment.title}</p>
      <p><strong>Type:</strong> ${assignment.task_type}</p>
      <p><strong>Created:</strong> ${new Date(assignment.created_at).toLocaleString()}</p>
      ${assignment.due_at ? `<p><strong>Due:</strong> ${new Date(assignment.due_at).toLocaleString()}</p>` : ""}
      <hr>
      <p><strong>Description:</strong></p>
      <p>${assignment.description || "No description provided."}</p>
    `;

    showModal("üìò Assignment Details", html);

  } catch (err) {
    console.error(err);
    showModal("‚ùå Error", "<p>Something went wrong.</p>");
  }
}






// STUDENT PROGRESS FUNCTIONS END //



function openStudentModal(studentId, username) {
  document.getElementById("studentModalTitle").textContent =
    `üë§ ${username} ‚Äî Full Details`;

  document.getElementById("studentModalBody").innerHTML =
    `<p class="loading">Fetching data‚Ä¶</p>`;

  document.getElementById("studentDetailsModal").classList.remove("hidden");

  // ‚úÖ LOAD REAL DATA
  loadStudentFullDetails(studentId);
}


function closeStudentModal() {
  document.getElementById("studentDetailsModal").classList.add("hidden");
}



async function loadStudentFullDetails(studentId) {
  try {
    // 1Ô∏è‚É£ Profile
    const { data: profile, error: profileError } = await supabase
      .from("profiles")
      .select("username, active, created_at")
      .eq("id", studentId)
      .single();

    if (profileError) throw profileError;

    // 2Ô∏è‚É£ Attempts + assignments
    const { data: attempts, error: attemptsError } = await supabase
      .from("attempts")
      .select(`
        id,
        submitted_at,
        time_spent,
        attempt_count,
        is_correct,
        assignments ( title )
      `)
      .eq("student_id", studentId)
      .order("submitted_at", { ascending: false });

    if (attemptsError) throw attemptsError;

    renderStudentModal(profile, attempts || []);
  } catch (err) {
    console.error(err);
    document.getElementById("studentModalBody").innerHTML =
      `<p style="color:#ff6b6b;">Failed to load student data</p>`;
  }
}

function getUnlockedAchievementCount(studentId) {
  try {
    const key = `unlocked_badges_${studentId}`;
    const raw = localStorage.getItem(key);
    if (!raw) return 0;

    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed.length : 0;
  } catch {
    return 0;
  }
}

/* ================================
   üéØ TARGET OBJECT SYSTEM (GLOBAL)
================================ */

// add your 20+ fun images here
const TARGET_IMAGES = [
  "assets/targets/ball.png",
  "assets/targets/burger.png",
  "assets/targets/chocolate.png",
  "assets/targets/cube.png",
  "assets/targets/star.png",
  "assets/targets/popcorn.png",
  "assets/targets/ele.png",
  "assets/targets/lorry.png",
  "assets/targets/duck.png",
  "assets/targets/dino.png",
  "assets/targets/cube.png",
  "assets/targets/robo.png",
  "assets/targets/truck.png",
  "assets/targets/unicorn.png"
  
];

// utility
function randomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function getRandomTarget() {
  return TARGET_IMAGES[Math.floor(Math.random() * TARGET_IMAGES.length)];
}



let misses = 0;
const missEl = document.getElementById("knightMisses");

let knightTarget = null;
let knightTargetImg = null;



const boardEl = document.getElementById("miniBoard");
const starEl = document.getElementById("stars");
const startBtn = document.getElementById("startMiniGame");

let knightPos = { x: 3, y: 3 };
let correctSquares = [];
let stars = 0;

const knightMoves = [
  [1,2],[2,1],[-1,2],[-2,1],
  [1,-2],[2,-1],[-1,-2],[-2,-1]
];

function drawBoard() {
  boardEl.innerHTML = "";
  correctSquares = [];

  // 1Ô∏è‚É£ calculate knight legal moves FIRST
  knightMoves.forEach(([dx, dy]) => {
    const nx = knightPos.x + dx;
    const ny = knightPos.y + dy;
    if (nx >= 0 && ny >= 0 && nx < 8 && ny < 8) {
      correctSquares.push(`${nx}-${ny}`);
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x); // a‚Äìh
      sq.dataset.rank = 8 - y;                        // 8‚Äì1

      // ‚ôò knight
      if (x === knightPos.x && y === knightPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wN.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object (if enabled)
      if (
        typeof knightTarget !== "undefined" &&
        knightTarget &&
        x === knightTarget.x &&
        y === knightTarget.y
      ) {
        const t = document.createElement("img");
        t.src = knightTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.onclick = () => handleClick(sq);
      boardEl.appendChild(sq);
    }
  }
}


function handleClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);

  const key = `${x}-${y}`;

  // ‚ùå illegal knight move
  if (!correctSquares.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal move
  square.classList.add("correct");

  // move knight
  knightPos = { x, y };

  // üéØ TARGET REACHED!
  if (knightTarget && x === knightTarget.x && y === knightTarget.y) {
    stars++;
    starEl.textContent = stars;

    setTimeout(startGame, 400); // next puzzle
    return;
  }

  // continue same puzzle
  setTimeout(drawBoard, 300);
}


function startGame() {
  stars = 0;
  starEl.textContent = stars;

  knightPos = randomSquare();

  // üéØ spawn target (not on knight)
  do {
    knightTarget = randomSquare();
  } while (
    knightTarget.x === knightPos.x &&
    knightTarget.y === knightPos.y
  );

  knightTargetImg = getRandomTarget();

  drawBoard();
}


startBtn.onclick = startGame;

function nextKnightRound() {
  knightPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawBoard();
}


let bishopMisses = 0;
const bishopMissEl = document.getElementById("bishopMisses");
let bishopTarget = null;
let bishopTargetImg = null;


const bishopBoard = document.getElementById("bishopBoard");
const bishopStarEl = document.getElementById("bishopStars");
const bishopStartBtn = document.getElementById("bishopStart");

let bishopPos = { x: 3, y: 3 };
let bishopCorrect = [];
let bishopStars = 0;

// ‚ôó Bishop diagonals
const bishopDirections = [
  [1,1], [1,-1], [-1,1], [-1,-1]
];

function drawBishopBoard() {
  bishopBoard.innerHTML = "";
  bishopCorrect = [];

  // 1Ô∏è‚É£ calculate bishop diagonals FIRST
  bishopDirections.forEach(([dx, dy]) => {
    let x = bishopPos.x + dx;
    let y = bishopPos.y + dy;

    while (x >= 0 && y >= 0 && x < 8 && y < 8) {
      bishopCorrect.push(`${x}-${y}`);
      x += dx;
      y += dy;
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // ‚ôó bishop
      if (x === bishopPos.x && y === bishopPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wB.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object
      if (
        bishopTarget &&
        x === bishopTarget.x &&
        y === bishopTarget.y
      ) {
        const t = document.createElement("img");
        t.src = bishopTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.onclick = () => bishopClick(sq);
      bishopBoard.appendChild(sq);
    }
  }
}


function bishopClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal bishop move
  if (!bishopCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal move
  square.classList.add("correct");

  bishopPos = { x, y };

  // üéØ target reached
  if (
    bishopTarget &&
    x === bishopTarget.x &&
    y === bishopTarget.y
  ) {
    bishopStars++;
    bishopStarEl.textContent = bishopStars;

    setTimeout(startBishopGame, 400);
    return;
  }

  setTimeout(drawBishopBoard, 300);
}



function nextBishopRound() {
  bishopPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawBishopBoard();
}

function startBishopGame() {
  bishopStars = 0;
  bishopStarEl.textContent = bishopStars;

  bishopPos = randomSquare();

  function sameSquareColor(a, b) {
  return (a.x + a.y) % 2 === (b.x + b.y) % 2;
}

  // üéØ spawn target on SAME COLOR square
  do {
    bishopTarget = randomSquare();
  } while (
    (bishopTarget.x === bishopPos.x && bishopTarget.y === bishopPos.y) ||
    !sameSquareColor(bishopPos, bishopTarget)
  );

  bishopTargetImg = getRandomTarget();

  drawBishopBoard();
}



bishopStartBtn.onclick = startBishopGame;

let rookMisses = 0;
const rookMissEl = document.getElementById("rookMisses");

let rookTarget = null;
let rookTargetImg = null;


const rookBoard = document.getElementById("rookBoard");
const rookStarEl = document.getElementById("rookStars");
const rookStartBtn = document.getElementById("rookStart");

let rookPos = { x: 3, y: 3 };
let rookCorrect = [];
let rookStars = 0;

function drawRookBoard() {
  rookBoard.innerHTML = "";
  rookCorrect = [];

  // 1Ô∏è‚É£ calculate rook moves (same rank & file)
  for (let i = 0; i < 8; i++) {
    if (i !== rookPos.x) rookCorrect.push(`${i}-${rookPos.y}`);
    if (i !== rookPos.y) rookCorrect.push(`${rookPos.x}-${i}`);
  }

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // ‚ôñ rook
      if (x === rookPos.x && y === rookPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wR.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object
      if (
        rookTarget &&
        x === rookTarget.x &&
        y === rookTarget.y
      ) {
        const t = document.createElement("img");
        t.src = rookTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.onclick = () => rookClick(sq);
      rookBoard.appendChild(sq);
    }
  }
}



function rookClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal rook move (not same rank/file)
  if (!rookCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal step
  square.classList.add("correct");

  // move rook
  rookPos = { x, y };

  // üéØ target reached
  if (
    rookTarget &&
    x === rookTarget.x &&
    y === rookTarget.y
  ) {
    rookStars++;
    rookStarEl.textContent = rookStars;

    setTimeout(startRookGame, 400);
    return;
  }

  // continue SAME puzzle
  setTimeout(drawRookBoard, 300);
}



function nextRookRound() {
  rookPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawRookBoard();
}

function startRookGame() {
  rookStars = 0;
  rookStarEl.textContent = rookStars;

  rookPos = randomSquare();

  // üéØ target can be ANYWHERE except rook square
  do {
    rookTarget = randomSquare();
  } while (
    rookTarget.x === rookPos.x &&
    rookTarget.y === rookPos.y
  );

  rookTargetImg = getRandomTarget();

  drawRookBoard();
}



rookStartBtn.onclick = startRookGame;


let queenMisses = 0;
const queenMissEl = document.getElementById("queenMisses");

let queenTarget = null;
let queenTargetImg = null;


const queenBoard = document.getElementById("queenBoard");
const queenStarEl = document.getElementById("queenStars");
const queenStartBtn = document.getElementById("queenStart");

let queenPos = { x: 3, y: 3 };
let queenCorrect = [];
let queenStars = 0;

// rook + bishop directions
const queenDirs = [
  [1,0],[-1,0],[0,1],[0,-1],   // rook
  [1,1],[1,-1],[-1,1],[-1,-1] // bishop
];

function drawQueenBoard() {
  queenBoard.innerHTML = "";
  queenCorrect = [];

  // 1Ô∏è‚É£ calculate queen moves (rook + bishop)
  queenDirs.forEach(([dx, dy]) => {
    let x = queenPos.x + dx;
    let y = queenPos.y + dy;

    while (x >= 0 && y >= 0 && x < 8 && y < 8) {
      queenCorrect.push(`${x}-${y}`);
      x += dx;
      y += dy;
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // ‚ôõ queen
      if (x === queenPos.x && y === queenPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wQ.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object (ANYWHERE)
      if (
        queenTarget &&
        x === queenTarget.x &&
        y === queenTarget.y
      ) {
        const t = document.createElement("img");
        t.src = queenTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.onclick = () => queenClick(sq);
      queenBoard.appendChild(sq);
    }
  }
}


function queenClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal queen move
  if (!queenCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal step
  square.classList.add("correct");
  queenPos = { x, y };

  // üéØ target reached
  if (
    queenTarget &&
    x === queenTarget.x &&
    y === queenTarget.y
  ) {
    queenStars++;
    queenStarEl.textContent = queenStars;

    setTimeout(startQueenGame, 400);
    return;
  }

  // continue same puzzle
  setTimeout(drawQueenBoard, 300);
}


function nextQueenRound() {
  queenPos = {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
  drawQueenBoard();
}

function startQueenGame() {
  queenStars = 0;
  queenStarEl.textContent = queenStars;

  queenPos = randomSquare();

  // üéØ target can be ANYWHERE except queen square
  do {
    queenTarget = randomSquare();
  } while (
    queenTarget.x === queenPos.x &&
    queenTarget.y === queenPos.y
  );

  queenTargetImg = getRandomTarget();

  drawQueenBoard();
}


queenStartBtn.onclick = startQueenGame;


let pawnMisses = 0;
const pawnMissEl = document.getElementById("pawnMisses");

let pawnTarget = null;
let pawnTargetImg = null;


const pawnBoard = document.getElementById("pawnBoard");
const pawnStarEl = document.getElementById("pawnStars");
const pawnStartBtn = document.getElementById("pawnStart");

let pawnPos = { x: 3, y: 6 }; // white pawn
let pawnCorrect = [];
let pawnStars = 0;

function drawPawnBoard() {
  pawnBoard.innerHTML = "";
  pawnCorrect = [];

  const x = pawnPos.x;
  const y = pawnPos.y;

  // ‚ôô forward one
  if (y - 1 >= 0) {
    pawnCorrect.push(`${x}-${y - 1}`);
  }

  // ‚ôô forward two from starting rank
  if (y === 6 && y - 2 >= 0) {
    pawnCorrect.push(`${x}-${y - 2}`);
  }

  // ‚öîÔ∏è capture diagonals
  if (x - 1 >= 0 && y - 1 >= 0) {
    pawnCorrect.push(`${x - 1}-${y - 1}`);
  }
  if (x + 1 < 8 && y - 1 >= 0) {
    pawnCorrect.push(`${x + 1}-${y - 1}`);
  }

  // draw board
  for (let yy = 0; yy < 8; yy++) {
    for (let xx = 0; xx < 8; xx++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((xx + yy) % 2 ? "dark" : "");

      sq.dataset.x = xx;
      sq.dataset.y = yy;
      sq.dataset.key = `${xx}-${yy}`;
      sq.dataset.file = String.fromCharCode(97 + xx);
      sq.dataset.rank = 8 - yy;

      // ‚ôô pawn
      if (xx === pawnPos.x && yy === pawnPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wP.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target
      if (
        pawnTarget &&
        xx === pawnTarget.x &&
        yy === pawnTarget.y
      ) {
        const t = document.createElement("img");
        t.src = pawnTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.onclick = () => pawnClick(sq);
      pawnBoard.appendChild(sq);
    }
  }
}


function pawnClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  if (!pawnCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // üö´ cannot capture forward
  if (
    x === pawnPos.x &&
    pawnTarget &&
    (pawnTarget.x !== x || pawnTarget.y !== y)
  ) {
    square.classList.add("wrong");
    return;
  }

  // üö´ cannot move diagonally unless target is there
  if (
    x !== pawnPos.x &&
    pawnTarget &&
    !(x === pawnTarget.x && y === pawnTarget.y)
  ) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal pawn action
  square.classList.add("correct");
  pawnPos = { x, y };

  // üéØ target reached (move or capture)
  if (
    pawnTarget &&
    x === pawnTarget.x &&
    y === pawnTarget.y
  ) {
    pawnStars++;
    pawnStarEl.textContent = pawnStars;

    setTimeout(startPawnGame, 400);
    return;
  }

  setTimeout(drawPawnBoard, 300);
}


function startPawnGame() {
  pawnStars = 0;
  pawnStarEl.textContent = pawnStars;

  // ‚ôô random file
  const startX = Math.floor(Math.random() * 8);

  // ‚ôô random rank BUT not 1st (7) or last (0)
  // board y: 0 = rank 8, 7 = rank 1
  const startY = Math.floor(Math.random() * 6) + 1; // 1 ‚Üí 6

  pawnPos = { x: startX, y: startY };

  // decide puzzle type
  const canDouble = pawnPos.y === 6;
  const mode = Math.random() < 0.6 ? "move" : "capture";

  if (mode === "move") {
    // ‚ôô forward move
    pawnTarget = {
      x: pawnPos.x,
      y: canDouble && Math.random() < 0.5
        ? pawnPos.y - 2
        : pawnPos.y - 1
    };
  } else {
    // ‚öîÔ∏è diagonal capture
    const dirs = [];
    if (pawnPos.x > 0) dirs.push(-1);
    if (pawnPos.x < 7) dirs.push(1);

    pawnTarget = {
      x: pawnPos.x + dirs[Math.floor(Math.random() * dirs.length)],
      y: pawnPos.y - 1
    };
  }

  pawnTargetImg = getRandomTarget();

  drawPawnBoard();
}



pawnStartBtn.onclick = startPawnGame;


let kingMisses = 0;
const kingMissEl = document.getElementById("kingMisses");

let kingTarget = null;
let kingTargetImg = null;


const kingBoard = document.getElementById("kingBoard");
const kingStarEl = document.getElementById("kingStars");
const kingStartBtn = document.getElementById("kingStart");

let kingPos = { x: 3, y: 3 };
let kingCorrect = [];
let kingStars = 0;

const kingDirs = [
  [-1,-1], [0,-1], [1,-1],
  [-1, 0],         [1, 0],
  [-1, 1], [0, 1], [1, 1]
];

function drawKingBoard() {
  kingBoard.innerHTML = "";
  kingCorrect = [];

  // 1Ô∏è‚É£ calculate king moves (1 square any direction)
  kingDirs.forEach(([dx, dy]) => {
    const x = kingPos.x + dx;
    const y = kingPos.y + dy;
    if (x >= 0 && y >= 0 && x < 8 && y < 8) {
      kingCorrect.push(`${x}-${y}`);
    }
  });

  // 2Ô∏è‚É£ draw board
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "mini-square " + ((x + y) % 2 ? "dark" : "");

      // üîë logic identity
      sq.dataset.x = x;
      sq.dataset.y = y;
      sq.dataset.key = `${x}-${y}`;

      // üî§ labels
      sq.dataset.file = String.fromCharCode(97 + x);
      sq.dataset.rank = 8 - y;

      // üëë king
      if (x === kingPos.x && y === kingPos.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wK.png";
        img.className = "mini-piece";
        sq.appendChild(img);
      }

      // üéØ target object (ANYWHERE)
      if (
        kingTarget &&
        x === kingTarget.x &&
        y === kingTarget.y
      ) {
        const t = document.createElement("img");
        t.src = kingTargetImg;
        t.className = "target-object";
        sq.appendChild(t);
      }

      sq.onclick = () => kingClick(sq);
      kingBoard.appendChild(sq);
    }
  }
}



function kingClick(square) {
  const x = parseInt(square.dataset.x);
  const y = parseInt(square.dataset.y);
  const key = `${x}-${y}`;

  // ‚ùå illegal king move
  if (!kingCorrect.includes(key)) {
    square.classList.add("wrong");
    return;
  }

  // ‚úÖ legal step
  square.classList.add("correct");
  kingPos = { x, y };

  // üéØ target reached
  if (
    kingTarget &&
    x === kingTarget.x &&
    y === kingTarget.y
  ) {
    kingStars++;
    kingStarEl.textContent = kingStars;

    setTimeout(startKingGame, 400);
    return;
  }

  // continue same puzzle
  setTimeout(drawKingBoard, 300);
}


function startKingGame() {
  kingStars = 0;
  kingStarEl.textContent = kingStars;

  kingPos = randomSquare();

  // üéØ target can be ANYWHERE except king square
  do {
    kingTarget = randomSquare();
  } while (
    kingTarget.x === kingPos.x &&
    kingTarget.y === kingPos.y
  );

  kingTargetImg = getRandomTarget();

  drawKingBoard();
}


kingStartBtn.onclick = startKingGame;


const memoryNextSound = new Audio("sounds/next.mp3");
memoryNextSound.volume = 0.5;

const memoryPartySound = new Audio("sounds/party.mp3");
memoryPartySound.volume = 0.7;

const memoryStartSound = new Audio("sounds/puzzle-rush-start.mp3");
memoryStartSound.volume = 0.6;
const memoryWrongSound = new Audio("sounds/wrong.mp3");
memoryWrongSound.volume = 0.6;





// =============================
// üß† MEMORY SQUARES GAME
// =============================

const memoryBoard = document.getElementById("memoryBoard");
const memoryTimerEl = document.getElementById("memoryTimer");
const memoryLivesEl = document.getElementById("memoryLives");
const memoryScoreEl = document.getElementById("memoryScore");
const memoryGameEl = document.getElementById("memoryGame");
const memoryMenu = document.getElementById("memoryMenu");

let memoryMode = "";
let memoryTimer = null;

let level = 1;
let round = 1;
let squaresToRemember = 3;

let playerClicks = [];

let lives = 3;
let score = 0;


function drawMemoryBoard() {
  memoryBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {      // üî• FIX: draw from rank 8 ‚Üí 1
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");

      // ‚úÖ Correct chess color orientation
      sq.className = "memory-square " + ((x + y) % 2 === 0 ? "dark" : "");

      // internal key (unchanged logic)
      sq.dataset.key = `${x}-${y}`;

      // ‚ôüÔ∏è FILE‚ÄìRANK LABEL
      const file = String.fromCharCode(97 + x); // a‚Äìh
      const rank = y + 1;                       // 1‚Äì8 (because y is reversed)

      const coord = document.createElement("div");
      coord.className = "memory-coord";
      coord.textContent = `${file}${rank}`;
      sq.appendChild(coord);

      sq.onclick = () => memoryClick(sq);
      memoryBoard.appendChild(sq);
    }
  }
}



function getRandomSquares(count) {
  const all = [];
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      all.push(`${x}-${y}`);
    }
  }

  return all.sort(() => 0.5 - Math.random()).slice(0, count);
}



function startMemoryRound() {
  playerClicks = [];
  correctSquares = getRandomSquares(squaresToRemember);

  drawMemoryBoard();

  // üî¶ FLASH
  document.querySelectorAll(".memory-square").forEach(sq => {
    if (correctSquares.includes(sq.dataset.key)) {
      sq.classList.add("flash");
    }
  });
  

  // ‚è± hide after 1 sec
  setTimeout(() => {
    document.querySelectorAll(".memory-square").forEach(sq =>
      sq.classList.remove("flash")
    );
  }, 1000);
}


function memoryClick(square) {
  const key = square.dataset.key;
  if (playerClicks.includes(key)) return;

  playerClicks.push(key);

  if (correctSquares.includes(key)) {
    square.classList.add("correct");
  } else {
    square.classList.add("wrong");
    
    // üîä WRONG SOUND
  memoryWrongSound.currentTime = 0;
  memoryWrongSound.play().catch(() => {});

    lives--;
    memoryLivesEl.textContent = lives;

    if (lives <= 0) {
      endMemoryGame();
      return;
    }
  }

  // ‚úÖ round complete
  if (playerClicks.length === correctSquares.length) {
  score++;
  memoryScoreEl.textContent = score;

  // üîä NEXT ROUND SOUND
  memoryNextSound.currentTime = 0;
  memoryNextSound.play().catch(() => {});

  round++;
  if (round > 5) {
    level++;
    round = 1;
    squaresToRemember++;
  }

  setTimeout(startMemoryRound, 600);
}

}


function startMemoryGame(mode, time) {

  // üîä GAME START SOUND
  memoryStartSound.currentTime = 0;
  memoryStartSound.play().catch(() => {});

  memoryMode = mode;
  lives = mode === "survival" ? 1 : 3;
  score = 0;
  level = 1;
  round = 1;
  squaresToRemember = 3;

  memoryLivesEl.textContent = lives;
  memoryScoreEl.textContent = score;

  memoryMenu.classList.add("hidden");
  memoryGameEl.classList.remove("hidden");

  drawMemoryBoard();
  startMemoryRound();

  if (time) {
    let t = time;
    memoryTimerEl.textContent = t;
    memoryTimer = setInterval(() => {
      t--;
      memoryTimerEl.textContent = t;
      if (t <= 0) endMemoryGame();
    }, 1000);
  }
}



function endMemoryGame() {
  clearInterval(memoryTimer);

  // üîä PARTY SOUND (play once)
  memoryPartySound.currentTime = 0;
  memoryPartySound.play().catch(() => {});

  showFloatingModal(
    "üß† Memory Squares",
    `
      <strong>Game Over!</strong><br><br>
      ‚≠ê Score: <strong>${score}</strong><br>
      ‚ù§Ô∏è Lives Left: <strong>${lives}</strong>
    `,
    () => {
      exitMemory();
      saveMiniGameScore("memory", score);

    }
  );
}



function exitMemory() {
  clearInterval(memoryTimer);
  memoryGameEl.classList.add("hidden");
  memoryMenu.classList.remove("hidden");
}


document.addEventListener("DOMContentLoaded", () => {
  const mem3 = document.getElementById("mem3");
  const mem5 = document.getElementById("mem5");
  const memSurvival = document.getElementById("memSurvival");
  const memoryExit = document.getElementById("memoryExit");

  if (mem3) mem3.onclick = () => startMemoryGame("rush", 180);
  if (mem5) mem5.onclick = () => startMemoryGame("rush", 300);
  if (memSurvival) memSurvival.onclick = () => startMemoryGame("survival");
  if (memoryExit) memoryExit.onclick = exitMemory;
});





function renderStudentModal(profile, attempts) {
  const total = attempts.length;
  const correct = attempts.filter(a => a.is_correct).length;
  const incorrect = total - correct;
  const totalTime = attempts.reduce((s, a) => s + (a.time_spent || 0), 0);
    const unlockedAchievements = getUnlockedAchievementCount(profile.id);
  const totalAchievements =
    Array.isArray(window.STUDENT_BADGES) ? STUDENT_BADGES.length : 0;


  let html = `
    <div style="text-align:left;">
      <p><strong>Status:</strong> ${profile.active ? "‚úÖ Active" : "‚ùå Inactive"}</p>
      <p><strong>Joined:</strong> ${new Date(profile.created_at).toLocaleDateString()}</p>

      <hr>

      <p><strong>Total assignments:</strong> ${total}</p>
      <p><strong>Correct:</strong> ${correct}</p>
      <p><strong>Incorrect:</strong> ${incorrect}</p>
      <p><strong>Total time spent:</strong> ${formatTime(totalTime)}</p>
            <p>
        <strong>üèÖ Achievements unlocked:</strong>
        ${unlockedAchievements} / ${totalAchievements}
      </p>


      <hr>

      <h4>üìö Assignment History</h4>
  `;

  if (total === 0) {
    html += `<p style="opacity:.7;">No attempts yet.</p>`;
  } else {
    attempts.forEach(a => {
      html += `
        <div style="padding:8px; border-bottom:1px solid rgba(255,255,255,0.08);">
          <strong>${a.assignments?.title || "Unknown"}</strong><br>
          Submitted: ${new Date(a.submitted_at).toLocaleString()}<br>
          Time: ${formatTime(a.time_spent || 0)} |
          Attempts: ${a.attempt_count || 1} |
          ${a.is_correct ? "‚úÖ Correct" : "‚ùå Incorrect"}
        </div>
      `;
    });
  }

  html += `</div>`;

  document.getElementById("studentModalBody").innerHTML = html;
}


// üåø Study move tree (flat for now)
const studyMoves = [];
let currentMoveIndex = -1;




let studyBoard = null;
let studyChess = null;
const studyState = {
  currentChapterPgn: "",
  chapters: [],
  baseMoveIndex: 0
};



// ===============================
// üìò Study Panel Interaction (UI only)
// ===============================

document.addEventListener("DOMContentLoaded", () => {
  const studyHeader = document.querySelector(".study-item");
  const chapters = document.querySelectorAll(".study-chapter");

  // Toggle study open/close
  if (studyHeader) {
    studyHeader.addEventListener("click", () => {
      studyHeader.classList.toggle("active");

      chapters.forEach(ch => {
        ch.style.display =
          ch.style.display === "none" ? "block" : "none";
      });
    });
  }

  // Chapter selection
  chapters.forEach(chapter => {
    chapter.addEventListener("click", () => {
      chapters.forEach(c => c.classList.remove("active"));
      chapter.classList.add("active");

      // üîí placeholder for later:
      // loadChapterPGN(chapter)
    });
  });
});

// ===============================
// üìò Study PGN Import (UI only)
// ===============================

function showFloatingModal(title, message, onClose) {
  const modal = document.getElementById("floatingModal");
  const modalTitle = document.getElementById("modalTitle");
  const modalBody = document.getElementById("modalBody");
  const modalOkBtn = document.getElementById("modalOkBtn");

  if (!modal) return;

  modalTitle.textContent = title;
  modalBody.innerHTML = message;

  modal.classList.remove("hidden");

  modalOkBtn.onclick = () => {
    modal.classList.add("hidden");
    if (onClose) onClose();
  };
}


// ===============================
// üìò Study PGN Import (UI only) ‚Äî FIXED
// ===============================

document.addEventListener("DOMContentLoaded", () => {
  const importBtn = document.getElementById("importStudyBtn");
  const modal = document.getElementById("studyImportModal");
  const cancelBtn = document.getElementById("importStudyCancel");
  const confirmBtn = document.getElementById("importStudyConfirm");
  const studyPgnInput = document.getElementById("studyPgnInput");
  const studyList = document.getElementById("studyList");
  const uploadBtn = document.getElementById("uploadStudyBtn");
const fileInput = document.getElementById("studyFileInput");

uploadBtn.addEventListener("click", () => {
  fileInput.click();
});

fileInput.addEventListener("change", () => {
  const file = fileInput.files[0];
  if (!file) return;

  const reader = new FileReader();

  reader.onload = () => {
    // put file content directly into textarea
    studyPgnInput.value = reader.result;
    modal.classList.remove("hidden");
  };

  reader.readAsText(file);
});
document.getElementById("studySelect").addEventListener("change", async (e) => {
  const pgnId = e.target.value;
  if (!pgnId) return;

  console.log("üìÇ Study selected:", pgnId);

  const { data, error } = await supabase
    .from("bulk_pgn_library")
    .select("pgn, title")
    .eq("id", pgnId)
    .single();

  if (error || !data) {
    console.error("‚ùå Failed to load PGN:", error);
    return;
  }

  // üîë THIS IS THE MAGIC
  studyPgnInput.value = data.pgn;

  // Optional: show title somewhere
  console.log("üìò Loaded study:", data.title);

  // üîì Open the SAME import modal
  studyImportModal.classList.remove("hidden");
});



  if (!importBtn || !modal) {
    console.error("‚ùå Study PGN elements not found");
    return;
  }

  

  

  // Open modal
  importBtn.addEventListener("click", () => {
    modal.classList.remove("hidden");
  });

  // Cancel modal
  cancelBtn.addEventListener("click", () => {
    modal.classList.add("hidden");
  });

  // Confirm import
  confirmBtn.addEventListener("click", () => {
    const raw = studyPgnInput.value.trim();
    if (!raw) return;

    // split multiple PGNs (Lichess-compatible)
    const games = raw
      .split(/\n\n(?=\[Event|\[ChapterName)/)
      .filter(Boolean);

    studyState.chapters = games.map((pgn, i) => ({
      title: `Chapter ${i + 1}`,
      pgn
    }));

    renderStudyChapters();
    modal.classList.add("hidden");
    studyPgnInput.value = "";
  });


function extractFenFromPgn(pgn) {
  const match = pgn.match(/\[FEN\s+"([^"]+)"\]/);
  return match ? match[1] : null;
}



  function renderStudyChapters() {
  studyList.innerHTML = `
    <div class="study-item active">‚ñ∂ Imported Study</div>
  `;

  studyState.chapters.forEach((ch, idx) => {
    const div = document.createElement("div");
    div.className = "study-chapter";
    div.textContent = `${idx + 1}. ${ch.title}`;

    div.addEventListener("click", () => {
      
      studyState.currentChapterPgn = ch.pgn;

  // active highlight
  document
    .querySelectorAll(".study-chapter")
    .forEach(c => c.classList.remove("active"));
  div.classList.add("active");

  // reset game
  // üîÅ FULL RESET (SAFE)
studyChess.reset();
studyMoves.length = 0;
currentMoveIndex = -1;

// üîë store current chapter PGN
studyState.currentChapterPgn = ch.pgn;

// üß† load PGN into ONE chess instance
// üîí CLEAN PGN (remove variations & comments for replay safety)
const cleanPgn = ch.pgn
  .replace(/\([^)]*\)/g, "")   // remove ( ... )
  .replace(/\{[^}]*\}/g, ""); // remove { comments }

// üß† load CLEAN PGN into studyChess
const ok = studyChess.load_pgn(cleanPgn, { sloppy: true });
if (!ok) {
  console.error("‚ùå PGN load failed");
  return;
}

if (!ok) {
  console.error("‚ùå PGN load failed");
  return;
}

// ‚ôüÔ∏è collect VERBOSE mainline moves
studyMoves.push(...studyChess.history({ verbose: true }));

// üìù render notation from SAME move source
renderStudyNotation(studyMoves);

// ‚ôüÔ∏è reset board to chapter start (or FEN)
jumpToMove(-1);


  console.log("üìò Chapter selected:", ch.title);
});


    studyList.appendChild(div);
  });
}

});




function jumpToMove(index) {
  studyChess.reset();

  // load base FEN if exists
  const fenMatch =
    studyState.currentChapterPgn.match(/\[FEN\s+"([^"]+)"\]/);

  if (fenMatch) {
    studyChess.load(fenMatch[1]);
  }

  if (index < 0) {
    studyBoard.position(studyChess.fen(), false);
    return;
  }

  for (let i = 0; i <= index; i++) {
    const move = studyMoves[i];
    if (!move) break;

    const result = studyChess.move(move);
    if (!result) {
      console.warn("‚ö†Ô∏è Failed to apply move:", move.san);
      break; // üî• STOP instead of silently failing
    }
  }

  studyBoard.position(studyChess.fen(), false);
}






function extractFenMoveIndex(pgn) {
  const moveMatch = pgn.match(/\n(\d+)\./);
  return moveMatch ? (parseInt(moveMatch[1], 10) - 1) * 2 : 0;
}






function renderStudyNotation(moves) {
  const notation = document.getElementById("studyNotation");
  if (!notation) return;

  notation.innerHTML = "";

  for (let i = 0; i < moves.length; i += 2) {
    const row = document.createElement("div");
    row.className = "notation-row";

    const num = document.createElement("span");
    num.className = "move-num";
    num.textContent = Math.floor(i / 2) + 1 + ".";
    row.appendChild(num);

    if (moves[i]) {
      const white = document.createElement("span");
      white.className = "move white";
      white.textContent = moves[i].san;

      white.onclick = () => {
        currentMoveIndex = i;
        jumpToMove(i);
      };
      row.appendChild(white);
    }

    if (moves[i + 1]) {
      const black = document.createElement("span");
      black.className = "move black";
      black.textContent = moves[i + 1].san;

      black.onclick = () => {
        currentMoveIndex = i + 1;
        jumpToMove(i + 1);
      };
      row.appendChild(black);
    }

    notation.appendChild(row);
  }
}








function appendInlineVariation(san, absoluteIndex, fen) {
  const notation = document.getElementById("studyNotation");
  if (!notation) return;

  const rows = notation.querySelectorAll(".notation-row");
  const lastRow = rows[rows.length - 1];
  if (!lastRow) return;

  const varSpan = document.createElement("span");
  varSpan.className = "move variation";
  varSpan.textContent = ` (${san})`;

  // üî• STORE EVERYTHING ON THE NODE (NO SEARCHING)
  varSpan.dataset.fen = fen;
  varSpan.dataset.index = absoluteIndex;

  varSpan.addEventListener("click", () => {
    // 1Ô∏è‚É£ FULL RESET
    studyChess.reset();

    // 2Ô∏è‚É£ LOAD CHAPTER BASE FEN (IF EXISTS)
    const fenMatch =
      studyState.currentChapterPgn.match(/\[FEN\s+"([^"]+)"\]/);

    if (fenMatch) {
      studyChess.load(fenMatch[1]);
    }

    // 3Ô∏è‚É£ REPLAY MAINLINE UP TO PARENT MOVE
    for (let i = 0; i < absoluteIndex; i++) {
  if (!studyMoves[i]) break;
  studyChess.move(studyMoves[i]);
}


    // 4Ô∏è‚É£ LOAD VARIATION POSITION DIRECTLY
    studyChess.load(varSpan.dataset.fen);
    studyBoard.position(varSpan.dataset.fen, false);

    console.log(
      "‚úÖ Variation rendered via FEN at move:",
      absoluteIndex,
      san
    );
  });

  lastRow.appendChild(varSpan);
}





  





// ===============================
// ‚ôüÔ∏è Init Study Board
// ===============================
window.studyDrawingsByFen = {};
studyChess = new Chess();

studyBoard = Chessboard("studyBoard", {
  position: "start",
  draggable: true,
  showNotation: false,
  pieceTheme: "https://lichess1.org/assets/piece/merida/{piece}.svg",
  onDrop: onStudyDrop
});

// ================================
// STUDY DRAW INIT (PASTE HERE)
// ================================
const studyWrapper = document.getElementById("studyBoardWrapper");
const studyBoardEl = document.getElementById("studyBoard");
const studyDrawLayer = document.getElementById("studyDrawLayer");

initStudyBoardDrawing(studyWrapper, studyBoardEl, studyDrawLayer);


function onStudyDrop(source, target) {
  const move = studyChess.move({
    from: source,
    to: target,
    promotion: "q"
  });

  if (!move) return "snapback";

  // üîë absolute move index (parent + 1)
  const absoluteIndex =
  currentMoveIndex >= 0 ? currentMoveIndex + 1 : studyMoves.length;
;

  // üî• store variation (optional, but useful later)
  studyMoves.push({
    san: move.san,
    absoluteIndex,
    fen: studyChess.fen()
  });

  // üî• CREATE VARIATION NODE (PASS FEN!)
  appendInlineVariation(
    move.san,
    absoluteIndex,
    studyChess.fen()
  );

  studyBoard.position(studyChess.fen(), false);

  console.log(
    "‚ôüÔ∏è Variation added at move:",
    absoluteIndex,
    move.san
  );
}











// üîÑ Study board flip state
let studyBoardFlipped = false;

// ‚å®Ô∏è Keyboard shortcut: F = flip board
document.addEventListener("keydown", (e) => {
  // ignore typing inside inputs / textareas
  if (
    e.target.tagName === "INPUT" ||
    e.target.tagName === "TEXTAREA"
  ) return;

  if (e.key.toLowerCase() === "f") {
    if (!studyBoard) return;

    studyBoardFlipped = !studyBoardFlipped;
    studyBoard.orientation(
      studyBoardFlipped ? "black" : "white"
    );

    console.log("üîÑ Study board flipped:", studyBoardFlipped);
  }
});



function initStudyBoardDrawing(wrapper, boardEl, canvas) {
  const ctx = canvas.getContext("2d");
  let startSquare = null;
  let isRightDown = false;

  function resizeCanvas() {
    const r = boardEl.getBoundingClientRect();
    canvas.width = r.width;
    canvas.height = r.height;
    canvas.style.width = r.width + "px";
    canvas.style.height = r.height + "px";
    redraw();
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function getSquareFromEvent(e) {
    const rect = boardEl.getBoundingClientRect();
    const size = rect.width / 8;
    const x = Math.floor((e.clientX - rect.left) / size);
    const y = Math.floor((e.clientY - rect.top) / size);
    if (x < 0 || y < 0 || x > 7 || y > 7) return null;
    return String.fromCharCode(97 + x) + (8 - y);
  }

  function squareCenter(square) {
    const file = square.charCodeAt(0) - 97;
    const rank = 8 - parseInt(square[1]);
    const size = canvas.width / 8;
    return {
      x: file * size + size / 2,
      y: rank * size + size / 2
    };
  }

  function getColor(e) {
    if (e.ctrlKey) return "rgba(0,120,255,0.9)";
    if (e.shiftKey) return "rgba(255,60,60,0.9)";
    return "rgba(0,200,0,0.9)";
  }

  function currentFenKey() {
    return studyChess.fen().split(" ").slice(0, 4).join(" ");
  }

  function getDrawings() {
    const k = currentFenKey();
    if (!studyDrawingsByFen[k]) studyDrawingsByFen[k] = [];
    return studyDrawingsByFen[k];
  }

  function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const d of getDrawings()) draw(d);
  }

  function draw(d) {
    ctx.strokeStyle = d.color;
    ctx.lineWidth = 4;
    ctx.lineCap = "round";

    if (d.type === "circle") {
      const c = squareCenter(d.square);
      ctx.beginPath();
      ctx.arc(c.x, c.y, canvas.width / 16 - 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    if (d.type === "arrow") {
      const a = squareCenter(d.from);
      const b = squareCenter(d.to);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();

      const angle = Math.atan2(b.y - a.y, b.x - a.x);
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(
        b.x - 14 * Math.cos(angle - 0.3),
        b.y - 14 * Math.sin(angle - 0.3)
      );
      ctx.lineTo(
        b.x - 14 * Math.cos(angle + 0.3),
        b.y - 14 * Math.sin(angle + 0.3)
      );
      ctx.closePath();
      ctx.fillStyle = d.color;
      ctx.fill();
    }
  }

  wrapper.addEventListener("contextmenu", e => e.preventDefault());

  wrapper.addEventListener("mousedown", e => {
    if (e.button !== 2) return;
    isRightDown = true;
    startSquare = getSquareFromEvent(e);
  });

  wrapper.addEventListener("mouseup", e => {
    if (!isRightDown || e.button !== 2) return;
    isRightDown = false;

    const endSquare = getSquareFromEvent(e);
    if (!startSquare || !endSquare) return;

    const drawings = getDrawings();
    const color = getColor(e);

    if (startSquare === endSquare) {
      const idx = drawings.findIndex(
        d => d.type === "circle" && d.square === startSquare
      );
      if (idx >= 0) drawings.splice(idx, 1);
      else drawings.push({ type: "circle", square: startSquare, color });
    } else {
      const idx = drawings.findIndex(
        d => d.type === "arrow" && d.from === startSquare && d.to === endSquare
      );
      if (idx >= 0) drawings.splice(idx, 1);
      else drawings.push({ type: "arrow", from: startSquare, to: endSquare, color });
    }

    redraw();
  });

  // üî• IMPORTANT: redraw on move navigation
  document.addEventListener("studyPositionChanged", redraw);
}

















function initStudyEngine() {
  if (studyEngine) return;

  studyEngine = new Worker("./stockfish/stockfish.js");

  studyEngine.onmessage = (e) => {
    const line = e.data;
    if (typeof line !== "string") return;
    updateStudyEngineUI(line);
  };

  studyEngine.postMessage("uci");

  // üî• ADD THIS LINE (CRITICAL)
  studyEngine.postMessage("setoption name MultiPV value 3");

  studyEngine.postMessage("isready");
}







function analyzeStudyPosition() {
  if (!studyEngine || !studyChess || !studyEngineEnabled) return;

  // üß† reset UI + engine search state
  studyLastDepth = 0;
  document.getElementById("studyEval").textContent = "‚Ä¶";
  document.getElementById("studyPVLines").innerHTML = "";

  // üõë stop any running search
  studyEngine.postMessage("stop");

  // ‚ôªÔ∏è CRITICAL: clear hash + previous context
  studyEngine.postMessage("ucinewgame");

  // ‚ôüÔ∏è send current position
  studyEngine.postMessage(
    "position fen " + studyChess.fen()
  );

  // üöÄ continuous analysis (best for UI)
  studyEngine.postMessage("go infinite");
}








// ===== ENGINE STATE =====
let studyLastDepth = 0;
const STUDY_MIN_EVAL_DEPTH = 16;

function updateStudyEngineUI(line) {
  if (!studyEngineEnabled) return;
  if (typeof line !== "string") return;
  if (!line.startsWith("info")) return;

  /* ================= DEPTH ================= */
  const depthMatch = line.match(/depth (\d+)/);
  if (depthMatch) {
    studyLastDepth = parseInt(depthMatch[1], 10);
    document.getElementById("studyDepth").textContent = studyLastDepth;
  }

  /* ================= ONLY PV 1 CONTROLS EVAL ================= */
  const isPV1 = /multipv 1\b/.test(line);
  if (!isPV1) {
    // still allow PV rendering later
  }

  const evalBox = document.getElementById("studyEval");
  const cpMatch = line.match(/score cp (-?\d+)/);
  const mateMatch = line.match(/score mate (-?\d+)/);

  // ===== MATE (PV1 ONLY) =====
  if (mateMatch && isPV1) {
    let mate = parseInt(mateMatch[1], 10);

    if (studyChess.turn() === "b") mate = -mate;

    evalBox.textContent = `M${mate}`;
    return;
  }

  // ===== CENTIPAWN (PV1 ONLY + DEPTH GATED) =====
  if (cpMatch && isPV1) {
    if (studyLastDepth < STUDY_MIN_EVAL_DEPTH) return;

    let cp = parseInt(cpMatch[1], 10);
    if (studyChess.turn() === "b") cp = -cp;

    const evalValue = (cp / 100).toFixed(2);
    evalBox.textContent = cp > 0 ? `+${evalValue}` : evalValue;
  }

  /* ================= MULTI-PV DISPLAY ================= */
  const pvMatch = line.match(/multipv (\d+).* pv (.+)/);
  if (!pvMatch) return;

  const index = pvMatch[1];
  const uciPv = pvMatch[2];

  const sanPv = uciLineToSAN(studyChess.fen(), uciPv);
  studyPV[index] = sanPv;

  const pvBox = document.getElementById("studyPVLines");
  pvBox.innerHTML = "";

  Object.keys(studyPV)
    .sort((a, b) => a - b)
    .forEach(i => {
      const div = document.createElement("div");
      div.className = "engine-line";
      div.textContent = studyPV[i];
      pvBox.appendChild(div);
    });
}





function uciLineToSAN(fen, uciLine) {
  const tempChess = new Chess(fen);
  const sanMoves = [];

  const moves = uciLine.trim().split(" ");

  for (const uci of moves) {
    const move = tempChess.move({
      from: uci.slice(0, 2),
      to: uci.slice(2, 4),
      promotion: uci[4] // handles promotion if any
    });

    if (!move) break;
    sanMoves.push(move.san);
  }

  return sanMoves.join(" ");
}








    window.startAssignment = async function(assignmentId) {
  try {
    const { data: assignment, error } = await supabase
      .from('assignments')
      .select('*')
      .eq('id', assignmentId)
      .single();
    if (error) {
      alert('Error loading assignment: ' + error.message);
      return;
    }

    // Reset all assignment state
    currentAssignment = assignment;
    expectedMoves = [];
    assignmentCursor = 0;
    attemptCount = 0;
    isNavigationMode = false;
    isPGNLoaded = false;

    const fen = assignment.fen || "start";
    const pgn = assignment.pgn || "";

    // Create new chess instance with the FEN
    chess = new Chess();
    
    try {
      if (fen === "start") {
        chess.reset();
      } else {
        chess.load(fen);
      }
    } catch (e) {
      alert("Invalid assignment FEN: " + e.message);
      return;
    }

   // --------------------------------------------------
// Parse expected moves from PGN (IF ANY)
// --------------------------------------------------
expectedMoves = [];
assignmentColor = "w";

if (pgn && pgn.trim().length > 0) {
  try {
    const tempChess = fen ? new Chess(fen) : new Chess();

    // Try loading PGN (allow sloppy PGN from lichess)
    tempChess.load_pgn(pgn, { sloppy: true });

    const moves = tempChess.history({ verbose: true });
    

    if (moves.length > 0) {
      // ‚úÖ PGN has solution moves
      expectedMoves = moves;
      assignmentColor = moves[0].color;
      console.log("Loaded expected moves:", expectedMoves.length);
    } else {
      // ‚úÖ Position-only PGN (Mate in N)
      console.log("PGN has NO moves (position-only puzzle)");
    }

  } catch (e) {
    console.warn("PGN parse error:", e);
    expectedMoves = [];
  }
}

// --------------------------------------------------
// Board orientation (safe)
// --------------------------------------------------
boardOrientation = assignmentColor === "b" ? "black" : "white";
board.orientation(boardOrientation);



    // Reset history
    moveHistory = [];
    fullPGNHistory = [];
    pgnCursor = 0;
    
    // Update board
    board.position(chess.fen());
    board.start(); // Ensure board is in the correct state

    // Update UI
    updatePGNViewer();
    renderNotation();
    updateNavigationButtons();
    safeShow("pgnContainer", true);
safeShow("submitBtn", true);
safeShow("gameStatus", false);

    
    // Enable move input
    document.getElementById('moveInput').disabled = false;
    document.getElementById('applyMoveBtn').disabled = false;

    // Show assignment info
    showModal(
  "‚ôü Assignment Started",
  `
  <strong>${assignment.title}</strong><br><br>
  ${assignment.description || "No description"}<br><br>
  Solve this position on the board.
  `,
  () => {
    // optional: focus board or start timer
    startTimer();
  }
);

    
    // Start timer
    startTimer();

    // Hide only PGN upload tools & admin stuff ‚Äî NOT the whole panel
document.getElementById("pgnUploadSection").style.display = "none";




  } catch (error) {
    console.error('Error starting assignment:', error);
    // Teacher test mode ‚Äì NO browser alert
showStatus("üß™ Testing assignment (teacher mode)", "info");

  }
};


function isPromotionMove(source, target) {
  const piece = chess.get(source);
  if (!piece || piece.type !== "p") return false;

  const rank = parseInt(target[1], 10);

  // Must be last rank
  const reachesLastRank =
    (piece.color === "w" && rank === 8) ||
    (piece.color === "b" && rank === 1);

  if (!reachesLastRank) return false;

  // Must be a legal move
  const legalMoves = chess.moves({ square: source, verbose: true });
  if (!legalMoves.some(m => m.to === target)) return false;

  return true;
}





    window.testAssignment = function(assignmentId) {
      startAssignment(assignmentId);
      safeStyle('submitBtn', 'display', 'none');

    };

    window.viewAssignment = async function (assignmentId) {
  try {
    const { data: assignment, error } = await supabase
      .from("assignments")
      .select("*")
      .eq("id", assignmentId)
      .single();

    if (error || !assignment) {
      showModal("Error", "Failed to load assignment details.");
      return;
    }

    const html = `
      <p><strong>Title:</strong> ${assignment.title}</p>
      <p><strong>Type:</strong> ${assignment.task_type}</p>
      <p><strong>Status:</strong> ${assignment.status}</p>
      <p><strong>Created:</strong> ${new Date(assignment.created_at).toLocaleString()}</p>
      ${assignment.due_at ? `<p><strong>Due:</strong> ${new Date(assignment.due_at).toLocaleString()}</p>` : ""}
      <hr>
      <p><strong>Description:</strong></p>
      <p>${assignment.description || "No description provided."}</p>
      <hr>
      <p><strong>Bulk Assignment:</strong> ${assignment.is_bulk ? "Yes" : "No"}</p>
    `;

    showModal("üìò Assignment Details", html);

  } catch (err) {
    console.error(err);
    showModal("Error", "Unexpected error occurred.");
  }
};




    window.createAssignment = async function () {
  // üîê Admin check
  if (currentProfile.role !== "admin") {
    alert("Access denied. Admin only.");
    return;
  }

  // üì• Read inputs
  const title = document.getElementById("assignTitle").value.trim();
  const description = document.getElementById("assignDesc").value.trim();
  const task_type = document.getElementById("assignType").value;
  const due_at = document.getElementById("assignDue").value;
  const fenInput = document.getElementById("assignFEN").value.trim();
  const pgn = document.getElementById("assignPGN").value.trim();
  const assignedTo = getSelectedStudentIds();
  console.log("Selected students:", assignedTo);



  // ‚ùå Title required
  if (!title) {
  showModal(
    "‚ö†Ô∏è Missing Title",
    "<p>Please enter an assignment title.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}


  // -------------------------------------------------------
  // üß† AUTO-FEN EXTRACTION FROM PGN
  // -------------------------------------------------------
  let autoFEN = null;

  if (pgn) {
    const fenMatch = pgn.match(/\[FEN\s+"([^"]+)"\]/i);
    if (fenMatch) {
      autoFEN = fenMatch[1];
      console.log("Auto-extracted FEN:", autoFEN);
    }
  }

  // -------------------------------------------------------
  // üß† DETECT IF PGN HAS ACTUAL MOVES
  // -------------------------------------------------------
  const hasMoves = /\d+\.\s/.test(pgn);

  // Warn admin if PGN has no moves (Mate in N positions)
  if (pgn && !hasMoves) {
    const proceed = confirm(
      "‚ö†Ô∏è PGN detected but NO MOVES found.\n\n" +
      "This is a POSITION-ONLY assignment (Mate in N).\n\n" +
      "‚Ä¢ Students will NOT be auto-checked\n" +
      "‚Ä¢ This is normal for Lichess studies\n\n" +
      "Click OK to continue\n" +
      "Click Cancel to paste full solution PGN"
    );

    if (!proceed) return;
  }

  // -------------------------------------------------------
  // üß† FINAL FEN PRIORITY
  // User FEN > PGN FEN > null
  // -------------------------------------------------------
  const finalFEN = fenInput || autoFEN || null;

  try {
  const { error } = await supabase
    .from("assignments")
    .insert([
      {
        title,
        description,
        task_type,
        due_at: due_at || null,
        fen: finalFEN,
        pgn: pgn || null,
        is_bulk: true,
        created_by: currentProfile.id,
        status: "active",

        // ‚úÖ CORE LOGIC
        assigned_to: assignedTo.length ? assignedTo : null,
        is_public: assignedTo.length === 0
      }
    ]);

  if (error) throw error;

    showModal(
  "üéâ Success",
  "<p>Assignment created successfully!</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);


    // üßπ Clear form
    [
      "assignTitle",
      "assignDesc",
      "assignDue",
      "assignFEN",
      "assignPGN"
    ].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.value = "";
    });

    // üîÑ Reload list
    loadAssignments();

  } catch (err) {
    console.error("Error creating assignment:", err);
    alert("‚ùå Error creating assignment: " + err.message);
  }
};

window.showPromotionDialog = function(from, to) {
  pendingPromotion = { from, to };
  document.getElementById("promotionModal").classList.remove("hidden");
};



window.completePromotion = function (piece) {
  if (!pendingPromotion) return;

  const { from, to } = pendingPromotion;

  const move = chess.move({
    from,
    to,
    promotion: piece
  });

  pendingPromotion = null;
  document.getElementById("promotionModal").classList.add("hidden");

  if (!move) return;
  // üîä PROMOTION SOUND (ONLY ADDITION)
if (move.flags.includes('k') || move.flags.includes('q')) {
  // üëë Castling
  playSound('castle');

} else if (move.san.includes('+')) {
  // üîî Check
  playSound('check');

} else if (move.captured) {
  // ‚öîÔ∏è Capture
  playSound('capture');

} else {
  // ‚ôü Normal move
  playSound('move');
}




  // ‚úÖ ADD TO HISTORY
  fullPGNHistory.push(move);
  pgnCursor++;

  // ===============================
  // üî• ASSIGNMENT MODE CONTINUATION
  // ===============================
  if (currentAssignment && expectedMoves.length > 0) {
    const expected = expectedMoves[assignmentCursor];

    // ‚ùå wrong promotion choice
    if (move.san !== expected.san) {
      attemptCount++;
      chess.undo();
      board.position(chess.fen());

      showStatus(
        `Wrong promotion. Try again. Attempts: ${attemptCount}`,
        "error"
      );
      return;
    }

    // ‚úÖ correct promotion
    assignmentCursor++;
    

    // üîÅ BULK CHECK
    if (currentAssignment.is_bulk && assignmentCursor >= expectedMoves.length) {
      bulkIndex++;

      if (bulkIndex < bulkPuzzles.length) {
        setTimeout(loadCurrentBulkPuzzle, 600);
      } else {
        showStatus(
          "üéâ All puzzles completed! Submit your assignment.",
          "success"
        );
        document.getElementById("submitBtn").style.display = "block";
      }
      return;
    }

    // ‚ñ∂ AUTO-PLAY OPPONENT MOVE
    if (assignmentCursor < expectedMoves.length) {
      const reply = expectedMoves[assignmentCursor];

      setTimeout(() => {
        const autoMove = chess.move(reply.san);
        if (autoMove) {
          fullPGNHistory.push(autoMove);
          pgnCursor++;
          assignmentCursor++;
          board.position(chess.fen());

          updatePGNViewer();
          renderNotation();
          updateNavigationButtons();
          
        }
      }, 400);
    }
  }

  board.position(chess.fen());
  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();
};


// BULK FUNCTIONS START//
function splitBulkPGNIntoPuzzles(rawPGN) {
  const games = rawPGN
    .split(/\n\n(?=\[Event )/g)
    .map(g => g.trim())
    .filter(Boolean);

  const puzzles = [];

  for (const gamePGN of games) {
    const fenMatch = gamePGN.match(/\[FEN\s+"([^"]+)"\]/i);
    const fen = fenMatch ? fenMatch[1] : "start";

    const temp = new Chess(fen);

    try {
      temp.load_pgn(gamePGN, { sloppy: true });
    } catch (e) {
      console.warn("Skipping invalid PGN:", e);
      continue;
    }

    const moves = temp.history({ verbose: true });

    puzzles.push({
      fen,
      moves,
      sideToMove: moves[0]?.color || "w",
      rawPGN: gamePGN
    });
  }

  return puzzles;
}

function loadCurrentBulkPuzzle() {
  // üî¥ HARD RESET (VERY IMPORTANT)
  assignmentCursor = 0;
  attemptCount = 0;
  expectedMoves = [];

  // Safety check
  if (!bulkPuzzles || bulkPuzzles.length === 0) return;
  if (bulkIndex < 0 || bulkIndex >= bulkPuzzles.length) return;

  const puzzle = bulkPuzzles[bulkIndex];

  // ‚úÖ SAFE FEN RESOLUTION
  const fenToLoad =
    puzzle.fen && puzzle.fen !== "start"
      ? puzzle.fen
      : START_FEN;

  // ‚úÖ Always initialize chess correctly
  chess = new Chess(fenToLoad);

  // Load solution moves
  expectedMoves = puzzle.moves || [];

  // Side to move
  assignmentColor = puzzle.sideToMove || chess.turn();

  // Board setup
  board.orientation(assignmentColor === "w" ? "white" : "black");
  board.position(chess.fen());

  // UI updates
  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();

  showStatus(
    `Puzzle ${bulkIndex + 1} / ${bulkPuzzles.length}`,
    "info",
    false
  );

  // üîπ Update bulk puzzle indicator
  const indicator = document.getElementById("bulkIndicator");
  if (indicator) {
    indicator.textContent = `Puzzle ${bulkIndex + 1} / ${bulkPuzzles.length}`;
  }
}




// ================================
// üîÅ BULK PUZZLE MANUAL NAVIGATION
// ================================

window.goToNextBulkPuzzle = function () {
  if (!currentAssignment?.is_bulk) return;

  if (bulkIndex < bulkPuzzles.length - 1) {
    bulkIndex++;
    loadCurrentBulkPuzzle();
  } else {
    showStatus("You are on the last puzzle", "info");
  }
};

window.goToPrevBulkPuzzle = function () {
  if (!currentAssignment?.is_bulk) return;

  if (bulkIndex > 0) {
    bulkIndex--;
    loadCurrentBulkPuzzle();
  } else {
    showStatus("You are on the first puzzle", "info");
  }
};

window.goToBulkPuzzle = function (index) {
  if (!currentAssignment?.is_bulk) return;
  if (index < 0 || index >= bulkPuzzles.length) return;

  bulkIndex = index;
  loadCurrentBulkPuzzle();
};




// BULK FUNCTIONS END //



function updateEngineUI() {
  const btn = document.getElementById("analyzeBtn");
  if (!btn) return;

  btn.style.display = isAssignmentMode ? "none" : "block";
}





function showStatus(message, type = "info", autoHide = true) {
  const status = document.getElementById("gameStatus");

  status.innerHTML = message;          // ‚úÖ allow HTML
  status.style.display = "block";

  status.className = "status-indicator";
  status.classList.add(type);          // success | error | info

  if (autoHide) {
    setTimeout(() => {
      status.style.display = "none";
    }, 3000);
  }
}

function refreshStudentList() {
  // Read dropdown value ONLY when refresh is clicked
  window.__studentPriorityMode =
    document.getElementById("defaultStudentStatus")?.value || "active";

  loadStudents();
}






    function startInteractiveAssignment(assignment) {
      isAssignmentMode = true;
updateEngineVisibility();

  console.log("Starting interactive assignment:", assignment);
  


  currentAssignment = assignment;

  // üîÅ BULK ASSIGNMENT MODE
  if (assignment.is_bulk && assignment.pgn) {
    console.log("Bulk assignment detected");

    bulkPuzzles = splitBulkPGNIntoPuzzles(assignment.pgn);
    bulkIndex = 0;

    if (!bulkPuzzles || bulkPuzzles.length === 0) {
      alert("No valid puzzles found in this bulk assignment.");
      return;
    }

    // Show assignment UI (same UI for bulk & single)
    document.getElementById("assignmentModeContainer").style.display = "block";
    document.getElementById("submitBtn").style.display = "none"; // shown only after last puzzle
    document.getElementById("timerDisplay").style.display = "block";
    document.getElementById("pgnContainer").classList.remove("hidden");
    document.getElementById("bulkNav").style.display = "block";
    



    startTimer();
    loadCurrentBulkPuzzle();
    return;
  }

  // ==================================================
  // üîÅ SINGLE ASSIGNMENT MODE (YOUR ORIGINAL LOGIC)
  // ==================================================

  const pgn = assignment.pgn || "";
  const fen = assignment.fen || "start";

  // Reset chess instance
  chess = new Chess();

  try {
    if (fen !== "start") {
      chess.load(fen);
    }
  } catch (e) {
    alert("Invalid assignment FEN");
    return;
  }

  // Load PGN sequence
  const temp = new Chess(fen);
  if (pgn && pgn.trim().length > 0) {
    try {
      temp.load_pgn(pgn, { sloppy: true });
      extractPlayersFromPGN(pgn);
    } catch (e) {
      console.error("Invalid PGN:", e);
      alert("Invalid PGN in this assignment.");
      return;
    }
  }

  // Store expected moves
  expectedMoves = temp.history({ verbose: true });

  if (expectedMoves.length === 0) {
    console.log("Position-only puzzle (Mate in N).");
    assignmentColor = chess.turn();
  } else {
    assignmentColor = expectedMoves[0].color || "w";
  }

  // Update board orientation
  board.orientation(assignmentColor === "w" ? "white" : "black");

  // Reset gameplay data
  assignmentCursor = 0;
  attemptCount = 0;
  moveHistory = [];
  fullPGNHistory = [];
  pgnCursor = 0;
  isNavigationMode = false;
  isPGNLoaded = false;

  // Render board
  board.position(chess.fen());

  // Show assignment UI
  document.getElementById("assignmentModeContainer").style.display = "block";
  document.getElementById("submitBtn").style.display = "block";
  document.getElementById("timerDisplay").style.display = "block";
  document.getElementById("pgnContainer").classList.remove("hidden");

  updatePGNViewer();
  renderNotation();
  updateNavigationButtons();

  startTimer();

  console.log("Single assignment fully loaded.");
}




    

    window.submitSolution = async function() {
  if (!currentAssignment || !chess) {
    alert('No active assignment');
    return;
  }

  stopTimer();

  const pgn = chess.pgn();
  const timeSpent = elapsedTime;
  const isComplete = (expectedMoves.length === 0) || (assignmentCursor >= expectedMoves.length);
  
  try {
    const { data, error } = await supabase
      .from('attempts')
      .insert([{
        assignment_id: currentAssignment.id,
        student_id: currentProfile.id,
        pgn: pgn,
        time_spent: timeSpent,
        is_correct: isComplete,
        attempt_count: attemptCount || 1,
        submitted_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    showResultModal(
  "‚úÖ Solution Submitted!",
  `
  <p>‚è± <strong>Time:</strong> ${formatTime(timeSpent)}</p>
  <p>‚ôü <strong>Moves:</strong> ${moveHistory.length}</p>
  <p>üîÅ <strong>Attempts:</strong> ${attemptCount}</p>
  <p style="margin-top:10px; color:#3cff8f;">
    ‚úî Completed successfully!
  </p>
  `
);

// üîÑ Refresh My Progress (student only)
if (currentProfile?.role === "student") {
  loadStudentProgress();
}



    // Reset assignment state
    currentAssignment = null;
    expectedMoves = [];
    assignmentCursor = 0;
    attemptCount = 0;
    assignmentColor = "w";
    
    document.getElementById('submitBtn').style.display = 'none';
    document.getElementById('timerDisplay').style.display = 'none';
    document.getElementById('pgnContainer').style.display = 'none';

    // Reset the board
    resetBoard();

    document.getElementById("sidePanel").style.display = "block";


  } catch (error) {
    console.error('Error submitting solution:', error);
    alert('Error submitting solution: ' + error.message);
  }
};

window.toggleStudentPassword = function () {
  const input = document.getElementById("newStudentPass");
  const btn = document.getElementById("togglePassBtn");
  if (!input || !btn) return;

  const isHidden = input.type === "password";

  input.type = isHidden ? "text" : "password";
  btn.textContent = isHidden ? "üëÅÔ∏è" : "üëÅÔ∏è‚Äçüó®Ô∏è";
};



    // ============================================
    // STUDENTS (ADMIN)
    // ============================================
    async function loadStudents() {
  if (currentProfile.role !== 'admin') return;

  const tableBody = document.getElementById('studentsTable');
  tableBody.innerHTML =
    '<tr><td colspan="4" class="loading">Loading students...</td></tr>';

  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .neq('role', 'admin')
      .order('created_at', { ascending: false });

    if (error) throw error;

    if (!data || data.length === 0) {
      tableBody.innerHTML =
        '<tr><td colspan="4">No students found. Add your first student above.</td></tr>';
      return;
    }

    // ===============================
    // ‚úÖ STEP 1: PRIORITY SORT (SAFE)
    // ===============================
    const priority = window.__studentPriorityMode || 'active';

      
// ‚úÖ STEP 2: UI hint (PUT IT HERE)
const hint = document.getElementById("studentSortHint");
if (hint) {
  hint.textContent =
    priority === "inactive"
      ? "Showing INACTIVE students first"
      : "Showing ACTIVE students first";
}
    // clone array (important ‚Äì no side effects)
    let students = [...data];

    if (priority === 'active') {
      // Active first, inactive later
      students.sort((a, b) => Number(b.active) - Number(a.active));
    }

    if (priority === 'inactive') {
      // Inactive first, active later
      students.sort((a, b) => Number(a.active) - Number(b.active));
    }

    // ===============================
    // RENDER TABLE
    // ===============================
    tableBody.innerHTML = students
      .map(
        (student) => `
        <tr>
          <td><input type="checkbox" value="${student.id}"></td>
          <td>
  <span
    class="student-name"
    style="cursor:pointer; color:#ffd700;"
    data-student-id="${student.id}"
  >
    ${student.username}
  </span>
</td>

          <td>${student.active ? '‚úÖ Active' : '‚ùå Inactive'}</td>
          <td>
            ${
              student.active
                ? `<button class="btn-danger" onclick="toggleStudentStatus('${student.id}', false)">Deactivate</button>`
                : `<button class="btn-success" onclick="toggleStudentStatus('${student.id}', true)">Activate</button>`
            }
          </td>
        </tr>
      `
      )
      .join('');

  } catch (error) {
    console.error('Error loading students:', error);
    tableBody.innerHTML =
      '<tr><td colspan="4" style="color: #ff4757;">Error loading students</td></tr>';
  }
}

window.refreshStudentList = function () {
  // Lock dropdown value at click time
  window.__studentPriorityMode =
    document.getElementById("defaultStudentStatus")?.value || "active";

  loadStudents();
};



    window.addStudent = async function() {
      if (currentProfile.role !== 'admin') {
        alert('Access denied. Admin only.');
        return;
      }

      const username = document.getElementById('newStudentUser').value.trim();
      const password = document.getElementById('newStudentPass').value.trim();

      if (!username || !password) {
  showModal(
    "‚ö†Ô∏è Missing Information",
    "<p>Please enter both username and password.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}

if (password.length < 6) {
  showModal(
    "‚ö†Ô∏è Weak Password",
    "<p>Password must be at least 6 characters long.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 1800);

  return;
}


      const email = `${username}@olympuschess.com`;

      try {
        const { data: authData, error: authError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: { username },
            emailRedirectTo: window.location.origin
          }
        });

        let userId = authData?.user?.id;

        if (authError) {
          if (authError.message.includes('already registered')) {
            const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({ email, password });
            if (signInError) {
  showModal(
    "‚ö†Ô∏è Login Error",
    "<p>User already exists but the password is incorrect.<br>Please use a different username.</p>"
  );

  setTimeout(() => {
    closeModal();
  }, 2200);

  return;
}

            userId = signInData.user.id;
          } else {
            throw authError;
          }
        }

        const { error: profileError } = await supabase
          .from('profiles')
          .insert([{ 
            id: userId, 
            username, 
            email,
            role: 'student', 
            active: true 
          }]);
        
        if (profileError) {
  if (profileError.message.includes('duplicate')) {
    showModal(
      "‚ö†Ô∏è Duplicate Student",
      "<p>A student with this username already exists.</p>"
    );

    setTimeout(() => {
      closeModal();
    }, 2000);

    return;
  }
  throw profileError;
}


        showModal(
  "üéâ Success",
  "<p>Student added successfully!</p>"
);

setTimeout(() => {
  closeModal();
}, 1500);

document.getElementById('newStudentUser').value = '';
document.getElementById('newStudentPass').value = '';
loadStudents();


      } catch (error) {
        console.error('Error adding student:', error);
        alert('‚ùå Error: ' + error.message);
      }
    };

    window.toggleStudentStatus = function (studentId, activate) {
  if (currentProfile.role !== 'admin') return;

  const action = activate ? 'activate' : 'deactivate';

  openGradeConfirm(
    `Confirm ${action}`,
    `<p>Are you sure you want to <strong>${action}</strong> this student?</p>`,
    async () => {
      try {
        const { error: profileError } = await supabase
          .from('profiles')
          .update({ active: activate })
          .eq('id', studentId);

        if (profileError) throw profileError;

        showModal(
          "‚úÖ Success",
          `<p>Student ${action}d successfully!</p>`
        );

        setTimeout(() => {
          closeModal();
        }, 1500);

        loadStudents();

      } catch (error) {
        console.error('Error toggling student status:', error);

        showModal(
          "‚ùå Error",
          `<p>${error.message}</p>`
        );

        setTimeout(() => {
          closeModal();
        }, 2000);
      }
    }
  );
};


    function showResultModal(title, htmlContent) {
  document.getElementById("modalTitle").textContent = title;
  document.getElementById("modalContent").innerHTML = htmlContent;
  document.getElementById("resultModal").classList.remove("hidden");
}

window.closeResultModal = function () {
  const modal = document.getElementById("resultModal");
  modal.classList.add("hidden");
};

window.closeAttemptDetails = function () {
  document.getElementById("attemptDetailsModal").classList.add("hidden");
};

function openAttemptDetails(title, html) {
  document.getElementById("attemptDetailsTitle").textContent = title;
  document.getElementById("attemptDetailsBody").innerHTML = html;
  document.getElementById("attemptDetailsModal").classList.remove("hidden");
}

let pendingGradeAction = null;

window.closeGradeConfirm = function () {
  document.getElementById("gradeConfirmModal").classList.add("hidden");
  pendingGradeAction = null;
};

function openGradeConfirm(title, message, onConfirm) {
  document.getElementById("gradeConfirmTitle").textContent = title;
  document.getElementById("gradeConfirmBody").innerHTML = message;

  const yesBtn = document.getElementById("gradeConfirmYesBtn");
  yesBtn.onclick = () => {
    closeGradeConfirm();
    if (typeof onConfirm === "function") onConfirm();
  };

  document.getElementById("gradeConfirmModal").classList.remove("hidden");
}








    // ============================================
    // ATTEMPTS (ADMIN)
    // ============================================
    async function loadAttempts() {
      if (currentProfile.role !== 'admin') return;

      const attemptsList = document.getElementById('attemptsList');
      attemptsList.innerHTML = '<div class="loading">Loading attempts...</div>';

      try {
        const { data: attempts, error } = await supabase
          .from('attempts')
          .select(`*, assignments (title), profiles (username)`)
          .order('submitted_at', { ascending: false });
        if (error) throw error;

        if (!attempts || attempts.length === 0) {
          attemptsList.innerHTML = '<div class="card"><p>No attempts yet.</p></div>';
          return;
        }

        attemptsList.innerHTML = attempts.map(attempt => `
          <div class="card">
            <h4>Assignment: ${attempt.assignments?.title || 'Unknown'}</h4>
            <p><strong>Student:</strong> ${attempt.profiles?.username || attempt.student_id || 'Unknown'}</p>
            <p><strong>Submitted:</strong> ${new Date(attempt.submitted_at).toLocaleString()}</p>
            <p><strong>Time Spent:</strong> ${formatTime(attempt.time_spent || 0)}</p>
            <p><strong>Attempts:</strong> ${attempt.attempt_count || 1}</p>
            <p><strong>Status:</strong> ${attempt.is_correct ? '‚úÖ Correct' : '‚ùå Needs Review'}</p>
            <p><strong>Score:</strong> ${attempt.score || 'Not graded'}</p>
            ${attempt.pgn ? `<div class="pgn-viewer" style="max-height: 100px;">${(attempt.pgn || '').substring(0, 100)}${attempt.pgn.length > 100 ? '...' : ''}</div>` : ''}
            <div style="margin-top: 10px;">
              <button class="btn-secondary" onclick="viewAttempt('${attempt.id}')">View Details</button>
              <button class="btn-success" onclick="gradeAttempt('${attempt.id}', true)" ${attempt.is_correct ? 'disabled' : ''}>Mark Correct</button>
              <button class="btn-danger" onclick="gradeAttempt('${attempt.id}', false)" ${!attempt.is_correct ? 'disabled' : ''}>Mark Incorrect</button>
            </div>
          </div>
        `).join('');

      } catch (error) {
        console.error('Error loading attempts:', error);
        attemptsList.innerHTML = '<div class="card"><p style="color: #ff4757;">Error loading attempts</p></div>';
      }
    }

    window.viewAttempt = async function (attemptId) {
  try {
    const { data: attempt, error } = await supabase
      .from("attempts")
      .select(`
        *,
        assignments(title, is_bulk),
        profiles(username)
      `)
      .eq("id", attemptId)
      .single();

    if (error || !attempt) throw error;

    let html = `
      <p><strong>Student:</strong> ${attempt.profiles?.username || "Unknown"}</p>
      <p><strong>Submitted:</strong> ${new Date(attempt.submitted_at).toLocaleString()}</p>
      <p><strong>Total Time:</strong> ${formatTime(attempt.time_spent || 0)}</p>
      <p><strong>Attempts:</strong> ${attempt.attempt_count}</p>
      <p><strong>Status:</strong> ${attempt.is_correct ? "‚úÖ Correct" : "‚ùå Incorrect"}</p>
      <hr>
    `;

    // üîÅ BULK ASSIGNMENT DETAILS
    if (attempt.assignments?.is_bulk && attempt.pgn) {
      const puzzles = splitBulkPGNIntoPuzzles(attempt.pgn);

      html += `<h4>üì¶ Bulk Puzzle Breakdown</h4>`;

      puzzles.forEach((p, i) => {
        html += `
          <div style="padding:10px; margin-bottom:8px; border:1px solid #333; border-radius:8px;">
            <strong>Puzzle ${i + 1}</strong><br>
            Side to move: ${p.sideToMove === "w" ? "White" : "Black"}<br>
            Moves in solution: ${p.moves.length}<br>
            Status: ${attempt.is_correct ? "‚úÖ Solved" : "‚ùå Failed"}
          </div>
        `;
      });
    } else {
      html += `<p>This is a single-puzzle assignment.</p>`;
    }

    openAttemptDetails(
      `Assignment: ${attempt.assignments?.title || "Unknown"}`,
      html
    );

  } catch (err) {
    console.error(err);
    alert("Failed to load attempt details");
  }
};


    window.gradeAttempt = function (attemptId, isCorrect) {
  const actionText = isCorrect ? "mark this attempt as CORRECT" : "mark this attempt as INCORRECT";

  openGradeConfirm(
    "Confirm Grading",
    `
      <p>Are you sure you want to <strong>${actionText}</strong>?</p>
      <p style="opacity:.8; margin-top:6px;">This action will update the student record.</p>
    `,
    async () => {
      try {
        const { error } = await supabase
          .from("attempts")
          .update({
            is_correct: isCorrect,
            graded_at: new Date().toISOString(),
            score: isCorrect ? 100 : 0
          })
          .eq("id", attemptId);

        if (error) throw error;

        showStatus(
          isCorrect ? "‚úÖ Attempt marked correct" : "‚ùå Attempt marked incorrect",
          "success"
        );

        loadAttempts(); // refresh list

      } catch (err) {
        console.error(err);
        alert("Failed to update attempt");
      }
    }
  );
};






/* =====================================
   üëë QUEEN MEMORY PATH (ISOLATED)
===================================== */

const pfBoardEl   = document.getElementById("pfBoard");
const pfTimerEl   = document.getElementById("pfTimer");
const pfLivesEl   = document.getElementById("pfLives");
const pfScoreEl   = document.getElementById("pfScore");
const pfExitBtn   = document.getElementById("pfExit");
const BASE_BLOCKS = 2;
const BASE_BOMBS = 1;


let pfTimer = 0;
let pfLives = 3;
let pfScore = 0;
let pfInterval = null;
let flashDuration = 1200; // milliseconds (1.2s memory flash)

let partyAudio = null;

function playPartySound() {
  if (partyAudio) {
    partyAudio.pause();
    partyAudio.currentTime = 0;
  }

  partyAudio = new Audio("./sounds/party.mp3");
  partyAudio.volume = 0.7; // pleasant, not loud
  partyAudio.play().catch(() => {});
}

let startGameAudio = null;

function playGameStartSound() {
  if (startGameAudio) {
    startGameAudio.pause();
    startGameAudio.currentTime = 0;
  }

  startGameAudio = new Audio("./sounds/puzzle-rush-start.mp3");
  startGameAudio.volume = 0.7;
  startGameAudio.play().catch(() => {});
}

let wrongAudio = null;

function playWrongSound() {
  if (wrongAudio) {
    wrongAudio.pause();
    wrongAudio.currentTime = 0;
  }

  wrongAudio = new Audio("./sounds/wrong.mp3");
  wrongAudio.volume = 0.7;
  wrongAudio.play().catch(() => {});
}

let nextAudio = null;

function playNextSound() {
  if (nextAudio) {
    nextAudio.pause();
    nextAudio.currentTime = 0;
  }

  nextAudio = new Audio("./sounds/next.mp3");
  nextAudio.volume = 0.8;
  nextAudio.play().catch(() => {});
}

let hitAudio = null;

function playHitSound() {
  if (hitAudio) {
    hitAudio.pause();
    hitAudio.currentTime = 0;
  }

  hitAudio = new Audio("./sounds/hit.mp3");
  hitAudio.volume = 0.7;
  hitAudio.play().catch(() => {});
}



// STEP 1: fixed home square (temporary)
 let qpHome = { x: 4, y: 4 };



let pfQueen = null;


let pfBombs = [];
let pfBlocks = [];
let pfPhase = "flash"; // flash | play


let pfMode = "easy"; // easy | medium | survival

function applyPfMode(mode) {
  pfMode = mode;

  if (mode === "easy") {
    flashDuration = 2000;
    pfLives = 3;
  }

  if (mode === "medium") {
    flashDuration = 1500;
    pfLives = 3;
  }

  if (mode === "survival") {
    flashDuration = 1000;
    pfLives = 1;
  }

  pfLivesEl.textContent = pfLives;
}

document.getElementById("pfEasy").onclick = () => {
  applyPfMode("easy");
  startPfGame();
};

document.getElementById("pfMedium").onclick = () => {
  applyPfMode("medium");
  startPfGame();
};

document.getElementById("pfSurvival").onclick = () => {
  applyPfMode("survival");
  startPfGame();
};


function startPfGame() {
  playGameStartSound(); // üîä PLAY HERE (user click ‚Üí allowed)
  document.getElementById("pfMenu").classList.add("hidden");
  document.getElementById("pfGame").classList.remove("hidden");
  pfStart();
}


pfExitBtn.onclick = () => {
  pfStop();
  document.getElementById("pfGame").classList.add("hidden");
  document.getElementById("pfMenu").classList.remove("hidden");
};



/* ---------- helpers ---------- */
function pfRand() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function pfSame(a, b) {
  return a.x === b.x && a.y === b.y;
}

/* ---------- board draw ---------- */
function drawPfBoard(showFlash = false) {
  pfBoardEl.innerHTML = "";

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {

      const sq = document.createElement("div");
      sq.className = `pf-square ${(x + y) % 2 ? "dark" : "light"}`;
      
      
      sq.dataset.x = x;
      sq.dataset.y = y;

      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = 8 - y;                       // 8‚Äì1

const coord = document.createElement("div");
coord.className = "pf-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);


      // üè† HOME square (always visible)
if (x === qpHome.x && y === qpHome.y) {
  sq.classList.add("qp-home");
  const home = document.createElement("div");
home.className = "pf-home-icon";
home.textContent = "üè†";
sq.appendChild(home);

}


      if (showFlash) {
        if (pfBlocks.some(b => b.x === x && b.y === y))
          sq.classList.add("pf-grey");
        if (pfBombs.some(b => b.x === x && b.y === y))
          sq.classList.add("pf-red");
        
      }

      if (pfSame(pfQueen, { x, y })) {
  const q = document.createElement("div");
  q.className = "pf-queen-emoji";
  q.textContent = "üë∏";   // üëë QUEEN EMOJI
  sq.appendChild(q);
}


      

      sq.onclick = () => pfHandleClick(x,y);
      pfBoardEl.appendChild(sq);
    }
  }
}

/* ---------- click ---------- */
function pfHandleClick(x, y) {
  if (pfPhase !== "play") return;

  // illegal move (queen logic simplified: row / col / diag)
  const dx = Math.abs(x - pfQueen.x);
  const dy = Math.abs(y - pfQueen.y);
  if (!(dx === 0 || dy === 0 || dx === dy)) return;

  // blocked path
  if (pfBlocks.some(b => b.x === x && b.y === y)) {
    playHitSound();
    return;
  }

  pfQueen = {x,y};

  // üè† HOME reached
if (x === qpHome.x && y === qpHome.y) {
  console.log("üè† Home reached");

  playNextSound(); // üîä NEXT PUZZLE SOUND

  // ‚≠ê INCREMENT SCORE FIRST
  pfScore++;
  pfScoreEl.textContent = pfScore;

  // ‚û°Ô∏è THEN start next round
  startNewPfRound();
  return;
}



  if (pfBombs.some(b => b.x === x && b.y === y)) {
    playWrongSound(); // üîä WRONG MOVE SOUND
  pfLives--;
  pfLivesEl.textContent = pfLives;

  if (pfLives <= 0) {
    pfPhase = "over";

    // üèÜ SAVE BEST SCORE (Queen Memory Path)
  saveMiniGameScore("pathfinder", pfScore);

    playPartySound(); // üéâ PLAY SOUND HERE

    showPfModal(
      "üí• Game Over",
      `You survived ${pfScore} rounds!`,
      () => {
        pfStop(); // go back to menu
      }
    );

    return;
  }
}


  


  drawPfBoard(false);
}

function handlePfSuccess() {
  // ‚≠ê increase score
  pfScore++;
  pfScoreEl.textContent = pfScore;

  // üîä success sound (optional)
  playSound?.("next.mp3");

  // ‚è≥ short pause feels nice
  setTimeout(() => {
    startNewPfRound();
  }, 400);
}

function startNewPfRound() {

  // üß™ DEBUG ‚Äî difficulty check
  console.log(
    "ROUND:", pfScore,
    "GREY:", BASE_BLOCKS + Math.floor(pfScore / 2),
    "RED:", BASE_BOMBS + Math.floor(pfScore / 2)
  );

  // üîÑ reset arrays
  pfBlocks = [];
  pfBombs = [];

  // ‚ôï random queen
  pfQueen = randomPfSquare();

  // üè† random home (not same as queen)
  do {
  qpHome = randomPfSquare();
} while (pfSame(qpHome, pfQueen));


  // üéö difficulty scaling
  const extra = Math.floor(pfScore / 2);

  generatePfBlocks(BASE_BLOCKS + extra);
  generatePfBombs(BASE_BOMBS + extra);

  // üëÅ memory flash
  drawPfBoard(true);

  setTimeout(() => {
    pfPhase = "play";
    drawPfBoard(false);
  }, flashDuration);
}



function randomPfSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function generatePfBlocks(count) {
  while (pfBlocks.length < count) {
    const pos = pfRand();

    if (pfSame(pos, pfQueen)) continue;
    if (pfSame(pos, qpHome)) continue;
    if (pfBlocks.some(b => pfSame(b, pos))) continue;

    pfBlocks.push(pos);
  }
}


function generatePfBombs(count) {
  

  while (pfBombs.length < count) {
    const pos = pfRand();

    if (pfSame(pos, pfQueen)) continue;
    if (pfSame(pos, qpHome)) continue;
    if (pfBlocks.some(b => pfSame(b, pos))) continue;
    if (pfBombs.some(b => pfSame(b, pos))) continue;

    pfBombs.push(pos);
  }
}



/* ---------- round ---------- */


/* ---------- start / stop ---------- */
function pfStart() {
  pfLives = 3;
  pfScore = 0;
  pfTimer = 0;

  pfLivesEl.textContent = pfLives;
  pfScoreEl.textContent = pfScore;
  pfTimerEl.textContent = pfTimer;

  clearInterval(pfInterval);
  pfInterval = setInterval(() => {
    pfTimer++;
    pfTimerEl.textContent = pfTimer;
  }, 1000);

  pfPhase = "flash";
startNewPfRound();

}

function pfStop() {
  clearInterval(pfInterval);
  pfInterval = null;

  pfPhase = "flash";

  // hide game
  document.getElementById("pfGame").classList.add("hidden");

  // show menu
  document.getElementById("pfMenu").classList.remove("hidden");
}


/* ---------- exit ---------- */
pfExitBtn.onclick = pfStop;

/* ---------- NAV HOOK ---------- */
document.querySelectorAll(".nav-btn").forEach(btn => {
  if (btn.dataset.tab === "pathfinder") {
    btn.onclick = () => {
      document.querySelectorAll(".section").forEach(s => s.classList.add("hidden"));
      document.getElementById("pathfinder-section").classList.remove("hidden");
      pfStart();
    };
  }
});

document.querySelectorAll(".nav-btn").forEach(btn => {
  if (btn.dataset.tab === "pathfinder") {
    btn.onclick = () => {
      document.querySelectorAll(".section")
        .forEach(s => s.classList.add("hidden"));

      document.getElementById("pathfinder-section")
        .classList.remove("hidden");

      document.getElementById("pfGame").classList.add("hidden");
      document.getElementById("pfMenu").classList.remove("hidden");
    };
  }
});


function showPfModal(title, message, onClose) {
  const overlay = document.getElementById("floatingModal");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  titleEl.textContent = title;
  bodyEl.textContent = message;

  overlay.classList.remove("hidden");

  okBtn.onclick = () => {
    overlay.classList.add("hidden");
    if (typeof onClose === "function") onClose();
  };
}

// ===============================
// üß† Flash Queen Game State
// ===============================

let fqTimer = 0;
let fqInterval = null;

let audioUnlocked = false;

function unlockAudioOnce() {
  if (audioUnlocked) return;

  const a = new Audio("./sounds/next.mp3");
  a.volume = 0;
  a.play().then(() => {
    a.pause();
    a.currentTime = 0;
    audioUnlocked = true;
    console.log("üîì Audio unlocked");
  }).catch(() => {});
}

document.addEventListener("click", unlockAudioOnce, { once: true });







const flashBoardEl = document.getElementById("flashQueenBoard");



function startFlashQueen(mode) {
  playGameStartSound();

  document.getElementById("flashQueenMenu").classList.add("hidden");
  document.getElementById("flashQueenGame").classList.remove("hidden");

 

  flashQueenState = {
    mode,
    level: 1,
    lives: 3,
    score: 0
  };

  document.getElementById("fqLives").textContent = 3;
  document.getElementById("fqScore").textContent = 0;

  startFlashQueenRound();
   startFQTimer(); 
}



const FQ_SIZE = 8;

const PIECES = [
  "üê±","üê∂","üê∏","ü¶Ñ","üêº","üêµ",
  "üêØ","ü¶ä","üê∞","üê∑","üê®","üêÆ",
  "üéà","üé≤","üçé","üç©","üç≠","‚öΩ", "üçé", "üçå", "üçì", "üçí","üèÄ", "üéæ","üêî", "üêß","üê≤", "üêâ",
  "üöó","‚úàÔ∏è","üöÄ","üéÅ"
];
 // random distractors
const QUEEN = "üë∏";

function startFQTimer() {
  stopFQTimer(); // safety
  fqTimer = 0;
  document.getElementById("fqTimer").textContent = fqTimer;

  fqInterval = setInterval(() => {
    fqTimer++;
    document.getElementById("fqTimer").textContent = fqTimer;
  }, 1000);
}

function stopFQTimer() {
  if (fqInterval) {
    clearInterval(fqInterval);
    fqInterval = null;
  }
}


function fqRandSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

function fqSame(a, b) {
  return a.x === b.x && a.y === b.y;
}

function getFlashTime() {
  if (fqState.mode === "easy") return 2500;
  if (fqState.mode === "medium") return 1800;
  return Math.max(800, 1600 - fqState.level * 50); // survival
}


const FlashQueen = {
  state: {
    level: 1,
    lives: 3,
    score: 0,
    mode: "easy",
    queenPos: null,
    pieces: [],
    phase: "flash"
  },

  start(mode) {
    this.state.mode = mode;
    this.state.level = 1;
    this.state.score = 0;
    this.state.lives = mode === "survival" ? 1 : 3;

    document.getElementById("fqScore").textContent = 0;
    document.getElementById("fqLives").textContent = this.state.lives;

    document.getElementById("flashQueenMenu").classList.add("hidden");
    document.getElementById("flashQueenGame").classList.remove("hidden");

    startFQTimer();
    this.startRound();
  },

  startRound() {
    this.state.phase = "flash";
    this.generatePosition();
    this.draw(true);

    setTimeout(() => {
      this.state.phase = "guess";
      this.draw(false);
    }, this.getFlashTime());
  },

  getFlashTime() {
    if (this.state.mode === "easy") return 800;
    if (this.state.mode === "medium") return 500;
    return Math.max(400, 800 - this.state.level * 50);
  },

  generatePosition() {
    this.state.pieces = [];
    const count = Math.min(1 + this.state.level, 50);

    this.state.queenPos = fqRandSquare();
    this.state.pieces.push({
  ...this.state.queenPos,
  piece: "üë∏",
  isQueen: true
});


    while (this.state.pieces.length < count) {
      const pos = fqRandSquare();
      if (this.state.pieces.some(p => fqSame(p, pos))) continue;

      this.state.pieces.push({
        ...pos,
        piece: PIECES[Math.floor(Math.random() * PIECES.length)]
      });
    }
  },

  draw(show) {
    const board = document.getElementById("flashQueenBoard");
    board.innerHTML = "";

    for (let y = 0; y < 8; y++) {
      for (let x = 0; x < 8; x++) {
        const sq = document.createElement("div");
        sq.className = `pf-square ${(x + y) % 2 ? "dark" : "light"}`;
              // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
      const file = String.fromCharCode(97 + x); // a‚Äìh
      const rank = 8 - y;                       // 8‚Äì1

      const coord = document.createElement("div");
      coord.className = "pf-coord";
      coord.textContent = `${file}${rank}`;
      sq.appendChild(coord);


        if (show) {
          const p = this.state.pieces.find(o => o.x === x && o.y === y);
          if (p) {
  sq.textContent = p.piece;
  sq.classList.add("pf-piece");

  if (p.isQueen) {
    sq.classList.add("pf-queen");
  }
}

        }

        sq.onclick = () => this.handleGuess(x, y);
        board.appendChild(sq);
      }
    }
  },

  handleGuess(x, y) {
    if (this.state.phase !== "guess") return;

    if (x === this.state.queenPos.x && y === this.state.queenPos.y) {
     playNextSound();

      this.state.score++;
      this.state.level++;
      document.getElementById("fqScore").textContent = this.state.score;
      
      this.startRound();
    } else {
      playWrongSound();
      this.state.lives--;
      document.getElementById("fqLives").textContent = this.state.lives;

      if (this.state.lives <= 0) {
      stopFQTimer();     // ‚úÖ STOP TIMER
      // üèÜ SAVE BEST SCORE (Flash Queen)
  saveMiniGameScore("flashqueen", this.state.score);
        playPartySound();

        showFloatingModal("Game Over", `Score: ${this.state.score}`);
      }
    }
  }
};













document.getElementById("fqEasy").onclick = () => FlashQueen.start("easy");
document.getElementById("fqMedium").onclick = () => FlashQueen.start("medium");
document.getElementById("fqSurvival").onclick = () => FlashQueen.start("survival");


document.getElementById("fqExit").onclick = () => {
stopFQTimer();     // ‚úÖ STOP TIMER
  document.getElementById("flashQueenGame").classList.add("hidden");
  document.getElementById("flashQueenMenu").classList.remove("hidden");
};





// ================================
// üê¥ KNIGHT FLASH PATH ‚Äì NO LIVES
// ================================

const kpBoard = document.getElementById("kpBoard");
const kpLevelEl = document.getElementById("kpLevel");

// ---------- GAME STATE ----------
let kpLevel = 1;
let kpKnightPos = null;
let kpPath = [];
let kpTargetSquare = null;
let kpWaitingForClick = false;
let kpStepIndex = 0;

let kpDifficulty = "easy";

const KP_FLASH_TIME = {
  easy:   { on: 500, off: 300 },
  medium: { on: 350, off: 220 },
  hard:   { on: 220, off: 150 }
};



// ---------- KNIGHT MOVES ----------
const KNIGHT_MOVES = [
  [1, 2], [2, 1], [-1, 2], [-2, 1],
  [1, -2], [2, -1], [-1, -2], [-2, -1]
];


function playKnightMoveSound() {
  const sound = new Audio("sounds/move.mp3");
  sound.volume = 0.5;
  sound.currentTime = 0;
  sound.play();
}

function playKnightWrongSound() {
  const sound = new Audio("sounds/wrong.mp3");
  sound.volume = 0.5;
  sound.currentTime = 0;
  sound.play();
}

function playKnightNextSound() {
  const sound = new Audio("sounds/next.mp3");
  sound.volume = 0.6;
  sound.currentTime = 0;
  sound.play();
}

function playKnightFlashSound() {
  const sound = new Audio("sounds/flash.mp3");
  sound.volume = 0.25; // keep it soft
  sound.currentTime = 0;
  sound.play();
}

    let knightAudioUnlocked = false;

function unlockKnightAudio() {
  if (knightAudioUnlocked) return;

  const audio = new Audio("sounds/flash.mp3");
  audio.volume = 0;
  audio.play().catch(() => {});
  knightAudioUnlocked = true;
}





// ================================
// START GAME
// ================================
window.startKP = function (mode) {
  unlockKnightAudio();   // üîì REQUIRED FOR FLASH SOUND
  kpDifficulty = mode;   // ‚úÖ THAT‚ÄôS IT
  kpLevel = 1;

  kpKnightPos = kpRandomSquare();
  showKnightPathGame();
  drawKPBoard();
  startLevel();
};


// ================================
// EXIT GAME
// ================================
window.exitKP = function () {
  // üèÜ SAVE BEST SCORE (Knight Flash Path)
  const finalScore = Math.max(0, kpLevel - 1);
  saveMiniGameScore("knightpath", finalScore);
  document.getElementById("kpGame").classList.add("hidden");
  document.getElementById("kpMenu").classList.remove("hidden");
};

// ================================
// START LEVEL
// ================================
function startLevel() {
  kpWaitingForClick = false;
  kpStepIndex = 0; // üî• reset step
 


  kpPath = generateKPPath();

  kpLevelEl.textContent = kpLevel;

  flashPath(0);
}


// ================================
// GENERATE PATH
// ================================
function generateKPPath() {
  let path = [];
  let pos = { ...kpKnightPos };

  for (let i = 0; i < kpLevel; i++) {
    const moves = KNIGHT_MOVES
      .map(([dx, dy]) => ({ x: pos.x + dx, y: pos.y + dy }))
      .filter(p => p.x >= 0 && p.x < 8 && p.y >= 0 && p.y < 8);

    pos = moves[Math.floor(Math.random() * moves.length)];
    path.push(pos);
  }
  return path;
}

// ================================
// FLASH PATH
// ================================
function flashPath(i) {
  if (i >= kpPath.length) {
    kpWaitingForClick = true;
    return;
  }

  const { x, y } = kpPath[i];
  const sq = document.querySelector(`[data-pos="${x}-${y}"]`);
  if (!sq) return;

  const { on, off } = KP_FLASH_TIME[kpDifficulty];

  sq.classList.add("flash");

  // üîä play flash sound
playKnightFlashSound();

  setTimeout(() => {
    sq.classList.remove("flash");
    setTimeout(() => flashPath(i + 1), off);
  }, on);
}


// ================================
// HANDLE CLICK
// ================================
function handleKPClick(x, y) {
  if (!kpWaitingForClick) return;

  const expected = kpPath[kpStepIndex];

  // ‚úÖ CORRECT NEXT STEP
  if (x === expected.x && y === expected.y) {

    // üîä correct move sound
    playKnightMoveSound();

    // move knight step-by-step
    kpKnightPos = { x, y };
    drawKPBoard();

    kpStepIndex++;

    // üèÅ finished full path
    if (kpStepIndex >= kpPath.length) {
      kpLevel++;

      // ‚≠ê animate level change
      kpLevelEl.classList.add("pop");
      setTimeout(() => kpLevelEl.classList.remove("pop"), 150);

      kpWaitingForClick = false;

      // ‚è≥ 1 SECOND GAP BEFORE NEXT LEVEL
      setTimeout(() => {
        startLevel();
      }, 1000);
    }

  } else {
    // ‚ùå wrong square
    playKnightWrongSound();
    // retry same step (no life system)
  }
}



// ================================
// DRAW BOARD
// ================================
function drawKPBoard() {
  kpBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";

      const isLight = (x + y) % 2 === 1;

      sq.classList.add(isLight ? "light" : "dark");

      sq.dataset.pos = `${x}-${y}`;

      // ‚ôüÔ∏è file & rank labels
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "kp-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);


      if (kpKnightPos.x === x && kpKnightPos.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("knight");
      }

      sq.onclick = () => handleKPClick(x, y);
      kpBoard.appendChild(sq);
    }
  }
}

// ================================
// RANDOM START
// ================================
function kpRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// SHOW GAME UI
// ================================
function showKnightPathGame() {
  document.getElementById("kpMenu").classList.add("hidden");
  document.getElementById("kpGame").classList.remove("hidden");
}

let lmMode = "easy";
let lmRound = 1;
let lmQuestionIndex = 0;
let lmTotalQuestions = 8;

let lmMap = [];           // [{x,y,color}]
let lmTargetColor = null;
let lmWaitingForClick = false;


const LM_COLORS = ["red", "green", "blue", "yellow", "orange", "violet"];

const LM_DIFFICULTY = {
  easy:   { squares: 4,  flashOn: 600, flashOff: 300 },
  medium: { squares: 6,  flashOn: 450, flashOff: 220 },
  hard:   { squares: 8,  flashOn: 300, flashOff: 150 }
};


window.startLabMixer = function (mode) {
  unlockKnightAudio(); // üîì AUDIO UNLOCK (REUSED)
  lmMode = mode;
  lmRound = 1;
  lmQuestionIndex = 0;

  document.getElementById("lmMenu").classList.add("hidden");
  document.getElementById("lmGame").classList.remove("hidden");

  nextLabQuestion();
}

function playLabNextSound() {
  const sound = new Audio("sounds/next.mp3");
  sound.volume = 0.6;
  sound.currentTime = 0;
  sound.play().catch(() => {});
}

function playLabFlashSound() {
  const sound = new Audio("sounds/flash.mp3");
  sound.volume = 0.25;   // soft, kid-friendly
  sound.currentTime = 0;
  sound.play().catch(() => {});
}

function playLabWrongSound() {
  const sound = new Audio("sounds/wrong.mp3");
  sound.volume = 0.6;
  sound.currentTime = 0;
  sound.play().catch(() => {});
}




function nextLabQuestion() {
  if (lmQuestionIndex >= lmTotalQuestions) {
    // round complete
    
    lmQuestionIndex = 0;
  }

  lmQuestionIndex++;
  document.getElementById("lmRound").textContent = lmRound;

  generateLabColors();
  drawLabBoard();
  flashLabColors(0);
}


function generateLabColors() {
  lmMap = [];
  lmWaitingForClick = false;

  const cfg = LM_DIFFICULTY[lmMode];
  const used = new Set();

  while (lmMap.length < cfg.squares) {
    const x = Math.floor(Math.random() * 8);
    const y = Math.floor(Math.random() * 8);
    const key = `${x}-${y}`;
    if (used.has(key)) continue;
    used.add(key);

    const color = LM_COLORS[Math.floor(Math.random() * LM_COLORS.length)];
    lmMap.push({ x, y, color });
  }

  lmTargetColor = lmMap[Math.floor(Math.random() * lmMap.length)].color;

const banner = document.querySelector("#color-section .lm-find-banner");

// remove old color classes
banner.classList.remove(
  "find-red",
  "find-green",
  "find-blue",
  "find-yellow",
  "find-orange",
  "find-violet"
);

// apply new color
banner.classList.add(`find-${lmTargetColor}`);

document.getElementById("lmTarget").textContent = lmTargetColor.toUpperCase();

}


function flashLabColors(i) {
  if (i >= lmMap.length) {
    lmWaitingForClick = true;
    return;
  }

  const { x, y, color } = lmMap[i];
  const sq = document.querySelector(`#lmBoard [data-pos="${x}-${y}"]`);
  if (!sq) return;

  const overlay = sq.querySelector(".lm-overlay");
  const { flashOn, flashOff } = LM_DIFFICULTY[lmMode];

  overlay.className = `lm-overlay lm-${color} show`;
  playLabFlashSound(); // üîä flash sound (isolated)


  setTimeout(() => {
    overlay.className = "lm-overlay";
    setTimeout(() => flashLabColors(i + 1), flashOff);
  }, flashOn);
}



function handleLabClick(x, y) {
  if (!lmWaitingForClick) return;

  const hit = lmMap.find(p => p.x === x && p.y === y);

  if (hit && hit.color === lmTargetColor) {
  playLabNextSound();

  lmWaitingForClick = false;

  // üî• INCREASE ROUND ON EVERY CORRECT ANSWER
  lmRound++;

  // update round number
document.getElementById("lmRound").textContent = lmRound;

// update round color ONLY if badge exists
const roundEl = document.querySelector("#color-section .lm-round");
if (roundEl) {
  roundEl.classList.remove(
    "round-1",
    "round-2",
    "round-3",
    "round-4",
    "round-5"
  );
  roundEl.classList.add(`round-${Math.min(lmRound, 5)}`);
}


  setTimeout(() => {
    nextLabQuestion();
  }, 600);
  }
  // ‚ùå WRONG CLICK
  else {
    playLabWrongSound(); // üîä wrong.mp3
}


}


function drawLabBoard() {
  const board = document.getElementById("lmBoard");
  board.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");

      // KEEP original square styles
      sq.className = "kp-square lm-square";
      sq.dataset.pos = `${x}-${y}`;

      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "lm-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);


      const isLight = (x + y) % 2 === 1;

      sq.classList.add(isLight ? "light" : "dark");

      // üëâ isolated overlay
      const overlay = document.createElement("div");
      overlay.className = "lm-overlay";
      sq.appendChild(overlay);

      sq.onclick = () => handleLabClick(x, y);
      board.appendChild(sq);
    }
  }
}



window.exitLabMixer = function () {

  // üèÜ SAVE BEST SCORE (Lab Mixer)
  saveMiniGameScore("color", Math.max(0, lmRound - 1));

  document.getElementById("lmGame").classList.add("hidden");
  document.getElementById("lmMenu").classList.remove("hidden");
  
}





// ================================
// KNIGHT VS MONSTER (ISOLATED)
// ================================

// STATE
let kvmMode = "easy";
let kvmKnight = null;
let kvmMonsters = [];
let kvmTurns = 0;
let kvmWaiting = false;
let kvmLevel = 1;           // future-proof
let kvmBlockedSquares = []; // üß± level 1 only



const kvmBoard = document.getElementById("kvmBoard");
const kvmTurnsEl = document.getElementById("kvmTurns");
const kvmMonsterCountEl = document.getElementById("kvmMonsterCount");


function generateKVMBlockedSquares(count) {
  const blocks = [];

  while (blocks.length < count) {
    const sq = kvmRandomSquare();

    // ‚ùå avoid knight start
    if (sq.x === kvmKnight.x && sq.y === kvmKnight.y) continue;

    // ‚ùå avoid monsters
    if (kvmMonsters.some(m => m.x === sq.x && m.y === sq.y)) continue;

    // ‚ùå avoid duplicates
    if (blocks.some(b => b.x === sq.x && b.y === sq.y)) continue;

    blocks.push(sq);
  }

  return blocks;
}



// ================================
// Knight vs Monster - Game Over Sound
// ================================
function playKVMGameOverSound() {
  try {
    const audio = new Audio("./sounds/party.mp3");
    audio.volume = 0.6; // üîä not too loud
    audio.play();
  } catch (e) {
    console.warn("üîá party.mp3 could not play", e);
  }
}

// ================================
// Knight vs Monster - Move Sound
// ================================
function playKVMMoveSound() {
  try {
    const audio = new Audio("./sounds/move.mp3");
    audio.volume = 0.5; // balanced, not loud
    audio.play();
  } catch (e) {
    console.warn("üîá move.mp3 could not play", e);
  }
}



// ================================
// START GAME
// ================================
window.startKVM = function (mode) {
  kvmMode = mode;
  kvmTurns = 0;

  document.getElementById("kvmMenu").classList.add("hidden");
  document.getElementById("kvmGame").classList.remove("hidden");

  kvmKnight = kvmRandomSquare();
  kvmMonsters = [];

  const monsterCount =
    mode === "easy" ? 1 : mode === "medium" ? 2 : 3;

  for (let i = 0; i < monsterCount; i++) {
    kvmMonsters.push(kvmRandomSquare());
  }

  // ‚úÖ STEP 3 ‚Äî BLOCK SQUARES (LEVEL 1 ONLY)
  kvmLevel = 1;

  if (kvmLevel === 1) {
    const blockCount =
      mode === "easy" ? 5 : mode === "medium" ? 4 : 4;

    kvmBlockedSquares = generateKVMBlockedSquares(blockCount);
  } else {
    kvmBlockedSquares = [];
  }

  kvmMonsterCountEl.textContent = monsterCount;
  kvmTurnsEl.textContent = 0;

  drawKVMBoard();
  kvmWaiting = true;
};


// ================================
// EXIT GAME
// ================================
window.exitKVM = function () {
  document.getElementById("kvmGame").classList.add("hidden");
  document.getElementById("kvmMenu").classList.remove("hidden");
};

// ================================
// RANDOM SQUARE
// ================================
function kvmRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// HANDLE KNIGHT CLICK
// ================================
function handleKVMClick(x, y) {
  if (!kvmWaiting) return;

  const dx = Math.abs(x - kvmKnight.x);
  const dy = Math.abs(y - kvmKnight.y);

  // üê¥ knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // üö´ blocked square (level 1 only)
  if (
    kvmLevel === 1 &&
    kvmBlockedSquares.some(b => b.x === x && b.y === y)
  ) {
    return;
  }

  // ‚úÖ MOVE KNIGHT
  kvmKnight = { x, y };
  playKVMMoveSound();

  kvmTurns++;
  kvmTurnsEl.textContent = kvmTurns;

  moveMonsters();

  if (isKnightCaught()) {
    showKVMGameOver(kvmTurns);
    return;
  }

  drawKVMBoard();
}


// ================================
// MOVE MONSTERS
// ================================
function moveMonsters() {
  const newPositions = [];

  for (let i = 0; i < kvmMonsters.length; i++) {
    const m = kvmMonsters[i];

    let bestMove = null;
    let bestDist = Infinity;

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;

        const nx = m.x + dx;
        const ny = m.y + dy;

        // board bounds
        if (nx < 0 || nx >= KND_SIZE || ny < 0 || ny >= KND_SIZE) continue;


        // üö´ avoid occupied monster squares
        if (newPositions.some(p => p.x === nx && p.y === ny)) continue;

        const dist =
          Math.abs(nx - kvmKnight.x) +
          Math.abs(ny - kvmKnight.y);

        if (dist < bestDist) {
          bestDist = dist;
          bestMove = { x: nx, y: ny };
        }
      }
    }

    // if no legal free square ‚Üí stay
    newPositions.push(bestMove || { ...m });
  }

  kvmMonsters = newPositions;
}


// ================================
// CHECK CAUGHT
// ================================
function isKnightCaught() {
  return kvmMonsters.some(
    m => m.x === kvmKnight.x && m.y === kvmKnight.y
  );
}

// ================================
// DRAW BOARD
// ================================
function drawKVMBoard() {
  kvmBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";
      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "kvm-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);

     sq.classList.add((x + y) % 2 === 1 ? "light" : "dark");

      sq.onclick = () => handleKVMClick(x, y);

      // üß± blocked square (level 1 only)
      if (
        kvmLevel === 1 &&
        kvmBlockedSquares.some(b => b.x === x && b.y === y)
      ) {
        sq.textContent = "üß±";
        sq.style.fontSize = "32px";
        sq.style.opacity = "0.85";
      }

      // üê¥ knight
      if (kvmKnight.x === x && kvmKnight.y === y) {
        sq.textContent = "üê¥";
      }

      // üëπ monsters
      for (const m of kvmMonsters) {
        if (m.x === x && m.y === y) {
          sq.textContent = "üëπ";
        }
      }

      kvmBoard.appendChild(sq);
    }
  }
}




function showKVMGameOver(turns) {
   playKVMGameOverSound(); // üéâ PLAY SOUND ON GAME OVER
      // üèÜ SAVE BEST SCORE (Knight vs Monster)
   saveMiniGameScore("knightmonster", turns);

  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  if (!modal || !title || !body || !okBtn) {
    console.error("‚ùå Floating modal not found");
    return;
  }

  title.textContent = "üëπ Game Over!";
  body.innerHTML = `
    <p style="font-size:16px; line-height:1.6;">
      The monster caught your knight üê¥<br><br>
      ‚≠ê <b>Turns survived:</b> ${turns}
    </p>
  `;

  modal.classList.remove("hidden");

  // Close behavior ONLY for this game
  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKVM(); // üëà safely exit Knight vs Monster only
  };
}


// ================================
// KNIGHT ESCAPE MAZE (ISOLATED)
// ================================

// STATE
let kemMode = "easy";
let kemKnight = null;
let kemExit = null;
let kemWalls = [];
let kemMonsters = [];
let kemTurns = 0;
let kemLevel = 1;
let kemWaiting = false;

const kemBoard = document.getElementById("kemBoard");
const kemTurnsEl = document.getElementById("kemTurns");
const kemLevelEl = document.getElementById("kemLevel");


// ================================
// Knight Escape Maze - Next Level Sound
// ================================
function playKEMNextSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("üîá next.mp3 could not play", e);
  }
}


// ================================
// RANDOM SQUARE
// ================================
function kemRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// GENERATE WALLS
// ================================
function generateKEMWalls(count) {
  const walls = [];

  while (walls.length < count) {
    const sq = kemRandomSquare();

    if (
      (sq.x === kemKnight.x && sq.y === kemKnight.y) ||
      (sq.x === kemExit.x && sq.y === kemExit.y) ||
      kemMonsters.some(m => m.x === sq.x && m.y === sq.y)
    ) continue;

    if (walls.some(w => w.x === sq.x && w.y === sq.y)) continue;

    walls.push(sq);
  }
  return walls;
}

// ================================
// START GAME
// ================================
window.startKEM = function (mode) {
  kemMode = mode;
  kemTurns = 0;
  kemLevel = 1;

  document.getElementById("kemMenu").classList.add("hidden");
  document.getElementById("kemGame").classList.remove("hidden");

  initKEMLevel();
};

// ================================
// INIT LEVEL
// ================================
function initKEMLevel() {
  kemKnight = kemRandomSquare();
  kemExit = kemRandomSquare();

  while (kemExit.x === kemKnight.x && kemExit.y === kemKnight.y) {
    kemExit = kemRandomSquare();
  }

  const monsterCount =
    kemMode === "easy" ? 1 :
    kemMode === "medium" ? 2 : 3;

  kemMonsters = [];
  for (let i = 0; i < monsterCount; i++) {
    kemMonsters.push(kemRandomSquare());
  }

  const wallBase =
    kemMode === "easy" ? 6 :
    kemMode === "medium" ? 10 : 14;

  kemWalls = generateKEMWalls(wallBase + kemLevel);

  kemTurnsEl.textContent = kemTurns;
  kemLevelEl.textContent = kemLevel;

  kemWaiting = true;
  drawKEMBoard();
}

// ================================
// EXIT GAME
// ================================
window.exitKEM = function () {
  document.getElementById("kemGame").classList.add("hidden");
  document.getElementById("kemMenu").classList.remove("hidden");
};

// ================================
// HANDLE CLICK
// ================================
function handleKEMClick(x, y) {
  if (!kemWaiting) return;

  const dx = Math.abs(x - kemKnight.x);
  const dy = Math.abs(y - kemKnight.y);

  // knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // blocked by wall
  if (kemWalls.some(w => w.x === x && w.y === y)) return;

  kemKnight = { x, y };
  kemTurns++;
  kemTurnsEl.textContent = kemTurns;

  playKVMMoveSound?.();

  moveKEMMonsters();

  // üíÄ CAUGHT
  if (isKEMKnightCaught()) {
    showKEMGameOver();
    return;
  }

  // üèÅ NEXT LEVEL
  if (x === kemExit.x && y === kemExit.y) {
   playKEMNextSound();   // üîä LEVEL UP SOUND
    kemLevel++;
    initKEMLevel();
    return;
  }

  drawKEMBoard();
}

// ================================
// MOVE MONSTERS (CHASE)
// ================================
function moveKEMMonsters() {
  const newPositions = [];

  for (const m of kemMonsters) {
    let bestMove = null;
    let bestDist = Infinity;

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;

        const nx = m.x + dx;
        const ny = m.y + dy;
if (nx < 0 || nx >= KND_SIZE || ny < 0 || ny >= KND_SIZE) continue;

        if (kemWalls.some(w => w.x === nx && w.y === ny)) continue;
        if (newPositions.some(p => p.x === nx && p.y === ny)) continue;

        const dist =
          Math.abs(nx - kemKnight.x) +
          Math.abs(ny - kemKnight.y);

        if (dist < bestDist) {
          bestDist = dist;
          bestMove = { x: nx, y: ny };
        }
      }
    }
    newPositions.push(bestMove || { ...m });
  }

  kemMonsters = newPositions;
}

// ================================
// CHECK CAUGHT
// ================================
function isKEMKnightCaught() {
  return kemMonsters.some(
    m => m.x === kemKnight.x && m.y === kemKnight.y
  );
}

// ================================
// DRAW BOARD
// ================================
function drawKEMBoard() {
  kemBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";
      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "kem-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);

      sq.classList.add((x + y) % 2 === 1 ? "light" : "dark");

      sq.onclick = () => handleKEMClick(x, y);

      if (kemWalls.some(w => w.x === x && w.y === y)) {
        sq.textContent = "üß±";
      }

      if (kemExit.x === x && kemExit.y === y) {
        sq.textContent = "üèÅ";
      }

      // üëπ MONSTERS (bigger)
for (const m of kemMonsters) {
  if (m.x === x && m.y === y) {
    sq.textContent = "üëπ";
    sq.style.fontSize = "34px";
    sq.style.transform = "scale(1.1)";
  }
}

// üê¥ KNIGHT (bigger & priority)
if (kemKnight.x === x && kemKnight.y === y) {
  sq.textContent = "üê¥";
  sq.style.fontSize = "30px";
  sq.style.transform = "scale(1.15)";
      }

      kemBoard.appendChild(sq);
    }
  }
}

// ================================
// GAME OVER (ONLY HERE MODAL)
// ================================
function showKEMGameOver() {
  playKVMGameOverSound?.();
    // üèÜ SAVE BEST SCORE (Knight Escape Maze)
  saveMiniGameScore("knightescape", kemLevel);


  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = "üëπ Game Over!";
  body.innerHTML = `
    <p style="font-size:16px;">
      The monster caught your knight üê¥<br><br>
      üèÜ Level reached: <b>${kemLevel}</b><br>
      ‚≠ê Moves: <b>${kemTurns}</b>
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKEM();
  };
}



// ================================
// ‚ö° KNIGHT SPEED RUN (WITH BOMBS)
// ================================

// STATE
let ksrMode = "medium";
let ksrKnight = null;
let ksrTarget = null;
let ksrBombs = [];
let ksrScore = 0;
let ksrTime = 30;
let ksrTimer = null;
let ksrRunning = false;

// ELEMENTS
const ksrBoard = document.getElementById("ksrBoard");
const ksrScoreEl = document.getElementById("ksrScore");
const ksrTimeEl = document.getElementById("ksrTime");

// ================================
// RANDOM SQUARE
// ================================
function ksrRandomSquare() {
  return {
    x: Math.floor(Math.random() * 8),
    y: Math.floor(Math.random() * 8)
  };
}

// ================================
// GENERATE BOMBS
// ================================
function generateKSRBombs(count) {
  const bombs = [];

  while (bombs.length < count) {
    const sq = ksrRandomSquare();

    if (
      (ksrKnight && sq.x === ksrKnight.x && sq.y === ksrKnight.y) ||
      (ksrTarget && sq.x === ksrTarget.x && sq.y === ksrTarget.y)
    ) continue;

    if (bombs.some(b => b.x === sq.x && b.y === sq.y)) continue;

    bombs.push(sq);
  }
  return bombs;
}

// ================================
// SPAWN TARGET
// ================================
function spawnKSRTarget() {
  do {
    ksrTarget = ksrRandomSquare();
  } while (
    ksrKnight &&
    ksrTarget.x === ksrKnight.x &&
    ksrTarget.y === ksrKnight.y
  );
}

// ================================
// START GAME
// ================================
window.startKSR = function (mode = "medium") {
  ksrMode = mode;

  document.getElementById("ksrMenu").classList.add("hidden");
  document.getElementById("ksrGame").classList.remove("hidden");

  ksrScore = 0;
  ksrRunning = true;

  ksrTime =
    mode === "easy" ? 40 :
    mode === "medium" ? 30 : 20;

  ksrKnight = ksrRandomSquare();
  spawnKSRTarget();

  const bombCount =
    mode === "easy" ? 3 :
    mode === "medium" ? 5 : 7;

  ksrBombs = generateKSRBombs(bombCount);

  ksrScoreEl.textContent = ksrScore;
  ksrTimeEl.textContent = ksrTime;

  drawKSRBoard();
  startKSRTimer();
};

// ================================
// EXIT GAME
// ================================
window.exitKSR = function () {
  stopKSRTimer();
  ksrRunning = false;

  document.getElementById("ksrGame").classList.add("hidden");
  document.getElementById("ksrMenu").classList.remove("hidden");
};

// ================================
// TIMER
// ================================
function startKSRTimer() {
  stopKSRTimer();

  ksrTimer = setInterval(() => {
    if (!ksrRunning) return;

    ksrTime--;
    ksrTimeEl.textContent = ksrTime;

    if (ksrTime <= 0) {
      stopKSRTimer();
      showKSRGameOver();
    }
  }, 1000);
}

function stopKSRTimer() {
  if (ksrTimer) {
    clearInterval(ksrTimer);
    ksrTimer = null;
  }
}

// ================================
// HANDLE CLICK
// ================================
function handleKSRClick(x, y) {
  if (!ksrRunning) return;

  const dx = Math.abs(x - ksrKnight.x);
  const dy = Math.abs(y - ksrKnight.y);

  // üê¥ Knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // ‚úÖ Move knight
  ksrKnight = { x, y };
  playKVMMoveSound?.();

  // üí• BOMB HIT (CHECK IMMEDIATELY)
  if (ksrBombs.some(b => b.x === x && b.y === y)) {
    showKSRGameOver(true);
    return;
  }

  // ‚≠ê STAR COLLECT
  if (x === ksrTarget.x && y === ksrTarget.y) {
    ksrScore++;
    ksrScoreEl.textContent = ksrScore;
    playKEMNextSound?.();
    spawnKSRTarget();
  }

  // üí£ NOW regenerate bombs AFTER survival
  const bombCount =
    ksrMode === "easy" ? 9 :
    ksrMode === "medium" ? 12 : 15;

  ksrBombs = generateKSRBombs(bombCount);

  drawKSRBoard();
}


// ================================
// DRAW BOARD
// ================================
function drawKSRBoard() {
  ksrBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = "kp-square";
      // ‚ôüÔ∏è FILE‚ÄìRANK COORDINATE
const file = String.fromCharCode(97 + x); // a‚Äìh
const rank = y + 1;                       // 1‚Äì8

const coord = document.createElement("div");
coord.className = "ksr-coord";
coord.textContent = `${file}${rank}`;
sq.appendChild(coord);

     sq.classList.add((x + y) % 2 === 1 ? "light" : "dark");

      sq.onclick = () => handleKSRClick(x, y);

      // üí£ BOMBS
      for (const b of ksrBombs) {
        if (b.x === x && b.y === y) {
          sq.textContent = "üí£";
          sq.style.fontSize = "30px";
        }
      }

      // ‚≠ê TARGET
      if (ksrTarget && ksrTarget.x === x && ksrTarget.y === y) {
        sq.textContent = "‚≠ê";
        sq.style.fontSize = "30px";
      }

      // üê¥ KNIGHT (TOP PRIORITY)
      if (ksrKnight && ksrKnight.x === x && ksrKnight.y === y) {
        sq.textContent = "üê¥";
        sq.style.fontSize = "36px";
        sq.style.transform = "scale(1.15)";
      }

      ksrBoard.appendChild(sq);
    }
  }
}

// ================================
// GAME OVER
// ================================
function showKSRGameOver(hitBomb = false) {
  ksrRunning = false;
  stopKSRTimer();
  playKVMGameOverSound?.();
    // üèÜ SAVE BEST SCORE (Knight Speed Run)
  saveMiniGameScore("knightspeed", ksrScore);


  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = hitBomb ? "üí• BOOM!" : "‚è± Time's Up!";
  body.innerHTML = `
    <p style="font-size:16px; line-height:1.6;">
      ${hitBomb ? "You hit a bomb üí£" : "Speed Run Complete"}<br><br>
      ‚≠ê <b>Stars:</b> ${ksrScore}<br>
      üéÆ <b>Mode:</b> ${ksrMode.toUpperCase()}
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKSR();
  };
}


// =================================
// üî• KNIGHT LAVA FLOOR (ISOLATED)
// =================================

// -------- CONFIG --------
const KLF_SIZE = 10;          // change to 10 for 10x10
const KLF_LAVA_PER_TURN = 3;

// -------- STATE --------
let klfKnight = { x: 0, y: 0 };
let klfLava = [];
let klfTurns = 0;
let klfAlive = false;



// -------- ELEMENTS --------
const klfBoard = document.getElementById("klfBoard");
const klfMenu = document.getElementById("klfMenu");
const klfGame = document.getElementById("klfGame");
const klfTurnsEl = document.getElementById("klfTurns");
const klfLavaEl = document.getElementById("klfLavaCount");

// -------- KNIGHT MOVES --------
const KLF_KNIGHT_MOVES = [
  [1, 2], [2, 1], [-1, 2], [-2, 1],
  [1, -2], [2, -1], [-1, -2], [-2, -1]
];

// =========================================
// üî• Knight Lava Floor ‚Äì Game Over Sound
// =========================================
function playKLFGameOverSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.6; // üîä not too loud
    audio.play();
  } catch (e) {
    console.warn("üîá complete.mp3 could not play", e);
  }
}

// =========================================
// üî• Knight Lava Floor ‚Äì Knight Move Sound
// =========================================
function playKLFMoveSound() {
  try {
    const audio = new Audio("./sounds/alert.mp3");
    audio.volume = 0.3; // üîä soft, non-annoying
    audio.play();
  } catch (e) {
    console.warn("üîá alert.mp3 could not play", e);
  }
}

// =========================================
// üî• Knight Lava Floor ‚Äì Game Start Sound
// =========================================
function playKLFStartSound() {
  try {
    const audio = new Audio("./sounds/puzzle-rush-start.mp3");
    audio.volume = 0.6; // üîä pleasant, not loud
    audio.play();
  } catch (e) {
    console.warn("üîá puzzle-rush-start.mp3 could not play", e);
  }
}




// =================================
// START GAME
// =================================
window.startKLF = function () {

  // üîä start game sound
  playKLFStartSound();

  klfMenu.classList.add("hidden");
  klfGame.classList.remove("hidden");

  klfTurns = 0;
  klfLava = [];
  klfAlive = true;

  klfKnight = {
    x: Math.floor(KLF_SIZE / 2),
    y: Math.floor(KLF_SIZE / 2)
  };

  updateKLFUI();
  drawKLFBoard();
};

// =================================
// EXIT GAME
// =================================
window.exitKLF = function () {
  klfGame.classList.add("hidden");
  klfMenu.classList.remove("hidden");
  klfAlive = false;
};

// =================================
// DRAW BOARD
// =================================
function drawKLFBoard() {
  klfBoard.innerHTML = "";
  klfBoard.style.gridTemplateColumns = `repeat(${KLF_SIZE}, 1fr)`;

  for (let y = KLF_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < KLF_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "klf-square";

      const light = (x + y) % 2 === 0;
      sq.classList.add(light ? "klf-light" : "klf-dark");

      if (isKlfLava(x, y)) {
        sq.classList.add("klf-lava");
        sq.textContent = "üî•";
      }

      if (klfKnight.x === x && klfKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("klf-knight");
      }

      sq.onclick = () => handleKLFMove(x, y);
      klfBoard.appendChild(sq);
    }
  }
}

// =================================
// HANDLE MOVE
// =================================
function handleKLFMove(x, y) {
  if (!klfAlive) return;

  const dx = Math.abs(x - klfKnight.x);
  const dy = Math.abs(y - klfKnight.y);
  const legal = (dx === 1 && dy === 2) || (dx === 2 && dy === 1);

  if (!legal) return;

  // üîä knight move sound
  playKLFMoveSound();


  klfKnight = { x, y };
  klfTurns++;

  spreadKlfLava();

  if (isKlfLava(x, y)) {
    endKLFGame();
    return;
  }

  updateKLFUI();
  drawKLFBoard();
}

// =================================
// LAVA LOGIC
// =================================
function spreadKlfLava() {
  let added = 0;

  while (added < KLF_LAVA_PER_TURN) {
    const x = Math.floor(Math.random() * KLF_SIZE);
    const y = Math.floor(Math.random() * KLF_SIZE);

    if (
      !isKlfLava(x, y) &&
      !(x === klfKnight.x && y === klfKnight.y)
    ) {
      klfLava.push({ x, y });
      added++;
    }
  }
}

function isKlfLava(x, y) {
  return klfLava.some(l => l.x === x && l.y === y);
}

// =================================
// GAME OVER
// =================================
function endKLFGame() {
  klfAlive = false;
  drawKLFBoard();

  // üèÜ SAVE BEST SCORE (Knight Lava Floor)
  saveMiniGameScore("knightlava", klfTurns);

  // üîä game over sound
  playKLFGameOverSound();

  setTimeout(() => {
    showKLFResult();
  }, 300);
}


// =================================
// UI UPDATE
// =================================
function updateKLFUI() {
  klfTurnsEl.textContent = klfTurns;
  klfLavaEl.textContent = klfLava.length;
}



// ===============================
// üî• KLF RESULT MODAL FUNCTIONS
// ===============================

window.showKLFResult = function () {
  document.getElementById("klfResultTitle").textContent = "üî• Game Over";
  document.getElementById("klfResultText").textContent =
    `Turns survived: ${klfTurns}`;

  document.getElementById("klfResultOverlay")
    .classList.remove("hidden");
};

window.closeKLFResult = function () {
  document.getElementById("klfResultOverlay")
    .classList.add("hidden");

  exitKLF(); // safely exit game
};


function closeKLFResult() {
  document.getElementById("klfResultOverlay")
    .classList.add("hidden");

  exitKLF(); // return to menu safely
}



// ================================
// KNIGHT FOG QUEST (ISOLATED)
// ================================

let kfqKnight;
let kfqItems = [];
let kfqMoves = 0;
let kfqFound = 0;
let kfqActive = false;
let kfqTimer = null;
let kfqTimeLeft = 0;
let kfqTimedMode = false;


const kfqBoard = document.getElementById("kfqBoard");
const kfqMovesEl = document.getElementById("kfqMoves");
const kfqFoundEl = document.getElementById("kfqFound");
const kfqTaskEl = document.getElementById("kfqTask");

const KfqSize = 10;
const KfqTargets = 8;

window.startKFQTimed = function (seconds) {
  kfqTimedMode = true;
  kfqTimeLeft = seconds;

  document.getElementById("kfqMenu").classList.add("hidden");
  document.getElementById("kfqGame").classList.remove("hidden");

  kfqKnight = randKFQ();
  kfqMoves = 0;
  kfqFound = 0;
  kfqActive = true;
  kfqFoundEl.textContent = `0 / ${KfqTargets}`;


  spawnKFQItems();
  nextKFQTask();
  drawKFQBoard();

  document.getElementById("kfqTime").textContent = kfqTimeLeft;

  startKFQTimer();
};

function startKFQTimer() {
  clearInterval(kfqTimer);

  kfqTimer = setInterval(() => {
    if (!kfqActive) {
      clearInterval(kfqTimer);
      return;
    }

    kfqTimeLeft--;
    document.getElementById("kfqTime").textContent = kfqTimeLeft;

    if (kfqTimeLeft <= 0) {
      clearInterval(kfqTimer);
      showKFQGameOver("‚è± Time‚Äôs up! You ran out of time.");
    }
  }, 1000);
}


// ================================
// START / EXIT
// ================================
window.startKFQ = function () {

  document.getElementById("kfqMenu").classList.add("hidden");
  document.getElementById("kfqGame").classList.remove("hidden");

  kfqKnight = randKFQ();
  kfqMoves = 0;
  kfqFound = 0;
  kfqFoundEl.textContent = `0 / ${KfqTargets}`;

  kfqActive = true;

  spawnKFQItems();
  nextKFQTask();
  drawKFQBoard();
}

window.exitKFQ = function () {
  clearInterval(kfqTimer);

  document.getElementById("kfqGame").classList.add("hidden");
  document.getElementById("kfqMenu").classList.remove("hidden");

  kfqActive = false;
};



function playKFQNextSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("üîá next.mp3 could not play", e);
  }
}

function playKFQCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.7;
    audio.play();
  } catch (e) {
    console.warn("üîá complete.mp3 could not play", e);
  }
}

function playKNDCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.7;
    audio.play();
  } catch (e) {
    console.warn("üîá complete.mp3 could not play");
  }
}




// ================================
// RANDOM
// ================================
function randKFQ() {
  return {
    x: Math.floor(Math.random() * KfqSize),
    y: Math.floor(Math.random() * KfqSize)
  };
}

// ================================
// SPAWN ITEMS
// ================================
function spawnKFQItems() {
  kfqItems = [];

  const emojis = ["üçé", "‚≠ê", "üí£", "üß±"];

  while (kfqItems.length < 25) {
    const sq = randKFQ();

    if (
      sq.x === kfqKnight.x &&
      sq.y === kfqKnight.y
    ) continue;

    if (kfqItems.some(i => i.x === sq.x && i.y === sq.y)) continue;

    kfqItems.push({
      ...sq,
      emoji: emojis[Math.floor(Math.random() * emojis.length)]
    });
  }
}

// ================================
// TASK SYSTEM
// ================================
function nextKFQTask() {
  kfqTaskEl.textContent = "Find the üçé Apple";
}

// ================================
// CLICK HANDLER
// ================================
function handleKFQClick(x, y) {
  if (!kfqActive) return;

  const dx = Math.abs(x - kfqKnight.x);
  const dy = Math.abs(y - kfqKnight.y);

  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  const block = kfqItems.find(
    i => i.x === x && i.y === y && i.emoji === "üß±"
  );
  if (block) return;

  kfqKnight = { x, y };
  kfqMoves++;
  kfqMovesEl.textContent = kfqMoves;

  const hit = kfqItems.find(i => i.x === x && i.y === y);

  if (hit) {
    if (hit && hit.emoji === "üçé") {
  playKFQNextSound(); // üîä apple collect sound

  kfqFound++;
  kfqFoundEl.textContent = `${kfqFound} / ${KfqTargets}`;


  kfqItems = kfqItems.filter(i => i !== hit);
  nextKFQTask();

  // üéâ WIN CONDITION (TIMED MODE SAFE)
  if (kfqFound >= KfqTargets) {
    clearInterval(kfqTimer);
    showKFQGameOver("üéâ All apples found in time!");
    return;
  }
}


    if (hit && hit.emoji === "üí£") {
  showKFQGameOver("üí£ You stepped on a bomb!");
  return;
}

  }

  drawKFQBoard();
}

// ================================
// DRAW BOARD (FOG)
// ================================
function drawKFQBoard() {
  kfqBoard.innerHTML = "";

  for (let y = KfqSize - 1; y >= 0; y--) {
    for (let x = 0; x < KfqSize; x++) {
      const sq = document.createElement("div");
      sq.className = "kfq-square";
      sq.onclick = () => handleKFQClick(x, y);

      // chess colors
      sq.classList.add(
        (x + y) % 2 === 0 ? "kfq-light" : "kfq-dark"
      );

      const dx = Math.abs(x - kfqKnight.x);
      const dy = Math.abs(y - kfqKnight.y);

      const visible =
        (dx === 0 && dy === 0) ||
        (dx === 2 && dy === 1) ||
        (dx === 1 && dy === 2);

      if (!visible) {
        sq.classList.add("kfq-fog");
      } else {
        const item = kfqItems.find(i => i.x === x && i.y === y);
        if (item) sq.textContent = item.emoji;
      }

      if (kfqKnight.x === x && kfqKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("kfq-knight");
      }

      kfqBoard.appendChild(sq);
    }
  }
}


function showKFQGameOver(reason) {
  kfqActive = false;
  // üèÜ SAVE BEST SCORE (Knight Fog Quest)
  saveMiniGameScore("knightfog", kfqFound);
  playKFQCompleteSound(); // üîä GAME OVER SOUND

  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = "üí• Game Over!";
  body.innerHTML = `
    <p style="font-size:16px;">
      ${reason}<br><br>
      üçé Apples found: <b>${kfqFound}</b><br>
      ‚≠ê Moves used: <b>${kfqMoves}</b>
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKFQ();
    
  };
}



// ================================
// üëë KING DEFENSE (FULLY ISOLATED)
// ================================

let kndKnight, kndKing;
let kndMonsters = [];
let kndMode = "easy";
const KND_SIZE = 10;


const kndBoard = document.getElementById("kndBoard");
const kndLeftEl = document.getElementById("kndLeft");

// ================================
// START GAME
// ================================
window.startKND = function (mode) {
  kndMode = mode;
  playKNDStartSound(); // üîä GAME START SOUND

  document.getElementById("kndMenu").classList.add("hidden");
  document.getElementById("kndGame").classList.remove("hidden");

  kndKing   = { x: 4, y: 0 };
  kndKnight = { x: 5, y: 4 };

 const count =
  mode === "easy"   ? 3:
  mode === "medium" ? 4:
                      5;//hard


  kndMonsters = [];

  // üëπ SPAWN LOGIC (PASTE HERE)
  const usedX = new Set();
  while (kndMonsters.length < count) {
    const x = Math.floor(Math.random() * KND_SIZE);
    if (usedX.has(x)) continue;
    usedX.add(x);
    kndMonsters.push({ x, y: KND_SIZE - 1 });
  }

  kndLeftEl.textContent = kndMonsters.length;
  drawKNDBoard();
};

// ================================
// üîä KND ‚Äì Knight Move Sound
// ================================
function playKNDKnightMoveSound() {
  try {
    const audio = new Audio("./sounds/alert.mp3");
    audio.volume = 0.1;
    audio.play();
  } catch (e) {
    console.warn("üîá alert.mp3 could not play", e);
  }
}

function playKNDStartSound() {
  try {
    const audio = new Audio("./sounds/puzzle-rush-start.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("üîá puzzle-rush-start.mp3 could not play");
  }
}




// ================================
// EXIT
// ================================
window.exitKND = function () {
  document.getElementById("kndGame").classList.add("hidden");
  document.getElementById("kndMenu").classList.remove("hidden");
};

// ================================
// MONSTER MOVEMENT (SAFE & CLEAN)
// ================================
function moveKNDMonstersTowardKing() {
  const occupied = new Set(
    kndMonsters.map(m => `${m.x},${m.y}`)
  );

  for (const m of kndMonsters) {
    occupied.delete(`${m.x},${m.y}`);

    let best = null;
    let bestScore = Infinity;

    // üß† KING-LIKE MOVEMENT (8 DIRECTIONS)
    const directions = [
      [-1,-1],[0,-1],[1,-1],
      [-1, 0],       [1, 0],
      [-1, 1],[0, 1],[1, 1],
    ];

    for (const [dx, dy] of directions) {
      const nx = m.x + dx;
      const ny = m.y + dy;

      if (
        nx < 0 || nx >= KND_SIZE ||
        ny < 0 || ny >= KND_SIZE
      ) continue;

      // üö´ cannot land on knight
      if (nx === kndKnight.x && ny === kndKnight.y) continue;

      // üö´ cannot stack monsters
      if (occupied.has(`${nx},${ny}`)) continue;

      // üéØ distance to king
      const distToKing =
        Math.abs(nx - kndKing.x) +
        Math.abs(ny - kndKing.y);

      // üß± density penalty (prevents stacking lines)
      let densityPenalty = 0;
      for (const o of occupied) {
        const [ox, oy] = o.split(",").map(Number);
        const d = Math.abs(nx - ox) + Math.abs(ny - oy);
        if (d === 1) densityPenalty += 8;
        if (d === 2) densityPenalty += 4;
      }

      // üß† FINAL SCORE
      const score = distToKing * 20 + densityPenalty;

      if (score < bestScore) {
        bestScore = score;
        best = { x: nx, y: ny };
      }
    }

    // üöë ABSOLUTE FAILSAFE (NEVER FREEZE)
    if (!best) {
      for (const [dx, dy] of directions) {
        const nx = m.x + dx;
        const ny = m.y + dy;
        if (
          nx >= 0 && nx < KND_SIZE &&
          ny >= 0 && ny < KND_SIZE &&
          !(nx === kndKnight.x && ny === kndKnight.y) &&
          !occupied.has(`${nx},${ny}`)
        ) {
          best = { x: nx, y: ny };
          break;
        }
      }
    }

    if (best) {
      m.x = best.x;
      m.y = best.y;
    }

    occupied.add(`${m.x},${m.y}`);

    // üëë KING KILLED (ANY DIRECTION)
    if (m.x === kndKing.x && m.y === kndKing.y) {
      showKNDModal("Defeat!", "üëë The King was slain!");
      return;
    }
  }
}









// ================================
// CLICK HANDLER
// ================================
function handleKNDClick(x, y) {
  const dx = Math.abs(x - kndKnight.x);
  const dy = Math.abs(y - kndKnight.y);

  // knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  // move knight
  kndKnight = { x, y };

  // üîä play move sound
playKNDKnightMoveSound();

  // üó°Ô∏è kill monster
  const hitIndex = kndMonsters.findIndex(
    m => m.x === x && m.y === y
  );
  if (hitIndex !== -1) {
    kndMonsters.splice(hitIndex, 1);
    kndLeftEl.textContent = kndMonsters.length;

    if (kndMonsters.length === 0) {
      // üèÜ SAVE BEST SCORE (King Defense)
  saveMiniGameScore("knightdefense", kndTotalMonsters);
  showKNDModal("Victory!", "üéâ All monsters defeated!");
  return;
}

  }

  // monsters move AFTER knight
  moveKNDMonstersTowardKing();
  drawKNDBoard();
}

// ================================
// DRAW BOARD (RANK SAFE)
// ================================
function drawKNDBoard() {
  kndBoard.innerHTML = "";

  for (let y = KND_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < KND_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "knd-square";
      sq.classList.add((x + y) % 2 === 0 ? "light" : "dark");
      sq.onclick = () => handleKNDClick(x, y);

      if (kndKing.x === x && kndKing.y === y) {
        sq.textContent = "üëë";
        sq.classList.add("king");
      }
      else if (kndKnight.x === x && kndKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("knight");
      }
      else {
        const m = kndMonsters.find(mm => mm.x === x && mm.y === y);
        if (m) {
          sq.textContent = "üëπ";
          sq.classList.add("monster");
        }
      }

      kndBoard.appendChild(sq);
    }
  }
}



// ================================
// GAME OVER
// ================================
function showKNDGameOver(msg) {
  showKNDModal("Game Over", msg);
  

}




function showKNDModal(title, message) {
  playKNDCompleteSound(); // üîä GAME END SOUND

  const modal = document.getElementById("floatingModal");
  const titleEl = document.getElementById("modalTitle");
  const bodyEl = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  titleEl.textContent = title;
  bodyEl.textContent = message;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitKND();
  };
}



// ================================
// üéµ GLOBAL BACKGROUND MUSIC
// ================================

const GAME_MUSIC_TRACKS = [
  "./sounds/sound_track_1.mp3",
  "./sounds/sound_track_2.mp3",
  "./sounds/sound_track_3.mp3",
  "./sounds/sound_track_4.mp3",
  "./sounds/sound_track_5.mp3",
  "./sounds/sound_track_6.mp3",
  "./sounds/sound_track_7.mp3",
  "./sounds/sound_track_8.mp3",
  "./sounds/sound_track_9.mp3",
  "./sounds/sound_track_10.mp3",
];

let gameMusic = null;
let musicMuted = false;
let musicStarted = false;

// ‚ñ∂Ô∏è PLAY SPECIFIC MUSIC (SINGLE SOURCE OF TRUTH)
function playMusic(src) {
  stopGameMusic();

  gameMusic = new Audio(src);
  gameMusic.loop = true;
  gameMusic.volume = 0.35;

  gameMusic.play()
    .then(() => {
      musicStarted = true;
    })
    .catch(() => {
      // autoplay blocked ‚Äì will retry on interaction
    });
}

// ‚ñ∂Ô∏è START RANDOM MUSIC
function startGameMusic() {
  if (musicMuted || musicStarted) return;

  const src =
    GAME_MUSIC_TRACKS[Math.floor(Math.random() * GAME_MUSIC_TRACKS.length)];

  playMusic(src);
}

// ‚èπ STOP MUSIC
function stopGameMusic() {
  if (!gameMusic) return;
  gameMusic.pause();
  gameMusic.currentTime = 0;
  gameMusic = null;
  musicStarted = false;
}

// ================================
// üîá MUTE BUTTON
// ================================

const musicMuteBtn = document.getElementById("musicMuteBtn");

musicMuteBtn.addEventListener("click", () => {
  musicMuted = !musicMuted;

  if (musicMuted) {
    stopGameMusic();
    musicMuteBtn.textContent = "üîá";
  } else {
    musicMuteBtn.textContent = "üîä";
    startGameMusic();
  }
});

// ================================
// üîë FIRST USER INTERACTION UNLOCK
// ================================

["click", "keydown", "touchstart"].forEach(evt => {
  document.addEventListener(evt, startGameMusic, { once: true });
});

// ================================
// üéº MUSIC MENU (HOVER SELECT)
// ================================

const musicControl = document.getElementById("musicControl");
const musicMenu = document.getElementById("musicMenu");

// hover show / hide
musicControl.addEventListener("mouseenter", () => {
  musicMenu.classList.remove("hidden");
});

musicControl.addEventListener("mouseleave", () => {
  musicMenu.classList.add("hidden");
});

// click to select track
musicMenu.querySelectorAll("div").forEach(item => {
  item.addEventListener("click", () => {
    const src = item.dataset.src;
    if (!src) return;

    musicMuted = false;
    musicMuteBtn.textContent = "üîä";

    playMusic(src);
    musicMenu.classList.add("hidden");
  });
});



/* ================================
   üëë KING MATH JOURNEY (FINAL FIX)
================================ */

/* ================================
   üëë KING MATH JOURNEY ‚Äî FINAL
================================ */

const KM_SIZE = 10;

/* -------- GAME STATE -------- */
let kmLevel = "easy";
let kmKing = { x: 0, y: 0 };
let kmUsedQuestions = new Set();
let kmCorrectAnswer = 0;

let kmSteps = 0;
let kmTargetSteps = 0;
let kmDirection = 1; // 1 = up, -1 = down
/* -------- TIMER -------- */
let kmTimeLeft = 0;
let kmTimerInterval = null;

const kmTimeEl = document.getElementById("kmTime");


/* -------- ELEMENTS -------- */ 
const kmBoard = document.getElementById("kmBoard");
const kmQuestionEl = document.getElementById("kmQuestion");
const kmStepEl = document.getElementById("kmStep");

/* ================================
   START / EXIT
================================ */

window.startKM = function (level) {
  kmLevel = level;

  // üîÅ FULL RESET (VERY IMPORTANT)
  kmUsedQuestions.clear();
  kmDirection = 1;

  kmSteps = 0;
  kmTargetSteps = getTargetSteps();
  kmStepEl.textContent = `${kmSteps} / ${kmTargetSteps}`;

  // üëë start from ANY column, LAST RANK
  kmKing = {
    x: rand(0, KM_SIZE - 1),
    y: 0
  };

  document.getElementById("kmMenu").classList.add("hidden");
  document.getElementById("kmGame").classList.remove("hidden");

  nextMath();
  drawKMBoard();
  startKMTimer(); // ‚úÖ HERE
};

window.exitKM = function () {
  stopKMTimer();

  // üèÜ SAVE BEST SCORE (King Math Journey)
  saveMiniGameScore("kingmath", kmSteps);

  document.getElementById("kmGame").classList.add("hidden");
  document.getElementById("kmMenu").classList.remove("hidden");
};

/* ================================
   TARGET STEPS
================================ */

function getTargetSteps() {
  if (kmLevel === "easy") return 25;
  if (kmLevel === "medium") return 35;
  return 40; // hard
}

function playKMNextSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {
    console.warn("‚ö†Ô∏è next.mp3 could not play");
  }
}


/* ================================
   MATH GENERATION
================================ */

function generateUniqueMath() {
  let q, a, key;

  do {
    let n1, n2, op;

    if (kmLevel === "easy") {
      n1 = rand(1, 10);
      n2 = rand(1, 10);
      op = Math.random() < 0.5 ? "+" : "-";
    } else if (kmLevel === "medium") {
      n1 = rand(1, 15);
      n2 = rand(1, 10);
      op = ["+", "-", "√ó"][rand(0, 2)];
    } else {
      n2 = rand(1, 10);
      a = rand(1, 10);
      n1 = a * n2;
      op = "√∑";
    }

    a = evalMath(n1, n2, op);
    q = `${n1} ${op} ${n2}`;
    key = q + "=" + a;

  } while (kmUsedQuestions.has(key));

  kmUsedQuestions.add(key);
  return { q, a };
}

function evalMath(a, b, op) {
  if (op === "+") return a + b;
  if (op === "-") return a - b;
  if (op === "√ó") return a * b;
  if (op === "√∑") return a / b;
}

function nextMath() {
  const m = generateUniqueMath();
  kmQuestionEl.textContent = m.q;
  kmCorrectAnswer = m.a;
}

/* ================================
   ANSWER CLICK
================================ */

function chooseAnswer(val, x, y) {
  if (val !== kmCorrectAnswer) {
    showKNDModal("‚ùå Wrong Answer", "Game Over!");
    exitKM(); // exitKM already stops timer
    return;
  }

  // üîä isolated correct answer sound
  playKMNextSound();

  // üëë move king
  kmKing.x = x;
  kmKing.y = y;

  // üîÑ flip direction at edges
  if (kmKing.y >= KM_SIZE - 2) kmDirection = -1;
  if (kmKing.y <= 1) kmDirection = 1;

  kmSteps++;
  kmStepEl.textContent = `${kmSteps} / ${kmTargetSteps}`;

  if (kmSteps >= kmTargetSteps) {
    showKNDModal("üéâ Victory!", "Chess Math Journey Completed!");
    exitKM(); // stops timer
    return;
  }

  nextMath();
  drawKMBoard();
}






/* ================================
   BOARD DRAW (BUG-FREE)
================================ */

function drawKMBoard() {
  kmBoard.innerHTML = "";

  // üß† answer row (SAFE)
  let answerY = kmKing.y + kmDirection;
  if (answerY < 0) answerY = 0;
  if (answerY >= KM_SIZE) answerY = KM_SIZE - 1;

  // üß† ALWAYS 3 valid X positions
  let answerXs = [];

  if (kmKing.x === 0) answerXs = [0, 1, 2];
  else if (kmKing.x === KM_SIZE - 1) answerXs = [KM_SIZE - 3, KM_SIZE - 2, KM_SIZE - 1];
  else answerXs = [kmKing.x - 1, kmKing.x, kmKing.x + 1];

  const answers = shuffle([
    kmCorrectAnswer,
    kmCorrectAnswer + rand(1, 4),
    kmCorrectAnswer - rand(1, 4)
  ]);

  const colors = getRandomAnswerColors();

  for (let y = KM_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < KM_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "square " + ((x + y) % 2 ? "dark" : "light");

      if (x === kmKing.x && y === kmKing.y) {
        sq.textContent = "üëë";
        sq.classList.add("king");
      }

      else if (y === answerY && answerXs.includes(x)) {
        const idx = answerXs.indexOf(x);
        const val = answers[idx];
        const col = colors[idx];

        sq.textContent = val;
        sq.classList.add("answer", col);
        sq.onclick = () => chooseAnswer(val, x, y);
      }

      kmBoard.appendChild(sq);
    }
  }
}

/* ================================
   HELPERS
================================ */

function rand(a, b) {
  return Math.floor(Math.random() * (b - a + 1)) + a;
}

function shuffle(arr) {
  return arr.sort(() => Math.random() - 0.5);
}

function getRandomAnswerColors() {
  return shuffle([
    "answer-green",
    "answer-yellow",
    "answer-blue",
    "answer-purple"
  ]).slice(0, 3);
}


function getLevelTime() {
  if (kmLevel === "easy") return 90;    // 1.5 min
  if (kmLevel === "medium") return 120; // 2 min
  return 150;                           // hard: 2.5 min
}

function startKMTimer() {
  stopKMTimer();

  // ‚è±Ô∏è time per level
  if (kmLevel === "easy") kmTimeLeft = 40;
  else if (kmLevel === "medium") kmTimeLeft = 60;
  else kmTimeLeft = 90;

  const timerEl = document.getElementById("kmTimer");
  const timeEl = document.getElementById("kmTime");

  timerEl.classList.remove("danger");
  timeEl.textContent = kmTimeLeft;

  kmTimerInterval = setInterval(() => {
    kmTimeLeft--;
    timeEl.textContent = kmTimeLeft;

    // üî• ADD THIS HERE (CORRECT PLACE)
    if (kmTimeLeft <= 10) {
      timerEl.classList.add("danger");
    }

    // ‚è∞ time over
    if (kmTimeLeft <= 0) {
      stopKMTimer();
      showKNDModal("‚è∞ Time Up!", "Game Over!");
      exitKM();
    }
  }, 1000);
}

function stopKMTimer() {
  if (kmTimerInterval) {
    clearInterval(kmTimerInterval);
    kmTimerInterval = null;
  }
}


// ================================
// üé® COLOR FLIP CHAOS (ISOLATED)
// ================================

const CFC_SIZE = 8;

// üé® minimum 10 colors (kid friendly)
const CFC_COLORS = [
  "white",
  "#ff6b6b", // red
  "#4dabf7", // blue
  "#51cf66", // green
  "#ffd43b", // yellow
  "#9775fa", // purple
  "#ff922b", // orange
  "#22b8cf", // cyan
  "#f783ac", // pink
  "#94d82d"  // lime
];

// ================================
// STATE
// ================================
let cfcKnight = null;
let cfcWhiteVisited = new Set();
let cfcScore = 0;
let cfcTarget = 5;
let cfcTime = 20;

let cfcTimer = null;
let cfcColorInterval = null;
let cfcColorGrid = [];
let cfcDifficulty = "easy";

// ‚è± FIXED COLOR SPEED (NEVER CHANGES)
const CFC_COLOR_SPEED = 2000;

// ================================
// ELEMENTS
// ================================
const cfcBoard = document.getElementById("cfcBoard");
const cfcScoreEl = document.getElementById("cfcScore");
const cfcTargetEl = document.getElementById("cfcTarget");
const cfcTimeEl = document.getElementById("cfcTime");

// ================================
// START GAME
// ================================
window.startCFC = function (mode = "easy") {
  cfcDifficulty = mode;

  // ‚è± difficulty = TIME ONLY
  if (mode === "easy") {
    cfcTime = 40;
    cfcTarget = 5;
  } else if (mode === "medium") {
    cfcTime = 30;
    cfcTarget = 6;
  } else {
    cfcTime = 20;
    cfcTarget = 5;
  }

  cfcKnight = {
    x: Math.floor(Math.random() * CFC_SIZE),
    y: Math.floor(Math.random() * CFC_SIZE)
  };

  cfcWhiteVisited.clear();
  cfcScore = 0;

  cfcScoreEl.textContent = cfcScore;
  cfcTargetEl.textContent = cfcTarget;
  cfcTimeEl.textContent = cfcTime;

  document.getElementById("cfcMenu").classList.add("hidden");
  document.getElementById("cfcGame").classList.remove("hidden");

  // üé® INIT COLOR GRID (ONCE)
  cfcColorGrid = [];
  for (let y = 0; y < CFC_SIZE; y++) {
    const row = [];
    for (let x = 0; x < CFC_SIZE; x++) {
      row.push(
        CFC_COLORS[Math.floor(Math.random() * CFC_COLORS.length)]
      );
    }
    cfcColorGrid.push(row);
  }

  drawCFCBoard();
  startCFCTimer();
  startColorChaos();
};

// ================================
// COLOR CHAOS (TIME ONLY)
// ================================
function startColorChaos() {
  clearInterval(cfcColorInterval);

  cfcColorInterval = setInterval(() => {
    for (let y = 0; y < CFC_SIZE; y++) {
      for (let x = 0; x < CFC_SIZE; x++) {
        cfcColorGrid[y][x] =
          CFC_COLORS[Math.floor(Math.random() * CFC_COLORS.length)];
      }
    }
    updateCFCBoardColors();
  }, CFC_COLOR_SPEED); // ‚úÖ fixed
}

// ================================
// UPDATE BOARD COLORS (NO REDRAW)
// ================================
function updateCFCBoardColors() {
  const squares = cfcBoard.children;
  let i = 0;

  for (let y = CFC_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < CFC_SIZE; x++) {
      const sq = squares[i++];
      const color = cfcColorGrid[y][x];
      sq.dataset.color = color;
      sq.style.backgroundColor = color;
    }
  }
}

// ================================
// SOUNDS
// ================================
function playCFCWhiteSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch {}
}

function playCFCWrongSound() {
  try {
    const audio = new Audio("./sounds/wrrong.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch {}
}

function playCFCCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch {}
}

// ================================
// EXIT GAME
// ================================
window.exitCFC = function () {
  clearInterval(cfcTimer);
  clearInterval(cfcColorInterval);

  document.getElementById("cfcGame").classList.add("hidden");
  document.getElementById("cfcMenu").classList.remove("hidden");
};

// ================================
// TIMER
// ================================
function startCFCTimer() {
  clearInterval(cfcTimer);

  cfcTimer = setInterval(() => {
    cfcTime--;
    cfcTimeEl.textContent = cfcTime;

    if (cfcTime <= 0) {
      showCFCGameOver(false);
    }
  }, 1000);
}

// ================================
// HANDLE CLICK
// ================================
function handleCFCClick(x, y, el) {
  const dx = Math.abs(x - cfcKnight.x);
  const dy = Math.abs(y - cfcKnight.y);

  // üê¥ Knight legality
  if (!((dx === 2 && dy === 1) || (dx === 1 && dy === 2))) return;

  cfcKnight = { x, y };

  if (el.dataset.color === "white") {
    const key = `${x}-${y}`;
    if (!cfcWhiteVisited.has(key)) {
      cfcWhiteVisited.add(key);
      cfcScore++;
      cfcScoreEl.textContent = cfcScore;
      playCFCWhiteSound();
    }
  } else {
    playCFCWrongSound();
  }

  if (cfcScore >= cfcTarget) {
    showCFCGameOver(true);
    return;
  }

  drawCFCBoard();
}

// ================================
// DRAW BOARD (POSITION ONLY)
// ================================
function drawCFCBoard() {
  cfcBoard.innerHTML = "";

  for (let y = CFC_SIZE - 1; y >= 0; y--) {
    for (let x = 0; x < CFC_SIZE; x++) {
      const sq = document.createElement("div");
      sq.className = "cfc-square";

      const color = cfcColorGrid[y][x];
      sq.dataset.color = color;
      sq.style.backgroundColor = color;

      if (cfcKnight.x === x && cfcKnight.y === y) {
        sq.textContent = "üê¥";
        sq.classList.add("cfc-knight");
      }

      sq.onclick = () => handleCFCClick(x, y, sq);
      cfcBoard.appendChild(sq);
    }
  }
}

// ================================
// GAME OVER
// ================================
function showCFCGameOver(win) {
  playCFCCompleteSound();
    // üèÜ SAVE BEST SCORE (Color Flip Chaos)
  saveMiniGameScore("colorchaos", cfcScore);


  clearInterval(cfcTimer);
  clearInterval(cfcColorInterval);

  const modal = document.getElementById("floatingModal");
  const title = document.getElementById("modalTitle");
  const body = document.getElementById("modalBody");
  const okBtn = document.getElementById("modalOkBtn");

  title.textContent = win ? "üéâ Chaos Master!" : "‚è± Time Up!";
  body.innerHTML = `
    <p style="font-size:16px;">
      ‚ö™ White Squares Collected: <b>${cfcScore}</b><br>
      üéØ Target: <b>${cfcTarget}</b>
    </p>
  `;

  modal.classList.remove("hidden");

  okBtn.onclick = () => {
    modal.classList.add("hidden");
    exitCFC();
  };
}


// ================================
// üìç BOARD COORDINATE TRAINING
// ================================

const ctBoardEl = document.getElementById("ctBoard");
const ctMenu = document.getElementById("ctMenu");
const ctGame = document.getElementById("ctGame");

const ctTargetEl = document.getElementById("ctTarget");
const ctScoreEl = document.getElementById("ctScore");
const ctMissEl = document.getElementById("ctMiss");

let ctTarget = "";
let ctScore = 0;
let ctMiss = 0;

// ================================
// üîä COORD TRAINING SOUNDS (ISOLATED)
// ================================

function playCTCorrectSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch (e) {}
}

function playCTWrongSound() {
  try {
    const audio = new Audio("./sounds/wrong.mp3");
    audio.volume = 0.6;
    audio.play();
  } catch (e) {}
}


// START
window.startCT = function () {
  ctScore = 0;
  ctMiss = 0;
  ctScoreEl.textContent = "0";
  ctMissEl.textContent = "0";

  ctMenu.classList.add("hidden");
  ctGame.classList.remove("hidden");

  drawCTBoard();
  nextCTTarget();
};

// EXIT
window.exitCT = function () {
  // üèÜ SAVE BEST SCORE (Board Coordinate Training)
  saveMiniGameScore("coordtrain", ctScore);
  ctGame.classList.add("hidden");
  ctMenu.classList.remove("hidden");
};

// DRAW BOARD
function drawCTBoard() {
  ctBoardEl.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");

     const isLight = (x + y) % 2 === 1;

      sq.className = "square " + (isLight ? "light" : "dark");

      const file = String.fromCharCode(97 + x);
      const rank = y + 1;
      const coord = file + rank;

      sq.dataset.coord = coord;

      sq.onclick = () => handleCTClick(coord, sq);

      ctBoardEl.appendChild(sq);
    }
  }
}

// TARGET
function nextCTTarget() {
  const file = String.fromCharCode(97 + Math.floor(Math.random() * 8));
  const rank = Math.floor(Math.random() * 8) + 1;
  ctTarget = file + rank;

  ctTargetEl.textContent = ctTarget;

  // üî• flash effect
  ctTargetEl.style.opacity = "0";
  setTimeout(() => (ctTargetEl.style.opacity = "1"), 100);
}

// CLICK
function handleCTClick(coord, sq) {
  if (coord === ctTarget) {

    playCTCorrectSound(); // üîä correct
    ctScore++;
    ctScoreEl.textContent = ctScore;

    sq.style.boxShadow = "inset 0 0 0 4px #51cf66";

    setTimeout(() => {
      sq.style.boxShadow = "";
      nextCTTarget();
    }, 300);
  } else {

     playCTWrongSound(); // üîä wrong
    ctMiss++;
    ctMissEl.textContent = ctMiss;

    sq.style.boxShadow = "inset 0 0 0 4px #ff6b6b";
    setTimeout(() => (sq.style.boxShadow = ""), 300);
  }
}

// ================================
// üëÅ TOGGLE FILES & RANKS (ISOLATED)
// ================================

let ctCoordsVisible = true;

window.toggleCTCoords = function () {
  ctCoordsVisible = !ctCoordsVisible;

  const ranks = document.querySelector("#coordtrain-section .cfc-ranks");
  const files = document.querySelector("#coordtrain-section .cfc-files");
  const btn = document.getElementById("ctToggleCoords");

  if (ctCoordsVisible) {
    ranks.style.visibility = "visible";
    files.style.visibility = "visible";
    btn.textContent = "üëÄ Hide Files & Ranks";
  } else {
    ranks.style.visibility = "hidden";
    files.style.visibility = "hidden";
    btn.textContent = "üôà Show Files & Ranks";
  }
};


// ======================================
// üß† BOARD FREEZE ‚Äî AUTO QUESTION ENGINE
// FULLY ISOLATED (FIXED)
// ======================================

// ---------- CONFIG ----------
const BF_FLASH_TIME = 5000; // ms

const BF_PIECES = [
  { type: "pawn",   color: "white", img: "./assets/pieces/wP.png" },
  { type: "rook",   color: "white", img: "./assets/pieces/wR.png" },
  { type: "knight", color: "white", img: "./assets/pieces/wN.png" },
  { type: "bishop", color: "white", img: "./assets/pieces/wB.png" },
  { type: "queen",  color: "white", img: "./assets/pieces/wQ.png" },
  { type: "king",   color: "white", img: "./assets/pieces/wK.png" },

  { type: "pawn",   color: "black", img: "./assets/pieces/bP.png" },
  { type: "rook",   color: "black", img: "./assets/pieces/bR.png" },
  { type: "knight", color: "black", img: "./assets/pieces/bN.png" },
  { type: "bishop", color: "black", img: "./assets/pieces/bB.png" },
  { type: "queen",  color: "black", img: "./assets/pieces/bQ.png" },
  { type: "king",   color: "black", img: "./assets/pieces/bK.png" }
];

// ---------- STATE ----------
let bfPieces = [];
let bfCorrectAnswer = 0;
let bfUserAnswer = 0;
let bfScore = 0;

// ---------- DOM (SAFE INIT) ----------
const bfBoard = document.getElementById("bfBoard");
const bfQuestionEl = document.getElementById("bfQuestion");
const bfAnswerEl = document.getElementById("bfAnswer");
const bfScoreEl = document.getElementById("bfScore");
const bfMenu = document.getElementById("bfMenu");
const bfGame = document.getElementById("bfGame");

// ---------- QUESTION BANK ----------
const BF_QUESTIONS = [
  () => countBy(p => p.type === "rook", "How many rooks?"),
  () => countBy(p => p.type === "bishop", "How many bishops?"),
  () => countBy(p => p.type === "queen", "How many queens?"),
  () => countBy(p => p.type === "knight", "How many knights?"),
  () => countBy(p => p.type === "pawn", "How many pawns?"),

  () => countBy(p => p.color === "white", "How many white pieces?"),
  () => countBy(p => p.color === "black", "How many black pieces?"),

  () => countBy(p => p.type === "pawn" && p.color === "white", "How many white pawns?"),
  () => countBy(p => p.type === "pawn" && p.color === "black", "How many black pawns?"),

  () => countBy(p => p.type === "rook" && p.color === "white", "How many white rooks?"),
  () => countBy(p => p.type === "rook" && p.color === "black", "How many black rooks?"),

  () => countBy(p => p.type === "bishop" && p.color === "white", "How many white bishops?"),
  () => countBy(p => p.type === "bishop" && p.color === "black", "How many black bishops?"),

  () => countBy(p => p.type === "queen" && p.color === "white", "How many white queens?"),
  () => countBy(p => p.type === "queen" && p.color === "black", "How many black queens?"),

  () => countBy(p => p.type === "king", "How many kings?"),
  () => countBy(p => p.type === "king" && p.color === "white", "How many white kings?"),
  () => countBy(p => p.type === "king" && p.color === "black", "How many black kings?"),

  () => countBy(p => isDarkSquare(p.x, p.y), "How many pieces on dark squares?"),
  () => countBy(p => !isDarkSquare(p.x, p.y), "How many pieces on light squares?"),

  () => countBy(p => p.type === "pawn" || p.type === "rook", "How many pawns + rooks?"),
  () => countBy(p => p.type === "bishop" || p.type === "knight", "How many bishops + knights?"),

  () => countBy(() => true, "How many total pieces?")
];

// ---------- HELPERS ----------
function isDarkSquare(x, y) {
  return (x + y) % 2 === 1;
}

function countBy(filterFn, questionText) {
  bfCorrectAnswer = bfPieces.filter(filterFn).length;
  bfQuestionEl.textContent = questionText;
}

// ---------- GAME FLOW ----------
window.startBF = function () {
  if (!bfBoard) return;

  bfMenu.classList.add("hidden");
  bfGame.classList.remove("hidden");

  bfScore = 0;
  bfScoreEl.textContent = "0";

  nextBFRound();
};

window.exitBF = function () {
  // üèÜ SAVE BEST SCORE (Board Freeze)
  saveMiniGameScore("boardfreeze", bfScore);
  bfGame.classList.add("hidden");
  bfMenu.classList.remove("hidden");
  
};

// ---------- ROUND ----------
function nextBFRound() {
  bfBoard.innerHTML = "";
  bfUserAnswer = 0;
  bfAnswerEl.textContent = "0";
  bfPieces = [];

  const pieceCount = 8 + Math.floor(Math.random() * 8);

  while (bfPieces.length < pieceCount) {
    const x = Math.floor(Math.random() * 8);
    const y = Math.floor(Math.random() * 8);
    if (bfPieces.some(p => p.x === x && p.y === y)) continue;

    const piece = BF_PIECES[Math.floor(Math.random() * BF_PIECES.length)];
    bfPieces.push({ ...piece, x, y });
  }

  const q = BF_QUESTIONS[Math.floor(Math.random() * BF_QUESTIONS.length)];
  q();

  drawBF(true);
  setTimeout(() => drawBF(false), BF_FLASH_TIME);
}

// ---------- DRAW ----------
function drawBF(show) {
  bfBoard.innerHTML = "";

  for (let y = 7; y >= 0; y--) {
    for (let x = 0; x < 8; x++) {
      const sq = document.createElement("div");
      sq.className = `square ${(x + y) % 2 === 0 ? "dark" : "light"}`;


      if (show) {
        const p = bfPieces.find(o => o.x === x && o.y === y);
        if (p) {
          const img = document.createElement("img");
          img.src = p.img;
          img.style.width = "80%";
          img.style.pointerEvents = "none";
          sq.appendChild(img);
        }
      }
      bfBoard.appendChild(sq);
    }
  }
}

// ---------- ANSWER CONTROLS ----------
window.bfPlus = function () {
  bfUserAnswer++;
  bfAnswerEl.textContent = bfUserAnswer;
};

window.bfMinus = function () {
  if (bfUserAnswer > 0) bfUserAnswer--;
  bfAnswerEl.textContent = bfUserAnswer;
};

window.bfSubmit = function () {
  if (bfUserAnswer === bfCorrectAnswer) {
    bfScore++;
    bfScoreEl.textContent = bfScore;
    playNextSound?.();
  } else {
    playWrongSound?.();
  }
  setTimeout(nextBFRound, 600);
  
};






/* ============================= */
/* üß≠ KNIGHT GPS ‚Äî FREE ROAM MODE */
/* ============================= */

const kgBoard = document.getElementById("kgBoard");
const kgFuelEl = document.getElementById("kgFuel");
const kgTargetEl = document.getElementById("kgTarget");

let kgKnight = { x: 0, y: 7 };
let kgTarget = { x: 7, y: 0 };
let kgFuel = 6;
let kgLevel = 1;

const knightsMoves = [
  [1,2],[2,1],[-1,2],[-2,1],
  [1,-2],[2,-1],[-1,-2],[-2,-1]
];

/* ============================= */
/* üöÄ GAME FLOW */
/* ============================= */


/* ============================= */
/* üîä KNIGHT GPS SOUNDS (ISOLATED) */
/* ============================= */

function playKGMoveSound() {
  try {
    const audio = new Audio("./sounds/move.mp3");
    audio.volume = 0.7;
    audio.play();
  } catch (e) {}
}

function playKGSuccessSound() {
  try {
    const audio = new Audio("./sounds/next.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch (e) {}
}

function playKGCompleteSound() {
  try {
    const audio = new Audio("./sounds/complete.mp3");
    audio.volume = 0.8;
    audio.play();
  } catch (e) {}
}




function startKG() {
  document.getElementById("kgMenu").classList.add("hidden");
  document.getElementById("kgGame").classList.remove("hidden");

  kgLevel = 1;
  nextKGLevel();
}

function exitKG() {
  document.getElementById("kgGame").classList.add("hidden");
  document.getElementById("kgMenu").classList.remove("hidden");
}

window.startKG = startKG;
window.exitKG = exitKG;

/* ============================= */
/* üîÅ LEVEL SYSTEM */
/* ============================= */

function nextKGLevel() {
  kgFuel = 5;                 // ‚úÖ FIXED MOVES
  kgKnight = { x: 0, y: 7 };  // a1

  kgTarget = randomTargetSquare();

  kgFuelEl.textContent = kgFuel;
  kgTargetEl.textContent =
    `${String.fromCharCode(97 + kgTarget.x)}${8 - kgTarget.y}`;

  drawKGBoard();
}

/* ============================= */
/* üé≤ RANDOM TARGET */
/* ============================= */

function randomTargetSquare() {
  let sq;
  do {
    sq = {
      x: Math.floor(Math.random() * 8),
      y: Math.floor(Math.random() * 8)
    };
  } while (
    sq.x === kgKnight.x && sq.y === kgKnight.y
  );
  return sq;
}

/* ============================= */
/* üé® DRAW BOARD */
/* ============================= */

function drawKGBoard() {
  kgBoard.innerHTML = "";

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {

      const sq = document.createElement("div");
      sq.className = "kg-square " + ((x + y) % 2 ? "kg-dark" : "kg-light");

      // üéØ target (FREE of square color)
if (x === kgTarget.x && y === kgTarget.y) {
  sq.style.background = "transparent"; // ‚úÖ KILLS dark square
  sq.classList.add("kg-target");

  const target = document.createElement("span");
  target.textContent = "üéØ";
  sq.appendChild(target);
}



      // ‚ôû knight
      if (x === kgKnight.x && y === kgKnight.y) {
        const img = document.createElement("img");
        img.src = "assets/pieces/wN.png";
        img.draggable = false;
        sq.appendChild(img);
      }

      sq.onclick = () => handleKGMove(x, y);
      kgBoard.appendChild(sq);
    }
  }
}

/* ============================= */
/* ‚ôû MOVE LOGIC */
/* ============================= */

function handleKGMove(x, y) {
  if (kgFuel <= 0) return;

  const legal = knightsMoves.some(
    ([dx, dy]) => kgKnight.x + dx === x && kgKnight.y + dy === y
  );

  if (!legal) return;
  // üîä play move sound ONLY on valid move
  playKGMoveSound();

  kgKnight = { x, y };
  kgFuel--;
  kgFuelEl.textContent = kgFuel;

  // üéâ SUCCESS
  if (x === kgTarget.x && y === kgTarget.y) {
    kgLevel++;
    playKGSuccessSound();
    setTimeout(nextKGLevel, 400);
    return;
  }

  // ‚ùå FAIL
  if (kgFuel === 0) {
  playKGCompleteSound();     // üîä game over sound
  showKGGameOverModal();     // ü™ü floating modal
  return;
}

  drawKGBoard();
}


/* ============================= */
/* ü™ü KNIGHT GPS ‚Äî GAME OVER MODAL */
/* ============================= */

function showKGGameOverModal() {
  try {
    const modal = document.getElementById("floatingModal");
    const title = document.getElementById("modalTitle");
    const body = document.getElementById("modalBody");
    const okBtn = document.getElementById("modalOkBtn");

    if (!modal || !title || !body || !okBtn) return;

    // üèÜ SAVE BEST SCORE (Knight GPS)
    saveMiniGameScore("knightgps", Math.max(0, kgLevel - 1));

    // content (isolated to Knight GPS)
    title.textContent = "‚õΩ Game Over";
    body.innerHTML = `
      <p style="margin-bottom:10px;">
        You ran out of moves.
      </p>
      <p style="font-size:14px; opacity:0.85;">
        Try to reach the target within <b>6 knight moves</b>.
      </p>
    `;

    // reset old handlers safely
    okBtn.onclick = null;

    // Knight GPS specific action
    okBtn.onclick = () => {
      modal.classList.add("hidden");
      exitKG(); // return to Knight GPS menu only
    };

    // show modal
    modal.classList.remove("hidden");
  } catch (e) {}
}









































    // ============================================
    // START APP
    // ============================================
    document.addEventListener('DOMContentLoaded', initApp);
  </script>

  <!-- Result Modal -->
<div id="resultModal" class="modal-overlay hidden">
  <div class="modal-card">
    <h2 id="modalTitle">‚úÖ Solution Submitted!</h2>

    <div id="modalContent" class="modal-content"></div>

    <button class="btn-success modal-btn" onclick="closeResultModal()">
      OK
    </button>
  </div>
</div>

<!-- Floating Modal -->
<div id="floatingModal" class="modal-overlay hidden">
  <div class="modal-card">
    <h3 id="modalTitle">Title</h3>
    <p id="modalBody">Message</p>
    <button id="modalOkBtn" class="btn-success">OK</button>
  </div>
</div>

<!-- Promotion Modal -->
<div id="promotionModal" class="promotion-modal hidden">
  <div class="promotion-box">
    <button onclick="completePromotion('q')">‚ôï</button>
    <button onclick="completePromotion('r')">‚ôñ</button>
    <button onclick="completePromotion('b')">‚ôó</button>
    <button onclick="completePromotion('n')">‚ôò</button>
  </div>
</div>

<!-- Attempt Details Modal -->
<div id="attemptDetailsModal" class="modal-overlay hidden">
  <div class="modal-card" style="width:700px; max-width:95%; text-align:left;">
    <h3 id="attemptDetailsTitle">Attempt Details</h3>

    <div id="attemptDetailsBody" style="max-height:60vh; overflow:auto;">
      <!-- dynamic content -->
    </div>

    <div style="text-align:right; margin-top:16px;">
      <button class="btn-secondary" onclick="closeAttemptDetails()">Close</button>
    </div>
  </div>
</div>

<!-- Grade Confirmation Modal -->
<div id="gradeConfirmModal" class="modal-overlay hidden">
  <div class="modal-card" style="width:420px; max-width:90%; text-align:center;">
    <h3 id="gradeConfirmTitle">Confirm Action</h3>

    <div id="gradeConfirmBody" class="modal-content">
      Are you sure?
    </div>

    <div style="display:flex; gap:12px; justify-content:center; margin-top:16px;">
      <button class="btn-success" id="gradeConfirmYesBtn">Yes</button>
      <button class="btn-secondary" onclick="closeGradeConfirm()">Cancel</button>
    </div>
  </div>
</div>

<!-- DELETE CONFIRM MODAL -->
<div id="deleteModal" class="modal-overlay hidden">
  <div class="modal-box">
    <h3>‚ö†Ô∏è Delete Assignment</h3>
    <p>
      This will permanently delete the assignment.<br><br>
      <strong>‚Ä¢ All student attempts will be deleted</strong><br>
      <strong>‚Ä¢ This action cannot be undone</strong>
    </p>

    <div class="modal-actions">
      <button class="btn-secondary" id="cancelDeleteBtn">Cancel</button>
      <button class="btn-danger" id="confirmDeleteBtn">Delete</button>
    </div>
  </div>
</div>

<!-- ‚ö° PUZZLE RUSH RESULT MODAL -->
<div id="puzzleRushResultModal" class="modal-overlay hidden">
  <div class="modal-box" style="max-width:420px; text-align:center;">
    <h3>‚ö° Puzzle Rush Over</h3>

    <p id="prResultReason" style="margin:12px 0;"></p>

    <p style="font-weight:600; color:#ffd700;">
      üß© Solved: <span id="prResultScore">0</span>
    </p>

    <div class="modal-actions">
      <button class="btn-success" id="prResultBtn">OK</button>
    </div>
  </div>
</div>


<!-- PGN TITLE MODAL -->
<div id="pgnTitleModal" class="modal hidden">
  <div class="modal-box">
    <h3>üì¶ Save PGN to Library</h3>

    <input
      type="text"
      id="pgnTitleInput"
      placeholder="Enter PGN title..."
    />

    <div class="modal-actions">
      <button id="cancelPGNTitle" class="btn-secondary">Cancel</button>
      <button id="confirmPGNTitle" class="btn-primary">Save</button>
    </div>
  </div>
</div>


<!-- üéâ Celebration Overlay -->
  <div id="celebrationOverlay" class="celebration hidden"></div>

  <!-- üéµ Celebration Sound -->
  <audio id="celebrationSound" preload="auto">
    <source src="sounds/party.mp3" type="audio/mpeg">
  </audio>

  <!-- ‚ö° PUZZLE RUSH SOUNDS -->
<audio id="prCheckSound" src="sounds/check.mp3" preload="auto"></audio>
<audio id="prNextSound" src="sounds/next.mp3" preload="auto"></audio>
<audio id="prWrongSound" src="sounds/wrong.mp3" preload="auto"></audio>
<audio id="prCompleteSound" src="sounds/complete.mp3" preload="auto"></audio>



<!-- üë§ Student Details Modal -->
<div id="studentDetailsModal" class="modal-overlay hidden">
  <div class="modal-box" style="max-width:700px;">
    <h3 id="studentModalTitle">Student Details</h3>

    <div id="studentModalBody">
      <p class="loading">Loading student data...</p>
    </div>

    <div class="modal-actions">
      <button class="btn-secondary" onclick="closeStudentModal()">Close</button>
    </div>
  </div>
</div>


<!-- ===============================
     üìò Study PGN Import Modal
     =============================== -->
<div id="studyImportModal" class="study-modal hidden">
  <div class="study-modal-content">
    <h3>Import PGN</h3>

    <textarea
      id="studyPgnInput"
      placeholder="Paste single or multiple PGNs here..."
    ></textarea>

    <div class="modal-actions">
      <button id="importStudyConfirm" class="btn-primary">
        Import
      </button>
      <button id="importStudyCancel" class="btn-secondary">
        Cancel
      </button>
    </div>
  </div>
</div>


<!-- üéØ QUIZ RESULT FLOATING MODAL -->
<div id="quizResultModal" class="quiz-result-modal hidden">
  <div class="quiz-result-box">
    <h2 id="quizResultTitle">Quiz Over</h2>
    <p id="quizResultText"></p>
    <button id="quizResultBtn">OK</button>
  </div>
</div>


<!-- =============================== -->
<!-- üî• KLF RESULT MODAL (ISOLATED) -->
<!-- =============================== -->
<div id="klfResultOverlay" class="klf-modal hidden">
  <div class="klf-modal-card">
    <h3 id="klfResultTitle">üî• Game Over</h3>
    <p id="klfResultText">Turns survived: 0</p>
    <button class="btn-success" onclick="closeKLFResult()">OK</button>
  </div>
</div>


<!-- ================================ -->
<!-- üëë KND FLOATING MODAL (ISOLATED) -->
<!-- ================================ -->
<div id="kndModal" class="knd-modal hidden">
  <div class="knd-modal-card">
    <h3 id="kndModalTitle">Game Over</h3>
    <p id="kndModalBody">Message</p>
    <button id="kndModalBtn" class="knd-btn">OK</button>
  </div>
</div>



<!-- üéµ Global Game Music Control -->
<div id="musicControl">
  <div id="musicMuteBtn" title="Mute / Unmute">üîä</div>

  <div id="musicMenu" class="hidden">
    <div data-src="./sounds/sound_track_1.mp3">üé∂ Sound_Track_1</div>
    <div data-src="./sounds/sound_track_2.mp3">üé∂ Sound_Track_2</div>
    <div data-src="./sounds/sound_track_3.mp3">üé∂ Sound_Track_3</div>
    <div data-src="./sounds/sound_track_4.mp3">üé∂ sound_track_4</div>
    <div data-src="./sounds/sound_track_5.mp3">üé∂ Sound_Track_5</div>
    <div data-src="./sounds/sound_track_6.mp3">üé∂ Sound_Track_6</div>
    <div data-src="./sounds/sound_track_7.mp3">üé∂ sound_track_7</div>
    <div data-src="./sounds/sound_track_8.mp3">üé∂ Sound_Track_8</div>
    <div data-src="./sounds/sound_track_9.mp3">üé∂ Sound_Track_9</div>
    <div data-src="./sounds/sound_track_10.mp3">üé∂ Sound_Track_10</div>
  </div>
</div>














<footer class="app-footer">
  ¬© 2026 <span class="footer-brand">The Olympus Chess Academy</span>. All rights reserved.
</footer>

</body>
</html>




















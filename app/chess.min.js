// chess.min.js - Simplified version
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Chess.js library - v0.13.4
var Chess = function(fen) {
  var BLACK = 'b'
  var WHITE = 'w'
  var EMPTY = -1
  var PAWN = 'p'
  var KNIGHT = 'n'
  var BISHOP = 'b'
  var ROOK = 'r'
  var QUEEN = 'q'
  var KING = 'k'
  var SYMBOLS = 'pnbrqkPNBRQK'
  var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*']
  var PAWN_OFFSETS = {b: [16, 32, 17, 15], w: [-16, -32, -17, -15]}
  var PIECE_OFFSETS = {
    n: [-18, -33, -31, -14,  18,  33,  31,  14],
    b: [-17, -15,  17,  15],
    r: [-16,   1,  16,  -1],
    q: [-17, -16, -15,   1,  17,  16,  15,  -1],
    k: [-17, -16, -15,   1,  17,  16,  15,  -1]
  }
  var ATTACKS = [
    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,
     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,
     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,
     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,
     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
    24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,
     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,
     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,
     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,
     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,
    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20
  ]
  var RAYS = [
     17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,
      0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,
      0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,
      0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,
      0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,
      0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,
      0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,
      1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,
      0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,
      0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,
      0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,
      0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,
      0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,
      0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,
    -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17
  ]
  var SHIFTS = {p: 0, n: 1, b: 2, r: 3, q: 4, k: 5}
  var FLAGS = {
    NORMAL: 'n',
    CAPTURE: 'c',
    BIG_PAWN: 'b',
    EP_CAPTURE: 'e',
    PROMOTION: 'p',
    KSIDE_CASTLE: 'k',
    QSIDE_CASTLE: 'q'
  }
  var BITS = {
    NORMAL: 1,
    CAPTURE: 2,
    BIG_PAWN: 4,
    EP_CAPTURE: 8,
    PROMOTION: 16,
    KSIDE_CASTLE: 32,
    QSIDE_CASTLE: 64
  }
  var RANK_1 = 7
  var RANK_2 = 6
  var RANK_3 = 5
  var RANK_4 = 4
  var RANK_5 = 3
  var RANK_6 = 2
  var RANK_7 = 1
  var RANK_8 = 0
  var SQUARES = {
    a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
    a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
    a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
    a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
    a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
    a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
    a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
  }
  var ROOKS = {
    w: [{square: SQUARES.a1, flag: BITS.QSIDE_CASTLE},
        {square: SQUARES.h1, flag: BITS.KSIDE_CASTLE}],
    b: [{square: SQUARES.a8, flag: BITS.QSIDE_CASTLE},
        {square: SQUARES.h8, flag: BITS.KSIDE_CASTLE}]
  }
  var board = new Array(128)
  var kings = {w: EMPTY, b: EMPTY}
  var turn = WHITE
  var castling = {w: 0, b: 0}
  var ep_square = EMPTY
  var half_moves = 0
  var move_number = 1
  var history = []
  var header = {}
  var comments = {}
  if (!fen) {
    load(DEFAULT_POSITION)
  } else {
    load(fen)
  }
  function clear() {
    board = new Array(128)
    kings = {w: EMPTY, b: EMPTY}
    turn = WHITE
    castling = {w: 0, b: 0}
    ep_square = EMPTY
    half_moves = 0
    move_number = 1
    history = []
    header = {}
    update_setup(generate_fen())
  }
  function reset() {
    clear()
    load(DEFAULT_POSITION)
  }
  function load(fen) {
    var tokens = fen.split(/\s+/)
    var position = tokens[0]
    var square = 0
    for (var i = 0; i < position.length; i++) {
      var piece = position.charAt(i)
      if (piece === '/') {
        square += 8
      } else if (is_digit(piece)) {
        square += parseInt(piece, 10)
      } else {
        var color = (piece < 'a') ? WHITE : BLACK
        put({type: piece.toLowerCase(), color: color}, algebraic(square))
        square++
      }
    }
    turn = tokens[1]
    if (tokens[2].indexOf('K') > -1) {
      castling.w |= BITS.KSIDE_CASTLE
    }
    if (tokens[2].indexOf('Q') > -1) {
      castling.w |= BITS.QSIDE_CASTLE
    }
    if (tokens[2].indexOf('k') > -1) {
      castling.b |= BITS.KSIDE_CASTLE
    }
    if (tokens[2].indexOf('q') > -1) {
      castling.b |= BITS.QSIDE_CASTLE
    }
    ep_square = (tokens[3] === '-') ? EMPTY : SQUARES[tokens[3]]
    half_moves = parseInt(tokens[4], 10)
    move_number = parseInt(tokens[5], 10)
    update_setup(generate_fen())
    return true
  }
  function put(piece, square) {
    board[SQUARES[square]] = piece
    if (piece.type === KING) {
      kings[piece.color] = SQUARES[square]
    }
  }
  function get(square) {
    var piece = board[SQUARES[square]]
    return piece ? {type: piece.type, color: piece.color} : null
  }
  function remove(square) {
    var piece = get(square)
    board[SQUARES[square]] = null
    if (piece && piece.type === KING) {
      kings[piece.color] = EMPTY
    }
    return piece
  }
  function build_move(board, from, to, flags, promotion) {
    var move = {
      color: turn,
      from: from,
      to: to,
      flags: flags,
      piece: board[from].type
    }
    if (promotion) {
      move.flags |= BITS.PROMOTION
      move.promotion = promotion
    }
    if (board[to]) {
      move.captured = board[to].type
    } else if (flags & BITS.EP_CAPTURE) {
      move.captured = PAWN
    }
    return move
  }
  function generate_moves(options) {
    function add_move(board, moves, from, to, flags) {
      if (board[from].type === PAWN &&
          (rank(to) === RANK_8 || rank(to) === RANK_1)) {
        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]
        for (var i = 0, len = pieces.length; i < len; i++) {
          moves.push(build_move(board, from, to, flags, pieces[i]))
        }
      } else {
        moves.push(build_move(board, from, to, flags))
      }
    }
    var moves = []
    var us = turn
    var them = swap_color(us)
    var second_rank = {b: RANK_7, w: RANK_2}
    var first_sq = SQUARES.a8
    var last_sq = SQUARES.h1
    var single_square = false
    if (options && options.square) {
      if (options.square in SQUARES) {
        first_sq = last_sq = SQUARES[options.square]
        single_square = true
      } else {
        return []
      }
    }
    for (var i = first_sq; i <= last_sq; i++) {
      if (i & 0x88) { i += 7; continue }
      var piece = board[i]
      if (piece == null || piece.color !== us) {
        continue
      }
      if (piece.type === PAWN) {
        var square = i + PAWN_OFFSETS[us][0]
        if (!board[square]) {
          add_move(board, moves, i, square, BITS.NORMAL)
          if (second_rank[us] === rank(i) && !board[i + PAWN_OFFSETS[us][1]]) {
            add_move(board, moves, i, i + PAWN_OFFSETS[us][1], BITS.BIG_PAWN)
          }
        }
        for (j = 2; j < 4; j++) {
          var square = i + PAWN_OFFSETS[us][j]
          if (square & 0x88) continue
          if (board[square] && board[square].color === them) {
            add_move(board, moves, i, square, BITS.CAPTURE)
          } else if (square === ep_square) {
            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)
          }
        }
      } else {
        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {
          var offset = PIECE_OFFSETS[piece.type][j]
          var square = i
          while (true) {
            square += offset
            if (square & 0x88) break
            if (!board[square]) {
              add_move(board, moves, i, square, BITS.NORMAL)
            } else {
              if (board[square].color === us) break
              add_move(board, moves, i, square, BITS.CAPTURE)
              break
            }
            if (piece.type === 'n' || piece.type === 'k') break
          }
        }
      }
    }
    if (!single_square || last_sq === kings[us]) {
      if (castling[us] & BITS.KSIDE_CASTLE) {
        var castling_from = kings[us]
        var castling_to = castling_from + 2
        if (board[castling_from + 1] == null &&
            board[castling_to] == null &&
            !attacked(them, kings[us]) &&
            !attacked(them, castling_from + 1) &&
            !attacked(them, castling_to)) {
          add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)
        }
      }
      if (castling[us] & BITS.QSIDE_CASTLE) {
        var castling_from = kings[us]
        var castling_to = castling_from - 2
        if (board[castling_from - 1] == null &&
            board[castling_from - 2] == null &&
            board[castling_from - 3] == null &&
            !attacked(them, kings[us]) &&
            !attacked(them, castling_from - 1) &&
            !attacked(them, castling_to)) {
          add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)
        }
      }
    }
    if (!options || !options.legal) {
      return moves
    }
    var legal_moves = []
    for (var i = 0, len = moves.length; i < len; i++) {
      make_move(moves[i])
      if (!king_attacked(us)) {
        legal_moves.push(moves[i])
      }
      undo_move()
    }
    return legal_moves
  }
  function move(move) {
    var move_obj = null
    if (typeof move === 'string') {
      move_obj = null
      var moves = generate_moves()
      for (var i = 0, len = moves.length; i < len; i++) {
        if (move === moves[i].san || move === moves[i].from + moves[i].to) {
          move_obj = moves[i]
          break
        }
      }
      if (!move_obj) {
        return null
      }
    } else if (typeof move === 'object') {
      var moves = generate_moves()
      for (var i = 0, len = moves.length; i < len; i++) {
        if (move.from === moves[i].from &&
            move.to === moves[i].to &&
            (!move.promotion || move.promotion === moves[i].promotion)) {
          move_obj = moves[i]
          break
        }
      }
      if (!move_obj) {
        return null
      }
    }
    if (move_obj) {
      var pretty_move = make_pretty(move_obj)
      make_move(move_obj)
      return pretty_move
    }
    return null
  }
  function undo_move() {
    var old = history.pop()
    if (old == null) {
      return null
    }
    var move = old.move
    kings = old.kings
    turn = old.turn
    castling = old.castling
    ep_square = old.ep_square
    half_moves = old.half_moves
    move_number = old.move_number
    var us = turn
    var them = swap_color(us)
    board[move.from] = board[move.to]
    board[move.from].type = move.piece
    board[move.to] = null
    if (move.captured) {
      if (move.flags & BITS.EP_CAPTURE) {
        var index
        if (us === BLACK) {
          index = move.to - 16
        } else {
          index = move.to + 16
        }
        board[index] = {type: move.captured, color: them}
      } else {
        board[move.to] = {type: move.captured, color: them}
      }
    }
    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
      var castling_to, castling_from
      if (move.flags & BITS.KSIDE_CASTLE) {
        castling_to = move.to + 1
        castling_from = move.to - 1
      } else if (move.flags & BITS.QSIDE_CASTLE) {
        castling_to = move.to - 2
        castling_from = move.to + 1
      }
      board[castling_to] = board[castling_from]
      board[castling_from] = null
    }
    return move
  }
  function attacked(color, square) {
    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
      if (i & 0x88) { i += 7; continue }
      var piece = board[i]
      if (piece == null || piece.color !== color) continue
      var difference = i - square
      var index = difference + 119
      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {
        if (piece.type === PAWN) {
          if (difference > 0) {
            if (piece.color === WHITE) return true
          } else {
            if (piece.color === BLACK) return true
          }
          continue
        }
        if (piece.type === 'n' || piece.type === 'k') return true
        var offset = RAYS[index]
        var j = i + offset
        var blocked = false
        while (j !== square) {
          if (board[j] != null) { blocked = true; break }
          j += offset
        }
        if (!blocked) return true
      }
    }
    return false
  }
  function king_attacked(color) {
    return attacked(swap_color(color), kings[color])
  }
  function in_check() {
    return king_attacked(turn)
  }
  function in_checkmate() {
    return in_check() && generate_moves().length === 0
  }
  function in_stalemate() {
    return !in_check() && generate_moves().length === 0
  }
  function in_draw() {
    return half_moves >= 100 ||
           in_stalemate() ||
           insufficient_material() ||
           in_threefold_repetition()
  }
  function insufficient_material() {
    var pieces = {}
    var bishops = []
    var num_pieces = 0
    var sq_color = 0
    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
      sq_color = (sq_color + 1) % 2
      if (i & 0x88) { i += 7; continue }
      var piece = board[i]
      if (piece) {
        pieces[piece.type] = (pieces[piece.type] || 0) + 1
        if (piece.type === BISHOP) {
          bishops.push(sq_color)
        }
        num_pieces++
      }
    }
    if (num_pieces === 2) { return true }
    else if (num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) { return true }
    else if (num_pieces === pieces[BISHOP] + 2) {
      var sum = 0
      var len = bishops.length
      for (var i = 0; i < len; i++) {
        sum += bishops[i]
      }
      if (sum === 0 || sum === len) { return true }
    }
    return false
  }
  function in_threefold_repetition() {
    var moves = []
    var positions = {}
    var repetition = false
    while (true) {
      var move = undo_move()
      if (!move) break
      moves.push(move)
    }
    while (true) {
      var move = moves.pop()
      if (!move) break
      make_move(move)
      var fen = generate_fen()
      positions[fen] = (positions[fen] || 0) + 1
      if (positions[fen] >= 3) {
        repetition = true
      }
    }
    moves.forEach(function() { undo_move() })
    return repetition
  }
  function game_over() {
    return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition()
  }
  function validate_fen(fen) {
    var errors = []
    var tokens = fen.split(/\s+/)
    if (tokens.length !== 6) {
      errors.push({0: "FEN string must contain six fields"})
      return {valid: false, error_number: 0, error: "FEN string must contain six fields"}
    }
    return {valid: true}
  }
  function fen() {
    return generate_fen()
  }
  function board() {
    var output = []
    var row = []
    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
      if (board[i] == null) {
        row.push(null)
      } else {
        row.push({type: board[i].type, color: board[i].color})
      }
      if ((i + 1) & 0x88) {
        output.push(row)
        row = []
        i += 8
      }
    }
    return output
  }
  function pgn(options) {
    var newline = (options && options.newline_char) ? options.newline_char : '\n'
    var max_width = (options && options.max_width) ? options.max_width : 0
    var result = []
    var header_exists = false
    for (var i in header) {
      result.push('[' + i + ' "' + header[i] + '"]' + newline)
      header_exists = true
    }
    if (header_exists && history.length) {
      result.push(newline)
    }
    var moves = []
    var temp_history = history.slice()
    var move_string = ''
    var move_number = 1
    while (temp_history.length > 0) {
      var move = temp_history.shift().move
      move_string = move_number + '. '
      if (move.color === 'w') {
        move_string += ''
      } else {
        move_string += move_string.trim() + ' '
      }
      move_string += move.san + ' '
      moves.push(move_string)
      move_number++
    }
    if (max_width === 0) {
      return result.join('') + moves.join('')
    }
    var current_width = 0
    for (i = 0; i < moves.length; i++) {
      if (current_width + moves[i].length > max_width && i !== 0) {
        if (result[result.length - 1] === ' ') {
          result.pop()
        }
        result.push(newline)
        current_width = 0
      } else if (i !== 0) {
        result.push(' ')
        current_width++
      }
      result.push(moves[i])
      current_width += moves[i].length
    }
    return result.join('')
  }
  function load_pgn(pgn, options) {
    function parse_pgn_header(header) {
      var headers = {}
      var lines = header.split('\n')
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim()
        if (line[0] === '[' && line[line.length - 1] === ']') {
          line = line.substring(1, line.length - 1)
          var parts = line.split(' "')
          if (parts.length === 2) {
            headers[parts[0]] = parts[1].substring(0, parts[1].length - 1)
          }
        }
      }
      return headers
    }
    var newline = (options && options.newline_char) ? options.newline_char : '\r?\n'
    var regex = new RegExp('^(\\[(.|' + newline + ')*\\])' + newline + newline + '(.|' + newline + ')*$')
    var header_string = ''
    if (regex.test(pgn)) {
      var header_end = pgn.indexOf(']\n\n')
      if (header_end === -1) {
        header_end = pgn.indexOf(']\r\n\r\n')
      }
      if (header_end !== -1) {
        header_string = pgn.substring(0, header_end + 1)
      }
      pgn = pgn.substring(header_end + 3)
    }
    var headers = parse_pgn_header(header_string)
    for (var key in headers) {
      set_header([key, headers[key]])
    }
    reset()
    var moves = pgn.replace(/\{.*?\}/g, '').split(/\.|\d+\./).join('.').split(/(?:\s+)/)
    moves = moves.filter(function(move) { return move !== '' })
    for (i = 0; i < moves.length; i++) {
      var move = moves[i].replace(/\$[0-9]+/g, '')
      var result = move(move)
      if (result === null) {
        return false
      }
    }
    return true
  }
  function header() {
    return header
  }
  function set_header(args) {
    header[args[0]] = args[1]
  }
  function ascii() {
    var s = '   +------------------------+\n'
    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
      if (file(i) === 0) {
        s += ' ' + '87654321'[rank(i)] + ' |'
      }
      if (board[i] == null) {
        s += ' . '
      } else {
        var piece = board[i].type
        var color = board[i].color
        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase()
        s += ' ' + symbol + ' '
      }
      if ((i + 1) & 0x88) {
        s += '|\n'
        i += 8
      }
    }
    s += '   +------------------------+\n'
    s += '     a  b  c  d  e  f  g  h\n'
    return s
  }
  function turn() {
    return turn
  }
  function move_number() {
    return move_number
  }
  function get_comment() {
    return comments[generate_fen()]
  }
  function set_comment(comment) {
    comments[generate_fen()] = comment
  }
  function delete_comment() {
    var comment = comments[generate_fen()]
    delete comments[generate_fen()]
    return comment
  }
  function get_comments() {
    return comments
  }
  function delete_comments() {
    comments = {}
  }
  return {
    WHITE: WHITE,
    BLACK: BLACK,
    PAWN: PAWN,
    KNIGHT: KNIGHT,
    BISHOP: BISHOP,
    ROOK: ROOK,
    QUEEN: QUEEN,
    KING: KING,
    SQUARES: (function() {
                  var keys = []
                  for (var i in SQUARES) keys.push(i)
                  return keys
                })(),
    FLAGS: FLAGS,
    load: function(fen) {
      return load(fen)
    },
    reset: function() {
      return reset()
    },
    moves: function(options) {
      return generate_moves(options)
    },
    in_check: function() {
      return in_check()
    },
    in_checkmate: function() {
      return in_checkmate()
    },
    in_stalemate: function() {
      return in_stalemate()
    },
    in_draw: function() {
      return in_draw()
    },
    insufficient_material: function() {
      return insufficient_material()
    },
    in_threefold_repetition: function() {
      return in_threefold_repetition()
    },
    game_over: function() {
      return game_over()
    },
    validate_fen: function(fen) {
      return validate_fen(fen)
    },
    fen: function() {
      return fen()
    },
    board: function() {
      return board()
    },
    pgn: function(options) {
      return pgn(options)
    },
    load_pgn: function(pgn, options) {
      return load_pgn(pgn, options)
    },
    header: function() {
      return header()
    },
    set_header: function(args) {
      return set_header(args)
    },
    ascii: function() {
      return ascii()
    },
    turn: function() {
      return turn()
    },
    move: function(move) {
      return move(move)
    },
    undo: function() {
      return undo_move()
    },
    clear: function() {
      return clear()
    },
    put: function(piece, square) {
      return put(piece, square)
    },
    get: function(square) {
      return get(square)
    },
    remove: function(square) {
      return remove(square)
    },
    perft: function(depth) {
      return perft(depth)
    },
    square_color: function(square) {
      if (square in SQUARES) {
        var sq_0x88 = SQUARES[square]
        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'
      }
      return null
    },
    history: function(options) {
      var reversed_history = []
      var move_history = []
      var verbose = options && options.verbose
      while (history.length > 0) {
        reversed_history.push(undo_move())
      }
      while (reversed_history.length > 0) {
        var move = reversed_history.pop()
        if (verbose) {
          move_history.push(move)
        } else {
          move_history.push(move.san)
        }
        make_move(move)
      }
      return move_history
    },
    get_comment: get_comment,
    set_comment: set_comment,
    delete_comment: delete_comment,
    get_comments: get_comments,
    delete_comments: delete_comments,
    attacked: attacked,
    king_attacked: king_attacked
  }
}
function swap_color(color) {
  return color === 'w' ? 'b' : 'w'
}
function rank(i) {
  return i >> 4
}
function file(i) {
  return i & 15
}
function algebraic(i) {
  var f = file(i), r = rank(i)
  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)
}
function is_digit(c) {
  return '0123456789'.indexOf(c) !== -1
}
function make_pretty(move) {
  move.san = move_to_san(move)
  move.to = algebraic(move.to)
  move.from = algebraic(move.from)
  var flags = ''
  for (var flag in BITS) {
    if (BITS[flag] & move.flags) {
      flags += FLAGS[flag]
    }
  }
  move.flags = flags
  return move
}
function make_move(move) {
  var us = turn
  var them = swap_color(us)
  history.push({
    move: move,
    kings: {w: kings.w, b: kings.b},
    turn: turn,
    castling: {w: castling.w, b: castling.b},
    ep_square: ep_square,
    half_moves: half_moves,
    move_number: move_number
  })
  board[move.to] = board[move.from]
  board[move.from] = null
  if (move.flags & BITS.EP_CAPTURE) {
    if (turn === BLACK) {
      board[move.to - 16] = null
    } else {
      board[move.to + 16] = null
    }
  }
  if (move.flags & BITS.PROMOTION) {
    board[move.to].type = move.promotion
  }
  if (board[move.to].type === KING) {
    kings[board[move.to].color] = move.to
    if (move.flags & BITS.KSIDE_CASTLE) {
      var castling_to = move.to - 1
      var castling_from = move.to + 1
      board[castling_to] = board[castling_from]
      board[castling_from] = null
    } else if (move.flags & BITS.QSIDE_CASTLE) {
      var castling_to = move.to + 1
      var castling_from = move.to - 2
      board[castling_to] = board[castling_from]
      board[castling_from] = null
    }
    castling[us] = 0
  }
  if (castling[us]) {
    for (var i = 0; i < ROOKS[us].length; i++) {
      if (move.from === ROOKS[us][i].square &&
          castling[us] & ROOKS[us][i].flag) {
        castling[us] ^= ROOKS[us][i].flag
        break
      }
    }
  }
  if (castling[them]) {
    for (var i = 0; i < ROOKS[them].length; i++) {
      if (move.to === ROOKS[them][i].square &&
          castling[them] & ROOKS[them][i].flag) {
        castling[them] ^= ROOKS[them][i].flag
        break
      }
    }
  }
  if (move.flags & BITS.BIG_PAWN) {
    if (turn === BLACK) {
      ep_square = move.to - 16
    } else {
      ep_square = move.to + 16
    }
  } else {
    ep_square = EMPTY
  }
  if (move.captured) {
    half_moves = 0
  } else if (board[move.to].type === PAWN) {
    half_moves = 0
  } else {
    half_moves++
  }
  if (turn === BLACK) {
    move_number++
  }
  turn = swap_color(turn)
}
function move_to_san(move) {
  var output = ''
  if (move.flags & BITS.KSIDE_CASTLE) {
    output = 'O-O'
  } else if (move.flags & BITS.QSIDE_CASTLE) {
    output = 'O-O-O'
  } else {
    var disambiguator = get_disambiguator(move)
    if (move.piece !== PAWN) {
      output += move.piece.toUpperCase() + disambiguator
    }
    if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
      if (move.piece === PAWN) {
        output += algebraic(move.from)[0]
      }
      output += 'x'
    }
    output += algebraic(move.to)
    if (move.flags & BITS.PROMOTION) {
      output += '=' + move.promotion.toUpperCase()
    }
  }
  make_move(move)
  if (in_check()) {
    if (in_checkmate()) {
      output += '#'
    } else {
      output += '+'
    }
  }
  undo_move()
  return output
}
function get_disambiguator(move) {
  var moves = generate_moves()
  var from = move.from
  var to = move.to
  var piece = move.piece
  var ambiguities = 0
  var same_rank = 0
  var same_file = 0
  for (var i = 0, len = moves.length; i < len; i++) {
    var ambig_from = moves[i].from
    var ambig_to = moves[i].to
    var ambig_piece = moves[i].piece
    if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {
      ambiguities++
      if (rank(from) === rank(ambig_from)) {
        same_rank++
      }
      if (file(from) === file(ambig_from)) {
        same_file++
      }
    }
  }
  if (ambiguities > 0) {
    if (same_rank > 0 && same_file > 0) {
      return algebraic(from)
    } else if (same_file > 0) {
      return algebraic(from).charAt(1)
    } else {
      return algebraic(from).charAt(0)
    }
  }
  return ''
}
function generate_fen() {
  var empty = 0
  var fen = ''
  for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
    if (board[i] == null) {
      empty++
    } else {
      if (empty > 0) {
        fen += empty
        empty = 0
      }
      var color = board[i].color
      var piece = board[i].type
      fen += (color === WHITE) ? piece.toUpperCase() : piece.toLowerCase()
    }
    if ((i + 1) & 0x88) {
      if (empty > 0) {
        fen += empty
      }
      if (i !== SQUARES.h1) {
        fen += '/'
      }
      empty = 0
      i += 8
    }
  }
  fen += ' ' + turn
  fen += ' '
  var castling = ''
  if (castling.w & BITS.KSIDE_CASTLE) { castling += 'K' }
  if (castling.w & BITS.QSIDE_CASTLE) { castling += 'Q' }
  if (castling.b & BITS.KSIDE_CASTLE) { castling += 'k' }
  if (castling.b & BITS.QSIDE_CASTLE) { castling += 'q' }
  fen += castling || '-'
  fen += ' ' + (ep_square === EMPTY ? '-' : algebraic(ep_square))
  fen += ' ' + half_moves
  fen += ' ' + move_number
  return fen
}
function update_setup(fen) {
  if (history.length > 0) return
  if (fen !== DEFAULT_POSITION) {
    header['SetUp'] = '1'
    header['FEN'] = fen
  } else {
    delete header['SetUp']
    delete header['FEN']
  }
}
if (typeof exports !== 'undefined') exports.Chess = Chess
if (typeof define !== 'undefined') define(function() { return Chess })
},{}]},{},[1]);
//# sourceMappingURL=chess.js.map